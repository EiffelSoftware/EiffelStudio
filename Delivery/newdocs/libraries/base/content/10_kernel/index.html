<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML XMLNS:MSHelp="http://msdn.microsoft.com/mshelp"><HEAD>
		<TITLE>EiffelBase, The Kernel</TITLE>
	<XML>
		<MSHelp:Keyword Index="K" Term="Kernel" />
		<MSHelp:Keyword Index="K" Term="EiffelBase, Kernel" />
		<MSHelp:Attr Name="Product" Value="Eiffel"/>
		<MSHelp:Attr Name="Locale" Value="kbEnglish"/>
	</XML>
		<LINK HREF="../../../../default.css" TYPE="text/css" REL="STYLESHEET"></HEAD>
	<BODY>
		<TABLE CLASS="HEADER" ID="Table1">
			<TR>
				<TD CLASS="HEADER">Eiffel ENViSioN!</TD>
			</TR>
			<TR>
				<TD CLASS="SUBHEADER">EiffelBase, The Kernel</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FRAME">
			<TR>
				<TD>
					<P>In addition to basic concepts close to the language level, the Kernel covers such
					common needs as <B>input</B> and <B>output</B>, <B>storage</B> and
					<B>retrieval</B> of objects on persistent storage, fine control over <B>exception
					handling</B> and <B>memory management</B>, and access to
					<B>operating system facilities</B>. The kernel can be divided into 5 logical
					clusters of classes:</P>
						
					<UL>
						<LI>The first cluster contains the universal class defining facilities accessible to all
						other classes: <A CLASS="eclass" HREF="../../reference/kernel/any_chart.html">ANY</A>. Every 
						developer-defined class is a descendant of this class. </LI>
							
						<LI>The second cluster includes classes whose facilities are directly related to
						language concepts:
						
							<UL>
								<LI>Classes describing the basic types:
								<A CLASS="eclass" HREF="../../reference/kernel/boolean_chart.html">BOOLEAN</A>,
								<A CLASS="eclass" HREF="../../reference/kernel/character_chart.html">CHARACTER</A>,
								<A CLASS="eclass" HREF="../../reference/kernel/integer_chart.html">INTEGER</A>,
								<A CLASS="eclass" HREF="../../reference/kernel/real_chart.html">REAL</A>
								and
								<A CLASS="eclass" HREF="../../reference/kernel/double_chart.html">DOUBLE</A>
								<LI>Arrays: class <A CLASS="eclass" HREF="../../reference/kernel/array_chart.html">ARRAY</A>
								<LI>Tuples: class <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>
								<LI>Strings: class <A CLASS="eclass" HREF="../../reference/kernel/string_chart.html">STRING</A>
								<LI>Basic facilities: class <A CLASS="eclass" HREF="../../reference/kernel/basic_routines_chart.html">BASIC_ROUTINES</A></LI>
							</UL>
						</LI>
				
						<LI>The third cluster provides input and output facilities:
						
							<UL>
								<LI><A CLASS="eclass" HREF="../../reference/kernel/std_files_chart.html">STD_FILES</A> 
								offers basic mechanisms, sufficient for simple input and output.</LI>
          
								<LI><A CLASS="eclass" HREF="../../reference/kernel/file_chart.html">FILE</A> 
								describes the notion of sequential file, viewed as a sequence of 
								characters and fully integrated in the data structure library.</LI>
          
								<LI><A CLASS="eclass" HREF="../../reference/kernel/directory_chart.html">DIRECTORY</A>
								gives properties of directories (files serving as collections of other files).</LI>
							</UL>
						</LI>
							
						<LI>The next cluster, through class <A CLASS="eclass" HREF="../../reference/kernel/storable_chart.html">STORABLE</A>, 
						makes it possible to store object structures on persistent storage and 
						retrieve them later. This facility can also be used to transmit object 
						structures through pipes or over a network.</LI>        
						
						<LI>The last cluster provides access to internal properties of the compiler and environment, useful for applications that need some fine-tuning of the basic mechanisms:

							<UL>
								<LI>Class <A CLASS="eclass" HREF="../../reference/kernel/exceptions_chart.html">EXCEPTIONS</A>
								(complemented by <A CLASS="eclass" HREF="../../reference/kernel/unix_signals_chart.html">UNIX_SIGNALS</A> 
								for Unix-type platforms) provides control over the exception handling 
								mechanism, in particular for applications that need to handle 
								different types of exception in different ways.</LI>
          
								
								<LI>Similarly, classes <A CLASS="eclass" HREF="../../reference/kernel/memory_chart.html">MEMORY</A>
								and <A CLASS="eclass" HREF="../../reference/kernel/gc_info_chart.html">GC_INFO</A> 
								provide ways to control the garbage collector and tailor it to 
								specific needs.</LI>
          
								
								<LI>Class <A CLASS="eclass" HREF="../../reference/kernel/arguments_chart.html">ARGUMENTS</A> gives access to the
								command-line arguments.</LI>
							</UL>
						</LI>
					</UL>
					
					<H1>Universal Class and its Features</H1>
					
					<P>The Eiffel inheritance mechanism is set up in such a way that every class is a
					descendant of a Kernel Library class called <A CLASS="eclass" HREF="../../reference/kernel/any_chart.html">ANY</A>.
					The features of this class provide a number of generally applicable facilities covering such needs as comparison, copying and
					rudimentary input and output.</P>
        
					<H2> The structure of universal classes</H2>
					
					<P>Every class which has no inheritance clause is understood to have an inheritance clause
					of the form</P>
					
					<CODE>
					<SPAN CLASS="ekeyword">inherit</SPAN><BR>
 					&nbsp;&nbsp; <A CLASS="eclass" HREF="../../reference/kernel/any_chart.html">ANY</A>
 					</CODE>
 					
 					<P>As a result, every developer-defined class is a descendant of <A CLASS="eclass" HREF="../../reference/kernel/any_chart.html">ANY</A>.
					You may introduce your own project specific features in <A CLASS="eclass" HREF="../../reference/kernel/any_chart.html">ANY</A>
					so that all the classes of your system will be able to use these
					features.</P>
					
					<H2>Using the universal classes</H2>
					
					<P>If you need to rename or redefine a feature inherited from one of the universal classes,
					you should include an explicit inheritance clause, as in</P>
					
					<CODE>
						<SPAN CLASS="ekeyword">class</SPAN><BR>
						&nbsp;&nbsp; <SPAN CLASS="eclass">C</SPAN><BR>
						<SPAN CLASS="ekeyword">inherit</SPAN><BR>
						&nbsp;&nbsp; <A CLASS="eclass" HREF="../../reference/kernel/any_chart.html">ANY</A><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN CLASS="ekeyword">rename</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A>
						<SPAN CLASS="ekeyword">as</SPAN> <SPAN CLASS="efeature">basic_out</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN CLASS="ekeyword">redefine</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_print">print</A><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN CLASS="ekeyword">end</SPAN><BR>
						&nbsp;&nbsp;&nbsp;...<BR>
						<SPAN CLASS="ekeyword">feature</SPAN><BR>
						&nbsp;&nbsp;&nbsp;...<BR>
						<SPAN CLASS="ekeyword">end</SPAN>
					</CODE>
					
					<P>The features of <A CLASS="eclass" HREF="../../reference/kernel/any_chart.html">ANY</A>
					are usable in both qualified and unqualified form. For example, the argumentless function out, which produces a printable representation of any object,
					may be called under either of the forms</P>
					
					<CODE>
				        <SPAN CLASS="elocal">x</SPAN> <SPAN CLASS="esymbol">:=</SPAN> <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A><BR>
						<SPAN CLASS="elocal">x</SPAN> <SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="elocal">a</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A>
					</CODE>
					
					<P>The first call yields a printable representation of the current object; the second,
					which assumes that a is not void, yields a printable representation of the object attached
					to a.</P>
					
					<H2>Input and output features</H2>
					
					<P>Some of the features of <A CLASS="eclass" HREF="../../reference/kernel/any_chart.html">ANY</A>
					cover common input and output needs.<BR>
					
					Feature <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_io">io</A>,
					of type <A CLASS="eclass" HREF="../../reference/kernel/std_files_chart.html">STD_FILES</A>,
					gives access to standard input and output facilities.
					For example,
					<A CLASS="efeature" HREF="../../reference/kernel/any.html#f_io">io</A><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/std_files.html#f_input">input</A>
					is the standard input file and
					<A CLASS="efeature" HREF="../../reference/kernel/any.html#f_io">io</A><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/std_files.html#f_new_line">new_line</A>
					will print a line feed on the standard output. Feature io is declared as a once function which, when first called,
					returns the value of an instance of <A CLASS="eclass" HREF="../../reference/kernel/std_files_chart.html">STD_FILES</A>
					that provides access to the standard input, the standard output and the error output. As a result, io is never void, so that
					operations such as
					<A CLASS="efeature" HREF="../../reference/kernel/any.html#f_io">io</A><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/std_files.html#f_new_line">new_line</A>
					are always possible.<BR>
					
					Function out, of type <A CLASS="eclass" HREF="../../reference/kernel/string_chart.html">STRING</A>,
					is a universal mechanism for obtaining a simple
					external representation of any object. For non-void <SPAN CLASS="elocal">x</SPAN> of any type, the string
					<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A>
					is a printable representation of <SPAN CLASS="elocal">x</SPAN>. This works for <SPAN CLASS="elocal">x</SPAN> of all types,
					reference or expanded. For example, if <SPAN CLASS="elocal">x</SPAN> is an integer expression,
					<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A>
					is its string representation, such as <SPAN CLASS="esymbol">-897</SPAN>; if n is a non-void reference,
					<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="symbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A> is (recursively)
					the concatenation of the result of
					applying out to the successive fields of the attached object, each labeled by the name of
					the corresponding attribute. You may redefine <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A>
					in any class to specify any suitable format for displaying instances of the class. To obtain the default representation
					regardless of any redefinition of <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A>, use
					<A CLASS="efeature" HREF="../../reference/kernel/any.html#f_tagged_out">tagged_out</A>, declared as a frozen synonym of
					the original <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A>.<BR>
					
					The call <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_print">print</A>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">)</SPAN>
					will output the value of
					<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A>
					on the default output if <SPAN CLASS="elocal">x</SPAN> is not void, and do nothing otherwise.</P>
					
					<H2>Copy and comparison routines</H2>
					
					<P align="left">Procedure copy copies the fields of an object onto those of another. It is used under the
					form</P>
					
					<CODE>
						<SPAN CLASS="elocal">target</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/any.html#f_copy">copy</A>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">source</SPAN><SPAN CLASS="esymbol">)</SPAN>
					</CODE>
					
					<P>Here both target and source must be non-void; this means that copy is only good
					for copying onto an object that already exists. If you need both to allocate a new object
					and to initialize it as a copy of another, use the function clone. For non-void source, the
					assignment</P>
					
					<CODE>
						<SPAN CLASS="elocal">target</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
						<A CLASS="efeature" HREF="../../reference/kernel/any.html#f_clone">clone</A>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">source</SPAN><SPAN CLASS="esymbol">)</SPAN>
					</CODE>
					
					<P>starts by creating a new object. If <SPAN CLASS="elocal">source</SPAN> is void, <SPAN CLASS="elocal">target</SPAN> will be made void too.
					The boolean function
					<A CLASS="efeature" HREF="../../reference/kernel/any.html#f_equal">equal</A>
					compares two objects for field-by-field equality. This is different from the equality operators
					<SPAN CLASS="esymbol">=</SPAN> and <SPAN CLASS="esymbol">/=</SPAN> which, in the case of reference types,
					compare references, not objects.<BR>
					
					The function
					<A CLASS="efeature" HREF="../../reference/kernel/any.html#f_deep_clone">deep_clone</A>
					produces a duplicate of an entire object structure. The boolean function
					<A CLASS="efeature" HREF="../../reference/kernel/any.html#f_deep_equal">deep_equal</A>
					determines whether
					two object structures are recursively
					identical. These routines are the <I>deep</I> counterparts of the shallow copy and equality
					tests provided by
					<A CLASS="efeature" HREF="../../reference/kernel/any.html#f_clone">clone</A>
					and
					<A CLASS="efeature" HREF="../../reference/kernel/any.html#f_equal">equal</A>.<BR>
					
					A class that needs a specific notion of equality and the corresponding copy
					semantics may redefine <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_copy">copy</A>
					and <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_is_equal">is_equal</A>
					(from which
					<A CLASS="efeature" HREF="../../reference/kernel/any.html#f_equal">equal</A>
					follows, since
					<A CLASS="efeature" HREF="../../reference/kernel/any.html#f_equal">equal
					</A><SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">a</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="elocal">b</SPAN><SPAN CLASS="esymbol">)</SPAN> is defined as
					<SPAN CLASS="elocal">a</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/any.html#f_is_equal">is_equal</A>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">b</SPAN><SPAN CLASS="esymbol">)</SPAN>  for non-void <SPAN CLASS="elocal">a</SPAN>).
					You will find such redefinitions in a number of classes of the Base libraries. For example an instance of
					<A CLASS="eclass" HREF="../../reference/kernel/string_chart.html">STRING</A> is a string
					descriptor containing a reference to the actual character sequence, not that sequence
					itself, so that what the default equal compares and the default copy copies is the
					descriptor, not the string. Class <A CLASS="eclass" HREF="../../reference/kernel/string_chart.html">STRING</A>
					redefines these routines to yield the semantics
					normally expected by string clients; the frozen variants <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_standard_copy">standard_copy</A>
					and <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_standard_equal">standard_equal</A>, originally declared as synonyms to equal and copy, remain available with the
					default semantics.<BR>
					
					The function <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_clone">clone</A>
					is defined in terms of <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_copy">copy</A>, and so will follow any redefinition
					of <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_copy">copy</A>. This makes it impossible to change the semantics of one but not of the other,
					which would be a mistake. The variant <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_standard_clone">standard_clone</A>
					is defined in terms of <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_standard_copy">standard_copy</A>.</P>
					
					<H2>Type information</H2>
					
					<P>
					The string-valued query <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_generator">generator</A>, applied to any object, returns the name of the
					object’s generating class: the class of which it is an instance. The boolean function
					<A CLASS="efeature" HREF="../../reference/kernel/any.html#f_conforms_to">conforms_to</A>
					makes it possible to test dynamically whether the
					type of an object conforms to that of another - that is to say whether the first one’s
					generator is a descendant of the second one’s.<BR>
					
					These two features enable clients to ascertain the dynamic type of an entity at runtime. They are only useful for low-level components; the normal mechanism for type-dependent operations is dynamic binding.</P>
					
					<H2>Miscellaneous</H2>
					
					<P>
					The query <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_void">Void</A>, of type
					<SPAN CLASS="eclass">NONE</SPAN>, denotes a reference that is always void - not attached to
					any object.<BR>
					Procedure <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_do_nothing">do_nothing</A>
					does what its name implies.<BR>
					Function <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_default">default</A>
					also has an
					empty body; its result type is <SPAN CLASS="ekeyword">like Current</SPAN>, so what it returns is the default value of the
					current type. This is mostly interesting for expanded types, since for reference types the
					default value is simply a void reference.
					</P>
					
					<H1>Language-related Facilities</H1>
					
					<P>A number of classes offer facilities which are very close to the language level. Here too
					the book Eiffel: The Language covers the classes in detail, so we can satisfy ourselves
					with a quick summary; the flat-short forms appear in part C.</P>
					
					<H2>Basic types</H2>
					
					<P>The basic types <A CLASS="eclass" HREF="../../reference/kernel/boolean_chart.html">BOOLEAN</A>,
					<A CLASS="eclass" HREF="../../reference/kernel/character_chart.html">CHARACTER</A>,
					<A CLASS="eclass" HREF="../../reference/kernel/integer_chart.html">INTEGER</A>, <A CLASS="eclass" HREF="../../reference/kernel/real_chart.html">REAL</A>
					and <A CLASS="eclass" HREF="../../reference/kernel/double_chart.html">DOUBLE</A> are defined
					by classes of the Kernel library.<BR>
					
					In reading the class specifications for the numeric types <A CLASS="eclass" HREF="../../reference/kernel/integer_chart.html">INTEGER</A>,
					<A CLASS="eclass" HREF="../../reference/kernel/real_chart.html">REAL</A> and <A CLASS="eclass" HREF="../../reference/kernel/double.html">DOUBLE</A>, you might think that the type declarations are too restrictive. For example the
					addition operation in class <A CLASS="eclass" HREF="../../reference/kernel/real_chart.html">REAL</A>
					reads</P>
					
					<CODE>
						<SPAN CLASS="ekeyword">infix</SPAN> <SPAN CLASS="esymbol">"+" (</SPAN><SPAN CLASS="elocal">other</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<A CLASS="eclass" HREF="../../reference/kernel/real_chart.html">REAL</A><SPAN CLASS="esymbol">):</SPAN>
						<A CLASS="eclass" HREF="../../reference/kernel/real_chart.html">REAL</A>
					</CODE>
					
					<P>but there is actually no problem here. A language convention applicable to all arithmetic
					expressions, the Balancing rule, states that in any such expression all operands are
					considered to be converted to the heaviest type, where <A CLASS="eclass" HREF="../../reference/kernel/double_chart.html">DOUBLE</A>
					is heavier than <A CLASS="eclass" HREF="../../reference/kernel/real_chart.html">REAL</A>
					and <A CLASS="eclass" HREF="../../reference/kernel/real_chart.html">REAL</A> is heavier than
					<A CLASS="eclass" HREF="../../reference/kernel/integer_chart.html">INTEGER</A>. So
					mixed-type arithmetic, consistent with common practice, is possible and indeed frequent.
					</P>
					
					<H2>Arrays</H2>
					
					<P>To create and manipulate one-dimensional arrays, use class <A CLASS="eclass" HREF="../../reference/kernel/array_chart.html">ARRAY</A>
					of the Kernel Library. Arrays are not primitive language elements; instead, they are handled through class
					<A CLASS="eclass" HREF="../../reference/kernel/array_chart.html">ARRAY</A>. This class is “normal” in the sense that it may be used just as any other class
					by client and descendant classes. It is also somewhat special, however, in that the Eiffel
					compiler knows about it and uses this knowledge to generate efficient code for array
					operations.<BR>
					
					To create an instance of <A CLASS="eclass" HREF="../../reference/kernel/array_chart.html">ARRAY</A>, use the creation instruction
					</P>
					
					<CODE>
						<SPAN CLASS="ekeyword">create</SPAN>
						<SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/array.html#f_make">make</A>
						<SPAN CLASS="esymbol">(1,</SPAN> <SPAN CLASS="elocal">u</SPAN><SPAN CLASS="esymbol">)</SPAN>
					</CODE>

					<P>where the arguments indicate the lower and upper bounds. These bounds will then be
					accessible as <SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/array.html#f_lower">lower</A>
					and <SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/array.html#f_upper">upper</A>. The number of items is
					<SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/array.html#f_count">count</A>;
					feature <A CLASS="efeature" HREF="../../reference/kernel/array.html#f_capacity">capacity</A>
					is a synonym for <A CLASS="efeature" HREF="../../reference/kernel/array.html#f_count">count</A>. The class invariant expresses
					the relation between <A CLASS="efeature" HREF="../../reference/kernel/array.html#f_count">count</A>,
					<A CLASS="efeature" HREF="../../reference/kernel/array.html#f_lower">lower</A>
					and <A CLASS="efeature" HREF="../../reference/kernel/array.html#f_upper">upper</A>.<BR>
					To access and change the item at index i in array a, you may use features
					<A CLASS="efeature" HREF="../../reference/kernel/array.html#f_item">item</A>
					and <A CLASS="efeature" HREF="../../reference/kernel/array.html#f_put">put</A>, as in
					</P>
					
					<CODE>
						x := <SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/array.html#f_item">item</A>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">i</SPAN><SPAN CLASS="esymbol">)</SPAN><BR>
						<SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/array.html#f_put">put</A>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">new_value</SPAN><SPAN CLASS="esymbol">,</SPAN> <SPAN CLASS="elocal">i</SPAN><SPAN CLASS="esymbol">)<BR>
						</SPAN>
					</CODE>
					
					<P>Function
					<A CLASS="efeature" HREF="../../reference/kernel/array.html#f_item">item</A>
					has an infix synonym, <SPAN CLASS="ekeyword">infix</SPAN>
					<SPAN CLASS="esymbol">"</SPAN><A CLASS="efeature" HREF="../../reference/kernel/array.html#f__infix_@">@</A><SPAN CLASS="esymbol">"</SPAN>,
					so that you may also write the first assignment above more concisely as</P>
					
					<CODE>x := <SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol"> </SPAN><A CLASS="efeature" HREF="../../reference/kernel/array.html#f_item">@</A>
						<SPAN CLASS="elocal">i</SPAN><BR>
						<SPAN CLASS="elocal"></SPAN>
					</CODE><BR>

					Features
					<A CLASS="efeature" HREF="../../reference/kernel/array.html#f_item">item</A>,
					<SPAN CLASS="ekeyword">infix</SPAN>
					<SPAN CLASS="esymbol">"</SPAN><A CLASS="efeature" HREF="../../reference/kernel/array.html#f__infix_@">@</A><SPAN CLASS="esymbol">"
					</SPAN>and <A CLASS="efeature" HREF="../../reference/kernel/array.html#f_put">put</A>
					have preconditions requiring the index
					(<SPAN CLASS="elocal">i</SPAN>in the above calls) to be within the bounds of the array. This means that you can detect
					bounds violations (which correspond to bugs in the client software) by using a version
					of class ARRAY compiled with precondition checking on. The bounds of an array may be changed dynamically through procedure resize.
					Previously entered elements are retained. Rather than an explicit resize, you may use calls to procedure force which has the
					same signature as put but no precondition; if the index is not within the current bounds
					force will perform a resize as necessary.
					
					<H2>Optimizing array computations</H2>
					
					<P class="caution"><B>
					CAUTION</B>: Although <A CLASS="eclass" HREF="../../reference/kernel/array_chart.html">ARRAY</A>
					benefits from an efficient implementation, its more advanced
					facilities such as resizing do not come for free. For extensive computations on large
					arrays, an optimization may be desirable, bypassing these facilities. The technique
					yields loops that run at about the same speed as the corresponding loops written in C or
					Fortran (the usual references for array computations). It is of interest for advanced uses
					only, so that you may safely skip this section on first reading unless your domain of
					application is numerical computation or some other area requiring high-performance
					array manipulations.</P>
					
					<P>
					The optimization relies on the class <A CLASS="eclass" HREF="../../reference/kernel/special_chart.html">SPECIAL</A>, used internally by
					<A CLASS="eclass" HREF="../../reference/kernel/array_chart.html">ARRAY</A> but of no
					direct interest to client developers in most common uses. With the declarations
					</P>
					
					<CODE>
						<SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">:</SPAN> <A CLASS="eclass" HREF="../../reference/kernel/array_chart.html">ARRAY</A>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">SOME_TYPE</SPAN><SPAN CLASS="esymbol">]</SPAN><BR>
						<SPAN CLASS="elocal">direct_access</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<A CLASS="eclass" HREF="../../reference/kernel/special_chart.html">SPECIAL</A>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">SOME_TYPE</SPAN><SPAN CLASS="esymbol">]</SPAN><BR>
					</CODE>
					
					<P>you may use direct_access in lieu of my_array within a critical loop, provided none of
					the operations may resize the array. Typically, the operations should only include
					<A CLASS="efeature" HREF="../../reference/kernel/special.html#f_put">put</A>
					and <A CLASS="efeature" HREF="../../reference/kernel/special.html#f_item">item</A>. In such a case you can use the following scheme:
					</P>
					
					<CODE>
						<SPAN CLASS="elocal">direct_access</SPAN><SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/array.html#f_area">area</A><BR>
						<SPAN CLASS="ecomment">-- The critical loop:</SPAN><BR>
						<SPAN CLASS="ekeyword">from</SPAN><BR>
						&nbsp;&nbsp; <SPAN CLASS="efeature">some_initialization</SPAN><BR>
						&nbsp;&nbsp; <SPAN CLASS="elocal">index</SPAN> <SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="elocal">some_initial_index</SPAN><BR>
						<SPAN CLASS="ekeyword">until</SPAN><BR>
						&nbsp;&nbsp; <SPAN CLASS="elocal">index</SPAN> <SPAN CLASS="esymbol">=</SPAN> <SPAN CLASS="elocal">some_final_index</SPAN><BR>
						<SPAN CLASS="ekeyword">loop</SPAN><BR>
						&nbsp;&nbsp; ...<BR>
						&nbsp;&nbsp; <SPAN CLASS="elocal">x</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="elocal">direct_access</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/special.html#f_item">item</A>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">index</SPAN><SPAN CLASS="esymbol">)</SPAN><BR>
						&nbsp;&nbsp; ...<BR>
						&nbsp;&nbsp; <SPAN CLASS="elocal">direct_access</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/special.html#f_item">put</A>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">some_value</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="elocal">index</SPAN><SPAN CLASS="esymbol">)</SPAN><BR>
						&nbsp;&nbsp; ...<BR>
						<SPAN CLASS="ekeyword">end</SPAN><BR>
					</CODE>
					
					<P>
					This replaces an original loop where the operations were on <SPAN CLASS="elocal">my_array</SPAN>. Feature area
					of <A CLASS="eclass" HREF="../../reference/kernel/array_chart.html">ARRAY</A> gives direct access to the special object, an instance of
					<A CLASS="eclass" HREF="../../reference/kernel/special_chart.html">SPECIAL</A>, containing
					the array values. Features
					<A CLASS="efeature" HREF="../../reference/kernel/array.html#f_put">put</A>
					and
					<A CLASS="efeature" HREF="../../reference/kernel/array.html#f_item">item</A>
					are available in <A CLASS="eclass" HREF="../../reference/kernel/special_chart.html">SPECIAL</A>
					as in <A CLASS="eclass" HREF="../../reference/kernel/array_chart.html">ARRAY</A>,
					but without the preconditions; in other words, you will not get any bounds checking.
					Instances of <A CLASS="eclass" HREF="../../reference/kernel/special_chart.html">SPECIAL</A>
					are always indexed from zero, in contrast with arrays, whose lower bound is arbitrary, 1 being the most common value. But rather than performing
					index translations (that is to say, subtracting
					<SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">.</SPAN>lower
					from
					<A CLASS="efeature" HREF="../../reference/kernel/array.html#f_index">index</A>
					throughout the loop) it is preferable to use the following simple technique: if the lower bound lb of
					<SPAN CLASS="elocal">my_array</SPAN> is 1 or another small integer, use 0 as lower bound instead when creating
					<SPAN CLASS="elocal">my_array</SPAN>, but only use the positions starting at lb. You will waste a few memory positions
					(0 to lb-1), but will not have to change anything in your algorithm and will avoid costly
					subtractions.<BR>
					It is important to note that this optimization, if at all necessary, should at most affect
					a few loops in a large system. You should always begin by writing your software using
					the normal <A CLASS="eclass" HREF="../../reference/kernel/array_chart.html">ARRAY</A>
					facilities; then once you have the certainty that the software is
					correct, if you detect that a large array computation is hampering the efficiency of the
					system, you may apply the above technique to get the fastest performance out of that
					computation. The change to the software will be minimal - a few lines - and will be
					easy to undo if necessary.</P>
					
					<H2>Tuples</H2>
					
					<P>A new Kernel Library class is introduced: <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>.<BR>
					Alone among all classes, class <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>
					has a variable number of generic parameters. <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>,
					<A href="../../reference/kernel/tuple_chart.html">TUPLE</A> [X], <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>
					[X, Y], <A href="../../reference/kernel/tuple_chart.html">TUPLE</A> [X, Y,
					Z] and so on are all valid types, assuming valid types X, Y, Z and so on.<BR>
					Conformance rules:</P>
					
					<PRE>[CONF1]
						For n &gt;= 0
						TUPLE [U<SUB>1</SUB>, U<SUB>2</SUB>, ..., U<SUB>n</SUB>, U<SUB>n+1</SUB>] conforms to
						TUPLE [U<SUB>1</SUB>, U<SUB>2</SUB>, ..., U<SUB>n</SUB>]
					</PRE>

					<P>(and hence to <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>
					[T<SUB>1</SUB>, T<SUB>2</SUB>, ..., T<SUB>n</SUB>] if each of the U<SUB>i</SUB>
					conforms to each of the T<SUB>i</SUB> for 1 &lt;= i &lt;= n.)</P>
					
					<P>In particular all tuple types conform to <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>,
					with no parameter.</P>
				
					<PRE>[CONF2]
					For n &gt;= 0
						If *every* one of the types T<SUB>1</SUB>, T<SUB>2</SUB>, ..., T<SUB>n</SUB> conforms
						to a type T, then TUPLE [T<SUB>1</SUB>, T<SUB>2</SUB>, ..., T<SUB>n</SUB>] conforms
						to ARRAY [T].
					</PRE>
				
					<P>Definition: a "tuple type" is any type based on class <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>,
					i.e. any type of the form <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>
					[T<SUB>1</SUB>, T<SUB>2</SUB>, ..., T<SUB>n</SUB>] for any n (including 0,
					for which there is no generic parameter).</P>
				
					<P class="note">(Note 1: CONF1 should be understood in terms of the underlying
					mathematical model. Mathematically, <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>
					[T<SUB>1</SUB>, T<SUB>2</SUB>, ..., T<SUB>n</SUB>] is the set TUPLE<SUB>n</SUB>
					of all partial functions f from N+ (the set of non-negative integers) to T<SUB>1</SUB>
					U T<SUB>2</SUB> U ... T<SUB>n</SUB>, such that:</P>
					
					<UL>
						<LI>The domain of f contains the interval 1..n (in 
        other words, f is defined for any i such that 1 &lt;= i &lt;= n). 
        
						<LI>For 1 &lt;= i &lt;= n, f (i) is a member of T<SUB>i</SUB>.</LI>
					</UL>
					
					<P>With this definition, TUPLE<SUB>n</SUB> is indeed a subset of TUPLE<SUB>n+1</SUB>,
					and in particular TUPLE<SUB>0</SUB>, the empty set, is a subset of TUPLE<SUB>n</SUB>
					for any n.)</P>
					
					<P>Semantics: an instance of <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>
					[T<SUB>1</SUB>, T<SUB>2</SUB>, ..., T<SUB>n</SUB>] is a tuple whose first
					element is an instance of T<SUB>1</SUB>, the second element being an
					instance of T<SUB>2</SUB> etc. (The precise definition is the mathematical
					one given in note 1.) Note that there can be more than n elements to the
					tuple: for example a tuple with first element 5 and second element "FOO"
					is an instance of all of the following tuple types: <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>;
					<A href="../../reference/kernel/tuple_chart.html">TUPLE</A> [<A CLASS="eclass" HREF="../../reference/kernel/integer_chart.html">INTEGER</A>];
					<A href="../../reference/kernel/tuple_chart.html">TUPLE</A> [<A CLASS="eclass" HREF="../../reference/kernel/integer_chart.html">INTEGER</A>, <A CLASS="eclass" HREF="../../reference/kernel/string_chart.html">STRING</A>].</P>
					
					<P class="note">
					(Note 2: It may seem restrictive at first to permit only one class, <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>, to have 
					an arbitrary number of actual generic parameters. Why not have a general 
					mechanism for declaring any class C so that all of C [X], C [X, Y] etc. 
					are valid? But in fact this is not really a restriction. To obtain this 
					effect without any complicated language convention, just declare C as</P>
					            
					<PRE>	C [G -&gt; TUPLE]</PRE>
					
					<P>and then use the generic derivations</P>
					
					<PRE>	C [TUPLE [X]]
					C [TUPLE [X, Y]]</PRE>
					
					and so on. This also makes it possible to have the effect of some fixed
					parameters and some variable ones, as in
					
					<PRE>	C [G, H, I -&gt; TUPLE]</PRE>
					
					<P>so we have all the necessary flexibility.)</P>
					
					<H2>Tuple expressions</H2>
					
					<P>Let e<SUB>1</SUB>, e<SUB>2</SUB>, ..., e<SUB>n</SUB> be expressions of
					respective types T<SUB>1</SUB>, T<SUB>2</SUB>, ..., T<SUB>n</SUB>. 
					Then the expression</P>  
					
					<PRE>	[e<SUB>1</SUB>, e<SUB>2</SUB>, ..., e<SUB>n</SUB>]</PRE>
					<P>denotes an instance of <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>
					[T<SUB>1</SUB>, T<SUB>2</SUB>, ..., T<SUB>n</SUB>], whose first element is e<SUB>1</SUB>,
					the second element being e<SUB>2</SUB> etc.<BR>
					Tuple expressions can be nested: whereas</P>
					
					<PRE>	[1, 2, 3]</PRE>
					
					<P>is a tuple with three elements (representing an instance of <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>
					[<A CLASS="eclass" HREF="../../reference/kernel/integer_chart.html">INTEGER</A>,
					<A CLASS="eclass" HREF="../../reference/kernel/integer_chart.html">INTEGER</A>,
					<A CLASS="eclass" HREF="../../reference/kernel/integer_chart.html">INTEGER</A>]),</P>
					
					<PRE>	 [1, [2, 3]]</PRE>
					
					<P>is a tuple with two elements, the second one itself a tuple; the overall
					expression represents an instance of <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>
					[<A CLASS="eclass" HREF="../../reference/kernel/integer_chart.html">INTEGER</A>,
					<A href="../../reference/kernel/tuple_chart.html">TUPLE</A> [<A CLASS="eclass" HREF="../../reference/kernel/integer_chart.html">INTEGER</A>,
					<A CLASS="eclass" HREF="../../reference/kernel/integer_chart.html">INTEGER</A>].<BR>
					As a special case of tuple expression syntax, the delimiters [ and ] are
					replaced by parentheses for the tuple representing the actual argument list
					of a routine call (see section 4).</P>
					
					<H2>Tuple features</H2>
					
					<P>The exact specification of class <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>
					will be described in an addition to ELKS. The principal features are:</P>
					
					<UL>
						<LI><A href="../../reference/kernel/tuple.html#f_count">count</A> 
						(number of significant elements)</LI>
        
						<LI><A href="../../reference/kernel/tuple.html#f_item">item</A> (i), with
						the obvious precondition: the i-th element, of type <A href="../../reference/kernel/any_chart.html">ANY</A> (since the 
						value of i is not known at compile time); also first, second, third, 
						fourth and fifth, of the appropriate types.</LI>
        
						<LI><A href="../../reference/kernel/tuple.html#f_put">put</A> (x, i), with
						the obvious precondition: replace i-th element with x. If argument x is
						not of the appropriate type T<SUB>i</SUB> 
				        there is no effect.</LI>
        
						<LI><A href="../../reference/kernel/tuple.html#f_is_equal">is_equal</A>:
							redefined to consider only the first n elements, where n is the smaller
							length.</LI>
					</UL>
					
					<P>Other features under consideration include:</P>
					
					<UL>
						<LI>stripped (i): a tuple of type <A href="../../reference/kernel/tuple_chart.html">TUPLE</A>
						[T<SUB>1</SUB>, T<SUB>2</SUB>, T<SUB>i-1</SUB>, T<SUB>i+1</SUB>, ..., T<SUB>n</SUB>], derived from the current one 
						by removing the i-th component, again with the obvious precondition.</LI>
        
						<LI>wedged (x, i): a tuple with one more element, inserted at position i.</LI>
        
						<LI><B>infix</B> "+": tuple concatenation</LI>
        
						<LI><B>infix</B> "++": element concatenation; t ++ x is the same
							thing as t.wedged (x, t.count + 1).</LI>
					</UL>
					
					<H2>What have we gained?</H2>
					
					<P>First we have solved the only case in the Eiffel 
					language in which an expression has no precisely defined type: polymorphic 
					manifest arrays. We don't have manifest arrays any more, but manifest 
					tuples, with a precisely defined type. No incompatibility is introduced 
					thanks to rule CONF2. The original syntax for manifest arrays, Result :=             
					&lt;&lt;e<SUB>1</SUB>, e<SUB>2</SUB>,
					..., e<SUB>n</SUB>&gt;&gt;, will continue to be supported.<BR>
					Second, we can define functions that return multiple results. This is a
					quite significant increase in expressive power. No common language has that.
					(You have to go to Lisp and functional languages.) Just define <A href="../../reference/kernel/tuple_chart.html">TUPLE</A> [...] as 
					the result type; in the function, you will write things like</P>
					            
					<PRE>	 Result := [e<SUB>1</SUB>, e<SUB>2</SUB>, ..., e<SUB>n</SUB>]</PRE>
					
					<P>Also, from a theoretical viewpoint, feature calls are simpler and more
					homogeneous: every feature takes exactly one tuple as argument and returns
					exactly one tuple as a result. (Either of these tuples may be empty: the
					first for a feature with no argument, the second for a procedure.) The
					syntax for a call becomes</P>
					
					<PRE>	Feature Arguments</PRE>
					
					<P>with Arguments defined as</P>
					
					<PRE>	Tuple_expression</PRE>
					
					<P>where the Tuple_expression uses the form given in section 2 but with the
					outermost [ and ] delimiters replaced by parentheses to conform to usual
					practice. So the call</P>
					
					<PRE>	f (a, b, c)</PRE>
					
					<P>which we continue to think of as having three arguments a, b and c,
					formally has only one tuple argument [a, b, c]. This is of course not to be
					confused with a call of the form</P>
					
					<PRE>	g ([a, b, c])tr</PRE>
					
					<P>which has one argument (a tuple with three elements) in both the ordinary
					and the formal sense.</P>
					
					<H2>Active, iterators, numerical applications, introspection</H2>
					
					<P>For a set of important applications of tuples see the book chapter on <A href="../20_structures/70_iteration.html">agents
					and iterators</A> which also covers aspects of numerical software and
					related topics following from the tuple mechanism.</P>
					
					<H2>Temporary limitations</H2>
					
					<P>The implementation of tuples has the following limitations:</P>
					
					<UL>
						<LI>Conformance of <A CLASS="eclass" HREF="../../reference/kernel/array_chart.html">ARRAY</A>
						types to <A href="../../reference/kernel/tuple_chart.html">TUPLE</A> types 
						is not yet fully supported.</LI>
        
						<LI>Class <A href="../../reference/kernel/tuple_chart.html">TUPLE</A> does
						not have features such as first and second. You must use item and, in
						most cases, an assignment attempt.</LI>
					</UL>
					
					<H2>Strings</H2>
						
					<P>Strings are handled by class <A CLASS="eclass" HREF="../../reference/kernel/string_chart.html">STRING</A>, similar in many respects to
					<A CLASS="eclass" HREF="../../reference/kernel/array_chart.html">ARRAY</A>. Strings are of arbitrary size. The make creation procedure takes an integer
					argument, as in&lt;</P>
					
					<CODE>
						<SPAN CLASS="elocal">s</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="elocal">s1</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="elocal">s2</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="elocal">s3</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<A CLASS="eclass" HREF="../../reference/kernel/string_chart.html">STRING</A><BR>
						...<BR>
						<SPAN CLASS="ekeyword">create</SPAN>
						<SPAN CLASS="elocal">s</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/string.html#f_make">make</A>
						<SPAN CLASS="esymbol">(30)</SPAN>
					</CODE>
					
					<P>The argument indicates the number of characters for the initial allocation. This is
					not an absolute limit: the string will automatically grow or shrink as a result of future
					operations. You may always request a resizing explicitly by calling procedure resize.</P>
					
					<H2>String descriptor</H2>
				
					<P>The object attached at run-time to an entity such declared of type <A CLASS="eclass" HREF="../../reference/kernel/string_chart.html">STRING</A>
					is not the actual sequence of characters but a string descriptor, which contains a
					reference to the actual string contents.</P>
					
					<P>As a result, four assignment or assignment-like operations are possible:</P>
					
					<UL>
						<LI><B>A1</B> <SPAN CLASS="elocal">s1</SPAN> <SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="elocal">s</SPAN>
						<LI><B>A2</B> <SPAN CLASS="elocal">s2</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/string.html#f_share">share</A>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">s</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<LI><B>A3</B> <SPAN CLASS="elocal">s3</SPAN> <SPAN CLASS="esymbol">:=</SPAN> <A CLASS="efeature" HREF="../../reference/kernel/string.html#f_clone">clone</A>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">s</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<LI><B>A4</B> <SPAN CLASS="elocal">s4</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/string.html#f_copy">copy</A>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">s</SPAN><SPAN CLASS="esymbol">)</SPAN></LI>
					</UL>

					<P>As illustrated below, <B> A1</B> is a reference assignment: <SPAN CLASS="elocal">s1</SPAN>
					will be attached to the same
					descriptor as s. <B> A2</B> keeps the descriptors distinct, but make them refer to the same
					sequence of characters. <B> A3</B> uses the redefinition of clone for class STRING:
					<SPAN CLASS="elocal">s3</SPAN>  will be
					attached to a new string, completely distinct from the string attached to
					<SPAN CLASS="elocal">s1</SPAN>  although
					made of identical characters. <B> A4</B> has almost the same effect as <B>A3</B>, but is only
					applicable if <SPAN CLASS="elocal">s4</SPAN> was not void, and will override the existing descriptor rather than
					creating a new one.</P>

					<IMG src="strings.png">
					
					<P class="figuretitle">fig. 1: Effect of string assignment and copy operations</P>
					
					<P><A CLASS="eclass" HREF="../../reference/kernel/basic_routines_chart.html">BASIC_ROUTINES</A>
					provides a number of conversion functions, such as <A CLASS="efeature" HREF="../../reference/kernel/basic_routines.html#f_charconv">charconv</A>.</P>
					
					<H1>Files, Input, Output</H1>
					
					<P>A few classes of the Kernel Library support file manipulation, input and output:
					<A CLASS="eclass" HREF="../../reference/kernel/std_files_chart.html">STD_FILES</A>,
					<A CLASS="eclass" HREF="../../reference/kernel/file_chart.html">FILE</A>, <A CLASS="eclass" HREF="../../reference/kernel/directory.html">DIRECTORY</A>
					and <A CLASS="eclass" HREF="../../reference/kernel/unix_file_info_chart.html">UNIX_FILE_INFO</A>. For simple
					applications it suffices to use <A CLASS="eclass" HREF="../../reference/kernel/std_files_chart.html">STD_FILES</A>, but to understand the concepts better it is
					preferable to look first at the other two.</P>
					
					<H2>General files</H2>
					
					<P><A CLASS="eclass" HREF="../../reference/kernel/file_chart.html">FILE</A> describes the notion of sequential file viewed as a data structure which fits in the
					general taxonomy of EiffelBase.<BR>
					
					The class declaration defines files as unbounded sequences of characters. This
					means that you will find in <A CLASS="eclass" HREF="../../reference/kernel/file_chart.html">FILE</A>
					all the operations on sequential data structures that you have come to know and love by reading this documentation - at least, all
					that apply. Just as stacks and linked lists, files have put, extend, has, item and so on.
					More specific to files are the typed input and output operations. For output, you will
					find <A CLASS="efeature" HREF="../../reference/kernel/file.html#f_put_character">put_character</A>,
					<A CLASS="efeature" HREF="../../reference/kernel/file.html#f_put_integer">put_integer</A>,
					<A CLASS="efeature" HREF="../../reference/kernel/file.html#f_put_real">put_real</A>,
					<A CLASS="efeature" HREF="../../reference/kernel/file.html#f_put_double">put_double</A>
					and <A CLASS="efeature" HREF="../../reference/kernel/file.html#f_put_string">put_string</A>, as well as
					<A CLASS="efeature" HREF="../../reference/kernel/file.html#f_new_line">new_line</A>. For input you
					will find <A CLASS="efeature" HREF="../../reference/kernel/file.html#f_read_integer">read_integer</A>
					and its co-conspirators.</P>
					
					<P class="warning">
					<B>Caution</B>:
					Note the application to input features of the command-query separation principle.<BR>
					The input features such as <A CLASS="efeature" HREF="../../reference/kernel/file.html#f_read_integer">read_integer</A>
					do not by themselves return a result; they set the
					values of queries such as <A CLASS="efeature" HREF="../../reference/kernel/file.html#f_last_integer">last_integer</A>. So the normal way to read is through two operations:<BR>
					<BR>
					<SPAN CLASS="elocal">my_ file</SPAN><SPAN CLASS="esymbol">.</SPAN>
					<A CLASS="efeature" HREF="../../reference/kernel/file.html#f_read_integer">read_integer</A><BR>
					<SPAN CLASS="elocal">new_value</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
					<SPAN CLASS="elocal">my_ file</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/file.html#f_last_integer">last_integer</A>
					</P>
					
					<P>
					Queries are available to determine the status of a file, in particular exists,
					<A CLASS="efeature" HREF="../../reference/kernel/file.html#f_is_readable">is_readable</A>,
					<A CLASS="efeature" HREF="../../reference/kernel/file.html#f_is_executable">is_executable</A>,
					<A CLASS="efeature" HREF="../../reference/kernel/file.html#f_is_writable">is_writable</A>,
					<A CLASS="efeature" HREF="../../reference/kernel/file.html#f_is_creatable">is_creatable</A>,
					<A CLASS="efeature" HREF="../../reference/kernel/file.html#f_is_closed">is_closed</A>,
					<A CLASS="efeature" HREF="../../reference/kernel/file.html#f_is_open_read">is_open_read</A>
					and so on.
					</P>
					
					<P class="warning">
					<B>Caution</B>:
					You will notice in the flat-short form that all these queries except the first have
					<A CLASS="efeature" HREF="../../reference/kernel/file.html#f_exists">exists</A>
					as a precondition. This precondition is good for efficiency since it saves an
					existence test - a relatively expensive operation - when you know that a certain file
					exists. But it also means that if you have any doubt about the file’s existence you must
					use the queries in the style<BR>
					<BR>
					<SPAN CLASS="ekeyword">if</SPAN>
					<SPAN CLASS="elocal">my_ file</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/file.html#f_exists">exists</A>
					<SPAN CLASS="ekeyword">and then</SPAN>
					<SPAN CLASS="elocal">my_ file</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/file.html#f_is_readable">is_readable</A>
					<SPAN CLASS="ekeyword">then</SPAN>...</P>
					
					<P>
					<A CLASS="eclass" HREF="../../reference/kernel/file_chart.html">FILE</A> is a deferred class. Various implementations are possible. A quite detailed one is
					<A CLASS="eclass" HREF="../../reference/kernel/file_chart.html">PLAIN_TEXT_FILE</A>, which adds many features for accessing
					reading and writing data from/to a file.<BR>
					<A CLASS="eclass" HREF="../../reference/kernel/unix_file_info_chart.html">UNIX_FILE_INFO</A>
					describes objects that contain internal information, such as protection mode and size, about a file.<BR>
					The class <A CLASS="eclass" HREF="../../reference/kernel/directory_chart.html">DIRECTORY</A>
					describes those files which are directories - nodes in the tree describing the file structure.</P>
					
					<H2>Basic input and output</H2>
					
					<P>
					Regardless of the operating system that you use, for simple input and output
					<A CLASS="eclass" HREF="../../reference/kernel/std_files_chart.html">STD_FILES</A>
					is sufficient. You may inherit from that class to gain direct access to its features;
					or you may declare an entity of type <A CLASS="eclass" HREF="../../reference/kernel/std_files_chart.html">STD_FILES</A>. But remember that a feature of this
					type is always available: <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_io">io</A>, from class
					<A CLASS="eclass" HREF="../../reference/kernel/any_chart.html">ANY</A>. Thanks to this feature you may include
					simple input and output in any class, with instructions such as</P>
					
					<CODE>
						<A CLASS="efeature" HREF="../../reference/kernel/any.html#f_io">io</A><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/io_medium.html#f_put_string">put_string</A>
						<SPAN CLASS="esymbol">("</SPAN><SPAN CLASS="estring">My message</SPAN><SPAN CLASS="esymbol">")</SPAN>
					</CODE>
					
					<P><A CLASS="eclass" HREF="../../reference/kernel/std_files_chart.html">STD_FILES</A>
					defines three default files through features <A CLASS="efeature" HREF="../../reference/kernel/std_files.html#f_input">input</A>,
					<A CLASS="efeature" HREF="../../reference/kernel/std_files.html#f_output">output</A>and
					<A CLASS="efeature" HREF="../../reference/kernel/std_files.html#f_error">error</A>.
					These features are Once functions, so that the first reference to any one of them will
					automatically create the corresponding file descriptor and open the associated file.<BR>
					To simplify the writing of common input and output operations, the most frequently
					used features of class <A CLASS="eclass" HREF="../../reference/kernel/file_chart.html">FILE</A>
					- for reading and writing integers, reals and so on, as discussed next - have been repeated in
					<A CLASS="eclass" HREF="../../reference/kernel/std_files_chart.html">STD_FILES</A>
					so as to apply to the default input and output. Procedure <A CLASS="efeature" HREF="../../reference/kernel/io_medium.html#f_put_string">put_string</A>
					in the example at the beginning of this section is typical: it writes its output on the standard output. More generally,
					<A CLASS="eclass" HREF="../../reference/kernel/std_files_chart.html">STD_FILES</A>
					has all the <SPAN CLASS="efeature">put_xxx</SPAN>, <SPAN CLASS="efeature">read_xxx</SPAN> and <SPAN CLASS="efeature">last_xxx</SPAN> features of <A CLASS="eclass" HREF="../../reference/kernel/file_chart.html">FILE</A>.</P>
					<H1>PERSISTENCE, STORAGE AND RETRIEVAL</H1>
					<P>Most object-oriented applications need the ability to store object 
					structures on persistent storage for later retrieval, and to transfer 
					such object structures to other applications.<BR>
					Class <A CLASS="eclass" HREF="../../reference/kernel/storable_chart.html">
					STORABLE</A> addresses this need.</P>
					
					<H2>Persistence completeness</H2>
					
					<P>A fundamental requirement on object persistence mechanisms is the <I> 
					Persistence Completeness</I> rule, stated as follows in Eiffel: The 
					Language:<BR>
					Whenever a routine of class <A CLASS="eclass" HREF="../../reference/kernel/storable_chart.html">
					STORABLE</A> stores an object into an external file, it stores with it 
					the dependents of that object. Whenever one of the associated retrieval 
					routines retrieves a previously stored object, it also retrieves all its 
					dependents.<BR>
					Storing an object just by itself would usually result in wrong 
					semantics: most objects contain references to other objects, which must 
					also be stored and retrieved with it. The persistence completeness rule 
					ensures that this is always the case. It also means, of course, that the 
					features of <A CLASS="eclass" HREF="../../reference/kernel/storable_chart.html">
					STORABLE</A> must do much more than simple input and&nbsp; output; they 
					must perform complete traversals of object structures.</P>
					
					<H2>Using the storage and retrieval facilities</H2>
					
					<P>Class <A CLASS="eclass" HREF="../../reference/kernel/storable_chart.html">
					STORABLE</A> is meant to be used as ancestor. You can use its features 
					in any descendant <SPAN CLASS="eclass">C</SPAN>; for example a routine 
					of <SPAN CLASS="eclass">C</SPAN> may contain a call of the form
					<A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_basic_store">
					basic_store</A>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">my_descriptor</SPAN><SPAN CLASS="esymbol">).<BR>
					</SPAN>The effect of this call will be to store the current object and 
					all its dependents into the file denoted by my_descriptor.<BR>
					
					Although
					<A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_basic_store">
					basic_store</A> and other procedures of <A CLASS="eclass" HREF="../../reference/kernel/storable_chart.html">
					STORABLE</A>will in general process objects of many different types, 
					only the generating class of the structure’s initial object,
					<SPAN CLASS="eclass">C</SPAN> in our example, needs to be a descendant 
					of
					<A CLASS="eclass" HREF="../../reference/kernel/storable_chart.html">
					STORABLE</A>.</P>
					
					<H2>Varieties of store operations</H2>
					
					<P>Two variants of the store operation are supported: basic store and 
					general store. Basic store produces more compact structures in the 
					resulting files, and is slightly faster; but the resulting structure is 
					dependent on the system which executes the store operation (“System” is 
					taken here, as elsewhere in this documentation, in its Eiffel sense of 
					an executable assembly of classes, compiled together with the help of an 
					Ace specification.) This means that you can use procedure <A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_basic_store">
					basic_store</A> to store an object structure during an execution of a 
					system if you will only retrieve it later in that execution, or in a<BR>
					subsequent execution of the same system. If you need to store objects 
					from a certain system and then retrieve them from a different system, 
					possibly running on a different computer, use <A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_general_store">
					general_store</A>. The result of <A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_general_store">
					general_store</A> is still platform-dependent; the representation of 
					numbers, in particular, is determined by the underlying machine 
					architecture. A third variant called
					<A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_independent_store">
					independent_store</A> will be added in the future to <A CLASS="eclass" HREF="../../reference/kernel/storable_chart.html">
					STORABLE</A>, using an entirely platform-independent storage format; 
					then a system running on a computer with a certain architecture will be 
					able to retrieve, without any explicit conversion operation, object 
					structures stored by a system running on a machine of a completely 
					different architecture. With
					<A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_general_store">
					general_store</A> the
					storing and retrieving computers must have compatible architectures.</P>
					
					<H2>Retrieval</H2>
					
					<P>You only need to be aware of the difference between basic and general 
					store at storage time. The stored structure will always be available 
					through feature retrieved; this feature will figure out, from the format 
					of the stored structure, whether it was stored by
					<A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_basic_store">
					basic_store</A> or <A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_general_store">
					general_store</A>, and will decode it accordingly.<BR>
					Feature retrieved returns a result of type <A CLASS="eclass" HREF="../../reference/kernel/storable_chart.html">
					STORABLE</A> and is typically used through an assignment attempt of the 
					form</P>
					
					<CODE>
						<SPAN CLASS="local">x</SPAN> <SPAN CLASS="esymbol">?=</SPAN>
						<A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_retrieved">
						retrieved</A>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">my_descriptor</SPAN><SPAN CLASS="esymbol">)</SPAN>
					</CODE><BR>
					
					<P>The assignment attempt is necessary because <A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_retrieved">
					retrieved</A> returns a result of type
					<A CLASS="eclass" HREF="../../reference/kernel/storable_chart.html">
					STORABLE</A>&nbsp; whereas the type of <SPAN CLASS="elocal">x</SPAN> 
					will be based on a proper descendant of <A CLASS="eclass" HREF="../../reference/kernel/storable_chart.html">
					STORABLE</A>. If the structure in the file has been corrupted and 
					retrieved is unable to do its job, it will trigger an exception. The 
					code for that exception in class <A CLASS="eclass" HREF="../../reference/kernel/exceptions_chart.html">
					EXCEPTIONS</A> (which inherits it from <A CLASS="eclass" HREF="../../reference/kernel/excep_const_chart.html">
					EXCEP_CONST</A> and is discussed in the next section, together with the 
					notion of exception code) is
					<SPAN CLASS="efeature">Retrieve_exception</SPAN>.</P>
					
					<H2><A name="Recoverable_storable"></A>Recoverable storable</H2>
					
					<P>Sometime you will be in a position where the schema of a class will 
					have changed between the time you stored your object and the time you 
					are trying to retrieve it. Such changes include:</P>
					
					<UL>
						<LI>class name changed </LI>
        
						<LI>attributes have been added or removed </LI>
        
						<LI>attributes have been renamed </LI>
        
						<LI>attributes type have changed</LI>
					</UL>
					
					<P>The storable mechanism allows you to retrieve the old version of the 
					object only if it was saved using the
					<A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_independent_store">
					independent_store</A> facility. Each time you retrieve an object of 
					a certain base class whose schema has changed, the feature 
					<SPAN class="efeature">correct_mismatch</SPAN> will be called. This 
					feature is defined in <SPAN class="eclass">ANY</SPAN> and by default will raise an exception. 
					To handle the mismatch, you need to redefine 
					<SPAN class="efeature">correct_mismatch</SPAN> in the base class whose 
					schema has been changed. For example in EiffelBase, <SPAN class="eclass">
					HASH_TABLE</SPAN> has 
					changed between version 5.1 and version 5.2 to use <SPAN class="eclass">
					SPECIAL</SPAN> rather than 
					<SPAN class="eclass">ARRAY </SPAN>for its internal data storage. To retrieve a 5.1 version of <SPAN class="eclass">
					HASH_TABLE</SPAN> , you need to define 
					<SPAN class="efeature">correct_mismatch</SPAN> as following:</P>
					
					<CODE>
						<SPAN class="efeature">correct_mismatch</SPAN> <SPAN class="ekeyword">is</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ecomment">-- Attempt to correct object mismatch during retrieve using `mismatch_information'.</SPAN><BR>
						&nbsp;&nbsp;&nbsp;<SPAN class="ekeyword">local</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="elocal">array_content</SPAN>: <SPAN class="eclass">ARRAY</SPAN> [G]<BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="elocal">array_keys</SPAN>: <SPAN class="eclass">ARRAY</SPAN> [H]<BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="elocal">array_marks</SPAN>: <SPAN class="eclass">ARRAY</SPAN> [<SPAN class="eclass">BOOLEAN</SPAN>]<BR>
						&nbsp;&nbsp;&nbsp;<SPAN class="ekeyword">do</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ecomment">-- In version 5.1 and earlier, `content', `keys' and `deleted_marks'</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ecomment">-- where of base class ARRAY. In 5.2 we changed it to be a SPECIAL for</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ecomment">-- efficiency reasons. In order to retrieve an old HASH_TABLE we</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ecomment">-- need to convert those ARRAY instances into SPECIAL instances.</SPAN><BR>
						<BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ecomment">-- Convert `content' from ARRAY to SPECIAL</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="elocal">array_content</SPAN> ?= <SPAN class="efeature">mismatch_information</SPAN>.<SPAN class="efeature">item</SPAN> ("content")<BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ekeyword">if</SPAN> <SPAN CLASS="elocal">array_content</SPAN> /= Void <SPAN class="ekeyword">then</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="efeature">content</SPAN> := <SPAN CLASS="elocal">array_content</SPAN>.<SPAN class="efeature">area</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ekeyword">end</SPAN><BR>
						<BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ecomment">-- Convert `keys' from ARRAY to SPECIAL</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="elocal">array_keys</SPAN> ?= <SPAN class="efeature">mismatch_information</SPAN>.<SPAN class="efeature">item</SPAN> ("keys")<BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ekeyword">if</SPAN> <SPAN CLASS="elocal">array_keys</SPAN> /= Void <SPAN class="ekeyword">then</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="efeature">keys</SPAN> := <SPAN CLASS="elocal">array_keys</SPAN>.<SPAN class="efeature">area</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ekeyword">end</SPAN><BR>
						<BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ecomment">-- Convert `deleted_marks' from ARRAY to SPECIAL</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="elocal">array_marks</SPAN> ?= <SPAN class="efeature">mismatch_information</SPAN>.<SPAN class="efeature">item</SPAN> ("deleted_marks")<BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ekeyword">if</SPAN> <SPAN CLASS="elocal">array_marks</SPAN> /= Void <SPAN class="ekeyword">then</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="efeature">deleted_marks</SPAN> := <SPAN CLASS="elocal">array_marks</SPAN>.<SPAN class="efeature">area</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ekeyword">end</SPAN><BR>
						<BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ekeyword">if</SPAN> <SPAN class="efeature">content</SPAN> = Void or <SPAN class="efeature">keys</SPAN> = Void or <SPAN class="efeature">deleted_marks</SPAN> = Void <SPAN class="ekeyword">then</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ecomment">-- Could not retrieve old version of HASH_TABLE. We throw an exception.</SPAN><BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Precursor {TABLE}<BR>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="ekeyword">end</SPAN><BR>
						&nbsp;&nbsp;&nbsp;<SPAN class="ekeyword">end</SPAN><BR>
					</CODE>
					
					<P>Note the use of <SPAN class="efeature">mismatch_information</SPAN>, 
					this is a once feature of <SPAN class="eclass">ANY</SPAN> of type <SPAN class="eclass">
					MISMATCH_INFORMATION </SPAN>which behaves like a <SPAN class="eclass">
					HASH_TABLE</SPAN>. The keys of the table are the names of the attributes 
					on which a mismatch occurred and the values are the corresponding object 
					fields as they were originally stored. In this particular case of <SPAN class="eclass">
					HASH_TABLE</SPAN> we know that the previous version was an 
					<SPAN class="eclass">ARRAY</SPAN>, so we do an assignment attempt and 
					if it succeeds we assign its <SPAN class="efeature">area </SPAN>to the 
					corresponding attribute of <SPAN class="eclass">
					HASH_TABLE</SPAN>.</P>

					<P>If a class name changed, then you need to create an instance of 
					<SPAN class="eclass">CLASS_NAME_TRANSLATIONS</SPAN>, it behaves like a <SPAN class="eclass">
					HASH_TABLE</SPAN> where the keys represent the old name, and the value 
					the new name. This instance needs to be created before the call to
					<A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_retrieved">
					retrieved</A>.</P>
					
					<H1>Access To Internal Properties</H1>
					
					<P>In some applications you may need to fine-tune the exception handling and memory
					management mechanisms. You may also need a simple way to access command-line
					arguments. In less common cases you may require low-level access to internal
					properties of objects.</P>
					
					<H2>Exception handling</H2>
					
					<P>Class <A CLASS="eclass" HREF="../../reference/kernel/exceptions_chart.html">EXCEPTIONS</A>
					enables you to control the handling of exceptions. <A CLASS="eclass" HREF="../../reference/kernel/unix_signals_chart.html">UNIX_SIGNALS</A>, discussed next, complements it for the special case of fine-grain signal
					handling on Unix or Unix-like platforms. Both are meant to be inherited by any class
					that needs their facilities.<BR>
					The basic exception mechanism treats all exceptions in the same way. In some cases
					it may be useful to discriminate in a Rescue clause between the various possible causes.<BR>
					Class <A CLASS="eclass" HREF="../../reference/kernel/exceptions_chart.html">EXCEPTIONS</A>
					provides the features to do this. Each kind of exception has an integer code, which you can use through several features:</P>
					
					<UL>
						<LI>The integer-valued query <A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_exception">exception</A> 
						which gives the code of the latest exception.</LI>
        
						<LI>Queries which determine the general nature of the latest exception:
						<A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_is_signal">is_signal</A>
						which determines whether the exception was an operating system signal;
						<A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_is_developer_exception">is_developer_exception</A>
						which determines whether it was explicitly caused by a
						raise, as explained next; <A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_assertion_violation">assertion_violation</A>.</LI>
        
						<LI>Query <A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_recipient_name">recipient_name</A>
						which gives the name of the exception’s recipient - the
						routine that was interrupted by the exception.</LI>
					</UL>
					
					<P>The class also provides a set of constant integer-valued attributes which denote the
					various possible codes, such as No_more_memory, Routine_ failure and Precondition_violation. So you can test the value of exception against these codes if you need to
					ascertain the precise nature of an exception. To keep <A CLASS="eclass" HREF="../../reference/kernel/exceptions_chart.html">EXCEPTIONS</A>
					simple these constant attributes are declared in a class <A CLASS="eclass" HREF="../../reference/kernel/excep_const_chart.html">EXCEP_CONST</A>, of which
					<A CLASS="eclass" HREF="../../reference/kernel/exceptions_chart.html">EXCEPTIONS</A>
					is an heir.<BR>
					
					Another occasional requirement is for a mechanism to trigger an exception
					explicitly. Procedure <A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_raise">raise</A>
					answers this needs; the argument, a string, is the tag chosen for the exception. The code in this case is Developer_exception; the query
					<A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_is_developer_exception">is_developer_exception</A>
					will return true; and the tag is accessible through feature <A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_tag_name">tag_name</A>.<BR>
					You will notice in the interface specification for <A CLASS="eclass" HREF="../../reference/kernel/exceptions_chart.html">EXCEPTIONS</A>
					that for some properties of the latest exception there are two features, one with a name such as
					<A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_exception">exception</A>
					or <A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_recipient_name">recipient_name</A>
					as seen above and the other with a name prefixed by original_: <A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_original_exception">original_exception</A>,
					<A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_original_recipient_name">original_r</A><A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_recipient_name">ecipient_name</A>.</P>
					
					<P class="warning"><B>
					CAUTION</B>: The reason for the presence of these pairs is that the immediately visible cause of a
					routine interruption may not be the real one. Assume that routine <SPAN CLASS="efeature">r</SPAN> from class <SPAN CLASS="eclass">C</SPAN>, which
					has a Rescue clause, calls <SPAN CLASS="efeature">s</SPAN> from <SPAN CLASS="eclass">D</SPAN> with no Rescue clause, and that some call executed
					by <SPAN CLASS="efeature">s</SPAN> causes a precondition violation. Because <SPAN CLASS="efeature">s</SPAN> has no Rescue clause of its own, <SPAN CLASS="efeature">s</SPAN> will fail. Up the call chain, the first
					routine that has a Rescue clause - <SPAN CLASS="efeature">r</SPAN> itself, or one of its own direct or indirect callers -
					may process the exception; but if it examines the exception code through attribute
					exception it will get the value of Routine_failure. This may be what you want; but to
					handle the situation in a finer way you will usually need to examine the code for the
					original exception, the one that interrupted <SPAN CLASS="efeature">s</SPAN>. This code will be accessible through the
					attribute <A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_original_exception">original_exception</A>, which in this case will have the value of
					<SPAN CLASS="efeature">Precondition</SPAN>, the
					exception code for precondition violations. So you have the choice between exploring
					the properties of the original exception, or those of the resulting routine failures. Just
					make sure you know what you are looking for.</P>
					
					<P>As you will see from the header comments in the flat-short form of class <A CLASS="eclass" HREF="../../reference/kernel/exceptions_chart.html">EXCEPTIONS</A>, the queries that return detailed information about an exception, such as
					<A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_assertion_violation">assertion_violation</A>, all give an answer determined by
					<A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_original_exception">original_exception</A>
					rather than <A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_exception">exception</A>, since when the two are different (that is to say, when you handle the
					exception in a routine other than the original recipient) the value of <A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_exception">exception</A>
					is always
					<SPAN CLASS="efeature">Routine_failure</SPAN> and there is nothing more to say about it.</P>
					
					<H2>Signal handling</H2>
					
					<P>The features of class <A CLASS="eclass" HREF="../../reference/kernel/exceptions_chart.html">EXCEPTIONS</A>
					enable you to determine whether a certain
					exception is a signal - an operating system event such as may result from a child
					process that disappears, a window that is resized, a user that hits the Break key and
					many others. But they do not give you more details because the exact set of possible
					signals is highly platform-dependent.<BR>
					
					Class <A CLASS="eclass" HREF="../../reference/kernel/unix_signals_chart.html">UNIX_SIGNALS</A>
					complements <A CLASS="eclass" HREF="../../reference/kernel/excep_const_chart.html">EXCEP_CONST</A>
					by providing codes for the signals of Unix and similar systems, such as Sigkill for the “kill” signal and Sigbus for
					bus error.<BR>
					Query <A CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_is_defined">is_defined</A>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">some_signal</SPAN><SPAN CLASS="esymbol">)</SPAN>, where
					<SPAN CLASS="elocal">some_signal</SPAN> is an integer code, will
					determine whether some_signal is supported on the platform.<BR>
					A class whose routines need to perform specific processing depending on the nature
					of signals received should inherit from <A CLASS="eclass" HREF="../../reference/kernel/unix_signals_chart.html">UNIX_SIGNALS</A>, or a similar class for another
					platform.<BR>
					
					Because signal codes are platform-dependent, the features of <A CLASS="eclass" HREF="../../reference/kernel/unix_signals_chart.html">UNIX_SIGNALS</A>
					are
					implemented as once functions - computed on the first call - rather than constants,
					although this makes no difference to clients.</P>
					
					<H2>Memory management</H2>
					
					<P>Class <A CLASS="eclass" HREF="../../reference/kernel/memory_chart.html">MEMORY</A>, like <A CLASS="eclass" HREF="../../reference/kernel/exceptions.html">EXCEPTIONS</A>, is meant to be used as an ancestor by classes that
					need its facilities. It offers a number of features for controlling memory management
					and fine-tuning the garbage collection mechanism, a key component of the ISE Eiffel
					environment.<BR>
					
					One of the most useful features in this class is dispose. This procedure describes
					actions to be applied to an unreachable object just before the garbage collector reclaims
					it. By default, as declared in <A CLASS="eclass" HREF="../../reference/kernel/memory_chart.html">MEMORY</A>, the procedure does nothing; but you may
					redefine it in a proper descendant of <A CLASS="eclass" HREF="../../reference/kernel/memory_chart.html">MEMORY</A>
					to describe dispose actions. Normally such actions will involve freeing external resources: for example a class describing file
					descriptors may redefine dispose so that whenever a descriptor object is garbage-collected
					the corresponding file will be closed.</P>
					
					<P class="warning"><B>Caution</B>: This example is typical of proper uses of dispose.In
					a dispose procedure you should not include any instruction that could modify the Eiffel object structure, especially if some objects in that
					structure may themselves have become unreachable: these instructions could conflict with the
					garbage collector’s operations and cause catastrophic behavior. The legitimate use of dispose
					redefinitions is for disposing of non-Eiffel resources.</P>
					
					<P>Other features of <A CLASS="eclass" HREF="../../reference/kernel/memory_chart.html">MEMORY</A>
					provide direct control over the operation of the garbage collector. You can in particular stop garbage collection through a call to
					<A CLASS="efeature" HREF="../../reference/kernel/memory.html#f_collection_off">collection_off</A>,
					and restart it through a call to
					<A CLASS="efeature" HREF="../../reference/kernel/memory.html#f_collection_on">collection_on</A>.
					By default, garbage collection is always on (a testimony to its authors’ trust in its efficiency).
					Garbage collection is normally incremental, so as not to disrupt the application in a
					perceptible way. To start a complete garbage collection mechanism - reclaiming all
					unused objects - call procedure full_collect. The remaining features of <A CLASS="eclass" HREF="../../reference/kernel/memory_chart.html">MEMORY</A>
					enable finer control of the collection mechanism and are useful in special cases only.
					You will even find a free procedure providing brave (and competent) developers with a
					mechanism for reclaiming individual objects manually.<BR>
					<A CLASS="eclass" HREF="../../reference/kernel/mem_info.html">MEM_INFO</A>, the result type for query
					<A CLASS="efeature" HREF="../../reference/kernel/memory.html#f_memory_statistics">memory_statistics</A>
					in
					<A CLASS="eclass" HREF="../../reference/kernel/memory_chart.html">MEMORY</A>, describes objects
					containing information collected about memory usage. The features of <A CLASS="eclass" HREF="../../reference/kernel/gc_info_chart.html">GC_INFO</A>
					provide statistics about the garbage collector’s operation.</P>
					
					<H2>Command-line arguments</H2>
					
					<P>Writing, assembling and compiling a system yields an executable command. The
					system’s users will call that command with arguments. These are normally provided in
					textual form on the command line, as in</P>
					<CODE>
						<B>your_system</B> arg1 arg2 arg3
					</CODE>
					
					<P>
					although one may conceive of other ways of entering the command arguments, such as
					tabular or graphical form-filling. In any case the software must be able to access the
					values passed as command arguments.<BR>
					A language mechanism is available for that purpose: the Root Class rule indicates
					that the creation procedure of the root class may have a single argument (in the Eiffel
					sense of argument to a routine) of type <A CLASS="eclass" HREF="../../reference/kernel/array_chart.html">ARRAY</A>
					[<A CLASS="eclass" HREF="../../reference/kernel/string_chart.html">STRING</A><SPAN CLASS="esymbol">]</SPAN>. The corresponding array of
					strings will be initialized at the beginning of the system’s execution with the values
					entered as arguments to that execution of the command.<BR>
					Although this facility suffices in many cases, it is not always convenient if you
					suddenly need to access the command arguments in a class that is far-away from the
					root. An alternative mechanism, class <A CLASS="eclass" HREF="../../reference/kernel/arguments_chart.html">ARGUMENTS</A>, is available. Once again, this is a
					class from which you should inherit if you need its facilities. It has just two exported
					features:</P>
					
					<UL>
						<LI><A CLASS="efeature" HREF="../../reference/kernel/arguments.html#f_argument_count">argument_count</A>, 
						a non-negative integer, is the number of command arguments. 
        
						<LI><A CLASS="efeature" HREF="../../reference/kernel/arguments.html#f_argument">argument</A>
						(i), a string, is the i-th command argument. Here <SPAN CLASS="elocal">i</SPAN> must be between <SPAN CLASS="esymbol">0</SPAN>
						and <A CLASS="efeature" HREF="../../reference/kernel/arguments.html#f_argument_count">argument_count</A>; the convention is that for
						<SPAN CLASS="elocal">i</SPAN> <SPAN CLASS="esymbol">= 0</SPAN> the result is the name of the command
						itself.</LI>
					</UL>
      			</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FOOTER">
			<TR>
				<TD>© 2003-2004 Eiffel Software. All rights reserved.</TD>
			</TR>
		</TABLE>
	</BODY>
</HTML>
