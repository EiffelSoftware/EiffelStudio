<document output="studio" title="Interfaces">
	<meta_data/>
	<paragraph>
		<paragraph>
			COM interfaces have several facets. First, an interface is a deferred, or an abstract, class.
			This means that an interface is a specification of a type.
			Second, an interface pointer represents a COM object, which is callable by a client 
			application. An object can expose several interfaces, or represent several types.
		</paragraph>
		<heading>
			<size>2</size>ECOM_INTERFACE
		</heading>
		<paragraph>
			For each interface listed in a type library, the EiffelCOM wizard generates a deferred class 
			and two effective classes: a proxy of an interface pointer, or a client side class, and a stub 
			of an interface pointer, or a server side class. The deferred interface class inherits from 
			<class_name>
				<url>../reference/Interfaces/ecom_interface_chart.xml</url>
				<label>ECOM_INTERFACE</label>
			</class_name>
			and has a deferred feature per each interface function. Both effective classes, or implemented 
			interfaces, inherit from the deferred class and implement its functions. The functions of the 
			interface proxy calls the underlying C layer, which in turn calls the COM component while 
			the functions of the interface stub implement the component functionality.
		</paragraph>
		<paragraph>
			<link>
				<url>../reference/Interfaces/ecom_interface_chart.xml</url>
				<label>ECOM_INTERFACE</label>
			</link> 
			holds a pointer to the underlying COM interface.
		</paragraph>
		<heading>
			<size>2</size>ECOM_QUERIABLE
		</heading>
		<paragraph>
			Different languages handle type coercion in different ways. C uses type cast; C++ introduces 
			several type casting mechanisms; Eiffel uses assignment attempt, etc. Every COM interface exposes 
			the <feature_name>QueryInterface</feature_name> function which allows clients to query the COM 
			component for a pointer to another interface. Querying a component for an interface pointer is 
			similar to using an assignment attempt in Eiffel. The Eiffel implementation of the assignment 
			attempt relies on the runtime data. Since changing the Eiffel runtime and the 
			implementation of the assignment attempt was not an option, EiffelCOM introduces a library class 
			<link>
					<label>ECOM_QUERIABLE</label>
					<url>../reference/Interfaces/ecom_queriable_chart.xml</url>					
			</link>
			, which has the creation routine
		</paragraph>
		<code_block>
			<feature_name>make_from_other</feature_name> <symbol>(</symbol>other<symbol>:</symbol> <class_name>ECOM_INTERFACE</class_name><symbol>)</symbol></code_block>
		<paragraph>
			which queries a COM component internally. Every interface proxy class inherits from 
			<link>
					<label>ECOM_QUERIABLE</label>
					<url>../reference/Interfaces/ecom_queriable_chart.xml</url>					
			</link>. 
			The one difference between this mechanism versus using assignment attempt is that upon failure an 
			exception will be raised. An assignment attempt that fails simply returns <keyword>Void</keyword>.
		</paragraph>
		<heading>
			<size>2</size>ECOM_STUB
		</heading>
		<paragraph>
			<link>
				<url>../reference/Interfaces/ecom_stub_chart.xml</url>
				<label>ECOM_STUB</label>
			</link> 
			inherits from 
			<link>
				<url>../reference/Interfaces/ecom_interface_chart.xml</url>
				<label>ECOM_INTERFACE</label>
			</link>
			, and exposes the feature 
			<code>
				<link>
					<url>../reference/Interfaces/ecom_stub_chart.xml</url><anchor_name>f_create_item</anchor_name>
					<label>create_item</label>
				</link>
			</code> 
			which allows creating the underlying COM object.
		</paragraph>
	</paragraph>
</document>
