<document title="10 Inheritance">
	<meta_data>
		<help>
			<toc>
				<envision_location>EiffelEnvision\A Guide to Eiffel for .NET\Invitation to Eiffel</envision_location>
				<envision_pseudo_name>91</envision_pseudo_name>
				<envision_title>Inheritance</envision_title>
				<studio_location/>
				<studio_title/>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph>Inheritance, the other fundamental generalization mechanism, makes it possible to define a new class by combination and specialization of existing classes rather than from scratch.  </paragraph>
		<paragraph>The following simple example, from the Data Structure Library in EiffelBase, is typical. 
			<code>
				<class_name>LIST</class_name>
			</code>, as noted, describes lists in any representation.  One such representation if the lists have a fixed number of elements uses an array.  We may define the corresponding class by combination of 
			<code>
				<class_name>LIST</class_name>
			</code> and 
			<code>
				<class_name>ARRAY</class_name>
			</code>, as follows:
		</paragraph>
		<code_block>
<keyword>class</keyword> <class_name>ARRAYED_LIST</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol>
	<keyword>inherit</keyword>
		<class_name>LIST</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol>
		<class_name>ARRAY</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol>

	<keyword>export</keyword> ... See below ... <keyword>end</keyword>

<keyword>feature</keyword>
	... Specific features of fixed-size lists ...

<keyword>end</keyword> <comment>-- ARRAYED_LIST</comment>
</code_block>
		<paragraph>The 
			<code>
				<keyword>inherit</keyword>
			</code> ... clause lists all the "parents" of the new class, which is said to be their "heir".  (The "ancestors" of a class include the class itself, its parents, grandparents etc.; the reverse term is "descendant".) Declaring 
			<code>
				<class_name>ARRAYED_LIST</class_name>
			</code> as shown ensures that all the features and properties of lists and arrays are applicable to arrayed lists as well.  Since the class has more than one parent, this is a case of 
			multiple inheritance.
		</paragraph>
		<paragraph>Standard graphical conventions -- drawn from the Business Object Notation or BON, a graphical object-oriented notation based on concepts close to those of Eiffel, and directly supported by EiffelStudio -- illustrate such inheritance structures:</paragraph>
		<image>
			<url>invitation-4.png</url>
		</image>
		<paragraph>An heir class such as 
			<code>
				<class_name>ARRAYED_LIST</class_name>
			</code> needs the ability to define its own export policy.  By default, inherited features keep their export status (publicly available, secret, available to selected classes only); but this may be changed in the heir.  Here, for example, 
			<code>
				<class_name>ARRAYED_LIST</class_name>
			</code> will export only the exported features of 
			<code>
				<class_name>LIST</class_name>
			</code>, making those of 
			<code>
				<class_name>ARRAY</class_name>
			</code> unavailable directly to 
			<code>
				<class_name>ARRAYED_LIST</class_name>
			</code> 's clients.  The syntax to achieve this is straightforward:
		</paragraph>
		<code_block>
<keyword>class</keyword> <class_name>ARRAYED_LIST</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol>
	<keyword>inherit</keyword>
		<class_name>LIST</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol>
		<class_name>ARRAY</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol>

	<keyword>export</keyword> <symbol>{</symbol>NONE<symbol>}</symbol> <keyword>all</keyword> <keyword>end</keyword>

	... The rest as above ...
</code_block>
		<paragraph>Another example of multiple inheritance comes from a windowing system based on a class 
			<code>
				<class_name>WINDOW</class_name>
			</code>, close to actual classes in EiffelVision 2.  Windows have 
			<bold>graphical</bold> features: a height, a width, a position, routines to scale windows, move them, and other graphical operations.  The system permits windows to be nested, so that a window also has 
			<bold>hierarchical</bold> features: access to sub windows and the parent window, adding a sub window, deleting a sub window, attaching to another parent and so on.  Rather than writing complex class that would contain specific implementations for all of these features, it is preferable to inherit all hierarchical features from 
			<code>
				<class_name>TREE</class_name>
			</code> (a class in EiffelBase describing trees), and all graphical features from a class 
			<code>
				<class_name>RECTANGLE</class_name>
			</code>.
		</paragraph>
		<paragraph>Inheritance complements the "client" relation by providing another form of reuse that yields remarkable economies of effort -- for analysis, design, implementation, evolution -- and has a profound effect on the entire software development process.  </paragraph>
		<paragraph>The very power of inheritance demands adequate means to keep it under control.  Multiple inheritance, in particular, raises the question of name conflicts between features inherited from different parents; this case will inevitably arise in practice, especially for classes contributed by independent developers.  You may remove such a name conflict through 
			<bold>renaming</bold>, as in
		</paragraph>
		<code_block>
<keyword>class</keyword> <class_name>C</class_name>
	<keyword>inherit</keyword>
		<class_name>A</class_name>
			<keyword>rename</keyword>
				<feature_name>x</feature_name> <keyword>as</keyword> <feature_name>x1</feature_name><symbol>,</symbol>
				<feature_name>y</feature_name> <keyword>as</keyword> <feature_name>y1</feature_name>
			<keyword>end</keyword>

		<class_name>B</class_name>
			<keyword>rename</keyword>
				<feature_name>x</feature_name> <keyword>as</keyword> <feature_name>x2</feature_name><symbol>,</symbol>
				<feature_name>y</feature_name> <keyword>as</keyword> <feature_name>y2</feature_name>
			<keyword>end</keyword>

<keyword>feature</keyword> ...
</code_block>
		<paragraph>Here, if both 
			<code>
				<class_name>A</class_name>
			</code> and 
			<code>
				<class_name>B</class_name>
			</code> have features named 
			<code>
				<local_variable>x</local_variable>
			</code> and 
			<code>
				<local_variable>y</local_variable>
			</code>, class 
			<code>
				<class_name>C</class_name>
			</code> would be invalid without the renaming.
		</paragraph>
		<paragraph>Renaming also serves to provide more appropriate feature names in descendants.  For example, class 
			<code>
				<class_name>WINDOW</class_name>
			</code> may inherit a routine 
			<code>
				<feature_name>insert_subtree</feature_name>
			</code> from 
			<code>
				<class_name>TREE</class_name>
			</code>.  For clients of 
			<code>
				<class_name>WINDOW</class_name>
			</code>, however, such a routine name is no longer appropriate.  An application that uses this class needs coherent window terminology, and should have to concern itself with the inheritance structure that led to the class.  So you may wish to rename 
			<code>
				<feature_name>insert_subtree</feature_name>
			</code> as 
			<code>
				<feature_name>add_subwindow</feature_name>
			</code> in the inheritance clause of 
			<code>
				<class_name>WINDOW</class_name>
			</code>.
		</paragraph>
		<paragraph>As a further protection against misusing multiple inheritance, the invariants of all parent classes automatically apply to a newly defined class.  So classes may not be combined if their invariants are incompatible.  </paragraph>
	</paragraph></document>
