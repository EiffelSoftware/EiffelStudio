<document title="9 Genericity">
	<meta_data>
		<help>
			<toc>
				<envision_location>Eiffel, The Language\Tutorials\Invitation to Eiffel</envision_location>
				<envision_pseudo_name>90</envision_pseudo_name>
				<envision_title>Genericity</envision_title>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph>Building software components (classes) as implementations of abstract data types yields systems with a solid architecture but does not in itself ensure reusability and extendibility.  Two key techniques address the problem: genericity (unconstrained or constrained) and inheritance.  Let us look first at the unconstrained form.  </paragraph>
		<paragraph>To make a class generic is to give it
			<bold>formal generic parameters</bold>  representing as unknown types, as in these examples from ISE's EiffelBase, an open-source library covering basic data structures and algorithms:
		</paragraph>
		<code_block>
	ARRAY [G]
	LIST [G]
	LINKED_LIST [G]
</code_block>
		<paragraph>These classes describe data structures -- arrays, lists without commitment to a specific representation, lists in linked representation -- containing objects of a certain type.  The formal generic parameter
			<code>
				<string>G</string>
			</code> denotes this type.
		</paragraph>
		<paragraph>A class such as these doesn't quite yet describe a type, but a type template, since
			<code>
				<string>G</string>
			</code> itself denotes an unknown type.  To derive a directly usable list or array type, you must provide a type corresponding to
			<code>
				<string>G</string>
			</code>, called an
			<bold>actual generic parameter</bold>; this may be either an expanded type, including basic types such as
			<code>
				<string>INTEGER</string>
			</code>, or a reference type.  Here are some possible generic derivations:
		</paragraph>
		<code_block>
	il : LIST [ INTEGER ]
	aa : ARRAY [ ACCOUNT ]
	aal : LIST [ ARRAY [ ACCOUNT ]]
</code_block>
		<paragraph>As the last example indicates, an actual generic parameter may itself be generically derived.  </paragraph>
		<paragraph>It would not be possible, without genericity, to have static type checking in a realistic object-oriented language.  </paragraph>
		<paragraph>A variant of this mechanism,
			<code>
				<string>constrained</string>
			</code> genericity, will enable a class to place specific requirements on possible actual generic parameters.  Constrained genericity will be described after inheritance.
		</paragraph>
	</paragraph></document>