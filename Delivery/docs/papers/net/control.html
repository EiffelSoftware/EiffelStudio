<HTML>
<HEAD>
<TITLE>Obtaining a Finer Degree of Control</TITLE>
<LINK REV="made" HREF="mailto:ise@eiffel.com">
<link rel="stylesheet" type="text/css" href="../../styles/tech.css">
<meta name="Microsoft Border" content="t, default">
</HEAD>

<BODY><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><table border="0" cellspacing="0" cellpadding="0" width="100%">
  <tr>
    <td valign="top" bgcolor="#000063" width="291"><b><font face="Arial" size="4" color="#FFFFFF">Interactive<br>
      Software Engineering</font></b></td>
    <td valign="top" bgcolor="#000063" width="720"><b><font face="Arial" size="6" color="#FFFFCC">Obtaining a Finer Degree of Control</font></b></td>
  </tr>
  <tr>
    <td colspan="2" valign="top" width="100%">
<p align="center">[<a href="http://eiffel.com">ISE Home</a>] <nobr>[&nbsp;<a href="../../index.html">Home</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../../release_notes.html">Release&nbsp;Notes</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../index.html">Technology&nbsp;Papers</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../../install.html">Installation&nbsp;Notes</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../../Eiffel/index.html">About&nbsp;Eiffel</a>&nbsp;]</nobr>
<hr>

    </td>
  </tr>
</table></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><!--msnavigation--><td valign="top">
<P>
<A HREF="datagram_sockets.html#Title"><IMG SRC="next.gif" ALIGN=RIGHT ALT="Next" width="16" height="16"></A>
<A HREF="toc.html"><IMG SRC="toc.gif" ALIGN=RIGHT ALT="TOC" width="16" height="16"></A>
<A HREF="working.html#Title"><IMG SRC="previous.gif"
ALT="Previous" ALIGN="RIGHT" width="16" height="16"></A>
<h1>The EiffelNet Library</h1>
<hr>

<H2><A NAME="Title">7 OBTAINING A FINER DEGREE OF CONTROL</A></H2>

<P>
Let us now take a more internal look at the workings of EiffelNet. The two examples that follow have the same behavior as the preceding one; since their text is less simple, they are only interesting as an illustration of the lower-level facilities that you may want to use in specific cases. If you are already familiar with socket programming, they will also give you a more precise idea of how EiffelNet encapsulates the basic socket mechanisms.
</P>
<P>
As before, we have a client and a server class, still called <I>OUR_CLIENT </I>and<I> OUR_SERVER</I>, which are part of two different systems and will run concurrently. The communication uses streams rather than datagrams; the datagram form of communication will be examined in section <A HREF="datagram_sockets.html#Title">chapter 8</A>.
</P>

<H3><A NAME=Same Machine"> 7.1  A client and a server on the same machine</A></H3>

<CENTER>
<TABLE BORDER=1 WIDTH=75%>
<TR><TD>
The example classes discussed in this section appear in the   
subdirectory <I>same_mach </I>of the example directory               
</TD></TR>
</TABLE>
</CENTER>

<P>First, let us assume that the client and server run on the same machine, so that we will use the <I>UNIX_</I> versions of the classes (the next example will be multi-machine). The communication protocol is also the same as before: the client sends a list of strings, the server returns it extended.
</P>
<P>
Here we will create and manipulate sockets directly. For that reason, both classes inherit from the EiffelNet class <I>SOCKET_RESOURCES </I>which introduces a number of constants and other useful socket-related features.
</P>
<P>
The two sockets must be able to refer to a common address. For a communication within a single machine, as noted, this address is a path name, again <I>/tmp/here</I> for this example. The address will be an argument of the creation procedure used to obtain a socket <I>soc1 </I>on either side:
<ul><DL>
<I>
	<DT>!! soc1.make_client ("/tmp/here")
	<DT>!! soc1.make_server ("/tmp/here")
</I>
</DL></ul>
<P>
The <I>make_</I> procedures take care of all the hassles of establishing a socket for a client or a server: creating an address object, setting it to the given path name, binding the socket to the address, and in the client case establishing the connection. For finer control, these procedures are still available: you can create a bare socket by using the basic creation procedure <I>make</I> (rather than the more sophisticated <I>make_client </I>and <I>make_server</I>), then create a separate address object, associate the two, and call the <I>bind</I> and <I>connect</I> procedures.
</P>
<P>
Because communication is bidirectional, the distinction between client and server is not between who sends and who receives, although here the server only sends messages of acknowledgment. The client is the party that initiates the communication; the server is the party which stands ready to accept the communication. This difference justifies the presence of two creation procedures <I>make_client</I> and <I>make_server </I>as illustrated above. To initiate the communication, the client will execute:
<ul><DL>
<I>
	<DT>soc1.connect
</I>
</DL></ul>
<P>
To make itself ready for the communication, the server will execute:
<ul><DL>
<I>
	<DT>soc1.listen (n)
</I>
</DL></ul>
<P>
where <I>n</I> is a positive integer indicating the maximum number of client connection attempts that may be queued. The value 5, used in the example, is typical for <I>n</I>.
</P>
<P>
When you use the <I>_SERVER</I> classes of the predefined level, as in the earlier example, 5 is indeed the default; you can change the value to a positive integer <I>n</I> through the call <I>set_queued </I>(<I>n</I>).
</P>
<P>
Whenever the server needs to exchange objects with one of the clients, it obtains access to the socket through the following sequence:
<ul><DL>
<I>
	<DT>soc1.accept;
	<DT>soc2:= soc1.accepted;
	<DT>... </I>Storage and retrieval operations using <I>soc2</I> (not <I>soc1</I>) ...;<I>
	<DT>soc2.close
</I>
</DL></ul>
<P>
Procedure <I>accept </I>ensures synchronization with the client. When communication is established, <I>accept</I> creates a new socket which will be accessible through attribute <I>accepted</I>, whose value is here assigned to the local entity <I>soc2</I>. To receive objects, the server will use operations of the form introduced earlier (<A HREF="overview.html#iObject Structures">3.4</A>):
<ul><DL>
<I>
	<DT>struct ?= soc2.retrieved
</I>
</DL></ul>
<P>
applying to <I>soc2</I>, not <I>soc1</I>; this makes <I>soc1 </I>available to accept connections with other clients, a fundamental feature of client-server mechanisms.
</P>
<P>
The operation <I>soc2</I>l<I>close</I> which terminates the above sequence closes the new socket. In principle this is not necessary, since garbage collection should eventually reclaim the socket object, and the <I>dispose</I> procedure of the corresponding socket class includes a call to <I>close</I>. But the risk exists that you run out of sockets before garbage collection reclaims all currently opened sockets, so it is preferable to include the <I>close</I> calls explicitly.
</P>
<P>
At the end of the processing it is necessary to close the original socket <I>soc1</I> but also to unlink it. The feature <I>cleanup</I> from class <I>SOCKET</I> takes care of both closing and unlinking.
</P>
<P>
Here is the server class based on these principles. The actual processing has been put aside in a procedure <I>process</I>.
<ul><DL>
<I>
	<DT><B>class</B> OUR_SERVER <B>inherit</B>
		<DT><DD>SOCKET_RESOURCES;
		<DT><DD>STORABLE
	<DT><B>creation</B>
		<DT><DD>make
	<DT><B>feature</B>
		<DT><DD>soc1, soc2: UNIX_STREAM_SOCKET;
<BR><BR>
		<DT><DD>make <B>is</B>
				<DT><DL><DT><DL><DT><DD></I>-- Accept communication with client and exchange messages<<I></DL>
			<DT><DD><B>local</B>
				<DT><DL><DT><DD>count: INTEGER</DL>
			<DT><DD><B>do</B>
				<DT><DL><DT><DD>!! soc1.make_server ("/tmp/here")
				<DT><DD><B>from</B>
					<DT><DL><DT><DD>soc1listen (5); count := 0</DL>
				<DT><DD><B>until</B>
					<DT><DL><DT><DD>count = 3</DL>
				<DT><DD><B>loop</B>
					<DT><DL><DT><DD>process; </I>-- See below<I>
					<DT><DD>count := count + 1</DL>
				<DT><DD><B>end</B>
				<DT><DD>soc1.cleanup</DL>
			<DT><DD><B>rescue</B>
				<DT><DL><DT><DD>soc1.cleanup</DL>
			<DT><DD><B>end</B>;</DL>
<BR><BR>
		<DT><DD>process <B>is</B>
				<DT><DL><DT><DL><DT><DD></I>-- Receive a message, extend it, and send it back<I></DL>
			<DT><DD><B>local</B>
				<DT><DL><DT><DD>our_new_list: OUR_MESSAGE</DL>
			<DT><DD><B>do</B>
				<DT><DL><DT><DD>soc1.accept;
				<DT><DD>soc2 ?= soc1.accepted;
				<DT><DD>our_new_list ?= retrieved (soc2);
				<DT><DD><B>from</B> our_new_list.start <B>until</B> our_new_list.after <B>loop</B>
					<DT><DL><DT><DD>io.putstring (our_new_list.item);
					<DT><DD>io.new_line;
					<DT><DD>our_new_list.forth</DL>
				<DT><DD><B>end</B>
				<DT><DD>our_new_list.extend ("%N I'm back.%N");
				<DT><DD>our_new_list.general_store (soc2);
				<DT><DD>soc2.close</DL>
			<DT><DD><B>end</B></DL>
	<DT><B>end</B>
</I></DL></ul>
<P>
Note that at the end the server should not only closes the original socket <I>soc1 </I>but also unlinks it. It is recommended to have a Rescue clause which, as here, ensures that the socket will be closed and unlinked if the system terminates abnormally before its term.
<P>Here now is the client class:
<ul><DL>
<I>
	<DT><B>class</B> OUR_CLIENT <B>inherit</B>
		<DT><DD>SOCKET_RESOURCES
	<DT><B>creation</B>
		<DT><DD>make
	<DT><B>feature</B>
		<DT><DD>soc1: UNIX_STREAM_SOCKET;
<BR><BR>
		<DT><DD>make <B>is</B>
				<DT><DL><DT><DL><DT><DD></I>-- Establish communication with server, and exchange messages<I></DL>
			<DT><DD><B>do</B>
				<DT><DL><DT><DD>!! soc1.make_client ("/tmp/here");
				<DT><DD>soc1.connect;
				<DT><DD>process; </I>-- See below<I>
				<DT><DD>soc1.cleanup</DL>
			<DT><DD><B>rescue</B>
				<DT><DL><DT><DD>soc1.cleanup</DL>
			<DT><DD><B>end</B>;</DL>
<BR><BR>
		<DT><DD>process <B>is</B>
				<DT><DL><DT><DL><DT><DD></I>-- Build a message to server, receive answer, build
				<DT><DD>-- modified message from that answer, and print it.<I></DL>
			<DT><DD><B>local</B>
				<DT><DL><DT><DD>our_list, our_new_list: OUR_MESSAGE</DL>
				<DT><DD><B>do</B>
					<DT><DL><DT><DD>!! our_list.make;
					<DT><DD>our_list.extend("This"); our_list.extend (" is");
					<DT><DD>our_list.extend (" our"); our_list.extend (" test");
					<DT><DD>our_list.general_store (soc1);
					<DT><DD>our_new_list ?= soc1.retrieved;
					<DT><DD><B>from</B>
						<DT><DL><DT><DD>our_new_list.start</DL>
					<DT><DD><B>until</B>
						<DT><DL><DT><DD>our_new_list.after</DL>
					<DT><DD><B>loop</B>
						<DT><DL><DT><DD>io.putstring (our_new_list.item);
						<DT><DD>our_new_list.forth</DL>
					<DT><DD><B>end</B>;
					<DT><DD>io.new_line</DL>
				<DT><DD><B>end</B></DL>
	<DT><B>end</B>
</I></DL></ul>

<H3><A NAME="Different Machines">7.2 Communication between two different machines</A></H3>

<CENTER>
<TABLE BORDER=1 WIDTH=75%>
<TR><TD>
The example classes discussed in this section appear in the   
subdirectory <I>two_mach </I>of the example directory                
</TD></TR>
</TABLE>
</CENTER>
<P>
Let us now assume that the client and the server will run on two separate machines. Instead of <I>UNIX_ </I>sockets, we must now use sockets of type <I>NETWORK_STREAM_SOCKET</I>.
</P>
<P>
The available creation procedures are slightly different. The server will be set up so as to listen to clients from any machine; it designates a <B>port</B>, identified by an integer, on which it will listen. The socket creation on the server side is then
<ul><DL>
<I>
	<DT>!! soc1.make_server_port (2000)
</I>
</DL></ul>
<P>
For the client, the creation will specify two elements of information: the port number and the server. The server argument, a string, identifies the machine used as a server; it may be the host name of that machine, for example <I>"serverhost" </I>as used in the example; or it can be the machine's internet address, made of a sequence of numbers separated by periods, such as <I>"127.0.0.1"</I>.
</P>
<P>
The rest of the classes is as before.
<ul><DL>
<I>
	<DT><B>class</B> OUR_SERVER <B>inherit</B>
		<DT><DD>SOCKET_RESOURCES
		<DT><DD>STORABLE
	<DT><B>creation</B>
		<DT><DD>make
	<DT><B>feature</B>
		<DT><DD>soc1, soc2: NETWORK_STREAM_SOCKET;
<BR><BR>
		<DT><DD>make <B>is</B>
				<DT><DL><DT><DL><DT><DD></I>-- Accept communication with client and exchange messages.<I></DL>
			<DT><DD><B>do</B>
				<DT><DL><DT><DD>!! soc1.make_server_by_port (2000);
				<DT><DD></I>... The rest as before...<I></DL>
			<DT><DD><B>end</B></DL>
		<DT><DD>process <B>is</B> </I>... As before ...<I>
	<DT><B>end</B>
<BR><BR>
	<DT><B>class</B> OUR_CLIENT <B>inherit</B>
		<DT><DD>SOCKET_RESOURCES
	<DT><B>creation</B>
		<DT><DD>make
	<DT><B>feature</B>
		<DT><DD>soc1: NETWORK_STREAM_SOCKET;
<BR><BR>
		<DT><DD>make <B>is</B>
			<DT><DL><DT><DD><B>do</B>
				<DT><DL><DT><DD>!! soc1.make_client_by_port (2000, "serverhost");
				<DT><DD></I>... The rest as before ...<I></DL>
			<DT><DD><B>end</B></DL>
<BR>
		<DT><DD>process <B>is </B></I>... As before ...<I>
	<DT><B>end</B>
</I>
</DL></ul>

<P>
<A HREF="working.html#Title"><IMG SRC="previous.gif" ALT="Previous" width="16" height="16">Previous
Chapter</A>
<A HREF="toc.html"><IMG SRC="toc.gif" ALT="TOC" width="16" height="16">Table of Contents</A>
<A HREF="datagram_sockets.html#Title"><IMG SRC="next.gif" ALT="Next" width="16" height="16">Next Chapter</A>
</P>

<!-- ICON BAR -->
<!--msnavigation--></td></tr><!--msnavigation--></table></BODY>
</HTML>
