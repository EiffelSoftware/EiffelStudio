<document title="C++ Externals" output="studio">
	<meta_data>
		<help></help>
	</meta_data>
	<paragraph>
		<heading>
			<size>1</size>C++ Externals
		</heading>
		<heading>
			<size>2</size>Introduction
		</heading>
		<paragraph>Before making C++ calls in EiffelStudio, you may want to learn the basics of making
			<link>
				<url>10_c_externals.xml</url>
				<label>C calls</label>
			</link>, since these basics are not repeated here but they might be useful for C++ users as well and are necessary to fully benefit from this document.
		</paragraph>
		<paragraph>The C++ interface and Legacy++ are part of all versions of ISE Eiffel starting with version 4.1.</paragraph>
		<heading>
			<size>2</size>Overview
		</heading>
		<paragraph>Eiffel software must interact with software written in other languages. In this document you will learn about how to incorporate C++ classes in your Eiffel software.</paragraph>
		<paragraph>The C++/Eiffel interface offers the following mechanisms:</paragraph>
		<list ordered="false">
			<item>You can create instances of C++ classes from Eiffel, using the C++ "constructor" of your choice.</item>
			<item>You can apply to these objects all the corresponding operations from the C++ class: executing functions ("methods"), accessing data members, executing destructors.</item>
			<item>You can use the Legacy++ tool to produce an Eiffel "wrapper class" encapsulating all the features of a C++ class, so that the result will look to the rest of the Eiffel software as if it had been written in Eiffel.</item>
		</list>
		<paragraph>The discussion concentrates on using C++ software from Eiffel. In the other direction, you can use the Cecil library (C-EiffelCall-In Library) described in chapter 24 of
			<link>
				<url>http://vig.pearsoned.com/store/product/1,3498,store-3841_isbn-0132479257,00.xml</url>
				<label></label>
			</link> with important complements in the
			<link>
				<url>/technologies/cecil/index.xml</url>
				<label>Cecil manual</label>
			</link> and atftp://ftp.eiffel.com.
		</paragraph>
		<heading>
			<size>2</size>Syntax specification
		</heading>
		<paragraph>In the following specification, the syntax for
			<span>External</span> and
			<span>External_name</span> is retained unchanged from
			<italic>Eiffel: The Language</italic>, where
			<span>Language_name</span> is defined simply as
			<span>Manifest_string</span>; the rest covers the additional facilities.
<code_block>
    External == external Language_name [External_name]

    Language_name ==
            '"'
            Basic_language_name
            [Special_external_declaration]
            [Signature]
            [Include_files]
                    '"'

    Basic_language_name == "C" | "C++"

    Special_external_declaration == "[" Special_feature "]"

    Special_feature == Special_C_feature | Special_C++_feature

    Special_C_feature == ... See appendix E of Eiffel: The Language...

    Special_C++_feature ==
            Member_function_call|
            Static_function_call |
            Object_creation |
            Object_deletion |
            Data_member_access |

    Member_function_call == C++_Class

    C++_Class == Class_name File_name

    Class_name == Identifier

    Static_function_call == static C++_Class

    Object_creation == new C++_Class

    Object_deletion == delete C++_Class

    Data_member_access == data_member C++_Class

                -- The remaining elements are repeated
                -- from the C interface specification (page 291 in Eiffel: The Environment).

    File_name ==  User_file_name | System_file_name

    User_file_name == '%"' Manifest string '%"'

    System_file_name == "&lt;" Manifest_string "&gt;"

    Signature ==  "(" Type_list ")" [Result_type]

    Type_list ==  {Type "," ...}

    Result_type ==  ":" Type

    Include_files ==  "|" File_list

    File_list ==  {File_name "," ...}

    External_name ==  alias Manifest_string
</code_block>
		</paragraph>
		<code> </code>
		<paragraph>As with the C extensions of the previous appendix, the syntax description conventions are those of
			<italic>Eiffel: The Language</italic>.
			<span>==</span> means "is defined as". The vertical bar
			<span>|</span> separates alternative choices, such as the three possibilities for Special_feature. The brackets
			<span>[...]</span> enclose optional components; forexample a
			<span>Language_name</span> is made of required quotes, a required Basic_language_name and three further components, any or all of which may be absent. The notation
			<span>{Element Separator ...}</span> means: 0 or more occurrences ("specimens") of
			<span>Element</span>separated, if more than one, by
			<span>Separator</span>.
		</paragraph>
		<paragraph>Several of the symbols of the syntax notation, such as the brackets or the vertical bar, also appear in the language; to avoid any confusion they are given in double quotes. For example thespecification for
			<span>Include_files</span> begins with
			<span>"|"</span> to indicate that an
			<span>Include_files</span> part starts with a vertical bar. Single quotes may be used instead of double quotes when one of the quoted characters is itself a double quote; for example
			<span>'%"'</span> appearing in the production for
			<span>User_file_name</span> denotes the percent character followed by the double quote character. Special words such as
			<bold>static</bold> in bold italics stand for themselves, unquoted.
		</paragraph>
		<heading>
			<size>2</size>Available possibilities
		</heading>
		<heading>
			<size>3</size>Processing C++ features
		</heading>
		<paragraph>A
			<span>Special_C++_feature</span>, if present, indicates one of the following, all illustrated by examples in the next sections:
		</paragraph>
		<list ordered="false">
			<item>If the special feature's declaration simply starts with a C++ class name, followed by the associated file name, it indicates that the Eiffel feature will call a C++ member function (also known as a "method") from that class. The name of the member function is by default the same as the name of the Eiffel feature; as usual, you can specify a different name through the alias clause of the external declaration.</item>
			<item>If the declaration starts with
				<bold>static</bold>, it indicates a call to a C++ static function.
			</item>
			<item>If the declaration starts with
				<bold>new</bold>, it indicates a call to one of the constructors in the C++ class, which will create a new instance of that class and apply to it the corresponding constructor function.
			</item>
			<item>If the declaration starts with
				<bold>delete</bold>, it indicates a call to a destructor from the C++ class. In this case the Eiffel class may inherit
				<link>
					<url>/libraries/base/reference/kernel/memory.xml</url>
				</link> and redefine the dispose procedure to execute the destructor operations whenever the Eiffel objects are garbage-collected.
			</item>
			<item>If the declaration starts with
				<bold>data_member</bold>, it indicates access to a data member(attribute in Eiffel terminology) from the C++ class.
			</item>
		</list>
		<paragraph>The rest of the possible components are the same as in the C interface:
			<span>Signature</span> to specify types for arguments and results; possible
			<span>Include</span> file.
		</paragraph>
		<heading>
			<size>3</size>Extra argument
		</heading>
		<paragraph>For a non-static C++ member function or destructor, the corresponding Eiffel feature should include an extra argument of type POINTER, at the first position. This argument represents the C++ object to which the function will be applied.</paragraph>
		<paragraph>For example, a C++ function</paragraph>
<code_block>
	void add(int new_int);
</code_block>
		<paragraph>should have the Eiffel counterpart</paragraph>
<code_block>
	cpp_add (obj: POINTER; new_int: INTEGER) is
		-- Encapsulation of member function add.
	external
		"C++ [IntArray %"intarray.h%"] (IntArray *, int)"
	end
</code_block>

This scheme, however, is often inconvenient because it forces the Eiffel side to work on objects in a non-object-oriented way. (The object-oriented way treats the current object, within a class, as implicit.) A better approach, used by Legacy++, is to make a feature such as cpp_add secret, and to export a feature whose signature corresponds to that of the original C++ function, with noextra object argument; that feature will use a secret attribute object_ptr to access the object. In the example this will give the feature

<code_block>
	add (new_int: INTEGER) is
		-- Encapsulation of member function add.
	do
		cpp_add (object_ptr, new_int)
	end
</code_block>

		<paragraph>where
			<italic>object_ptr</italic> is a secret attribute of type
			<link>
				<url>/libraries/base/reference/kernel/pointer.xml</url>
			</link>, initialized by the creation procedures of the class. To the Eiffel developer, add looks like a normal object-oriented feature, which takes only the expected argument. Further examples appear below. This technique only works of course when the C++ object is implicit in the context of the Eiffel class.
		</paragraph>
		<paragraph>There is no need for an extra argument in the case of static member functions, constructors and data members.</paragraph>
		<heading>
			<size>2</size>Wrapping C++ classes: Legacy++
		</heading>
		<paragraph>Before taking a look at examples of the various facilities mentioned, it is useful to consider the tool that will help you, in many cases, avoid worrying about their details.</paragraph>
		<heading>
			<size>3</size>The role of Legacy++
		</heading>
		<paragraph>Often you will want to provide an Eiffel encapsulation of all the facilities -- member functions, static functions, constructors, destructors, data members -- of a C++ class. This means producing an Eiffel class that will provide an Eiffel feature for each one of these C++ facilities, using external declarations based on the mechanisms listed in the preceding section.</paragraph>
		<paragraph>Rather than writing these external declarations and the class structure manually, you can use the Legacy++ tool to produce the Eiffel class automatically from the C++ class.</paragraph>
		<heading>
			<size>3</size>Calling Legacy++
		</heading>
		<paragraph>Legacy++ is called with an argument denoting a
			<italic>.h</italic> file that must contain C++ code: one or more classes and structure declarations. It will translate these declarations into Eiffel wrapper classes. Legacy++ is only available on Windows. It is located in the $ISE_EIFFEL\bench\spec\windows\bin directory, under the name h2e.exe. By default the installation program creates an entry for it in the Start menu.
		</paragraph>
		<paragraph>The following options are available:</paragraph>
		<list ordered="false">
			<item>
				<bold>-E</bold>: apply the C preprocessor to the file, so that it will process #include, #define, #ifdef and other preprocessor directives. This is in fact the default, so that you do not need to specify -E explicitly (see next option).
			</item>
			<item>
				<bold>-NE</bold>: do not apply the C preprocessor to the file.
			</item>
			<item>
				<bold>-p</bold> 
				<italic>directories</italic>: use
				<italic>directories</italic> as includepath.
			</item>
			<item>
				<bold>-c</bold> 
				<italic>compiler</italic>: use
				<italic>compiler</italic> as the C++ compiler.
			</item>
			<item>
				<bold>-g</bold>: treat the C++ code as being intended for the GNU C++ compiler.
			</item>
		</list>
		<heading>
			<size>3</size>Result of applying Legacy++
		</heading>
		<paragraph>Running Legacy++ on a C++ file will produce the corresponding Eiffel classes. Legacy++ processes not only C++ classes but also C++ "structs"; in both cases it will generate an Eiffel class.</paragraph>
		<paragraph>Legacy++ knows about default specifiers: public for structs, private for classes.</paragraph>
		<paragraph>Legacy++ will generate Eiffel features for member functions(static or not).</paragraph>
		<paragraph>It will also handle any constructors and destructors given in the C++ code, yielding the corresponding Eiffel creation procedures. If there is no explicit constructor, it will produce a creation procedure with no arguments and an empty body.</paragraph>
		<paragraph>For any non-static member function or destructor, Legacy++ will generate a secret feature with an extra argument representing the object, as explained in the preceding section in this page. It will also produce a public feature with the same number of arguments as the C++ function, relying on a call to the secret feature, as illustrated for add and cpp_add above.</paragraph>
		<paragraph>The char* type is translated into
			<link>
				<url>/libraries/base/reference/kernel/pointer.xml</url>
			</link>. Pointer types, as well as reference types corresponding to classes and types that Legacy++ has processed, will be translated into
			<link>
				<url>/libraries/base/reference/kernel/pointer.xml</url>
			</link>. Other types will yield the type
			<code>
				<class_name>UNRESOLVED_TYPE</class_name>
			</code>.
		</paragraph>
		<heading>
			<size>3</size>Legacy++ limitations
		</heading>
		<paragraph>It is up to you to supply Eiffel equivalents of all the needed types. If Legacy++ encounters the name of a C++ class or type that is does not know -- i.e. it is neither a predefined type nor a previously translated class -- it will use the Eiffel type name
			<code>
				<class_name>UNRESOLVED_TYPE</class_name>
			</code>. If you do not change that type in the generated class, the Eiffel compiler will produce an error (unknown class) at degree 5.
		</paragraph>
		<paragraph>Legacy++ does not handle inline function declarations.</paragraph>
		<paragraph>Legacy++ makes no effort to understand the C++ inheritance structure.</paragraph>
		<paragraph>More generally, given the differences in the semantic models of C++ and Eiffel, Legacy++ can only perform the basic Eiffel wrapping of a C++ class, rather than a full translation. You should always inspect the result and be prepared to adapt it manually.</paragraph>
		<paragraph>Legacy++'s contribution is to take care of the bulk of the work, in particular the tedious and repetitive parts. The final details are left to the Eiffel software developer.</paragraph>
		<paragraph>Legacy++ is only supported on the windows platform.</paragraph>
		<heading>
			<size>2</size>Example
		</heading>
		<paragraph>Consider the following C++ class, which has an example of every kind of facility that one may wish to access from the Eiffel side:</paragraph>
<code_block>
    class IntArray
            {
            public:
                IntArray(int size);
                ~IntArray();
                void output();
                void add(int new_int);
                static char * type();

            protected:
                int *_integers;
            };
</code_block>
		<paragraph>Here is the result of applying Legacy++ to that class, which will serve as an illustration of both the C++ interface mechanisms and Legacy++:</paragraph>
<code_block>
indexing
    description: "Eiffel encapsulation of C++ class IntArray";

    date: "$Date$";
    revision: "$Revision$"

class
    INTARRAY

inherit
    MEMORY
        redefine
            dispose
        end

creation
    make

feature -- Initialization
    make (size: INTEGER) is
            -- Create Eiffel and C++ objects.
        do
            object_ptr := cpp_new (size)
        end

feature -- Removal
    dispose is
            -- Delete C++ object.
        do
            cpp_delete (object_ptr)
        end

feature
    output is
            -- Call C++ counterpart.
        do
            cpp_output (object_ptr)
        end

    add (new_int: INTEGER) is
            -- Call C++ counterpart.
        do
            cpp_add (object_ptr, new_int)
        end

feature {INTARRAY}
    underscore_integers: POINTER is
            -- Value of corresponding C++ data member.
        do
            Result := underscore_integers (object_ptr)
        end

feature {NONE} -- Externals
    cpp_new (size: INTEGER): POINTER is
            -- Call single constructor of C++ class.
        external
            "C++ [new IntArray %"INTARRAY.H%"] (EIF_INTEGER)"
        end

    cpp_delete (cpp_obj: POINTER) is
            -- Call C++ destructor on C++ object.
        external
            "C++ [delete IntArray %"INTARRAY.H%"] ()"
        end

    cpp_output (cpp_obj: POINTER) is
            -- Call C++ member function.
        external
            "C++ [IntArray %"INTARRAY.H%"] ()"
        alias
            "output"
        end

    cpp_add (cpp_obj: POINTER; new_int: INTEGER) is
            -- Call C++ member function.
        external
            "C++ [IntArray %"INTARRAY.H%"] (EIF_INTEGER)"
        alias
            "add"
        end

    cpp_underscore_integers (cpp_obj: POINTER): POINTER is
            -- Value of C++ data member
        external
            "C++ [data_member IntArray %"INTARRAY.H%"]: EIF_POINTER"
        alias
            "_integers"
        end

feature {NONE} -- Implementation
    object_ptr: POINTER

end -- class INTARRAY
</code_block>
	</paragraph>
</document>