<document title="10 Inheritance"><meta_data ><help ><toc ><envision_location >Eiffel, The Language\Tutorials\Invitation to Eiffel</envision_location><envision_pseudo_name>91</envision_pseudo_name><envision_title >Inheritance</envision_title><studio_location /><studio_title /></toc></help></meta_data><paragraph ><heading ><size >1</size><content >10 Inheritance</content></heading><paragraph >Inheritance, the other fundamental generalization mechanism, makes it possible to define a new class by combination and specialization of existing classes rather than from scratch.  </paragraph><paragraph >The following simple example, from the Data Structure Library in EiffelBase, is typical.  <code ><string >LIST</string></code>, as noted, describes lists in any representation.  One such representation if the lists have a fixed number of elements uses an array.  We may define the corresponding class by combination of <code ><string >LIST</string></code> and <code ><string >ARRAY</string></code>, as follows:</paragraph>


<code_block >
class ARRAYED_LIST [G] inherit

    LIST [G]

    ARRAY [G]

         export ... See below ... end

feature

    ... Specific features of fixed-size lists ...

end -- class ARRAYED_LIST

</code_block>

<paragraph >The <code ><keyword >inherit</keyword></code> ...clause lists all the "parents" of the new class, which is said to be their "heir".  (The "ancestors" of a class include the class itself, its parents, grandparents etc.  ; the reverse term is "descendant".  ) Declaring <code ><string >ARRAYED_LIST</string></code> as shown ensures that all the features and properties of lists and arrays are applicable to arrayed lists as well.  Since the class has more than one parent, this is a case of <span >multiple</span> inheritance.  </paragraph><paragraph >Standard graphical conventions -- drawn from the Business Object Notation or BON, a graphical object-oriented notation based on concepts close to those of Eiffel, and directly supported by EiffelStudio -- illustrate such inheritance structures:</paragraph><image ><url >invitation-4.png</url></image><paragraph >An heir class such as <code ><string >ARRAYED_LIST</string></code> needs the ability to define its own export policy.  By default, inherited features keep their export status (publicly available, secret, available to selected classes only); but this may be changed in the heir.  Here, for example, <code ><string >ARRAYED_LIST</string></code> will export only the exported features of <code ><string >LIST</string></code>, making those of <code ><string >ARRAY</string></code> unavailable directly to <code ><string >ARRAYED_LIST</string></code> 's clients.  The syntax to achieve this is straightforward:</paragraph>


<code_block >
class ARRAYED_LIST [G] inherit

        LIST [G]

        ARRAY [G]

               export {NONE} all end

    ... The rest as above ...

</code_block>

<paragraph >Another example of multiple inheritance comes from a windowing system based on a class <code ><string >WINDOW</string></code>, close to actual classes in EiffelVision 2.  Windows have <bold >graphical</bold> features: a height, a width, a position, routines to scale windows, move them, and other graphical operations.  The system permits windows to be nested, so that a window also has <bold >hierarchical</bold> features: access to subwindows and the parent window, adding a subwindow, deleting a subwindow, attaching to another parent and so on.  Rather than writing complex class that would contain specific implementations for all of these features, it is preferable to inherit all hierarchical features from <code ><string >TREE</string></code> (a class in EiffelBase describing trees), and all graphical features from a class <code ><string >RECTANGLE</string></code> .  </paragraph><paragraph >Inheritance complements the "client" relation by providing another form of reuse that yields remarkable economies of effort -- for analysis, design, implementation, evolution -- and has a profound effect on the entire software development process.  </paragraph><paragraph >The very power of inheritance demands adequate means to keep it under control.  Multiple inheritance, in particular, raises the question of name conflicts between features inherited from different parents; this case will inevitably arise in practice, especially for classes contributed by independent developers.  You may remove such a name conflict through <bold >renaming</bold>, as in</paragraph>


<code_block >
class C inherit

    A rename x as x1, y as y1 end

    B rename x as x2, y as y2 end

feature ...

</code_block>

<paragraph >Here, if both <code ><string >A</string></code> and <code ><string >B</string></code> have features named <code ><string >x</string></code> and <code ><string >y</string></code>, class <code ><string >C</string></code> would be invalid without the renaming.  </paragraph><paragraph >Renaming also serves to provide more appropriate feature names in descendants.  For example, class <code ><string >WINDOW</string></code> may inherit a routine <code ><string >insert_subtree</string></code> from <code ><string >TREE</string></code> .  For clients of <code ><string >WINDOW</string></code>, however, such a routine name is no longer appropriate.  An application that uses this class needs coherent window terminology, and should have to concern itself with the inheritance structure that led to the class.  So you may wish to rename <code ><string >insert_subtree</string></code> as <code ><string >add_subwindow</string></code> in the inheritance clause of <code ><string >WINDOW</string></code> .  </paragraph><paragraph >As a further protection against misusing multiple inheritance, the invariants of all parent classes automatically apply to a newly defined class.  So classes may not be combined if their invariants are incompatible.  </paragraph></paragraph></document>