indexing
	description: "Command that reads the description file generated by %
				% EiffelBench and fill the corresponding structures."
	date: "$Date$"
	id: "$Id$"
	revision: "$Revision$"

class
	IMPORT_APPLICATION_CLASS_CMD

inherit
	
	COMMAND

	EB_ENVIRONMENT

	SHARED_CLASS_IMPORTER

feature

	execute (arg: ANY) is
			-- Read the description file and fill the internal structure.
		local
			description_file: PLAIN_TEXT_FILE
			description_name: DIRECTORY_NAME
			line: STRING
		do
			!! description_name.make_from_string (Common_directory)
			description_name.extend (Description_file_name)
			!! description_file.make (description_name)
			if description_file.exists then
				description_file.open_read
				from
					description_file.start
					current_line := 0
				until
					description_file.end_of_file
				loop
					current_line := 1 + current_line
					description_file.read_line
					line := clone (description_file.last_string)
					process_line (line)
				end
				description_file.close
				update_routine_list
			end
		end

feature {NONE} -- Implementation

	process_line (a_line: STRING) is
			-- Add a command or a query, or create a new application class
			-- object according to the value of the line.
		local
			i: INTEGER
			key_value, value: STRING
		do
			if a_line.has (':') then
				a_line.left_adjust
				a_line.right_adjust
				i := a_line.index_of (':', 1)
				key_value := a_line.substring (1, i - 1)
				value := a_line.substring (i + 1, a_line.count)
				if key_value.substring_index (classname_keyword, 1) > 0 then
					process_class_name (value)
				elseif key_value.substring_index (infix_keyword, 1) > 0 then
				elseif key_value.substring_index (precondition_keyword, 1) > 0 then
					process_precondition (value)
				elseif key_value.substring_index (postcondition_keyword, 1) > 0  
					or else key_value.substring_index (creation_keyword, 1) > 0
				then
					--| do nothing
				elseif a_line.has ('(') and then a_line.has (')') then
					i := a_line.index_of (')', 1)
					if i = a_line.count then
							--| not a fonction
						if a_line.has (',') or else a_line.has (';') then
							process_routine (a_line)
						else
							process_command (a_line)
						end
					end
				elseif a_line.substring_index (" is ", 1) < 1 then
						--| not a constant
					process_query (a_line)
				end
			elseif not a_line.empty then
				process_routine (a_line)
			end
		end

	process_class_name (class_name: STRING) is
			-- Create a new application class object and add into the list.
		local
			an_app_class: APPLICATION_CLASS
			cmd_list: LINKED_LIST [APPLICATION_COMMAND]
			app_routine: APPLICATION_ROUTINE
		do
			if class_name.has (':') or class_name.has ('(') or class_name.has (')') then
				display_error_message
			else
				if current_application_class /= Void and not class_list.empty then
					cmd_list := current_application_class.command_list
					from
						cmd_list.start
					until
						cmd_list.after
					loop
						!! app_routine.make_from_command (cmd_list.item)
						current_application_class.add_routine (app_routine)
						cmd_list.forth
					end
				end
				!! an_app_class.make (class_name)
				class_list.extend (an_app_class)
				class_list.finish
			end


		end

	process_command (signature: STRING) is
			-- Add a command to the currently edited APPLICATION_CLASS object.
		local
			an_app_command: APPLICATION_COMMAND
			lower, upper: INTEGER
			cmd_name, arg_name, arg_type: STRING
		do
			signature.prune_all (' ')
			lower := 1
			upper := signature.index_of ('(', 1)
			if (upper <= 1) or (upper > (signature.count - 5)) then
				display_error_message
			else
				cmd_name := signature.substring (lower, upper - 1)
				lower := upper + 1
				upper := signature.index_of (':', lower)
				if (upper < lower) or (upper > (signature.count - 2)) then
					display_error_message
				else
					arg_name := signature.substring (lower, upper - 1)
					lower := upper + 1
					upper := signature.index_of (')', lower)
					if (upper < lower) or (upper /= signature.count) then
						display_error_message
					else
						arg_type := signature.substring (lower, upper - 1)
						!! an_app_command.make (cmd_name, arg_name, arg_type)
						current_application_class.add_command (an_app_command)
						current_application_method := an_app_command
					end
				end
			end
		end

	process_query (declaration: STRING) is
			-- Add a query to the currently edited APPLICATION_CLASS object.
		local
			an_app_query: APPLICATION_QUERY
			i: INTEGER
			q_name, q_type: STRING
		do
			declaration.prune_all (' ')
			i := declaration.index_of (':', 1)
			if (i <= 1) or (i > (declaration.count - 2)) then
				display_error_message
			else
				q_name := declaration.substring (1, i - 1)
				q_type := declaration.substring (i + 1, declaration.count)
				if q_type.has ('(') or q_type.has (')') or q_type.has (':') or q_type.has (';') then
					display_error_message
				else
					!! an_app_query.make (q_name, q_type)
					current_application_class.add_query (an_app_query)
				end
			end
		end

	process_routine (signature: STRING) is
			-- Add a routine to currently edited APPLICATION_CLASS object.
		local
			app_routine: APPLICATION_ROUTINE
			lower, upper: INTEGER
			arg_lower, arg_upper: INTEGER
			cmd_name, arg_type, arg_name: STRING
			arg_list: LINKED_LIST [APPLICATION_ARGUMENT]
			arg: APPLICATION_ARGUMENT
			finished, error: BOOLEAN
		do
			signature.prune_all (' ')
			lower := 1
			upper := signature.index_of ('(', 1)
			if (upper <= 1) then
				upper := signature.index_of (')', 1)
				if upper >= 1 then
					display_error_message
				else
					cmd_name := signature.substring (lower, signature.count)
					cmd_name.prune_all (' ')
					!! arg_list.make
				end
			else
				cmd_name := signature.substring (lower, upper - 1)
				!! arg_list.make
				from
				until
					finished or error
				loop
					lower := upper + 1
					upper := signature.index_of (':', lower)
					if (upper <= 1) or (upper > (signature.count - 2)) then
						display_error_message
						error := True
					else
						arg_name := signature.substring (lower, upper - 1)
						lower := upper + 1
						upper := signature.index_of (';', lower)
						if upper <= 1 then
							upper := signature.index_of (')', lower)
							if lower < upper then
								finished := True
							else
								display_error_message
								error := True
							end
						end
						if upper <= 1 then
							display_error_message
							error := True
						else
							arg_type := signature.substring (lower, upper - 1)
							from
							until
								arg_upper > arg_name.count
							loop
								arg_lower := arg_upper + 1
								arg_upper := arg_name.index_of (',', arg_lower)
								if arg_upper < 1 then
									arg_upper := arg_name.count + 1
								end
								!! arg.make (arg_name.substring (arg_lower, arg_upper - 1),
											arg_type)
								arg_list.extend (arg)
							end
						end
					end
				end
			end
			if not error then
				!! app_routine.make (cmd_name, arg_list)
				current_application_class.add_routine (app_routine)
				current_application_method := app_routine
			end
		end

	process_precondition (expression: STRING) is
			-- Add a precondition to the currently edited APPLICATION_ROUTINE object.
		local
			a_precondition: APPLICATION_PRECONDITION
			lower, upper, semi_column_index: INTEGER
		do
			if current_application_method /= Void then
				from
				until
					upper > expression.count
				loop
					lower := upper + 1
					upper := expression.index_of (';', lower)
					if upper <= 1 then
						upper := expression.count + 1
					end
					semi_column_index := expression.index_of (':', lower)
					if semi_column_index > 0 and then semi_column_index < upper then
						lower := semi_column_index + 2
					end
						!! a_precondition.make (expression.substring (lower, upper - 1))
						current_application_method.add_precondition (a_precondition)
				end
			end
		end

	display_error_message is
			-- Display Error message.
		do
			io.put_string ("Error in generated code at line")
			io.put_integer (current_line)
			io.new_line
		end

	update_routine_list is
			-- Update routine list of `current_application_class' with
			-- command list at the end of file.
		local
			cmd_list: LINKED_LIST [APPLICATION_COMMAND]
			app_routine: APPLICATION_ROUTINE
		do
			if current_application_class /= Void then
				cmd_list := current_application_class.command_list
				from
					cmd_list.start
				until
					cmd_list.after
				loop
					!! app_routine.make_from_command (cmd_list.item)
					current_application_class.add_routine (app_routine)
					cmd_list.forth
				end
			end
		end

feature {NONE} -- Attributes
	
	current_line: INTEGER
			-- Current line
	
	current_application_method: APPLICATION_METHOD
			-- Currently edited application method object

 	current_application_class: APPLICATION_CLASS is
			-- Currently edited application class object 
		do
			Result := class_list.item
		end


feature {NONE} -- Constants


	classname_keyword: STRING is "<class>"
			-- Keyword "<class_name>"

	creation_keyword: STRING is "<creation>"
			-- Keyword "<creation>"

	infix_keyword: STRING is "<infix>"
			-- Keyword "<infix>"

	precondition_keyword: STRING is "<require>"
			-- Keyword "<require>"

	postcondition_keyword: STRING is "<ensure>"
			-- Keyword "<ensure>"

end -- class IMPORT_APPLICATION_CLASS_CMD	
