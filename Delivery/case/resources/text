!EiffelCase
EiffelCase
^EiffelCase#

#
1 - @Introduction@#
2 - @Graphical interface@#
2.1 - @Project Tool@#
2.2 - @Architecture Tool@#
2.2.1 - @classes@#
2.2.2 - @clusters@#
2.2.3 - @inheritance@ links#
2.2.4 - @client-supplier@ links#
2.3 - @Tool Windows@#
2.3.1 - @Class Tool@#
2.3.2 - @Feature Tool@#
2.3.3 - @Link Tool@#
2.4 - @Naming Objects@#
2.5 - @System Tool@#
2.6 - @History Tool@#
2.7 - @Preferences Tool@#
2.8 - @Help Tool@#
2.9 - @View Tool@#
2.10 - @Print Tool@#
2.11 - @Generation Tool@#
3 - @Views@#
4 - @Reverse Engineering@#
5 - Customization with @resources file@#
@Appendices@#
A.1 @Eiffel 3@#
A.2 @BON@#
A.3 Current @limitations@#
@Subject Index@#

#
To get help about help, click on the following text: @Help Tool@.#

#
"$Revision$"#
"$Revision$"#
&) Interactive Software Engineering - Santa Barbara, 1994.#
E-mail (Internet): eiffel@eiffel.com#

#

#
!Introduction
EiffelCase
^1 - Introduction#

#
EiffelCase is an object-oriented modeling, design, analysis and
documentation workbench developed
by Soci&it&i des Outils du Logiciel (Paris) and ISE Inc.
(Santa Barbara).#

#
It complements the ISE Eiffel development environment
with up-front O-O CASE tool capabilities.
EiffelCase is entirely written in @Eiffel@ and extensively relies
on ISE Eiffel class libraries.#

#
EiffelCase provides developers with high-level graphical representations
of software elements described as abstract structures (clusters, classes)
with properties (attributes, features) and relation links. EiffelCase
promotes a seamless software development that starts
with the mapping of problem space elements into solution space
entities and results into the production of Eiffel class templates
traceable with analysis and design classes.#

#
The in-line help facility serves as a quick reference guide.
It may be looked at sequentially or using simple hypertext-like navigation 
features to move back and forth between key reference items.#
.#
!Graphical interface
Introduction
^2 - Graphical interface#

#

#
EiffelCase relies on the following interaction conventions.#

#
The mouse buttons with key combinations are assigned to the following purposes:#
- <SHIFT> + right mouse button: @naming objects@#
- <SHIFT> + Left mouse button: creating graphical @classes@ and @clusters@#
- <CONTROL> + Left mouse button: selection or unselection of graphical objects#
- Right mouse button: drag and drop#
- <CONTROL> + right mouse button: @tool@ creation#

#
The graphical interface consists of @tool@ windows and information
windows. The user interface mechanism is based upon the drag-and-drop
method. Any object in the interface can be dragged and dropped. To start
a drag the mouse cursor must be placed over the object. Press and release
the right mouse button. A corresponding cursor shape will appear and when
you move the cursor a line is drawn from the source of the pebble to the
cursor. To drop the pebble, press and release the right button.#

#
Each window in the interface has a wastebasket hole. All objects
can be dropped into this hole and removed from the interface. The interface
will be updated automatically.#

#
All EiffelCase projects have the following subdirectories under CASEGEN:#
- Doc (EiffelCase documentation files)#
- E_code (Eiffel code generated)#
- Storage (Project information)#
- View (Information for all views)#
- .restore (for recovery).#

#

!Project Tool
Graphical interface
^2.1 - Project Tool#

#

#
The Project Tool has the following buttons:#
- Cluster, class, and relation holes#
By dragging and dropping a pebble into the appropriate hole, a corresponding
@tool@ will appear for that pebble. You can also drop these pebble types into
the visibility area of the Project Tool which will create a tool.#
- Wastebasket hole#
To remove an object, drag and drop a pebble into the Wastebasket hole.#
- Project creation and loading buttons#
Press "Create project" button to create a new project or press "load project"
button to retrieve an existing project. A file selection box will appear for both of
these requests.#
- Save button#
This saves the edited project.#
- Save-as button#
A file selection box will appear and then you can enter the name in which the current
project to be saved as. This will become the current project.#
- Quit Button#
This exits from EiffelCase. It will warn you if you have not saved
your project before exiting.#
- Generate Eiffel code button#
This displays the @Generation Tool@.
- Print button#
This displays the @Print Tool@.
- View Tool button#
This displays the @View Tool@.

#
Other tools that can be called from the Project Tool are:#
- The @System Tool@#
- The @History Tool@#
- The @Preferences Tool@#
- The @Help Tool@#
- The @View Tool@#

#
These tools are part of visibility area of the Project Tool. When you
press one of the toggle buttons, the corresponding window will appear (eg. pressing the
@History Tool@ toggle button will make the @History Tool@ appear). Pressing
the same toggle button will close the tool if it is being displayed.#

#

#
!Architecture Tool
Graphical interface
^2.2 - System Architecture Tool#

#

#
LAYOUT#

#
EiffelCase deals with possibly multiple graphical area windows.
When a project is loaded or created, EiffelCase displays 
a main architecture tool.
This main architecture tool consists of a central workspace
and several parts in the frame around it. The workspace is adjustable 
using right and down side scroll bars.#

#
The central workspace displays graphical objects
conforming to the @BON@ notation part used to represent
static architectures. There are basically two categories of
graphical objects: structure objects ( @classes@ and @clusters@) 
and relation link objects linking the structure objects ( @inheritance@,
@client-supplier@ and aggregation relation links).
Inheritance, association or aggregation links
semantically define different relation links between
clusters or classes.  Links always follow objects they 
connect together, like a rubber band.#

#
The various combinable graphical objects are:#
- @classes@ and @clusters@#
- @inheritance@ relation links#
- @client-supplier@ relation links# 

Five iconic column-aligned buttons inside the bottom frame represent
different graphical object shapes.  These buttons are used to 
create graphical objects instances.#

#
Inside the workspace, selected objects are editable 
or destroyable when dragged and dropped onto a corresponding tool hole or
the Wastebasket hole displayed at the top of the frame.#

#
A cluster may contain inner clusters, classes and relation links. 
Relation links may involve objects contained within a cluster or
objects belonging to other clusters. Therefore a relation link may extend
outside the cluster border.#

#
A cluster delineates a consistent system partition. Therefore,
whenever a cluster is moved, its inner objects follow. 
Selecting a cluster means selecting all its constitutive elements.
Moving a class or a cluster across the border of another cluster,
results in the merge of the moved object with the elements of the
destination cluster. Of course, when selecting and moving a class 
belonging to a cluster, its outer cluster does not move.#

#
GRAPHICAL OBJECTS

#
EiffelCase deals with different types of objects helping the partitioning
of the system complexity. Systems are defined with basic and
decentralized components represented by collections of classes.#

#
In EiffelCase, there are two different types of @client-supplier@ relation links:
association and aggregation relation links. 
@Client-supplier@ relation links stress 
dependencies between classes or clusters on the basis of
visible class features.3

#
@Client-supplier@ relation links may be tagged with 
the feature names or structural properties that are involved
in the dependency between the client and the supplier class.

#

#
!classes
Architecture Tool
^2.2.1 - Classes#

#

#
FORMAT#
Classes are represented with a name inside an ellipse.
Different class annotations complement this representation
to highlight specific class properties: deferred or effected classes, 
generic classes, etc.
Annotations are selected using the @Class Tool@ (see further
section).#

#
CREATION#
There are two methods for class creation:.#
1. To create a new class, move the cursor (small arrow shape) inside
the class icon located at the bottom of the architecture tool.#
Then click and release with the right mouse button. A corresponding
class creation cursor appears. Drag the cursor at the location of the
graphical area where you want to create the class and then click and release 
the right mouse button.#
2. The left most two buttons at the bottom of the architecture tool
relate to the creation of classes and clusters. 
Class creation is selected by default. Place the mouse cursor at the location
desired and press <SHIFT> and the left mouse button together. This will
create the class. #

#
SELECTION AND MOTION#
Classes, clusters and link handles can be moved around in the graphical area. 
To move a class, press the left mouse button on a class header. 
When releasing the left mouse button after a class is dragged around, motion stops.
When moved around, the frame of the class alone is displayed.#

#
To select a class press <CONTROL> and left mouse button together and the
corresponding class will appear in reverse mode or in a different background color.
Several graphical objects may be selected at once.  One possible way to achieve 
multiple object selections in the workspace, is to press <CONTROL> and the left 
mouse button together, designate the top left corner of a resizable rectangle frame
and then drag down the right down corner to delimit a selected objects area.#

#
The above multiple delimitation technique cannot be used within the borderline 
of a cluster. Then, in this case, use the single selection method to iteratively select
graphical objects.#

#
When all objects are selected (classes and clusters), use the left 
mouse button to move them all up to a new position obtained when 
releasing the mouse button.

#

#
!clusters
Architecture Tool
^2.2.2 - Clusters#

#

#
FORMAT#
Clusters are represented inside dashed border line and 
rounded corners rectangles.
A cluster has a tag window. The tag window is a name inside 
a top or bottom dashed line box along the cluster border.
A cluster may contain other clusters.
Additional architecture cluster tools windows may be created at will by dragging and 
dropping into the cluster hole of the Project Tool or by <CONTROL> right
click on the cluster object.#

#
CREATION#
There are two methods for class creation:.#
1. To create a new cluster, move the cursor (small arrow shape) inside
the cluster icon next to the create class icon at the bottom
of the drawing panel.
Then click and release with the right mouse button. A corresponding
cluster creation cursor appears. Drag the cursor at the location of the
graphical area where you want to create the cluster and then click and release 
the right mouse button.#
2. As explained above, Class creation is selected by default. 
To create a cluster, press the
left most button at the bottom of the drawing window (button with
"create cluster" focus) with the left mouse button. Notice that this
will visually display your selection. Place mouse cursor at the location
desired and press <SHIFT> and left mouse button together. This will
create the cluster.#

#
SELECTION AND MOTION#
The cluster tag name window may be moved along the north
or the south cluster borderline. To obtain this effect, select
the tag window with the left mouse button. Then, keeping
the left mouse button pressed, drag the tag window from right
to left or conversely. To flip over the tag window 
to the opposite horizontal borderline, drag the tag window in the 
up or down direction.  A tag ghost window appears then. 
When releasing the left mouse
button at a location nearest to the new desired tag location,
the tag window is definitively moved.
Clusters may be moved around similarly to classes.
When moved, its frame alone is displayed.
Beware that deleting a cluster leads to
the deletion of all the objects it contains.#

#
ZOOMING IN/OUT#
Clusters may be zoomed in or out to focus on specific diagram parts. A cluster
can be zoomed inside the system architecture tool, or inside another cluster 
tool.
To zoom into a cluster inside the architecture tool, drag and drop the
cluster into the cluster hole of the architecture tool (or you may drop it
into an empty region not occupied by an object in the graphical area).
To zoom out, press the "show parent cluster of Current" button located at the
top right of the architecture tool (next to the cluster name hole).
If a same cluster is viewed in several architecture tools at the same time, 
any cluster modification occurring inside one graphical area 
is immediately and automatically propagated inside the competing views.
NOTE: cluster zooming in or out should not be confused with cluster
abstraction; it is orthogonal. Of course abstracted clusters,
because of a lack of room at a certain display level, are
good candidate for zoom in and out operations.#

#

#
!inheritance
Architecture Tool
^2.2.3 - Inheritance links#

#

#
FORMAT#
Inheritance links are represented with an oriented single line ending with
an arrowhead, outgoing from the descendant class and incoming the
parent class. Inheritance links are, according to the @BON@ methodology,
only allowed in the horizontal or vertical direction.#

#
CREATION#
Links are created in two steps. First, a type of link is selected from
the bottom panel of the architecture tool. By default, the inheritance link
is selected.
Drag the source object (class or cluster) involved in the relation link
by click and release with the right mouse button. Then drag the stone
and release on the destination object (class or cluster). A link is then
established from the source to the target object.#

#
CHANGE OF SHAPE#
Although the methodology suggest not to use angled links, EiffelCase
creates angled links whenever two structure objects are not
vertically or horizontally aligned. To better comply with recommended
guidelines proceed as follows:#
- Select the link using the left mouse button. This will
display end handles and two small triangles across the middle of
the link facing two opposite directions.# 
- Click with left mouse button one triangle head. 
This will substitute the angled link with an horizontal 
and a vertical link joined with a corner inside 
the quadrangle area pointed to by the triangle head.#

#
JOINING LINKS#
Inheritance join points group together multiple inheritance relation link into one.
To join inheritance links, break one inheritance link first. This will create
a angle corner marked with a handle. To merge different links together, 
select another inheritance link at a certain location and drag it on top
of the join point. This will combine different links together. Joined
links will then share destiny when moved, deleted or stretched.#

#

#
!client-supplier
Graphical interface
^2.2.4 - Client-supplier links#

#

#
ASSOCIATION LINKS#
A double line ending with an arrowhead represents an association links.
The direction of the link goes from the client class to the
supplier class.
An association link stresses a typed reference between the
client and the supplier classes.
To create an association link, select the "create client" bottom located
at the bottom of the architecture tool by pressing the left mouse button. Notice
that the button is visually selected. 
Follow the same sequence of steps as the one defined for inheritance links
to create an association link.#

#
AGGREGATION LINKS#
A double line ending with an open curly bracket represents an
aggregation link. The direction of the link goes
from the client class to the supplier class.
An aggregation link 
stresses a part of a whole between the client and the supplier classes.#

#

#
!Tool windows
Graphical interface
^2.3 Tool Windows#

#

#
All tools have the same interface format. Buttons located at the bottom are
formats. To activate a format, press with the left mouse button over the
button. Buttons located next to text areas have dual purposes:#
- by pressing on these buttons, an object of that type is created#
- it can receive compatible stone type in which it will copy once a pebble is dropped into it#

#
Within the text area, elements can be shuffled with other compatible elements. For example,
in the Feature Tool the text area can have the following text:#

#
f is#
.....require#
........prec1: prec1#
........prec2: prec2#
........prec3: prec3#
.....do#
.....end#

#
To insert precondition with tag "prec3" before "prec1" drag pebble prec3 and drop it
on top of prec1. The following text should appear:#

#
f is#
....require#
........prec3: prec3#
........prec1: prec1#
........prec2: prec2#
....do#
....end#

#
Thus elements are inserted before the element it is dropped onto.#

#

#
!Class Tool
tool windows
^2.3.1 Class Tool#

#

#
The Class Tool window is displayed when a class is dragged into the
class hole of the architecture tool or the Project Tool.
It is possible to reuse the same tool window for different classes.
This avoids new tool creations each time a class edition
occurs.
To edit a different class, drag a class from the interface into
the class hole of the Class Tool.
After the class has been dropped into the tool hole, it automatically
changes the class name displayed inside the text entry field. The tool is
now available to edit another class.#

#
Five formats are available:#
- Annotations#
Class annotations may be added on request by ticking the selected
box in the selection panel. The selection is immediately in effect
inside the architecture tool.#
- Chart#
The user can add/remove index clauses, constraints, queries and commands.#
- Specification#
Features, generics, invariants can be added and removed. It is also possible
to sort features upon request.#
- Eiffel Code#
Same functionality as specification format.#
- Features#
This only displays features. Features can be added/removed and sorted upon
request.#

#

#
!Feature Tool
tool windows
^2.3.2 Feature Tool#

#

#
To edit a feature you must either drag-and-drop an feature from a class
tool or use the text fields located at the top of Feature Tool to do
a partial search and then select the desired feature. To invoke the
partial search enter text into the feature field and/or into the
class field and press <RETURN>. Classes are retrieved with the prefix
of the text that was entered in the class field and then a list will
appear with all the features with the prefix value entered in the
feature field for each of the retrieved classes.#

#
The Feature Tool has two formats:#
1. Show specification#
Displays @BON@ specification definition for a feature.#
2. Show eiffel code#
Displays the features eiffel code.#

#
To add the desired component of the feature, press with the left mouse
button on the appropriate button. For example, if you wish to add an
argument, press the button that has the focus "Add argument". An argument
will then appear in the text region. It will also update the Class
Tool if the corresponding feature is shown in the text region.

#

#
!Link Tool
tool windows
^2.3.3 Relation Link Tool#

#

#
The Relation Link Tool is used to label class or cluster relation links. First
select a link and <CONTROL> and right mouse click to create a Link Tool or
drag-and-drop a link into a relation hole. The tool will display
the source and the destination of the link.
There are two formats for the Link Tool:#
1. Show label#
Type in the text entry field the label to associate to the link.#
2. Show Markers (for @client-supplier@ and aggregation links only)#
To add a multiplicity marker press on the toggle named "Multiplicity" and
use the scale to define the value. To define a shared marker (only for
@client-supplier@ relation links) press the toggle marked "Shared".#

#

#
!naming objects
Graphical interface
^2.4 Naming Objects#

#

#
By pressing the left mouse button on any object in the interface a Name Tool will
appear.#
There are three types of Name Tool. They are: #
- Naming simple objects (classes, clusters and features)#
In this case, only a text field is displayed. If you enter an existing name
the Name Tool will display the error message above the text area.#
- Naming tagged objects (assertions and arguments)#
The Name Tool will display two text field.#
- Naming free text objects (description and feature comments)#
A text area will appear but will be larger than the previous Name Tool types.# 

Type in the new text name ending with <RETURN>. However, for free text 
objects text entry is terminated by pressing <SHIFT><RETURN>. You may erase any
typed in character using the <DEL> key or by selecting a text portion with 
the left mouse button and then re-typing it.#

#

#
!System Tool
Graphical interface
^2.5 System Tool#

#

#
The System Tool offers three formats:#
- Display the @classes@/ @clusters@ of the system.#
This gives a heirarchical view of the system textually.#
- Display the system chart.#
- Display the data dictionary.#
Each of these functionalities are represented by a format button located at
the bottom of the System Tool. Each button has a focus to describe what
the format is. Press desired format with the left mouse button.

#

#
!History Tool
Graphical interface
^2.6 History Tool#

#

#
To display the History Tool press on the toggle button (named History)
on the Project Tool.
The History Tool piles in all commands performed inside a session.
To undo or redo commands, simply click on one of the top buttons: #
- Pixmap representing an up arrow implies undo#
- Pixmap representing a down arrow implies redo.#

#

#
!Preferences Tool
Graphical interface
^2.7 Preferences Tool#

#

#
To display the Preferences Tool press on the toggle button (labeled Preferences)
on the Project Tool.
This opens up a tool presenting a set of possible options
such as the display of a background grid, the use of a magnetic background
to automatically align graphical elements and the associated 
tunable spacing.#

#

#
!Help Tool
Graphical interface
^2.8 Help Tool#

#

#
The Help Tool is the tool from which you are reading this text.#
It provides the following functionalities:#
- Go to the table of contents#
- Go up one chapter level#
- Go to the next page#
- Go to the previous page.#
These are represented by icons located at the top right corner of the tool.#

#

#
!View Tool
Graphical interface
^2.9 View Tool#

#

#
The View Tool displays the current view name, its description and
other views for the project. To create a new view, enter a view name
that does not exist in the 'New view' text field and press return. This
will create a new view using the current view information. To edit the
new view, left click on the load project button and the new view entered
will be displayed in the project list column and then select this view.#

#
!Print Tool
Graphical interface
^2.10 Print Tool#

#

#
The documentation will be generated in directory <project directory>/E_Code.
The generated documentation includes: class data dictionary, cluster_chart, system_chart,
class_charts, class_interfaces, and static diagrams. These documents can
be generated into a directory or directly to the printer. There is a choice
of the printing format (currently it supports ascii and postscript). Consult
the eiffelbench manuals on how to specify filter formats.#
!Generation Tool
Graphical interface
^2.11 Generation Tool#

#
There are two choices when generating the Eiffel template classes from case.#

1. Case project#
This will generate all the class templates in directory <project directory>/E_code. 
A cluster is represented by a subdirectory and classes are generated in their corresponding
cluster directory.#
2. Eiffel project#
This will generate the modified classes since the last reversed engineering into
the Eiffel project (where the source of the reversed engineering was done).
A subdirectory called CASEMOD will be created for each cluster that had classes
modified and the template class will be generated into this directory.#

Select the desired toggle (Case project or Eiffel project) and press the generate
button which is located next to the exit button.

#
!views
Graphical interface
^3 - Views#

#

#
Eiffelcase has the ability of having multiple views for the
same project. There is a common data structure which is the
same for all views (eg. classes/clusters, client, supp ...).
However, it is possible to manipulate this information so it
can be represented differently for each view.#

#
The following are actions that will only affect a view:#
. Hiding/showing classes and clusters#
. Setting colors classes, clusters and relations#
. Positioning of classes, clusters, handles and relations.#
. Adding handles to relations.#
. Iconifying clusters.#
. Hiding/showing of @inheritance@, @client-supplier@, aggregation and
relation labels.#
. Hiding/showing grid and specifying grid size.#
. Hiding/showing some of the @BON@ notations (chart and specifications).#

#
!reverse engineering
views
^4 - Reverse Engineering#

#
Eiffelcase can reverse engineer any Eiffel projects that
has been compiled with EiffelBench.#

#
To perform reverse engineering you may, from the graphical Eiffel
environment (EiffelBench) press the Case storage button, located on the
lower-right part of the EiffelBench's Project Tool window.#

#
Alternatively, you can use the command-line version:#
1. Go to the Eiffel project directory.#

2. type 'es3 -loop' and press return.#
The following should be displayed.#

#
==== ISE Eiffel3 - Interactive Batch Version (v3.x.y) ====#

#
........(C) Class......: class formats and information.#
........(I) Compile....: compile or run the system.#
........(F) Feature....: feature formats and information.#
........(S) System.....: Ace and cluster details.#

#
........(H) Help.......: show list of commands.#
........(Q) Quit.......: terminate session.#
........(Y) Yank.......: yank (save) output of last command to a file.#

#
Command =>#


#
3. Type `s' or `S' at the command prompt and the window
should display:#
Command => s#
........(A) Ace..........: show the Ace file.#
........(L) Classes......: show the classes in alphabetic order.#
........(C) Clusters.....: show the system's classes, cluster by cluster.#
........(V) Edit.........: edit the Ace file.#
........(I) Indexing.....: show indexing clauses of classes.#
........(O) Modifications: show classes modified since last compilation.#
........(T) Statistics...: show system statistics.#
........(S) Store........: store in case format.#

#
........(H) Help.........: show list of commands.#
........(M) Main.........: go back to main menu.#
........(Q) Quit.........: terminate session.#
........(Y) Yank.........: yank (save) output of last command to a file.#

#
3. Once again, type `s' or `S' (for (S) Store) at the 
command prompt and should display something like:#
Command => s#

#
Processing clusters#
...Analyzing cluster: KERNEL#
...[analyzing other cluster and classes]#

#
The end will be indicated by the following message:#

#
Saving EiffelCase project to disk.#
Finished storing EiffelCase project.#
Command =>#
#
#

!resources file
reverse engineering 
^5 - Customization#

#

#
EiffelCase uses an application defaults file. Consult the Eiffel: 
the environment manual (Appendix A: Environment customization)
for the location and modifying resource file for eiffel products.#

The following default resources are used by EiffelCase:

#
auxiliary_cluster_window_height: 400#
auxiliary_cluster_window_width: 700#
auxiliary_cluster_window_x: 100#
auxiliary_cluster_window_y: 100#
background_color: ""#
chart_page_size: 100#
class_color: "black"#
class_ellipse_x_offset: 10#
class_ellipse_y_offset: 6#
class_generic_offset: 2#
class_interior_color: "LightSeaGreen"#
class_name_font: "-adobe-times-medium-i-normal--12-120-75-75-p-63-iso8859-1"#
class_reused_offset: 2#
class_root_offset: 2#
class_symbols_offset: 2#
class_symbols_spacing: 2#
class_window_height: 400#
class_window_width: 450#
cluster_chart_window_height: 600#
cluster_chart_window_width: 500#
cluster_color: "red"#
cluster_height: 75#
cluster_icon_x_margin: 10#
cluster_icon_y_margin: 30#
cluster_iconized_color: "white"#
cluster_name_font: "-adobe-times-medium-i-normal--12-120-75-75-p-63-iso8859-1"#
cluster_print_window_height: 500#
cluster_print_window_width: 400#
cluster_title_interior_color: "white"#
cluster_title_margin: 5#
cluster_width: 75#
cluster_window_height: 440#
cluster_window_width: 770#
cluster_window_x: 0#
cluster_window_y: 0#
color_window_height: 100#
color_window_width: 100#
component_page_size: 200#
default_font: ""#
dictionary_page_size: 100#
documentation_tool_height: 400#
documentation_tool_width: 300#
drawing_background_color: "AliceBlue"#
feature_tool_height: 400#
feature_tool_width: 550#
focus_label_font: ""#
foreground_color: ""#
generic_font: "-adobe-times-medium-r-normal--12-120-75-75-p-64-iso8859-1"#
generation_tool_width: 200#
generation_tool_height: 150#
grid_color: "LightGray"#
help_link_font: "-adobe-times-bold-i-normal--12-120-75-75-p-68-iso8859-1"#
help_text_font: "-adobe-helvetica-bold-r-normal--24-240-75-75-p-138-iso8859-1"#
help_title_font: "-adobe-helvetica-bold-r-normal--24-240-75-75-p-138-iso8859-1#
help_tool_height: 630#
help_tool_width: 430#
hidden_component_tool_height: 400#
hidden_component_tool_width: 400#
history_size: 10#
history_tool_width: 280#
link_apart: 1#
link_arrow_size: 6#
link_bracket_size: 6#
link_color: "black"#
link_digit_font: "-adobe-times-medium-r-normal--8-80-75-75-p-44-iso8859-1"#
link_label_font: "-adobe-times-medium-i-normal--12-120-75-75-p-63-iso8859-1"#
link_label_space: 2#
link_width: 2#
main_panel_height: 160#
main_panel_width: 520#
main_panel_x: -1#
main_panel_y: 0#
name_tool_width: 300#
name_tool_width_with_tag: 470#
color_buttons_per_line: 10#
preference_tool_width: 200#
printer_command: "/usr/ucb/lpr"#
project_selection_width: 300#
project_selection_height: 350#
relation_tool_height: 310#
relation_tool_width: 500#
resize_coin_color: "black"#
selected_interior_color: "grey43"#
selected_invert_color: "white"#
show_bon: True#
system_variable: "SYSTEM"#
system_tool_height: 440#
system_tool_width: 400#
tab_length: 8#
view_tool_height: 400#
view_tool_width: 300#
window_max_free_list: 0#
#

#
!Appendices
EiffelCase
^APPENDICES#

#

#
A.1 - @Eiffel 3@#
A.2 - @BON@#
A.3 - @Limitations@#

#

#
!Eiffel 3
appendices
^A.1 - Eiffel 3#

#

#
Eiffel is a pure object-oriented language, promoting
the development of systems seeking quality factors such robustness,
reusability and extendibility.#

#
Eiffel provides strong and static typing, multiple inheritance, genericity, 
dynamic binding, assertion monitoring and exception handling.

#
Eiffel 3 was designed to combine in a simple and easy-to-learn
way the most advanced principles of modern software engineering
in a clean, elegant and powerful syntactical and semantical mind set.#

#
&) Eiffel is a registered trademark of NICE, the Eiffel Consortium.#

#

#
!BON
appendices
^A.2 - BON#

#

#
BON (Better Object Notation) is an analysis and design technique relying
on a set of notations and guidelines.#

#
BON promotes a descriptive method that primarily addresses
early stages of software development.#

#
Key criteria have guided the definition of BON:#
- scalability#
- documentation aid#
- structuring mechanisms#
- systematic design support#
- component management support#
- reverse engineering capabilities#

#
BON helps build and display multiple
system views of which formalisms vary according to end-users' needs:
customer, analyst or designer.#
The notation uses a well-defined set of
conventions and supports semantics: assertions, contracts, class invariants.

#
Either textual or graphical elements can be used and manipulated.

#
BON both supports dynamic and static system descriptions.#

#
The BON static description allows the display of clusters, entire systems,
selected abstractions, zooming in and out of sub-system parts.

#
The BON dynamic description highlights selected message passing 
scenarios triggered after an external event is received and propagated 
inside the system.

#
The comprehensive set of BON standardized deliverables is listed below:

#
CLUSTER CHARTS AND SYSTEM CHART#
	 Definition of clusters and list of associated classes.#

#
CLASS GLOSSARY PER CLUSTER#
	 Definition of each class using problem domain vocabulary,
	 in term of services, stored data and business rules.#

#
ANALYSIS CLASS CHARTS#
	  Semi-formal descriptions of analysis classes, understandable
	  by non-technical people, and defined like black boxes questionable
	  and changeable through a set of visible state data,
	  services and constraints.#

#
CLASS DESCRIPTIONS#
	 Syntax based definitions of system classes in term of features,
	 invariants, routine pre- and postconditions expressed in a
	semi-formal language and simple class indexing fields.#

#
EVENT CHART AND SCENARIO CHART#
	 Set of stimuli incoming the system to change its state and
	 behavior, followed by a sequence of most perceptible unpredictable
	 events associated to its normal use. Set of the most
	 relevant internal messages triggered after an external event is
	 recognized and handled in the system.#

#
STATIC ARCHITECTURE#
	Set of A4-format structured pages in graphical notation representing
	clusters, class headers and relation links between classes and clusters,
	at a certain focus level.#

#
CREATION CHART#
	 List of classes in charge of creating class instances.#

#
OBJECT COMMUNICATION PROTOCOL#
	 Relevant threads of message passing protocols between analysis
	 objects after an external event is received or before an outgoing
	 information is sent.#

#
References:#
Jean-Marc Nerson: ``Extending Eiffel Toward O-O Analysis and
Design'', associated paper in Proc. TOOLS 5, Santa Barbara,
July-August 1991, Prentice Hall, 1991, pp. 377-392.#

#
Jean-Marc Nerson:  ``OOA and OOD in the Business Class Project''
Workshop on Object-Oriented Modeling Analysis OOPSLA 91, Phoenix,
October 1991.#

#
Jean-Marc Nerson: ``O-O Development of a Date and Time Management
Cluster'', Journal of Object-Oriented Programming, SIGS Publication, March 1992.#

#
Jean-Marc Nerson: ``Applying Object-Oriented Analysis and Design''
Communications of the ACM, Vol. 35, No 9, September 1992, pp. 63-74.#

#
Kim Walden and Jean-Marc Nerson: ``Seamless Object-Oriented Software Architecture: Analysis and Design of Reliable Systems'', Prentice Hall, 1994.#

#
ISE Inc.: ``EiffelCase: Engineering Object-Oriented Software, Forward and Backward'' (the manual for EiffelCase), ISE Inc., Technical Report TR-EI-53/EA 1995.#

#

#
!Limitations
appendices
^A.3 - Current limitations#

#
- Dynamic system description is not supported.#
- Link labels strings are neither syntactically nor semantically checked
on input.#
- History stack is not saved when exiting the session.#

#
!Subject Index
Appendices
^Subject Index#

#

#
@Architecture Tool@#
@BON@#
@Class Tool@#
@classes@#
@client-supplier@#
@clusters@#
@Eiffel 3@#
@Feature Tool@#
@Generation Tool@#
@graphical interface@#
@Help Tool@#
@History Tool@#
@inheritance@#
@introduction@#
@limitations@#
@Link Tool@#
@Project Tool@#
@naming objects@#
@Preferences Tool@#
@Print Tool@#
@resources file@#
@reverse engineering@#
@System Tool@#
@Tool Windows@#
@views@#
@View Tool@#
