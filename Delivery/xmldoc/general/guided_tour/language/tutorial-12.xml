<document title="11 Agents"><meta_data ><help ><toc ><envision_location >Eiffel, The Language\Tutorials\An Eiffel Tutorial</envision_location><envision_pseudo_name>92</envision_pseudo_name><envision_title >Agents</envision_title><studio_location /><studio_title /></toc></help></meta_data><paragraph ><heading ><size >1</size><content >11 AGENTS</content></heading><paragraph >Our last mechanism, agents, adds one final level of expressive power to the framework describe so far.  Agents apply object-oriented concepts to the modeling of <span >operations</span>.</paragraph><heading ><size >2</size><content >Objects for operations</content></heading><paragraph >Operations are not objects; in fact, object technology starts from the decision to separate these two aspects, and to choose object types, rather than the operations, as the basis for modular organization of a system, attaching each operation to the resulting modules -- the classes.  </paragraph><paragraph >In a number of applications, however, we may need objects that <span >represent</span> operations, so that we can include them in object structures that some other piece of the software will later traverse to uncover the operations and, usually, execute them.  Such "operation wrapper" objects, called agents, are useful in a number of application areas such as:</paragraph><list ordered="false"><item > GUI (Graphical User Interface) programming, where we may associate an agent with a certain event of the interface, such as a mouse click at a certain place on the screen, to prescribe that if the event occurs -- a user clicks there -- it must cause execution of the agent's associated operation.  </item><item > Iteration on data structures, where we may define a general-purpose routine that can apply an arbitrary operation to all the elements of a structure such as a list; to specify a particular operation to iterate, we will pass to the iteration mechanism an agent representing that operation.  </item><item > Numerical computation, where we may define a routine that computes the integral of any applicable function on any applicable interval; to represent that function and pass its representation to the integration routine, we will use an agent.  </item></list><paragraph >Operations in Eiffel are expressed as routines, and indeed every agent will have an associated routine.  Remember, however, that the fundamental distinction between objects and operations remains: an agent is an object, and it is not a routine; it <span >represents</span> a routine.  As further evidence that this is a proper data abstraction, note that the procedure <code ><string >call</string></code>, available on all agents to call the associated routine, is only one of the features of agents.  Other features may denote properties such as the class to which the routine belongs, its precondition and postcondition, the result of the last call for a function, the number of arguments.  </paragraph><heading ><size >2</size><content >Building an agent</content></heading><paragraph >In the simplest form, also one of the most common, you obtain an agent just by writing</paragraph>
<code_block >
	agent r
</code_block>

<paragraph >where <code ><string >r</string></code> is the name of a routine of the enclosing class.  This is an expression, which you may assign to a writable entity, or pass as argument to aroutine.  Here for example is how you will specify event handling in the style of the EiffelVision 2 GUI library:</paragraph>
<code_block >
	your_icon .  click_actions .extend ( agent your_routine )
</code_block>

<paragraph >This adds to the end of my_icon<code ><keyword >.  </keyword></code> click_actions -- the list of agents associated with the "click" event for <code ><string >my_icon</string></code>, denoting an icon in the application's user interface -- an agent representing <code ><string >your_routine</string></code> .  Then when a user clicks on the associated icon at execution, the EiffelVision 2 mechanisms will call the procedure <code ><string >call</string></code> on every agent of the list, which for this agent will execute <code ><string >your_routine</string></code> .  This is a simple way to associate elements of your application, more precisely its "business model" (the processing that you have defined, directly connected to the application's business domain), with elements of its GUI.  </paragraph><paragraph >Similarly although in a completely different area, you may request the integration of a function <code ><string >your_function</string></code> over the interval <code ><comment >0</comment></code> <span >..</span> <code ><comment >1</comment></code> through a call such as</paragraph>
<code_block >
	your_integrator .  integral ( agent your_function, 0, 1 )
</code_block>

<paragraph >In the third example area cited above, you may call an iterator of EiffelBase through</paragraph>
<code_block >
	your_list .  do_all ( agent your_proc )
</code_block>

<paragraph >with <code ><string >your_list</string></code> of a type such as <code ><string >LIST</string></code> <code ><comment >[</comment></code> <code ><string >YOUR_TYPE</string></code> <code ><comment >]</comment></code> .  This will apply <code ><string >your_proc</string></code> to every element of the list in turn.  </paragraph><paragraph >The agent mechanism is type-checked like the rest of Eiffel; so the last example is valid if and only if <code ><string >your_proc</string></code> is a procedure with one argument of type <code ><string >YOUR_TYPE</string></code> .  </paragraph><heading ><size >2</size><content >Operations on agents</content></heading><paragraph >An agent <code ><keyword >agent</keyword></code> <code ><string >r</string></code> built from a procedure <code ><string >r</string></code> is of type <code ><string >PROCEDURE</string></code> <code ><comment >[</comment></code> <code ><string >ARGS T, </string></code> <code ><comment >]</comment></code> where<code ><string >T</string></code> represents the class to which <code ><string >r</string></code> belongs and <code ><string >ARGS</string></code> the type of its arguments.  If <code ><string >r</string></code> is a function of result type <code ><string >RES</string></code>, the type is <code ><string >FUNCTION</string></code> <code ><comment >[</comment></code> <code ><string >ARGS T, </string></code> <code ><comment >, </comment></code> <code ><string >RES</string></code> <code ><comment >]</comment></code> .  Classes <code ><string >PROCEDURE</string></code> and <code ><string >FUNCTION</string></code> are from the Kernel Library of EiffelBase, both inheriting from <code ><string >ROUTINE</string></code> <code ><comment >[</comment></code> <code ><string >ARGS T, </string></code> <code ><comment >]</comment></code> .  </paragraph><paragraph >Among the features of <code ><string >ROUTINE</string></code> and its descendants the most important are <code ><string >call</string></code>, already noted, which calls the associated routine, and <code ><string >item</string></code>, appearing only in <code ><string >FUNCTION</string></code> and yielding the result of the associated function, which it obtains by calling <code ><string >call</string></code>.  </paragraph><paragraph >As an example of using these mechanisms, here is how the function <code ><string >integral</string></code> could look like in our <code ><string >INTEGRATOR</string></code> example class.  The details of the integration algorithm (straightforward, and making no claims to numerical sophistication) do not matter, but you see, in the highlighted line, the place were we evaluate the mathematical function associated with <code ><string >f</string></code>, by calling <code ><string >item</string></code> on <code ><string >f</string></code> :</paragraph>
<code_block >
integral

    ( f: FUNCTION [ANY, TUPLE [REAL], REAL];

    low, high: REAL): REAL is

            -- Integral of f over the interval [ low , high ]

     require

        meaningful_interval: low &lt;= high

     local

        x: REAL

     do

         from

            x := low

         invariant

            x &gt;= low ; x &lt;= high + step

            -- Result approximates the integral over

            -- the interval [ low , low . max ( x - step )]

         until x &gt; high loop

            Result := Result + step *




            x := x + step

        end

    end
</code_block>

<paragraph >Function <code ><string >integral</string></code> takes three arguments: the agent <code ><string >f</string></code> representing the function to be integrated, and the two interval bounds.  When we need to evaluate that function for the value <code ><string >x</string></code>, in the line</paragraph>
<code_block >
	Result := Result + step *
</code_block>

<paragraph >we don't directly pass <code ><string >x</string></code> to <code ><string >item</string></code> ; instead, we pass a one-element tuple <code ><comment >[</comment></code> <code ><string >x</string></code> <code ><comment >]</comment></code>, using the syntax for manifest tuples introduced in <link ><url >tutorial-11.html#36752</url></link> .  You will always use tuples for the argument to <code ><string >call</string></code> and <code ><string >item</string></code>, because these features must be applicable to <span >any</span> routine, and so cannot rely on a fixed number of arguments.  Instead they take a single tuple intended to contain all the arguments.  This property is reflected in the type of the second actual generic parameter to <code ><string >f</string></code>, corresponding to <code ><string >ARGS</string></code> (the formal generic parameter of <code ><string >FUNCTION</string></code> ): here it's TUPLE [REAL] to require an argument such as  <code ><comment >[</comment></code> <code ><string >x</string></code> <code ><comment >]</comment></code>, where <code ><string >x</string></code> is of type <code ><string >REAL</string></code> .  </paragraph><paragraph >Similarly, consider the agent that the call seen above:</paragraph>
<code_block >
	your_icon . click_actions .extend ( agent your_routine )
</code_block>

<paragraph >added to an EiffelVision list.  When the EiffelVision mechanism detects a mouse click event, it will apply to each element <code ><string >item</string></code> of the list of agents, your_icon<code ><keyword >.  </keyword></code> click_actions, an instruction such as</paragraph>
<code_block >
	item .  call ([ x, y ])
</code_block>

<paragraph >where <code ><string >x</string></code> and <code ><string >y</string></code> are the coordinates of the mouse clicking position.  If <code ><string >item</string></code> denotes the list element <code ><keyword >agent</keyword></code> your_routine, inserted by the above call to <code ><string >extend</string></code>, the effect will be the same as that of calling</paragraph>
<code_block >
	your_routine ( x, y )
</code_block>

<paragraph >assuming that <code ><string >your_routine</string></code> indeed takes arguments of the appropriate type, here <code ><string >INTEGER</string></code> representing a coordinate in pixels.  (Otherwise type checking would have rejected the call to <code ><string >extend</string></code>.  )</paragraph><heading ><size >2</size><content >Open and closed arguments</content></heading><paragraph >In the examples so far, execution of the agent's associated routine, through <code ><string >item</string></code> or <code ><string >call</string></code>, passed exactly the arguments that a direct call to the routine would expect.  You can have more flexibility.  In particular, you may build an agent from a routine with more arguments than expected in the final call, and you may set the values of some arguments at the time you define the agent.  </paragraph><paragraph >Assume for example that a cartographical application lets a user record the location of a city by clicking on the corresponding position on the map.  The application may do this through a procedure</paragraph>
<code_block >
record_city ( cn : STRING ; pop : INTEGER; x, y : INTEGER )

        -- Record that the city of name name is at coordinates

        -- x and y with population pop .
</code_block>

<paragraph >Then you can associate it with the GUI through a call such as</paragraph>
<code_block >
map .  click_actions .extend ( agent record_city ( name, population, ?, ? ))
</code_block>

<paragraph >assuming that the information on the <code ><string >name</string></code> and the <code ><string >population</string></code> has already been determined.  What the agent denotes is the same as <code ><keyword >agent</keyword></code> <code ><string >your_routine</string></code> as given before, where <code ><string >your_routine</string></code> would be a fictitious two-argument routine obtained from record_city -- a four-argument routine -- by setting the first two arguments once and for all to the values given, <code ><string >name</string></code> and <code ><string >population</string></code> .  </paragraph><paragraph >In the agent <code ><keyword >agent</keyword></code> record_city <code ><comment >(</comment></code> <code ><string >name</string></code> <code ><comment >, </comment></code> <code ><string >population</string></code> <code ><comment >, </comment></code> <code ><keyword >?</keyword></code> <code ><comment >, </comment></code> <code ><keyword >?</keyword></code><code ><comment >)</comment></code>, we say that these first two arguments, with their set values, are <bold >closed</bold> ; the last two are <bold >open</bold> .  The question mark syntax introduced by this example may only appear in agent expressions; it denotes open arguments.  This means, by the way, that you may view the basic form used in the preceding examples, <code ><keyword >agent</keyword></code> your_routine, as an abbreviation -- assuming your_routine has two arguments -- for <code ><keyword >agent</keyword></code> your_routine <code ><comment >(</comment></code> <code ><keyword >?</keyword></code> <code ><comment >, </comment></code> <code ><keyword >?</keyword></code> <code ><comment >)</comment></code> .  It is indeed permitted, to define an agent with all arguments open, to omit the argument list altogether; no ambiguity may result.  </paragraph><paragraph >For type checking, <code ><keyword >agent</keyword></code> record_city <code ><comment >(</comment></code> <code ><string >name</string></code> <code ><comment >, </comment></code> <code ><string >population</string></code> <code ><comment >, </comment></code> <code ><keyword >?</keyword></code> <code ><comment >, </comment></code> <code ><keyword >?</keyword></code> <code ><comment >)</comment></code> and <code ><keyword >agent</keyword></code> your_routine are acceptable in exactly the same situations, since both represent routines with two arguments.  The type of both is</paragraph>
<code_block >
	PROCEDURE [ ANY, TUPLE [ INTEGER, INTEGER ]]
</code_block>

<paragraph >where the tuple type specifies the open operands.  </paragraph><paragraph >A completely closed agent, such as <code ><keyword >agent</keyword></code> your_routine <code ><comment >(</comment></code> <code ><string >25</string></code> <code ><comment >, </comment></code> <code ><string >32</string></code> <code ><comment >)</comment></code> or <code ><keyword >agent</keyword></code> record_city <code ><comment >(</comment></code> <code ><string >name</string></code> <code ><comment >, </comment></code> <code ><string >population</string></code> <code ><comment >, </comment></code> <code ><string >25</string></code> <code ><comment >, </comment></code> <code ><string >32</string></code> <code ><comment >)</comment></code>, has the type <code ><string >TUPLE</string></code>, with no parameters; you will call it with <code ><string >call</string></code> <code ><comment >)] ([</comment></code>, using an empty tuple as argument.  </paragraph><paragraph >The freedom to start from a routine with an arbitrary number of arguments, and choose which ones you want to close and which ones to leave open, provides a good part of the attraction of the agent mechanism.  It means in particular that in GUI applications you can limit to the strict minimum the "glue" code (sometimes called the <span >controller</span> in the so-called MVC, Model-View Controller, scheme of GUI design) between the user interface and "business model" parts of a system.  A routine such as <code ><string >record_city</string></code> is a typical example of an element of the business model, uninfluenced -- as it should be -- by considerations of user interface design.  Yet by passing it in the form of an agent with partially open and partially closed arguments, you may be able to use it <span >directly</span> in the GUI, as shown above, without any "controller" code.  </paragraph><paragraph >As another example of the mechanism's versatility, we saw above an integral function that could integrate a function of one variable over an interval, as in</paragraph>
<code_block >
	your_integrator .  integral ( agent your_function (0, 1) )
</code_block>

<paragraph >Now assume that <code ><string >function3</string></code> takes three arguments.  To integrate <code ><string >function3</string></code> with two arguments fixed, you don't need a new <code ><string >integral</string></code> function; just use the same <code ><string >integral</string></code> as before, judiciously selecting what to close and what to leave open:</paragraph>
<code_block >
	your_integrator .  integral ( agent function3 ( 3.  5, ?, 6.  0 ), 0, 1 )
</code_block>

<heading ><size >2</size><content >Open targets</content></heading><paragraph >All the agent examples seen so far were based on routines of the enclosing class.  This is not required.  Feature calls, as you remember, were either unqualified, as in <code ><string >f</string></code> <code ><comment >(</comment></code> <code ><string >y x, </string></code> <code ><comment >)</comment></code>, or qualified, as in <code ><string >a</string></code> <span >.  </span> <code ><string >g</string></code> <code ><comment >(</comment></code> <code ><string >y x, </string></code> <code ><comment >)</comment></code> .  Agents, too, have a qualified variant as in</paragraph>
<code_block >
	agent a .  g
</code_block>

<paragraph >which is closed on its target <code ><string >a</string></code> and open on the arguments.  Variants such as <code ><keyword >agent</keyword></code> <code ><string >a</string></code> <span >.  </span> <code ><string >g</string></code> <code ><comment >(</comment></code> <code ><string >y x, </string></code> <code ><comment >)</comment></code>, all closed, and <code ><keyword >agent</keyword></code> <code ><string >a</string></code> <span >.  </span> <code ><string >g</string></code> <code ><comment >(</comment></code> <code ><keyword >?</keyword></code> <code ><string >y, </string></code> <code ><comment >)</comment></code>, open on one argument, are all valid.  </paragraph><paragraph >You may also want to make the <span >target</span> open.  The question mark syntax could not work here, since it wouldn't tell us the class to which feature <code ><string >g</string></code> belongs, known in the preceding examples from the type of <code ><string >a</string></code>.  As in creation expressions, we must list the type explicitly; the convention is the same: write the types in braces, as in</paragraph>
<code_block >
agent { SOME_TYPE } . g

agent { SOME_TYPE } . g ( ? , ? )

agent { SOME_TYPE } . g ( ? , y )
</code_block>

<paragraph >The first two of these examples are open on he target and both operands; they mean the same.  The third is closed on one argument, open on the other and on the target.  </paragraph><paragraph >These possibilities give even more flexibility to the mechanism because they mean that an operation that needs agents with certain arguments open doesn't care whether they come from an argument or an operand of the original routine.  This is particularly useful for iterators and means that if you have two lists</paragraph>
<code_block >
your_account_list : LIST [ ACCOUNT ]

your_integer_list : LIST [ INTEGER ]
</code_block>

<paragraph >you may write both</paragraph>
<code_block >
your_ acccount_list . do_all ( agent deposit_one_grand )

your_ integer_list . do_all ( agent add_to_n )
</code_block>

<paragraph >even though the two procedures used in the agents have quite different forms.  We are assuming here that the first one, in class <code ><string >ACCOUNT</string></code>, issomething like</paragraph>
<code_block >
deposit_one_grand is

        -- Add one thousand dollars to balance of account.

     do balance := balance + 1000 end
</code_block>

<paragraph >so that it doesn't take an argument: it is normally called on its target, as in <code ><string >my_account</string></code> <span >.  </span> deposit_one_grand.  In contrast, the other routine has an argument:</paragraph>
<code_block >
add_to_n ( x: INTEGER ) is

        -- Add x to the value of total .

     do total := total + x end
</code_block>

<paragraph >where <code ><string >total</string></code> is an integer attribute of the enclosing class.  Without the versatility of playing with open and closed arguments for both the original arguments and target, you would have to write separate iteration mechanisms for these two cases.  Here you can use a single iteration routine of <code ><string >LIST</string></code> and similar classes of EiffelBase, <code ><string >do_all</string></code>, for both purposes:</paragraph><list ordered="false"><item > Depositing money on every account in a list of accounts.  </item><item > Adding all the integers in a list of integers.  </item></list><paragraph >Agents provide a welcome complement to the other mechanisms of Eiffel.  They do not conflict with them but, when appropriate -- as in the examples sketched in this section -- provide clear and expressive programming schemes, superior to the alternatives.  </paragraph></paragraph></document>