<document title="12 Lexical Conventions and Style Rules">
	<meta_data>
		<help>
			<toc>
				<envision_location>EiffelEnvision\A Guide to Eiffel for .NET\An Eiffel Tutorial</envision_location>
				<envision_pseudo_name>93</envision_pseudo_name>
				<envision_title>Lexical Conventions and Style Rules</envision_title>
				<studio_location/>
				<studio_title/>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph>Eiffel software texts are free-format: distribution into lines is not semantically significant, and any number of successive space and line-return characters is equivalent to just one space.  The style rules suggest indenting software texts as illustrated by the examples in this chapter.  </paragraph>
		<paragraph>Successive declarations or instructions may be separated by semicolons.  Eiffel's syntax has been so designed, however, that (except in rare cases) 
			<bold>the semicolon is optional</bold>.  Omitting semicolons for elements appearing on separate lines lightens text and is the recommended practice since semicolons, as used by most programming languages, just obscure the text by distracting attention from the actual contents.  
			Do use semicolons if you occasionally include successive elements on a single line.  
		</paragraph>
		<paragraph>63 names -- all unabbreviated single English words, except for 
			<code>
				<keyword>elseif</keyword>
			</code> which is made of two words -- are reserved, meaning that you cannot use them to declare new entities.  Here is the list:
		</paragraph>
		<table>
			<row>
				<cell><code><keyword>agent</keyword></code></cell>
				<cell><code><keyword>alias</keyword></code></cell>
				<cell><code><keyword>all</keyword></code></cell>
				<cell><code><keyword>and</keyword></code></cell>
				<cell><code><keyword>as</keyword></code></cell>
				<cell><code><keyword>assign</keyword></code></cell>
				<cell><code><keyword>check</keyword></code></cell>								
			</row>
			<row>
				<cell><code><keyword>class</keyword></code></cell>
				<cell><code><keyword>convert</keyword></code></cell>
				<cell><code><keyword>create</keyword></code></cell>
				<cell><code><keyword>Current</keyword></code></cell>
				<cell><code><keyword>debug</keyword></code></cell>
				<cell><code><keyword>deferred</keyword></code></cell>
				<cell><code><keyword>do</keyword></code></cell>
			</row>
			<row>
				<cell><code><keyword>else</keyword></code></cell>
				<cell><code><keyword>elseif</keyword></code></cell>
				<cell><code><keyword>end</keyword></code></cell>
				<cell><code><keyword>ensure</keyword></code></cell>
				<cell><code><keyword>expanded</keyword></code></cell>
				<cell><code><keyword>export</keyword></code></cell>
				<cell><code><keyword>external</keyword></code></cell>
			</row>
			<row>
				<cell><code><keyword>False</keyword></code></cell>
				<cell><code><keyword>feature</keyword></code></cell>
				<cell><code><keyword>from</keyword></code></cell>
				<cell><code><keyword>frozen</keyword></code></cell>
				<cell><code><keyword>if</keyword></code></cell>
				<cell><code><keyword>implies</keyword></code></cell>
				<cell><code><keyword>indexing</keyword></code></cell>
			</row>
			<row>
				<cell><code><keyword>infix</keyword></code></cell>
				<cell><code><keyword>inherit</keyword></code></cell>
				<cell><code><keyword>inspect</keyword></code></cell>
				<cell><code><keyword>invariant</keyword></code></cell>
				<cell><code><keyword>is</keyword></code></cell>
				<cell><code><keyword>like</keyword></code></cell>
				<cell><code><keyword>local</keyword></code></cell>
			</row>
			<row>
				<cell><code><keyword>loop</keyword></code></cell>
				<cell><code><keyword>not</keyword></code></cell>
				<cell><code><keyword>obsolete</keyword></code></cell>
				<cell><code><keyword>old</keyword></code></cell>
				<cell><code><keyword>once</keyword></code></cell>
				<cell><code><keyword>or</keyword></code></cell>
				<cell><code><keyword>prefix</keyword></code></cell>
			</row>
			<row>
				<cell><code><keyword>Precursor</keyword></code></cell>
				<cell><code><keyword>pure</keyword></code></cell>
				<cell><code><keyword>redefine</keyword></code></cell>
				<cell><code><keyword>reference</keyword></code></cell>
				<cell><code><keyword>rename</keyword></code></cell>
				<cell><code><keyword>require</keyword></code></cell>
				<cell><code><keyword>rescue</keyword></code></cell>
			</row>
			<row>
				<cell><code><keyword>Result</keyword></code></cell>
				<cell><code><keyword>retry</keyword></code></cell>
				<cell><code><keyword>separate</keyword></code></cell>
				<cell><code><keyword>then</keyword></code></cell>
				<cell><code><keyword>True</keyword></code></cell>
				<cell><code><keyword>TUPLE</keyword></code></cell>
				<cell><code><keyword>undefine</keyword></code></cell>
			</row>
		</table>
		<paragraph>Since this tutorial has covered all the essential mechanisms, you may ignore the keywords not encountered; they are reserved for future use.  </paragraph>
		<paragraph>Most of the reserved words are keywords, serving only as syntactic markers, and written in boldface in typeset texts such as the present one: 
			<code>
				<keyword>class</keyword>
			</code>, 
			<code>
				<keyword>feature</keyword>
			</code>, 
			<code>
				<keyword>inherit</keyword>
			</code>. The others, such as 
			<code>
				<keyword>Current</keyword>
			</code>, directly carry a semantic denotation; they start with an upper-case letter and are typeset in boldface.  
		</paragraph>
		<paragraph>These conventions about letter case are only style rules.  Eiffel is case-insensitive, since it is foolish to assume that two identifiers denote two different things just on the basis of a letter written in lower or upper case.  The obvious exception is manifest character constants (appearing in single quotes, such as 
			<code>
				<string>'A'</string>
			</code>) and manifest character strings (appearing in double quotes, such as 
			<code>
				<string>"UPPER and lower"</string>
			</code>).  
		</paragraph>
		<paragraph>The style rules, however, are precise, and any serious Eiffel project will enforce them; the tools of EiffelStudio also observe them in the texts they output (although they will not mess up with your source text unless you ask them to reformat it).  Here are the conventions, illustrated by the examples of this tutorial:</paragraph>
		<list ordered="false">
			<item>Class names in upper case, as 
				<code>
					<class_name>ACCOUNT</class_name>
				</code>. 
			</item>
			<item>Non-constant feature names and keywords in lower case, as 
				<code>
					<feature_name>balance</feature_name>
				</code> and 
				<code>
					<keyword>class</keyword>
				</code>.  
			</item>
			<item>Constant features and predefined entities and expressions with an initial upper case, as 
				<code>
					<feature_name>Avogadro</feature_name>
				</code> and 
				<code>
					<keyword>Result</keyword>
				</code>.  
			</item>
		</list>
		<paragraph>In typeset documents including Eiffel texts, the standard for font styles is also precise.  You should use 
			<code>
				<keyword>bold face</keyword>
			</code> for keywords and 
			<code>
				<string>italics</string>
			</code> for all other Eiffel elements.  Comments, however, are typeset in 
			<code>
				<comment>roman</comment>
			</code>.  This lets a software element, such as an identifier, stand out clearly in what is otherwise a comment text expressed in English or another human language, as in the earlier example
		</paragraph>
		<code_block>
<comment>-- Add `sum' to account.</comment>
</code_block>
		<paragraph>which makes clear that 
			<code>
				<local_variable>sum</local_variable>
			</code> is a software element, not the English word.  
		</paragraph>
		<paragraph>There is also an Eiffel style to the choice of identifiers.  For features, stay away from abbreviations and use full words.  In multi-word identifiers, separate the constituents by underscores, as in 
			<code>
				<class_name>LINKED_LIST</class_name>
			</code> and 
			<code>
				<feature_name>set_owner</feature_name>
			</code>.  The competing style of no separation but mid-identifier upper-case, as in 
			<code>
				<comment>linkedList</comment>
			</code> or 
			<code>
				<comment>setOwner</comment>
			</code>, is less readable and not in line with standard Eiffel practices. 
		</paragraph>
		<paragraph>Features of reusable classes should use consistent names.  A set of standard names -- 
			<code>
				<feature_name>put</feature_name>
			</code> for the basic command to add or replace an element, 
			<code>
				<feature_name>count</feature_name>
			</code> for the query that returns the number of element in a structure, 
			<code>
				<feature_name>item</feature_name>
			</code> to access an element -- is part of the style rules, and used systematically in EiffelBase.  Use them in your classes too.  
		</paragraph>
		<paragraph>For local entities and formal arguments of routines, it is all right to use abbreviated names, since these identifiers only have a local scope, and choosing a loud name would give them too much pretense, leading to potential conflicts with features.  </paragraph>
		<paragraph>The complete set of style rules applied by ISE is available on the web in both 
			<span>
				<link>
					<url>http://www.eiffel.com/doc/manuals/language/style/</url>
					<label>HTML</label>
				</link>
			</span> and 
			<span>
				<link>
					<url>http://www.eiffel.com/doc/manuals/language/style/style.pdf</url>
					<label>PDF</label>
				</link>
			</span> forms.  These rules are an integral part of the Eiffel method; in quality software, there is no such thing as a detail.  Applying them systematically promotes consistency between projects in the Eiffel world, enhances reusability, and facilitates everyone's work.  
		</paragraph>
	</paragraph></document>
