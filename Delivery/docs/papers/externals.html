<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Interface to other programming languages</title>
<link rev="made" href="mailto:webmaster@eiffel.com">
<link rel="stylesheet" href="../styles/tech.css" type="text/css">
<meta name="Microsoft Border" content="t, default">
</head>

<body><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><table border="0" cellspacing="0" cellpadding="0" width="100%">
  <tr>
    <td valign="top" bgcolor="#000063" width="291"><b><font face="Arial" size="4" color="#FFFFFF">Interactive<br>
      Software Engineering</font></b></td>
    <td valign="top" bgcolor="#000063" width="720"><b><font face="Arial" size="6" color="#FFFFCC">Interface to other programming languages</font></b></td>
  </tr>
  <tr>
    <td colspan="2" valign="top" width="100%">
<p align="center">[<a href="http://eiffel.com">ISE Home</a>] <nobr>[&nbsp;<a href="../index.html">Home</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../release_notes.html">Release&nbsp;Notes</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="index.html">Technology&nbsp;Papers</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../install.html">Installation&nbsp;Notes</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../Eiffel/index.html">About&nbsp;Eiffel</a>&nbsp;]</nobr>
<hr>

    </td>
  </tr>
</table></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><!--msnavigation--><td valign="top"><table cols="1" cellpadding="5" cellspacing="0" border="0">
<tr><td>


<h2>Introduction</h2>
<p>With ISE EiffelBench you can encapsulate features written in C, <a href="c++.html">C++</a>
and <a href="eiffel2java.html">Java</a>. Click on the last two to get specific
information. We will describe below only what is common to C and C++ and also
specific constructs available only for C.</p>
<p>For Windows users: please read the <a href="#windows">last section of this
document</a>.</p>
<p>
&nbsp;<table border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td height=60 valign="top"><img border="0" src="../images/danger.gif" width="45" height="39"></td>
    <td valign="bottom">
      <h2>General consideration</h2>
    </td>
    <td height=60 valign="top"><img border="0" src="../images/danger.gif" width="45" height="39"></td>
  </tr>
</table>
<p>As ISE's technology relies heavily on the use of a C/C++ ANSI compiler, you
have to be sure to always put the correct signature of an external C/C++
routine. If it was not the case, the C compilation of your system could fail.
Most of the time a C compiler is more comprehensive than a C++ compiler and most
type errors won't cause you any harm, but C++ compilers are not as lax as C
compilers and they will mostly generate errors.</p>
<p>The section concerning <a href="#macros">Macros</a> and <a href="#structs">Structs</a>
are also available for C++, i.e. if the macro or the struct is defined in a C++
header file.</p>
<p>&nbsp;</p>

<h2><a name="C">C routines</a></h2>

<p>You can encapsulate routines that are defined in a C header file. We
will take some examples and will show you how to write wrappers in Eiffel.</p>

<p>If in a header file called `my_header.h', you have the following
declaration:</p>
<center>
<table border="0" bgcolor="#FFFFE6">
  <tr>
    <td width="100%"><pre>
		/* Routine with no parameter */
	extern void no_param(void);

		/* Routine with one parameter */
	extern void one_param(int j);
	
		/* Routine returning a value with no parameter */
	extern size_t no_param_return(void);
	
		/* Routine returning a value with one parameter */
	extern size_t one_param_return(FILE *f);
    </pre></td>
  </tr>
</table>
</center>
<p>Here is the corresponding Eiffel code:</p>
<center>
<table border="0" bgcolor="#FFFFE6">
  <tr>
    <td width="100%"><pre>
		c_no_param is
				-- Encapsulation of a C routine with no parameter.
			external
				&quot;C | %&quot;my_header.h%&quot;&quot;
			end

		c_one_param (i: INTEGER) is
				-- Encapsulation of a C routine with one parameter.
			external
				&quot;C (int) | %&quot;my_header.h%&quot;&quot;
			end

		c_no_param_return: INTEGER is
				-- Encapsulation of a C routine with no parameter
				-- returning an INTEGER
			external
				&quot;C (): EIF_INTEGER| %&quot;my_header.h%&quot;&quot;
			end

		c_no_param_return (p: POINTER): INTEGER is
				-- Encapsulation of a C routine with one parameter
				-- returning an INTEGER
			external
				&quot;C (FILE *): EIF_INTEGER| %&quot;my_header.h%&quot;&quot;
			end
    </pre></td>
  </tr>
</table>
</center>
<h2><a name="macros">Macros</a></h2>
<p>If in a header file called `my_header.h', you have the following
declaration:</p>
<center>
<table border="0" bgcolor="#FFFFE6">
  <tr>
    <td width="100%"><pre>
		/* Predefined constants */
	#define ID_MENU				128
	#define ID_MENU_CHARACTER	'c'
    
		/* Access the `i'-th element of `a' where `a'
		 * is an array of EIF_INTEGER */
	#define i_th(a,i)				((a) + (i)*sizeof(EIF_INTEGER))
    </pre></td>
  </tr>
</table>
</center>
<p>Then, the corresponding Eiffel code willl look like:</p>
<center>
<table border="0" bgcolor="#FFFFE6">
  <tr>
    <td width="100%"><pre>
	menu_id: INTEGER is
			-- `ID_MENU' C encapsulation.
		external
			&quot;C [macro %&quot;my_header.h%&quot;] : EIF_INTEGER&quot;
		alias
			&quot;ID_MENU&quot;
		end
		
	menu_id_character: CHARACTER is
			-- `ID_MENU_CHARACTER' C encapsulation.
		external
			&quot;C [macro %&quot;my_header.h%&quot;] : EIF_CHARACTER&quot;
		alias
			&quot;ID_MENU_CHARACTER&quot;
		end
		
	i_th (p: POINTER; i: INTEGER): INTEGER is
			-- Access the `i'-th element of `p', array of C EIF_INTEGER.
		external
			&quot;C [macro %&quot;my_header.h%&quot;] (EIF_INTEGER *, EIF_INTEGER): EIF_INTEGER&quot;
		alias
			&quot;i_th&quot;
		end	</pre></td>
  </tr>
</table>
</center>
<p>&nbsp;</p>
<h2><a name="structs">Structs</a></h2>
<p>The struct encapsulation enables you to wrap C/C++ structures easily without
to have to write any additional code in a C header file as it was the case until
ISE introduced this new keyword in the external specification with ISE
EiffelBench 4.5. With the struct encapsulation you can set and retrieve the
value of a certain field of a struct.</p>
<p>If in a header file called `my_header.h', you have the following declaration
of the `Point' structure from which we want to access and set the `x' and `y'
field:</p>
<center>
<table border="0" bgcolor="#FFFFE6">
  <tr>
    <td width="100%"><pre>
		/* Definition of `Point' */
	typdef struct point {
		int x;
		int y;
	} Point;
    </pre></td>
  </tr>
</table>
</center>
<p>Then, the corresponding Eiffel code willl look like:</p>
<center>
<table border="0" bgcolor="#FFFFE6">
  <tr>
    <td width="100%"><pre>
	x (p: POINTER): INTEGER is
			-- Access field x of struct pointed by `p'.
		external
			&quot;C [struct %&quot;my_header.h%&quot;] (Point): EIF_INTEGER&quot;
		alias
			&quot;x&quot;
		end	

	y (p: POINTER): INTEGER is
			-- Access field y of struct pointed by `p'.
		external
			&quot;C [struct %&quot;my_header.h%&quot;] (Point): EIF_INTEGER&quot;
		alias
			&quot;y&quot;
		end	

	set_x (p: POINTER; v: INTEGER): INTEGER is
			-- Set field x of struct pointed by `p'.
		external
			&quot;C [struct %&quot;my_header.h%&quot;] (Point, int)&quot;
		alias
			&quot;x&quot;
		end	

	set_y (p: POINTER: v: INTEGER): INTEGER is
			-- Set field y of struct pointed by `p' with `v'.
		external
			&quot;C [struct %&quot;my_header.h%&quot;] (Point, int)&quot;
		alias
			&quot;y&quot;
		end	
	</pre></td>
  </tr>
</table>
</center>
<p>&nbsp;</p>
<h2><a name="windows">Windows externals</a></h2>
<h3>DLLS</h3>
<p>With ISE EiffelBench you now have two different ways to call C routines
exported in a DLL. Why two, because Windows offers two way to call a C routines:</p>
    <ul>
      <li>_cdecl: referred as the standard way</li>
      <li>__stdcall referred as the Pascal way</li>
    </ul>
<p>Therefore if you want to call an external routines defined in a DLL to be
called using the `_cdecl' method, you have to use the `<font color="#0000FF"><b>dll32</b>'</font>
sub-language option. For `__stdcall' you need to use the `<b><font color="#0000FF">dllwin32</font></b>'
sub-language option. Here is an example:</p>
<center>
<table border="0" bgcolor="#FFFFE6">
  <tr>
    <td width="100%"><pre>
	my_cdecl_routine (a: INTEGER): POINTER is
			-- Encapsulation of a dll function with the `_cdecl' call mechanism.
		external
			&quot;C [dll32 %&quot;my_dll.dll%&quot;] (int): EIF_POINTER&quot;
		end

	my_stdcall_routine (a: INTEGER): POINTER is
			-- Encapsulation of a dll function with the `_stdcall' call mechanism.
		external
			&quot;C [dllwin32 %&quot;my_dll.dll%&quot;] (int): EIF_POINTER&quot;
		end

    </pre></td>
  </tr>
</table>
</center>
<p>
&nbsp;<table border="0" cellspacing="0" cellpadding="0">
  <tr>
    <td><img border="0" src="../images/danger.gif" width="45" height="39"></td>
    <td>Using wrongly <b><font color="#0000FF">dll32</font></b>
instead of <b><font color="#0000FF">dllwin32</font></b> and reciprocally will
conduce to a crash of your system since the C call stack will be corrupted. For
more information please read your C compiler documentation.</td>
  </tr>
</table>
<h3>Windows API</h3>
<p>As described in the previous section concerning routines exported in a DLL,
the Windows API is using the `__stdcall' convention. As a consequence, you
cannot use the standard external mechanism to wrap them because it is using the
`_cdecl' convention. However, you can easily wrap those function by using the `<b>macro</b>'
sub-language.
<p>Here is an example that has been taken from WEL, the Windows Eiffel Library,
to encapsulate the Windows `SendMessage' function:
<p>&nbsp;
<center>
<table border="0" bgcolor="#FFFFE6">
  <tr>
    <td width="100%">
    
Windows defined SendMessage as:<pre>
<B>	LRESULT SendMessage(
		HWND</B><I> hWnd</I><B>,      </B>// handle to destination window
<B>		UINT</B><I> Msg</I><B>,       </B>// message
<B>		WPARAM</B><I> wParam</I><B>,  </B>// first message parameter
<B>		LPARAM</B><I> lParam</I>   // second message parameter
<B>	);</B></PRE>
In WEL, the encapsulation is written as:<pre>
	cwin_send_message (hwnd: POINTER; msg, wparam,
				lparam: INTEGER) is
			-- SDK SendMessage (without the result)
		external
			&quot;C [macro %&quot;wel.h%&quot;] (HWND, UINT, WPARAM, LPARAM)&quot;
		alias
			&quot;SendMessage&quot;
		end
    </pre></td>
  </tr>
</table>
</center>
<p>&nbsp;</td></tr></table>&nbsp;<!--msnavigation--></td></tr><!--msnavigation--></table></body>

</html>
