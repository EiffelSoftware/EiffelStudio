note
	description: "Objects that represent an EV_TITLED_WINDOW.%
		%The original version of this class was generated by EiffelBuild."
	generator: "EiffelBuild"
	date: "$Date$"
	revision: "$Revision$"

class
	MAIN_WINDOW

inherit
	MAIN_WINDOW_IMP
		redefine
			create_interface_objects
		end


feature {NONE} -- Initialization

	user_initialization
			-- Called by `initialize'.
			-- Any custom user initialization that
			-- could not be performed in `initialize',
			-- (due to regeneration of implementation class)
			-- can be added here.
		do
			set_size (1280, 600)

			show_actions.extend_kamikaze (agent init_docking_manager)

			restore_tool_info_from_disk

			show_actions.extend_kamikaze (agent
								local
									l_env: EV_ENVIRONMENT
								do
									create l_env
									if attached l_env.application as l_app then
										l_app.destroy_actions.extend (agent save_tool_info_when_exit)
									end
								end)
		end

	init_docking_manager
			--
		local
			l_docking_manager: like docking_manager
			l_tool_bar: SD_TOOL_BAR_CONTENT
		do
			create l_docking_manager.make (Current, Current)
			docking_manager := l_docking_manager
			type_selector.attach_to_docking_manager (l_docking_manager)
			layout_constructor.attach_to_docking_manager (l_docking_manager)
			object_editor.attach_to_docking_manager (l_docking_manager)
			l_tool_bar := build_tool_bar
			l_docking_manager.tool_bar_manager.contents.extend (l_tool_bar)
			l_tool_bar.set_top ({SD_ENUMERATION}.top)
		end

	create_interface_objects
			-- <Precursor>
		local
			l_project_info: ER_PROJECT_INFO
		do
				-- Initialize before calling Precursor all the attached attributes
				-- from the current class.

				-- Proceed with vision2 objects creation.
			Precursor
			create shared_singleton

			create type_selector.make

			create layout_constructor.make
			shared_singleton.layout_constructor_cell.put (layout_constructor)

			create object_editor.make

			create code_generator.make

			shared_singleton.object_editor_cell.put (object_editor)

			create l_project_info
			shared_singleton.project_info_cell.put (l_project_info)
		end

	build_tool_bar: SD_TOOL_BAR_CONTENT
			--
		local
			l_list: ARRAYED_SET [SD_TOOL_BAR_ITEM]
			l_item: SD_TOOL_BAR_BUTTON
		do
			create l_list.make (10)

			create l_item.make
			l_item.set_text ("Open")
			l_item.select_actions.extend (agent layout_constructor.load_tree)
			l_list.extend (l_item)

			create l_item.make
			l_item.set_text ("Save")
			l_item.select_actions.extend (agent layout_constructor.save_tree)
			l_list.extend (l_item)

			create l_item.make
			l_item.set_text ("Generate Code")
			l_item.select_actions.extend (agent code_generator.generate_all_codes)
			l_list.extend (l_item)

			create Result.make_with_items ("MAIN_TOOL_BAR", l_list)
		end

feature {NONE} -- Agents

	on_new_project_selected
			-- <Precursor>
		local
			l_folder: EV_DIRECTORY_DIALOG
			l_misc: ER_MISC_CONSTANTS
		do
			create l_folder
			l_folder.show_modal_to_window (Current)

			if attached shared_singleton.project_info_cell.item as l_item then
				if not l_folder.directory.is_empty then
					l_item.set_project_location (l_folder.directory)

					if attached shared_singleton.tool_info_cell.item as l_tool_info then
						create l_misc
						if attached l_misc.project_full_file_name as l_config_file then
							l_tool_info.recent_projects.extend (l_config_file)
						end

					else
						check should_not_happen: False end
					end
				else
					-- User didn't select any folder
				end
			else
				check False end
			end
		end

	on_open_project_selected
			-- <Precursor>
		local
			l_file: EV_FILE_OPEN_DIALOG
		do
			create l_file
			l_file.show_modal_to_window (Current)

			if attached l_file.file_name as l_file_name then
				open_project_file (l_file_name)
			end
		end

	on_exit_selected
			-- <Precursor>
		local
			l_env: EV_ENVIRONMENT
		do
			create l_env
			if attached l_env.application as l_app then
				l_app.destroy
			end
		end

feature {NONE} -- Implementation

	restore_tool_info_from_disk
			--
		local
			l_tool_info: detachable ER_TOOL_INFO

			l_file: RAW_FILE
			l_reader: SED_MEDIUM_READER_WRITER
			l_facility: SED_STORABLE_FACILITIES
			l_constants: ER_MISC_CONSTANTS
		do
			create l_constants
			create l_file.make (l_constants.tool_info_file_name)
			if l_file.exists then
			l_file.open_read
				create l_reader.make (l_file)
				l_reader.set_for_reading
				create l_facility
				if attached {ER_TOOL_INFO} l_facility.retrieved (l_reader, False) as l_tool_info_attached then
					l_tool_info := l_tool_info_attached
				end
				l_file.close
			end

			if l_tool_info = Void then
				create l_tool_info.make
			end

			shared_singleton.tool_info_cell.put (l_tool_info)

			restore_recent_item_menu
		end

	restore_recent_item_menu
			--
		local
			l_menu_item: EV_MENU_ITEM
			l_projects: ARRAYED_LIST [STRING]
		do
			if attached shared_singleton.tool_info_cell.item as l_tool_info then
				l_projects := l_tool_info.recent_projects
				from
					l_projects.finish
				until
					l_projects.before or l_projects.index > 10
				loop
					create l_menu_item.make_with_text_and_action (l_projects.item, agent open_project_file (l_projects.item))
					recent_projects.extend (l_menu_item)
					l_projects.back
				end

			end
		end

	open_project_file (a_eiffel_ribbon_file: STRING)
			--
		require
			not_void: a_eiffel_ribbon_file /= Void
		local
			l_file_name: FILE_NAME
--			l_inf
			l_env: OPERATING_ENVIRONMENT
			l_dir: STRING
			l_index, l_last_index: INTEGER
		do
			if attached shared_singleton.tool_info_cell.item as l_tool_info then

				create l_env
				from
					l_index := 1 -- Make sure loop run at least once
				until
					l_index = 0
				loop
					l_index := a_eiffel_ribbon_file.index_of (l_env.directory_separator, (l_last_index + 1))
					if l_index /= 0 then
						l_last_index := l_index
					end
				end
				check l_last_index /= 0 end
				l_dir := a_eiffel_ribbon_file.substring (1, (l_last_index - 1))

				create l_file_name.make_from_string (a_eiffel_ribbon_file)
				if not l_tool_info.recent_projects.has (a_eiffel_ribbon_file) then
					l_tool_info.recent_projects.extend (a_eiffel_ribbon_file)
				end

				if attached shared_singleton.project_info_cell.item as l_project_info then
					l_project_info.set_project_location (l_dir)
				end
			end

		end

	save_tool_info_when_exit
			--
		local
			l_file: RAW_FILE
			l_writer: SED_MEDIUM_READER_WRITER
			l_facility: SED_STORABLE_FACILITIES
			l_constants: ER_MISC_CONSTANTS
		do
			if attached shared_singleton.tool_info_cell.item as l_tool_info then
				create l_constants
				create l_file.make (l_constants.tool_info_file_name)
				l_file.create_read_write
				create l_writer.make (l_file)
				l_writer.set_for_writing
				create l_facility
				l_facility.store (l_tool_info, l_writer)
				l_file.close
			end
		end

	docking_manager: detachable SD_DOCKING_MANAGER
			--

	type_selector: ER_TYPE_SELECTOR
			--

	layout_constructor: ER_LAYOUT_CONSTRUCTOR
			--

	object_editor: ER_OBJECT_EDITOR
			--

	shared_singleton: ER_SHARED_SINGLETON
			--

	code_generator: ER_CODE_GENERATOR
			--

end
