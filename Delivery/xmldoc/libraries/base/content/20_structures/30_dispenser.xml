<document title="EiffelBase, Dispensers">
	<meta_data>
		<help>
			<toc>
				<envision_location>Class Libraries\EiffelBase\EiffelBase\EiffelBase Data Structures Overview</envision_location>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph> A dispenser is called that way because of the image of a vending machine (a dispenser) of a rather primitive nature, in which there is only one button. If you press the button and the dispenser is not empty, you get one of its items in the exit tray at the bottom, but you do not choose that item: the machine does. There is also an input slot at the top, into which you may deposit new items; but you have no control over the order in which successive button press operations will retrieve these items.</paragraph>
		<paragraph> The deferred class  <link><url>/libraries/base/reference/structures/dispenser/DISPENSER_chart.xml</url><label>DISPENSER</label></link> provides the facilities which will be shared by all specialized classes. In fact, the interface of all dispenser classes is nearly identical, with the exception of a few extra possibilities offered by priority queues. Many kinds of dispenser are possible, each defined by the relation that the machine defines between the order in which items are inserted and the order in which they arereturned. The Base libraries support three important categories - stacks, queues, and priority queues:</paragraph>
		<list ordered="false">
			<item>A stack is a dispenser with a last-in, first-out (LIFO) internal policy: items come out in the reverse order of their insertion. Each button press returns the last deposited item.</item>
			<item>A queue is a dispenser with a first-in, first-out (FIFO) internal policy: items come out in the order of their insertion. Each button press returns the oldest item deposited and not yet removed.</item>
			<item>In a priority queue, items have an associated notion of order; the element that comes out at any given time is the largest of those which are in the dispenser.</item>
		</list>
		<heading>
			<size>2</size>Stacks
		</heading>
		<paragraph> Stacks - dispensers with a LIFO retrieval policy - are a ubiquitous structure in software development. Their most famous application is to parsing (syntactic analysis), but many other types of systems use one or more stacks. Class STACK describes general stacks, without commitment to a representation. This is a deferred class which may not be directly instantiated. The fundamental operations are  put (add an element at end of queue), item (retrieve the oldest element, non-destructively), remove (remove the oldest element), is_empty (test for empty queue).
			<line_break/> Three effective heirs are provided:
		</paragraph>
		<list ordered="false">
		<item><link><url>/libraries/base/reference/structures/dispenser/LINKED_STACK_chart.xml</url><label>LINKED_STACK</label></link> : stacks implemented as linked lists, with no limit on the number of items (<code><feature_name>count</feature_name></code>).</item>			<item><link><url>/libraries/base/reference/structures/dispenser/BOUNDED_STACK_chart.xml</url><label>BOUNDED_STACK</label></link> : stacks implemented as arrays. For such stacks, the maximum number of items (<code><feature_name>capacity</feature_name></code>) is set at creation time.</item>			<item><link><url>/libraries/base/reference/structures/dispenser/ARRAYED_STACK_chart.xml</url><label>ARRAYED_STACK</label></link> : also implemented as arrays, but in this case there is no limit on the number of items; the interface is the same as <link><url>/libraries/base/reference/structures/dispenser/LINKED_STACK_chart.xml</url><label>LINKED_STACK</label></link> except for the creation procedure. If the number of elements exceeds the initially allocated capacity, the array will simply be resized.</item>
		</list>
		<heading>
			<size>2</size>Queues
		</heading>
		<paragraph> Class <link><url>/libraries/base/reference/structures/dispenser/QUEUE_chart.xml</url><label>QUEUE</label></link> describes general queues, without commitment to a representation. This is a deferred class which may not be directly instantiated. Three non-deferred heirs are also provided, distinguished by the same properties as their stack counterparts:</paragraph>
		<list ordered="false">
			<item><link><url>/libraries/base/reference/structures/dispenser/LINKED_QUEUE_chart.xml</url><label>LINKED_QUEUE</label></link>.</item>
			<item><link><url>/libraries/base/reference/structures/dispenser/BOUNDED_QUEUE_chart.xml</url><label>BOUNDED_QUEUE</label></link>.</item>
			<item><link><url>/libraries/base/reference/structures/dispenser/ARRAYED_QUEUE_chart.xml</url><label>ARRAYED_QUEUE</label></link>.</item>
		</list>
		<heading>
			<size>2</size>Priority Queues
		</heading>
		<paragraph> In a priority queue, each item has an associated priority value, and there is an order relation on these values. The item returned by item or removed by remove is the element with the highest priority.The most general class is <link><url>/libraries/base/reference/structures/dispenser/PRIORITY_QUEUE_chart.xml</url><label>PRIORITY_QUEUE</label></link> , which is deferred. Two effective variants are provided:</paragraph>
		<list ordered="false">
			<item> <link><url>/libraries/base/reference/structures/dispenser/LINKED_PRIORITY_QUEUE_chart.xml</url><label>LINKED_PRIORITY_QUEUE</label></link>, a linked list implementation.</item>
			<item> <link><url>/libraries/base/reference/structures/dispenser/HEAP_PRIORITY_QUEUE_chart.xml</url><label>HEAP_PRIORITY_QUEUE</label></link> which is more efficient and is to be preferred in most cases. A heap is organized like a binary tree, although physically stored in an array; elements with a high priority percolate towards the root.</item>
		</list>
		<paragraph> Because it must be possible to compare priorities, the type of the items must conform to  <link><url>/libraries/base/reference/kernel/PART_COMPARABLE_chart.xml</url><label>PART_COMPARABLE</label></link>. Constrained genericity ensures this; all the priority queue classes have a formal generic parameter constrained by  <link><url>/libraries/base/reference/kernel/PART_COMPARABLE_chart.xml</url><label>PART_COMPARABLE</label></link>.</paragraph>
	</paragraph></document>
