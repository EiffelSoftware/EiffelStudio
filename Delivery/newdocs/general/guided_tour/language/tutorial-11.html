<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="tour.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE> 10  OTHER MECHANISMS</TITLE>
</HEAD>
<body bgcolor="#faf0e6">
<DIV>
<p class="top" align="center"><a href="http://www.eiffel.com">Eiffel Home Page (Web)</a> -- <a href="../index.html">Getting started with Eiffel (local)</a>

<img src="power.gif" ALT="Eiffel Home Page" align="right" border="0"  usemap="#eiffel" width="109" height="226"><map name="eiffel"><area shape="RECT" alt="Eiffel Home Page" coords="0,0,109,226" HREF="http://www.eiffel.com"><area shape="default" nohref></map>

<p class="top" ALIGN="left"><IMG SRC="normaldoc.gif" ALT="Previous, Up, Next" BORDER="0" WIDTH="300" HEIGHT="40" USEMAP="#navigation"><map name="navigation"><AREA SHAPE="RECT" alt="Previous section" COORDS="0,0,95,40" HREF="tutorial-10.html"><AREA SHAPE="RECT" alt="Up" COORDS="96,0,199,40" HREF="tutorial-00.html"><AREA SHAPE="RECT" alt="Next section" COORDS="200,0,300,40" HREF="tutorial-12.html"><area shape="default" nohref></MAP>
</DIV>
<H1 CLASS="aa-sec2">
<A NAME="pgfId-555115"></A>10  OTHER MECHANISMS</H1>
<P CLASS="nn-first">
<A NAME="pgfId-515813"></A>We now examine a few important mechanisms that complement the preceding picture: shared objects; constants; instructions; and lexical conventions.
<DIV>
<H2 CLASS="aa-sec3">
<A NAME="pgfId-515815"></A><A NAME="71816"></A>Once routines and shared objects</H2>
<P CLASS="nn-first">
<A NAME="pgfId-515816"></A>The Eiffel's method obsession with extendibility, reusability and maintainability yields, as has been seen, modular and decentralized architectures, where inter-module coupling is limited to the strictly necessary, interfaces are clearly delimited, and all the temptations to introduce obscure dependencies, in particular global variables, have been removed. There is a need, however, to let various components of a system access common objects, without requiring their routines to pass these objects around as arguments (which would only be slightly better than global variables). For example various classes may need to perform output to a common &quot;console window&quot;, represented by a shared object.
<P CLASS="nn-normal">
<A NAME="pgfId-515817"></A>Eiffel addresses this need through an original mechanism that also takes care of another important issue, poorly addressed by many design and programming approaches: initialization. The idea is simple: if instead of <SPAN CLASS="ee-keyword">
do</SPAN>
 the implementation of an effective routine starts with the keyword <SPAN CLASS="ee-keyword">
once</SPAN>
, it will only be executed the first time the routine is called during a system execution (or, in a multithreaded environment, the first time in each thread), regardless of what the caller was. Subsequent calls from the same caller or others will have no effect; if the routine is a function, it will always return the result computed by the first call -- object if an expanded type, reference otherwise.
<P CLASS="nn-normal">
<A NAME="pgfId-515818"></A>In the case of procedures, this provides a convenient initialization mechanism. A delicate problem in the absence of a <SPAN CLASS="ee-keyword">
once </SPAN>
mechanism is how to provide the users of a library with a set of routines which they can call in any order, but which all need, to function properly, the guarantee that some context had been properly set up. Asking the library clients to precede the first call with a call to an initialization procedure <SPAN CLASS="ee-text">
setup</SPAN>
 is not only user-unfriendly but silly: in a well-engineered system we will want to check proper set-up in every of the routines, and report an error if necessary; but then if we were able to detect improper set-up we might as well shut up and set up ourselves (by calling <SPAN CLASS="ee-text">
setup</SPAN>
). This is not easy, however, since the object on which we call <SPAN CLASS="ee-text">
setup</SPAN>
 must itself be properly initialized, so we are only pushing the problem further. Making <SPAN CLASS="ee-text">
setup</SPAN>
 a <SPAN CLASS="ee-keyword">
once</SPAN>
 procedure solves it: we can simply include a call
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-515821"></A>setup
</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-515822"></A>at the beginning of each affected routine; the first one to come in will perform the needed initializations; subsequent calls will have, as desired, no effect.
<P CLASS="nn-normal">
<A NAME="pgfId-515830"></A>Once functions will give us shared objects. A common scheme is
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-515825"></A>console: WINDOW <SPAN CLASS="ee-keyword">
is</SPAN>

<P CLASS="ee-comment">
<A NAME="pgfId-515826"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Shared console window
<P CLASS="ee-text">
<A NAME="pgfId-515827"></A>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ee-keyword">
once</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515828"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ee-keyword">
create</SPAN>
 Result<SPAN CLASS="ee-dot">
.</SPAN>
make (&#8230;)
<P CLASS="ee-text">
<A NAME="pgfId-515829"></A>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ee-keyword">
end</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-515831"></A>Whatever client first calls this function will create the appropriate window and return a reference to it. Subsequent calls, from anywhere in the system, will return that same reference. The simplest way to make this function available to a set of classes is to include it in a class <SPAN CLASS="ee-text">
SHARED_STRUCTURES</SPAN>
 which the classes needing a set of related shared objects will simply inherit.
<P CLASS="nn-normal">
<A NAME="pgfId-515832"></A>For the classes using it, <SPAN CLASS="ee-text">
console</SPAN>
, although a function, looks very much as if it were an attribute -- only one referring to a shared object.
<P CLASS="nn-normal">
<A NAME="pgfId-515836"></A>The &quot;Hello World&quot; system at the beginning of this discussion (section <A HREF="tutorial-05.html#35212" CLASS="XRef"><SPAN CLASS="ww-crossref">
4</SPAN>
</A>) used an output instruction of the form <SPAN CLASS="ee-text">
io</SPAN>
<SPAN CLASS="ee-dot">
.</SPAN>
<SPAN CLASS="ee-text">
put_string </SPAN>
<SPAN CLASS="ee-comment">
(&quot;</SPAN>
<SPAN CLASS="ee-text">
Some string</SPAN>
&quot;<SPAN CLASS="ee-comment">
)</SPAN>
. This is another example of the general scheme illustrated by <SPAN CLASS="ee-text">
console</SPAN>
. Feature <SPAN CLASS="ee-text">
io</SPAN>
, declared in <SPAN CLASS="ee-text">
ANY</SPAN>
 and hence usable by all classes, is a once function that returns an object of type <SPAN CLASS="ee-text">
STANDARD_FILES</SPAN>
 (another Kernel Library class) providing access to basic input and output features, one of which is procedure <SPAN CLASS="ee-text">
put_string</SPAN>
. Because basic input and output must all work on the same files, <SPAN CLASS="ee-text">
io</SPAN>
 should clearly be a once function, shared by all classes that need these mechanisms.
</DIV>
<DIV>
<H2 CLASS="aa-sec3">
<A NAME="pgfId-515838"></A><A NAME="94304"></A>Constant and unique attributes</H2>
<P CLASS="nn-first">
<A NAME="pgfId-515839"></A>The attributes studied earlier were variable: each represents a field present in each instance of the class and changeable by its routines.
<P CLASS="nn-normal">
<A NAME="pgfId-515843"></A>It is also possible to declare constant attributes, as in
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-515842"></A><SPAN CLASS="ee-text">
Solar_system_planet_count</SPAN>
: <SPAN CLASS="ee-text">
INTEGER</SPAN>
 <SPAN CLASS="ee-keyword">
is</SPAN>
 <SPAN CLASS="ee-text">
9</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-515844"></A>These will have the same value for every instance and hence do not need to occupy any space in objects at execution time. (In other approaches similar needs would be addressed by symbolic constants, as in Pascal or Ada, or macros, as in C.)
<P CLASS="nn-normal">
<A NAME="pgfId-515845"></A>What comes after the<SPAN CLASS="ee-keyword">
 is</SPAN>
 is a manifest constant: a self-denoting value of the appropriate type. Manifest constants are available for integers, reals (also used for doubles), booleans (<SPAN CLASS="ee-text">
True</SPAN>
 and <SPAN CLASS="ee-text">
False</SPAN>
), characters (in single quotes, as <SPAN CLASS="ee-comment">
'</SPAN>
<SPAN CLASS="ee-text">
A</SPAN>
<SPAN CLASS="ee-comment">
'</SPAN>
, with special characters expressed using a percent sign as in <SPAN CLASS="ee-comment">
'%</SPAN>
<SPAN CLASS="ee-text">
N</SPAN>
<SPAN CLASS="ee-comment">
'</SPAN>
<SPAN CLASS="ee-text">
 </SPAN>
for new line, <SPAN CLASS="ee-comment">
'%</SPAN>
<SPAN CLASS="ee-text">
B</SPAN>
<SPAN CLASS="ee-comment">
'</SPAN>
 for backspace and <SPAN CLASS="ee-comment">
'%</SPAN>
<SPAN CLASS="ee-text">
U</SPAN>
<SPAN CLASS="ee-comment">
'</SPAN>
 for null).
<P CLASS="nn-normal">
<A NAME="pgfId-515846"></A>For integer constants, it is also possible to avoid specifying the values. A declaration of the form
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-515849"></A><SPAN CLASS="ee-text">
a</SPAN>
, <SPAN CLASS="ee-text">
b</SPAN>
, <SPAN CLASS="ee-text">
c</SPAN>
, &#8230; <SPAN CLASS="ee-text">
n</SPAN>
: <SPAN CLASS="ee-text">
INTEGER</SPAN>
 <SPAN CLASS="ee-keyword">
is unique</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-515850"></A>introduces <SPAN CLASS="ee-text">
a</SPAN>
, <SPAN CLASS="ee-text">
b</SPAN>
, <SPAN CLASS="ee-text">
c</SPAN>
, &#8230; <SPAN CLASS="ee-text">
n </SPAN>
as constant integer attributes, whose value are assigned by the Eiffel compiler rather than explicitly by the programmer. The values are different for all <SPAN CLASS="ee-keyword">
unique</SPAN>
 attributes in a system; they are all positive, and, in a single declaration such as the above, guaranteed to be consecutive (so that you may use an invariant property of the form <SPAN CLASS="ee-text">
code</SPAN>
<SPAN CLASS="ee-comment">
 &gt;=</SPAN>
 <SPAN CLASS="ee-text">
a</SPAN>
 <SPAN CLASS="ee-keyword">
and </SPAN>
<SPAN CLASS="ee-text">
code</SPAN>
<SPAN CLASS="ee-comment">
 &lt;= </SPAN>
<SPAN CLASS="ee-text">
n</SPAN>
 to express that <SPAN CLASS="ee-text">
code</SPAN>
 should be one of the values). This mechanism replaces the &quot;enumerated types&quot; found in many anguages, without suffering from the same problems. (Enumerated types have an ill-defined place in the type system; and it is not clear what operations are permitted.)
<P CLASS="nn-normal">
<A NAME="pgfId-530639"></A>You may use Unique values in conjunction with the <SPAN CLASS="ee-keyword">
inspect</SPAN>
 multi-branch instruction studied in the next section. They are only appropriate for codes that can take on a fixed number of well-defined values -- not as a way to program operations with many variants, a need better addressed by the object-oriented technique studied earlier and relying on inheritance, polymorphism, redeclaration and dynamic binding.
<P CLASS="nn-normal">
<A NAME="pgfId-515854"></A>Manifest constants are also available for strings, using double quotes as in
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-515853"></A><SPAN CLASS="ee-text">
User_friendly_error_message</SPAN>
: <SPAN CLASS="ee-text">
INTEGER</SPAN>
 <SPAN CLASS="ee-keyword">
is</SPAN>
 &quot;<SPAN CLASS="ee-text">
Go get a life</SPAN>
!&quot;
</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-515855"></A>with special characters again using the <SPAN CLASS="ee-comment">
%</SPAN>
 codes. It is also possible to declare manifest arrays using double angle brackets:
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-515858"></A>&lt;&lt;<SPAN CLASS="ee-text">
1</SPAN>
, <SPAN CLASS="ee-text">
2</SPAN>
, <SPAN CLASS="ee-text">
3</SPAN>
, <SPAN CLASS="ee-text">
5</SPAN>
, <SPAN CLASS="ee-text">
7</SPAN>
, <SPAN CLASS="ee-text">
11</SPAN>
, <SPAN CLASS="ee-text">
13</SPAN>
, <SPAN CLASS="ee-text">
17</SPAN>
, <SPAN CLASS="ee-text">
19</SPAN>
&gt;&gt;
</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-515859"></A>which is an expression of type <SPAN CLASS="ee-text">
ARRAY </SPAN>
<SPAN CLASS="ee-comment">
[</SPAN>
<SPAN CLASS="ee-text">
INTEGER</SPAN>
<SPAN CLASS="ee-comment">
]</SPAN>
. Manifest arrays and strings are not atomic, but denote instances of the Kernel Library classes <SPAN CLASS="ee-text">
STRING</SPAN>
 and <SPAN CLASS="ee-text">
ARRAY</SPAN>
, as can be produced by once functions.
</DIV>
<DIV>
<H2 CLASS="aa-sec3">
<A NAME="pgfId-530651"></A><A NAME="38021"></A>Instructions</H2>
<P CLASS="nn-first">
<A NAME="pgfId-530788"></A>Eiffel has a remarkably small set of instructions. The basic computational instructions have been seen: creation, assignment, assignment attempt, procedure call, <SPAN CLASS="ee-keyword">
retry</SPAN>
. They are complemented by control structures: conditional, multi-branch, loop, as well as <SPAN CLASS="ee-keyword">
debug</SPAN>
 and <SPAN CLASS="ee-keyword">
check</SPAN>
.
<P CLASS="nn-normal">
<A NAME="pgfId-515863"></A>A conditional instruction has the form <SPAN CLASS="ee-keyword">
if</SPAN>
<SPAN CLASS="ee-text">
 </SPAN>
&#8230;<SPAN CLASS="ee-text">
 </SPAN>
<SPAN CLASS="ee-keyword">
then </SPAN>
&#8230;<SPAN CLASS="ee-keyword">
 elseif </SPAN>
&#8230;<SPAN CLASS="ee-keyword">
 then </SPAN>
&#8230; <SPAN CLASS="ee-keyword">
else </SPAN>
&#8230;<SPAN CLASS="ee-keyword">
 end</SPAN>
. The <SPAN CLASS="ee-keyword">
elseif </SPAN>
&#8230;<SPAN CLASS="ee-keyword">
 then </SPAN>
&#8230; part (of which there may be more than one) and the <SPAN CLASS="ee-keyword">
else </SPAN>
&#8230;<SPAN CLASS="ee-keyword">
 </SPAN>
part are optional. After <SPAN CLASS="ee-keyword">
if</SPAN>
 and <SPAN CLASS="ee-keyword">
elseif </SPAN>
comes a boolean expression; after <SPAN CLASS="ee-keyword">
then</SPAN>
, <SPAN CLASS="ee-keyword">
elseif</SPAN>
 and <SPAN CLASS="ee-keyword">
else</SPAN>
 come zero or more instructions.
<P CLASS="nn-normal">
<A NAME="pgfId-515876"></A>A multi-branch instruction has the form
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-515866"></A><SPAN CLASS="ee-keyword">
inspect</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515867"></A>&nbsp;&nbsp;&nbsp;&nbsp;exp
<P CLASS="ee-text">
<A NAME="pgfId-515868"></A><SPAN CLASS="ee-keyword">
when</SPAN>
 v<SPAN CLASS="ee-sub">
1</SPAN>
 then
<P CLASS="ee-text">
<A NAME="pgfId-515869"></A>&nbsp;&nbsp;&nbsp;&nbsp;inst<SPAN CLASS="ee-sub">
1</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515870"></A><SPAN CLASS="ee-keyword">
when </SPAN>
v<SPAN CLASS="ee-sub">
2</SPAN>
 <SPAN CLASS="ee-keyword">
then</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515871"></A>&nbsp;&nbsp;&nbsp;&nbsp;inst<SPAN CLASS="ee-sub">
2</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515872"></A>&#8230; 
<P CLASS="ee-text">
<A NAME="pgfId-515873"></A><SPAN CLASS="ee-keyword">
else</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515874"></A>&nbsp;&nbsp;&nbsp;&nbsp;inst<SPAN CLASS="ee-sub">
0</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515875"></A><SPAN CLASS="ee-keyword">
end</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-515877"></A>where the <SPAN CLASS="ee-keyword">
else</SPAN>
<SPAN CLASS="ee-text">
 inst</SPAN>
<SPAN CLASS="ee-sub">
0</SPAN>
<SPAN CLASS="ee-text">
 </SPAN>
part is optional, <SPAN CLASS="ee-text">
exp</SPAN>
 is a character or integer expression, <SPAN CLASS="ee-text">
v</SPAN>
<SPAN CLASS="ee-sub">
1</SPAN>
, <SPAN CLASS="ee-text">
v</SPAN>
<SPAN CLASS="ee-sub">
2</SPAN>
, &#8230; are constant values of the same type as <SPAN CLASS="ee-text">
exp</SPAN>
, all different, and <SPAN CLASS="ee-text">
inst</SPAN>
<SPAN CLASS="ee-sub">
0</SPAN>
, <SPAN CLASS="ee-text">
inst</SPAN>
<SPAN CLASS="ee-sub">
1</SPAN>
, <SPAN CLASS="ee-text">
inst</SPAN>
<SPAN CLASS="ee-sub">
2</SPAN>
, &#8230; are sequences of zero or more instructions. In the integer case, it is often convenient to use <SPAN CLASS="ee-keyword">
unique</SPAN>
 values (<A HREF="tutorial-11.html#94304" CLASS="XRef"><SPAN CLASS="ww-crossref">
&quot;Constant and unique attributes&quot;,  page 83</SPAN>
</A>) for the <SPAN CLASS="ee-text">
v</SPAN>
<SPAN CLASS="ee-sub">
i</SPAN>
.
<P CLASS="nn-normal">
<A NAME="pgfId-515878"></A>The effect of such a multi-branch instruction, if the value of <SPAN CLASS="ee-text">
exp</SPAN>
 is one of the <SPAN CLASS="ee-text">
v</SPAN>
<SPAN CLASS="ee-sub">
i</SPAN>
, is to execute the corresponding <SPAN CLASS="ee-text">
inst</SPAN>
<SPAN CLASS="ee-sub">
i</SPAN>
. If none of the <SPAN CLASS="ee-text">
v</SPAN>
<SPAN CLASS="ee-sub">
i</SPAN>
<SPAN CLASS="ee-text">
 </SPAN>
matches, the instruction executes <SPAN CLASS="ee-text">
inst</SPAN>
<SPAN CLASS="ee-sub">
0</SPAN>
, unless there is no <SPAN CLASS="ee-keyword">
else </SPAN>
part, in which case it triggers an exception.
<P CLASS="jj-small">
<A NAME="pgfId-530829"></A>Raising an exception is the proper behavior, since the absence of an <SPAN CLASS="ee-keyword">
else</SPAN>
 indicates that the author asserts that one of the values will match. If you want an instruction that does nothing in this case, rather than cause an exception, use an <SPAN CLASS="ee-keyword">
else</SPAN>
 part with an empty <SPAN CLASS="ee-text">
inst</SPAN>
<SPAN CLASS="ee-sub">
0</SPAN>
. In contrast, <SPAN CLASS="ee-keyword">
if </SPAN>
<SPAN CLASS="ee-text">
c </SPAN>
<SPAN CLASS="ee-keyword">
then </SPAN>
<SPAN CLASS="ee-text">
inst</SPAN>
<SPAN CLASS="ee-keyword">
 end</SPAN>
 with no <SPAN CLASS="ee-keyword">
else</SPAN>
 part does nothing in the absence of an <SPAN CLASS="ee-keyword">
else</SPAN>
 part, since in this case there is no implied claim that <SPAN CLASS="ee-text">
c</SPAN>
 must hold.)
<P CLASS="nn-first">
<A NAME="pgfId-515892"></A>The loop construct has the form
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-515881"></A><SPAN CLASS="ee-keyword">
from</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515882"></A>&nbsp;&nbsp;&nbsp;&nbsp;initialization
<P CLASS="ee-text">
<A NAME="pgfId-515883"></A><SPAN CLASS="ee-keyword">
until</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515884"></A>&nbsp;&nbsp;&nbsp;&nbsp;exit
<P CLASS="ee-text">
<A NAME="pgfId-515885"></A><SPAN CLASS="ee-keyword">
invariant</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515886"></A>&nbsp;&nbsp;&nbsp;&nbsp;inv
<P CLASS="ee-text">
<A NAME="pgfId-515887"></A><SPAN CLASS="ee-keyword">
variant</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515888"></A>&nbsp;&nbsp;&nbsp;&nbsp;var
<P CLASS="ee-text">
<A NAME="pgfId-515889"></A><SPAN CLASS="ee-keyword">
loop</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515890"></A>&nbsp;&nbsp;&nbsp;&nbsp;body
<P CLASS="ee-text">
<A NAME="pgfId-515891"></A><SPAN CLASS="ee-keyword">
end</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-515893"></A>where the <SPAN CLASS="ee-keyword">
invariant </SPAN>
<SPAN CLASS="ee-text">
inv</SPAN>
 and <SPAN CLASS="ee-keyword">
variant</SPAN>
<SPAN CLASS="ee-text">
 var</SPAN>
 parts are optional, the others required. <SPAN CLASS="ee-text">
initialization</SPAN>
 and <SPAN CLASS="ee-text">
body</SPAN>
 are sequences of zero or more instructions; <SPAN CLASS="ee-text">
exit </SPAN>
and <SPAN CLASS="ee-text">
inv</SPAN>
 are boolean expressions (more precisely, <SPAN CLASS="ee-text">
inv</SPAN>
 is an assertion); <SPAN CLASS="ee-text">
var</SPAN>
 is an integer expression.
<P CLASS="nn-normal">
<A NAME="pgfId-515894"></A>The effect is to execute <SPAN CLASS="ee-text">
initialization</SPAN>
, then, zero or more times until <SPAN CLASS="ee-text">
exit</SPAN>
 is satisfied, to execute <SPAN CLASS="ee-text">
body</SPAN>
. (If after <SPAN CLASS="ee-text">
initialization</SPAN>
 the value of <SPAN CLASS="ee-text">
exit</SPAN>
 is already true, <SPAN CLASS="ee-text">
body</SPAN>
 will not be executed at all.) Note that the syntax of loops always includes an initialization, as most loops require some preparation. If not, just leave <SPAN CLASS="ee-text">
initialization</SPAN>
 empty, while including the <SPAN CLASS="ee-keyword">
from</SPAN>
 since it is a required component.
<P CLASS="nn-normal">
<A NAME="pgfId-515895"></A>The assertion <SPAN CLASS="ee-text">
inv</SPAN>
, if present, expresses a <SPAN CLASS="ff-bold">
loop invariant</SPAN>
<SPAN CLASS="ee-keyword">
 </SPAN>
(not to be confused with class invariants). For the loop to be correct, <SPAN CLASS="ee-text">
initialization</SPAN>
 must ensure <SPAN CLASS="ee-text">
inv</SPAN>
, and then every iteration of <SPAN CLASS="ee-text">
body</SPAN>
 executed when <SPAN CLASS="ee-text">
exit</SPAN>
 is false must preserve the invariant; so the effect of the loop is to yield a state in which both <SPAN CLASS="ee-text">
inv</SPAN>
 and <SPAN CLASS="ee-text">
exit</SPAN>
 are true. The loop must terminate after a finite number of iterations, of course; this can be guaranteed by using a <SPAN CLASS="ff-bold">
loop variant</SPAN>
<SPAN CLASS="ee-text">
 var</SPAN>
. It must be an integer expression whose value is non-negative after execution of <SPAN CLASS="ee-text">
initialization</SPAN>
, and decreased by at least one, while remain non-negative, by any execution of <SPAN CLASS="ee-text">
body</SPAN>
 when <SPAN CLASS="ee-text">
exit</SPAN>
 is false; since a non-negative integer cannot be decreased forever, this ensures termination. The assertion monitoring mode, if turned on at the highest level, will check these properties of the invariant and variant after initialization and after each loop iteration, triggering an exception if the invariant does not hold or the variant is negative or does not decrease.
<P CLASS="nn-normal">
<A NAME="pgfId-515896"></A>An occasionally useful instruction is <SPAN CLASS="ee-keyword">
debug </SPAN>
<SPAN CLASS="ee-comment">
(</SPAN>
<SPAN CLASS="ee-text">
Debug_key, </SPAN>
&#8230;<SPAN CLASS="ee-comment">
)</SPAN>
<SPAN CLASS="ee-text">
 instructions </SPAN>
<SPAN CLASS="ee-keyword">
end</SPAN>
 where <SPAN CLASS="ee-text">
instructions</SPAN>
 is a sequence of zero or more instructions and the part in parentheses is optional, containing if present one or more strings, called debug keys. The EiffelStudio compiler lets you specify the corresponding <SPAN CLASS="ee-keyword">
debug</SPAN>
 compilation option: <SPAN CLASS="ee-keyword">
yes</SPAN>
, <SPAN CLASS="ee-keyword">
no</SPAN>
, or an explicit debug key. The <SPAN CLASS="ee-text">
instructions</SPAN>
 will be executed if and only if the corresponding option is on. The obvious use is for instructions that should be part of the system but executed only in some circumstances, for example to provide extra debugging information.
<P CLASS="nn-normal">
<A NAME="pgfId-515897"></A>The final instruction is connected with Design by Contract. The instruction <SPAN CLASS="ee-keyword">
check </SPAN>
<SPAN CLASS="ee-text">
Assertions </SPAN>
<SPAN CLASS="ee-keyword">
end</SPAN>
, where <SPAN CLASS="ee-text">
Assertions </SPAN>
is a sequence of zero or more assertions, will have no effect unless assertion monitoring is turned on at the <SPAN CLASS="ee-keyword">
Check</SPAN>
 level or higher. If so it will evaluate all the assertions listed, having no further effect if they are all satisfied; if any one of them does not hold, the instruction will trigger an exception.
<P CLASS="nn-normal">
<A NAME="pgfId-515898"></A>This instruction serves to state properties that are expected to be satisfied at some stages of the computation -- other than the specific stages, such as routine entry and exit, already covered by the other assertion mechanisms such as preconditions, postconditions and invariants. A recommended use of <SPAN CLASS="ee-keyword">
check</SPAN>
 involves calling a routine with a precondition, where the call, for good reason, does not explicitly test for the precondition. Consider a routine of the form
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-515901"></A>r (ref: SOME_REFERENCE_TYPE) <SPAN CLASS="ee-keyword">
is</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515902"></A>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ee-keyword">
require</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515903"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;not_void: r /= Void
<P CLASS="ee-text">
<A NAME="pgfId-515904"></A>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ee-keyword">
do</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515905"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r<SPAN CLASS="ee-dot">
.</SPAN>
some_feature
<P CLASS="ee-text">
<A NAME="pgfId-515906"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8230; 
<P CLASS="ee-text">
<A NAME="pgfId-515907"></A>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ee-keyword">
end</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-515908"></A>Because of the call to <SPAN CLASS="ee-text">
some_feature</SPAN>
, the routine will only work if its precondition is satisfied on entry. To guarantee this precondition, the caller may protect it by the corresponding test, as in
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-530896"></A><SPAN CLASS="ee-keyword">
if </SPAN>
<SPAN CLASS="ee-text">
x</SPAN>
 <SPAN CLASS="ee-comment">
/=</SPAN>
 <SPAN CLASS="ee-text">
Void </SPAN>
<SPAN CLASS="ee-keyword">
then </SPAN>
<SPAN CLASS="ee-text">
a</SPAN>
<SPAN CLASS="ee-dot">
.</SPAN>
<SPAN CLASS="ee-text">
r </SPAN>
<SPAN CLASS="ee-comment">
(</SPAN>
<SPAN CLASS="ee-text">
x</SPAN>
<SPAN CLASS="ee-comment">
)</SPAN>
<SPAN CLASS="ee-keyword">
 end</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-530885"></A>but this is not the only possible scheme; for example if an <SPAN CLASS="ee-keyword">
create</SPAN>
 <SPAN CLASS="ee-text">
x</SPAN>
 appears shortly before the call we know <SPAN CLASS="ee-text">
x</SPAN>
 is not void and do not need the protection. It is a good idea in such cases to use a <SPAN CLASS="ee-keyword">
check</SPAN>
 instruction to document this property, if only to make sure that a reader of the code will realize that the omission of an explicit test (justified or not) was not a mistake. This is particularly appropriate if the justification for not testing the precondition is less obvious. For example <SPAN CLASS="ee-text">
x</SPAN>
 could have been obtained, somewhere else in the algorithm, as <SPAN CLASS="ee-text">
clone</SPAN>
 <SPAN CLASS="ee-comment">
(</SPAN>
<SPAN CLASS="ee-text">
y</SPAN>
<SPAN CLASS="ee-comment">
) </SPAN>
for some <SPAN CLASS="ee-text">
y </SPAN>
that you know is not void. You should document this knowledge by writing the call as
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-515911"></A>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ee-keyword">
check</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515912"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x_not_void: x /= Void <SPAN CLASS="ee-keyword">
end</SPAN>

<P CLASS="ee-comment">
<A NAME="pgfId-515913"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Because <SPAN CLASS="ee-text">
x</SPAN>
 was obtained as a clone of <SPAN CLASS="ee-text">
y</SPAN>
,<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- and <SPAN CLASS="ee-text">
y</SPAN>
 is not void because <SPAN CLASS="ee-comment">
[</SPAN>
etc.<SPAN CLASS="ee-comment">
]</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515914"></A>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ee-keyword">
end</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-515915"></A>a<SPAN CLASS="ee-dot">
.</SPAN>
r (x)
</TD>
</TR>
</table></ul><p>
<P CLASS="jj-small">
<A NAME="pgfId-515916"></A>Note the recommended convention: extra indentation of the <SPAN CLASS="ee-keyword">
check</SPAN>
 part to separate it from the algorithm proper; and inclusion of a comment listing the rationale behind the developer's decision not to check explicitly for the precondition.
<P CLASS="nn-first">
<A NAME="pgfId-515917"></A>In production mode with assertion monitoring turned off, this instruction will have no effect. But it will be precious for a maintainer of the software who is trying to figure out what it does, and in the process to reconstruct the original developer's reasoning. (The maintainer might of course be the same person as the developer, six months later.) And if the rationale is wrong somewhere, turning assertion checking on will immediately uncover the bug.
</DIV>
<DIV>
<H2 CLASS="aa-sec3">
<A NAME="pgfId-531239"></A>Obsolete features and classes</H2>
<P CLASS="nn-first">
<A NAME="pgfId-531240"></A>One of the conditions for producing truly great reusable software is to recognize that although you should try to get everything right the first time around you won't always succeed. But if &quot;good enough&quot; may be good enough for application software, it's not good enough, in the long term, for reusable software. The aim is to get ever closer to the asymptote of perfection. If you find a better way, you must implement it. The activity of <SPAN CLASS="ff-italics">
generalization</SPAN>
, discussed as part of the lifecycle, doesn't stop at the first release of a reusable library.
<P CLASS="nn-normal">
<A NAME="pgfId-531241"></A>This raises the issue of backward compability: how to move forward with a better design, without compromising existing applications that used the previous version?
<P CLASS="nn-normal">
<A NAME="pgfId-531242"></A>The notion of obsolete class and feature helps address this issue. By declaring a feature as <SPAN CLASS="ee-keyword">
obsolete</SPAN>
, using the syntax
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-531246"></A>enter (<SPAN CLASS="ee-text">
i</SPAN>
<SPAN CLASS="ee-comment">
:</SPAN>
<SPAN CLASS="ee-text">
 INTEGER</SPAN>
; x: G) <SPAN CLASS="ee-keyword">
is</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-598260"></A><SPAN CLASS="ee-keyword">
&nbsp;&nbsp;&nbsp;&nbsp;obsolete</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-531268"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ee-comment">
&quot;</SPAN>
<SPAN CLASS="ee-text">
Use </SPAN>
<SPAN CLASS="ee-comment">
`</SPAN>
<SPAN CLASS="ee-text">
put </SPAN>
<SPAN CLASS="ee-comment">
(</SPAN>
<SPAN CLASS="ee-text">
x, i</SPAN>
<SPAN CLASS="ee-comment">
)' </SPAN>
<SPAN CLASS="ee-text">
instead</SPAN>
<SPAN CLASS="ee-comment">
&quot;</SPAN>
<SPAN CLASS="ee-keyword">
</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-531247"></A>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ee-keyword">
require</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-531248"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8230;
<P CLASS="ee-text">
<A NAME="pgfId-531249"></A>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ee-keyword">
do</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-531250"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put (x, i)
<P CLASS="ee-text">
<A NAME="pgfId-531252"></A>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ee-keyword">
end</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-531285"></A>you state that you are now advising against using it, and suggest a replacement through the message that follows the keyword <SPAN CLASS="ee-keyword">
obsolete</SPAN>
, a mere string. The obsolete feature is still there, however; using it will cause no other harm than a warning message when someone compiles a system that includes a call to it. Indeed, you don't want to hold a gun to your client authors' forehead (&quot;<SPAN CLASS="ff-italics">
Upgrade now or die</SPAN>
!'); but you do want to let them know that there is a new version and that they should upgrade at their leisure. 
<P CLASS="nn-normal">
<A NAME="pgfId-531319"></A>Besides routines, you may also mark classes as obsolete.
<P CLASS="nn-normal">
<A NAME="pgfId-553536"></A>The example above is a historical one, involving an early change of interface for the EiffelBase library class <SPAN CLASS="ee-text">
ARRAY</SPAN>
; the change affected both the feature's name, with a new name ensuring better consistency with other classes, and the order of arguments, again for consistency. It shows the recommended style for using <SPAN CLASS="ee-keyword">
obsolete</SPAN>
:
<UL>
<p class="nn-first"><img src="greenball.gif" alt="+" width="6" height="6">
<A NAME="pgfId-553537"></A>In the message following the keyword, explain the recommended replacement. This message will be part of the warning produced by the compiler for a system that includes the obsolete element.
<p class="nn-first"><img src="greenball.gif" alt="+" width="6" height="6">
<A NAME="pgfId-531333"></A>In the body of the routine, it is usually appropriate, as here, to replace the original implementation by a call to the new version. This may imply a small performance overhead, but simplifies maintenance and avoids errors.
</UL>
<P CLASS="nn-first">
<A NAME="pgfId-531334"></A>It is good discipline not to let obsolete elements linger around for too long. The next major new release, after a suitable grace period, should remove them.
<P CLASS="nn-normal">
<A NAME="pgfId-531322"></A>The design flexibility afforded by the <SPAN CLASS="ee-keyword">
obsolete</SPAN>
 keyword is critical to ensure the harmonious long-term development of ambitious reusable software.
</DIV>
<DIV>
<H2 CLASS="aa-sec3">
<A NAME="pgfId-553392"></A><A NAME="28280"></A>Creation variants</H2>
<P CLASS="nn-first">
<A NAME="pgfId-553393"></A>The basic forms of creation instruction, and the one most commonly used, are the two illustrated earlier (<A HREF="tutorial-07.html#59651" CLASS="XRef"><SPAN CLASS="ww-crossref">
&quot;Creating and initializing objects&quot;,  page 20</SPAN>
</A>):
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-553498"></A><SPAN CLASS="ee-keyword">
create</SPAN>
 <SPAN CLASS="ee-text">
x</SPAN>
<SPAN CLASS="ee-dot">
.</SPAN>
<SPAN CLASS="ee-text">
make </SPAN>
<SPAN CLASS="ee-comment">
(</SPAN>
<SPAN CLASS="ee-text">
2000</SPAN>
<SPAN CLASS="ee-comment">
)</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-553486"></A><SPAN CLASS="ee-keyword">
create</SPAN>
 <SPAN CLASS="ee-text">
x</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-553493"></A>the first one if the corresponding class has a <SPAN CLASS="ee-keyword">
create</SPAN>
 clause, the second one if not. In either form you may include a type name in braces, as in
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-553506"></A><SPAN CLASS="ee-keyword">
create</SPAN>
 <SPAN CLASS="ee-comment">
{</SPAN>
<SPAN CLASS="ee-text">
SAVINGS_ACCOUNT</SPAN>
<SPAN CLASS="ee-comment">
} </SPAN>
<SPAN CLASS="ee-text">
x</SPAN>
<SPAN CLASS="ee-dot">
.</SPAN>
<SPAN CLASS="ee-text">
make </SPAN>
<SPAN CLASS="ee-comment">
(</SPAN>
<SPAN CLASS="ee-text">
2000</SPAN>
<SPAN CLASS="ee-comment">
)</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-553520"></A>which is valid only if the type listed, here <SPAN CLASS="ee-text">
SAVINGS_ACCOUNT</SPAN>
, conforms to the type of <SPAN CLASS="ee-text">
x</SPAN>
, assumed here to be <SPAN CLASS="ee-text">
ACCOUNT</SPAN>
. This avoids introducing a local entity, as in
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-553531"></A><SPAN CLASS="ee-keyword">
local</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-553540"></A>&nbsp;&nbsp;&nbsp;&nbsp;sx<SPAN CLASS="ee-comment">
: </SPAN>
<SPAN CLASS="ee-text">
SAVINGS_ACCOUNT</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-553547"></A><SPAN CLASS="ee-keyword">
do</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-553535"></A><SPAN CLASS="ee-keyword">
&nbsp;&nbsp;&nbsp;&nbsp;create</SPAN>
 <SPAN CLASS="ee-text">
xs</SPAN>
<SPAN CLASS="ee-dot">
.</SPAN>
<SPAN CLASS="ee-text">
make </SPAN>
<SPAN CLASS="ee-comment">
(</SPAN>
<SPAN CLASS="ee-text">
2000</SPAN>
<SPAN CLASS="ee-comment">
)</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-553563"></A>&nbsp;&nbsp;&nbsp;&nbsp;x := xs
<P CLASS="ee-text">
<A NAME="pgfId-553554"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8230;
</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-553564"></A>and has exactly the same effect. Another variant is the <SPAN CLASS="ff-bold">
creation expression</SPAN>
, which always lists the type, but returns a value instead of being an instruction. It is useful in the followingcontext:
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-553568"></A><SPAN CLASS="ee-text">
some_routine </SPAN>
<SPAN CLASS="ee-comment">
(</SPAN>
<SPAN CLASS="ee-keyword">
create</SPAN>
 <SPAN CLASS="ee-comment">
{</SPAN>
<SPAN CLASS="ee-text">
ACCOUNT</SPAN>
<SPAN CLASS="ee-comment">
}</SPAN>
<SPAN CLASS="ee-dot">
.</SPAN>
<SPAN CLASS="ee-text">
make </SPAN>
<SPAN CLASS="ee-comment">
(</SPAN>
<SPAN CLASS="ee-text">
2000</SPAN>
<SPAN CLASS="ee-comment">
))</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-553610"></A>which you may again view as an abbreviation for a more verbose form that would need a local entity, using a creation instruction:
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-553613"></A><SPAN CLASS="ee-keyword">
local</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-553614"></A>&nbsp;&nbsp;&nbsp;&nbsp;x<SPAN CLASS="ee-comment">
: </SPAN>
<SPAN CLASS="ee-text">
ACCOUNT</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-553615"></A><SPAN CLASS="ee-keyword">
do</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-553616"></A><SPAN CLASS="ee-keyword">
&nbsp;&nbsp;&nbsp;&nbsp;create</SPAN>
 <SPAN CLASS="ee-text">
x</SPAN>
<SPAN CLASS="ee-dot">
.</SPAN>
<SPAN CLASS="ee-text">
make </SPAN>
<SPAN CLASS="ee-comment">
(</SPAN>
<SPAN CLASS="ee-text">
2000</SPAN>
<SPAN CLASS="ee-comment">
)</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-553617"></A>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ee-text">
some_routine </SPAN>
<SPAN CLASS="ee-comment">
(</SPAN>
<SPAN CLASS="ee-text">
x</SPAN>
<SPAN CLASS="ee-comment">
)</SPAN>

<P CLASS="ee-text">
<A NAME="pgfId-553618"></A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8230;
</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-553619"></A>Unlike creation instructions, creation expressions must always list the type explicitly, <SPAN CLASS="ee-comment">
{</SPAN>
<SPAN CLASS="ee-text">
ACCOUNT</SPAN>
<SPAN CLASS="ee-comment">
} </SPAN>
in the example. They are useful in the case shown: creating an object that only serves as an argument to be passed to a routine. If you need to retain access to the object through an entity, the instruction <SPAN CLASS="ee-keyword">
create </SPAN>
<SPAN CLASS="ee-text">
x</SPAN>
&#8230; is the appropriate construct.
<P CLASS="nn-normal">
<A NAME="pgfId-601996"></A>The creation mechanism gets an extra degree of flexibility through the notion of <SPAN CLASS="ee-text">
default_create</SPAN>
. The simplest form of creation instruction, <SPAN CLASS="ee-keyword">
create </SPAN>
<SPAN CLASS="ee-text">
x</SPAN>
 without an explicit creation procedure, is actually an abbreviation for <SPAN CLASS="ee-keyword">
create</SPAN>
 <SPAN CLASS="ee-text">
x</SPAN>
<SPAN CLASS="ee-dot">
.</SPAN>
<SPAN CLASS="ee-text">
default_create</SPAN>
, where <SPAN CLASS="ee-text">
default_create</SPAN>
 is a procedure defined in class <SPAN CLASS="ee-text">
ANY</SPAN>
 to do nothing. By redefining <SPAN CLASS="ee-text">
default_create</SPAN>
 in one of your classes, you can ensure that <SPAN CLASS="ee-keyword">
create </SPAN>
<SPAN CLASS="ee-text">
x</SPAN>
 will take care of non-default initialization (and ensure the invariant if needed). When a class has no <SPAN CLASS="ee-keyword">
create</SPAN>
 clause, it's considered to have one that lists only <SPAN CLASS="ee-text">
default_create</SPAN>
. If you want to allow <SPAN CLASS="ee-keyword">
create </SPAN>
<SPAN CLASS="ee-text">
x</SPAN>
 as well as the use of some explicit creation procedures, simply list <SPAN CLASS="ee-text">
default_create</SPAN>
 along with these procedures in the <SPAN CLASS="ee-keyword">
create</SPAN>
 clause. To disallow creation altogether, include an empty <SPAN CLASS="ee-keyword">
create</SPAN>
 clause, although this technique is seldom needed since most non-creatable classes are deferred, and one can't instantiate a deferred class.
<P CLASS="nn-normal">
<A NAME="pgfId-602010"></A>One final twistis the mechanism for creating instances of formal generic parameters. For <SPAN CLASS="ee-text">
x</SPAN>
 of type <SPAN CLASS="ee-text">
G</SPAN>
 in a class C <SPAN CLASS="ee-comment">
[</SPAN>
<SPAN CLASS="ee-text">
G</SPAN>
<SPAN CLASS="ee-comment">
]</SPAN>
, it wouldn't be safe to allow <SPAN CLASS="ee-keyword">
create</SPAN>
 <SPAN CLASS="ee-text">
x</SPAN>
, since <SPAN CLASS="ee-text">
G</SPAN>
 stands for many possible types, all of which may have their own creation procedures. To allow such creation instructions, we rely on constrained genericity. You may declare a class as
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-602029"></A><SPAN CLASS="ee-text">
 [G -&gt; T </SPAN>
<SPAN CLASS="ee-keyword">
create </SPAN>
<SPAN CLASS="ee-text">
cp </SPAN>
<SPAN CLASS="ee-keyword">
end</SPAN>
<SPAN CLASS="ee-text">
]</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-602034"></A>to make <SPAN CLASS="ee-text">
G </SPAN>
constrained by <SPAN CLASS="ee-text">
T</SPAN>
, as we learned before, and specify that any actual generic parameter must have <SPAN CLASS="ee-text">
cp</SPAN>
 among its creation procedures. Then it's permitted to use <SPAN CLASS="ee-keyword">
create</SPAN>
 <SPAN CLASS="ee-text">
x</SPAN>
<SPAN CLASS="ee-dot">
.</SPAN>
<SPAN CLASS="ee-text">
cp</SPAN>
, with arguments if required by <SPAN CLASS="ee-text">
cp</SPAN>
, since it is guaranteed to be safe. The mechanism is very general since you may use <SPAN CLASS="ee-text">
ANY </SPAN>
for<SPAN CLASS="ee-text">
 T </SPAN>
and<SPAN CLASS="ee-text">
 default_create </SPAN>
for<SPAN CLASS="ee-text">
 cp</SPAN>
. The only requirement on <SPAN CLASS="ee-text">
cp</SPAN>
 is that it must be a <SPAN CLASS="ff-italics">
procedure</SPAN>
 of <SPAN CLASS="ee-text">
T</SPAN>
, not necessarily a <SPAN CLASS="ff-italics">
creation</SPAN>
 procedure; this permits using the mechanism even if <SPAN CLASS="ee-text">
T</SPAN>
 is deferred, a common occurrence. It's only descendants of <SPAN CLASS="ee-text">
T</SPAN>
 that must make <SPAN CLASS="ee-text">
cp </SPAN>
a creation procedure, by listing it in the <SPAN CLASS="ee-keyword">
create</SPAN>
 clause, if they want to serve as actual generic parameters for <SPAN CLASS="ee-text">
C</SPAN>
.<SPAN CLASS="ee-text">
</SPAN>

</DIV>
<DIV>
<H2 CLASS="aa-sec3">
<A NAME="pgfId-602012"></A><A NAME="36752"></A>Tuple types</H2>
<P CLASS="nn-first">
<A NAME="pgfId-555303"></A>The study of genericity described arrays. Another common kind of container objects bears some resemblance to arrays: sequences, or &quot;tuples&quot;, of elements of specified types. The difference is that all elements of an array were of the same type, or a conforming one, whereas for tuples you will specify the types we want for each relevant element. A typical tuple type is of the form
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-555306"></A>TUPLE <SPAN CLASS="ee-comment">
[</SPAN>
X, Y, Z<SPAN CLASS="ee-comment">
]</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-555349"></A>denoting a tuple of least three elements, such that the type of the first conforms to <SPAN CLASS="ee-text">
X</SPAN>
, the second to <SPAN CLASS="ee-text">
Y</SPAN>
, and the third to <SPAN CLASS="ee-text">
Z</SPAN>
.
<P CLASS="nn-normal">
<A NAME="pgfId-555350"></A>You may list any number of types in brackets, including none at all: <SPAN CLASS="ee-text">
TUPLE</SPAN>
, with no types in brackets, denotes tuples of arbitrary length.
<P CLASS="jj-small">
<A NAME="pgfId-555309"></A>The syntax, with brackets, is intentionally reminiscent of generic classes, but <SPAN CLASS="ee-text">
TUPLE</SPAN>
 is a reserved word, not the name of a class; making it a class would not work since a generic class has a fixed number of generic parameters. You may indeed use <SPAN CLASS="ee-text">
TUPLE</SPAN>
 to obtain the effect of a generic class with a variable number of parameters.
<P CLASS="nn-first">
<A NAME="pgfId-555310"></A>To write the tuples themselves -- the sequences of elements, instances of a tuple type -- you will also use square brackets; for example
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-555313"></A><SPAN CLASS="ee-comment">
[</SPAN>
<SPAN CLASS="ee-text">
x1</SPAN>
<SPAN CLASS="ee-comment">
,</SPAN>
 <SPAN CLASS="ee-text">
y1</SPAN>
<SPAN CLASS="ee-comment">
,</SPAN>
 <SPAN CLASS="ee-text">
z1</SPAN>
<SPAN CLASS="ee-comment">
]</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-555314"></A>with <SPAN CLASS="ee-text">
x1</SPAN>
 of type <SPAN CLASS="ee-text">
X</SPAN>
 and so on is a tuple of type <SPAN CLASS="ee-text">
TUPLE</SPAN>
 <SPAN CLASS="ee-comment">
[</SPAN>
<SPAN CLASS="ee-text">
X</SPAN>
<SPAN CLASS="ee-comment">
,</SPAN>
 <SPAN CLASS="ee-text">
Y</SPAN>
<SPAN CLASS="ee-comment">
,</SPAN>
 <SPAN CLASS="ee-text">
Z</SPAN>
<SPAN CLASS="ee-comment">
]</SPAN>
.
<P CLASS="nn-normal">
<A NAME="pgfId-555315"></A>The definition of tuple types states that <SPAN CLASS="ee-text">
TUPLE</SPAN>
 <SPAN CLASS="ee-comment">
[</SPAN>
<SPAN CLASS="ee-text">
X1</SPAN>
<SPAN CLASS="ee-comment">
, </SPAN>
<SPAN CLASS="tt-nsymbol">
&#8230;</SPAN>
<SPAN CLASS="ee-comment">
 , </SPAN>
<SPAN CLASS="ee-text">
Xn</SPAN>
<SPAN CLASS="ee-comment">
] </SPAN>
denotes sequences of <SPAN CLASS="ff-italics">
at least</SPAN>
 <SPAN CLASS="ee-text">
n </SPAN>
elements, of which the first <SPAN CLASS="ee-text">
n</SPAN>
 have types respectively conforming to <SPAN CLASS="ee-text">
X1</SPAN>
<SPAN CLASS="ee-comment">
, </SPAN>
<SPAN CLASS="tt-nsymbol">
&#8230;</SPAN>
<SPAN CLASS="ee-comment">
 , </SPAN>
<SPAN CLASS="ee-text">
Xn</SPAN>
. Such a sequence may have more than <SPAN CLASS="ee-text">
n</SPAN>
 elements.
<P CLASS="nn-normal">
<A NAME="pgfId-555316"></A>Features available on tuple types include <SPAN CLASS="ee-text">
count</SPAN>
<SPAN CLASS="ee-comment">
: </SPAN>
<SPAN CLASS="ee-text">
INTEGER</SPAN>
, yielding the number of elements in a tuple, <SPAN CLASS="ee-text">
item</SPAN>
 <SPAN CLASS="ee-comment">
(</SPAN>
<SPAN CLASS="ee-text">
i: INTEGER</SPAN>
<SPAN CLASS="ee-comment">
): </SPAN>
<SPAN CLASS="ee-text">
ANY </SPAN>
which returns the <SPAN CLASS="ee-text">
i</SPAN>
-th element, and <SPAN CLASS="ee-text">
put</SPAN>
 which replaces an element.
<P CLASS="nn-normal">
<A NAME="pgfId-555317"></A>Tuples are appropriate when these are the only operations you need, that is to say, you are using sequences with no further structure or properties. Tuples give you &quot;anonymous classes&quot; with predefined features <SPAN CLASS="ee-text">
count</SPAN>
, <SPAN CLASS="ee-text">
item</SPAN>
 and <SPAN CLASS="ee-text">
put</SPAN>
. A typical example is a general-purpose output procedure that takes an arbitrary sequence of values, of arbitrary types, and prints them. It may simply take an argument of type <SPAN CLASS="ee-text">
TUPLE</SPAN>
, so that clients can call it under the form
<p><ul><table width="79%">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-555320"></A><SPAN CLASS="ee-text">
write </SPAN>
<SPAN CLASS="ee-comment">
([</SPAN>
<SPAN CLASS="ee-text">
your_integer</SPAN>
<SPAN CLASS="ee-comment">
,</SPAN>
 <SPAN CLASS="ee-text">
your_real</SPAN>
<SPAN CLASS="ee-comment">
,</SPAN>
 <SPAN CLASS="ee-text">
your_account</SPAN>
<SPAN CLASS="ee-comment">
])</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-555321"></A>As soon as you need a type with more specific features, you should define a class.
</DIV>
<p class="bottom" ALIGN="left"><IMG SRC="normaldoc.gif" ALT="Previous, Up, Next" BORDER="0" WIDTH="300" HEIGHT="40" USEMAP="#navigation"><map name="navigation"><AREA SHAPE="RECT" alt="Previous section" COORDS="0,0,95,40" HREF="tutorial-10.html"><AREA SHAPE="RECT" alt="Up" COORDS="96,0,199,40" HREF="tutorial-00.html"><AREA SHAPE="RECT" alt="Next section" COORDS="200,0,300,40" HREF="tutorial-12.html"><area shape="default" nohref></MAP>

<p class="bottom" align="center"><a href="http://www.eiffel.com">Eiffel Home Page (Web)</a> -- <a href="../index.html">Getting started with Eiffel (local)</a>

<p class="copyright" align="center">Copyright Interactive Software Engineering, 2001
</BODY>
</HTML>
