<document title="9 Genericity">
	<meta_data>
		<help>
			<toc>
				<envision_location>Eiffel, The Language\Tutorials\Invitation to Eiffel</envision_location>
				<envision_pseudo_name>90</envision_pseudo_name>
				<envision_title>Genericity</envision_title>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph>Building software components (classes) as implementations of abstract data types yields systems with a solid architecture but does not in itself ensure reusability and extendibility.  Two key techniques address the problem: genericity (unconstrained or constrained) and inheritance.  Let us look first at the unconstrained form.  </paragraph>
		<paragraph>To make a class generic is to give it 
			<bold>formal generic parameters</bold>  representing as unknown types, as in these examples from ISE's EiffelBase, an open-source library covering basic data structures and algorithms:
		</paragraph>
		<code_block><class_name>ARRAY</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol>
<class_name>LIST</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol>
<class_name>LINKED_LIST</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol></code_block>
		<paragraph>These classes describe data structures -- arrays, lists without commitment to a specific representation, lists in linked representation -- containing objects of a certain type.  The formal generic parameter 
			<code>
				<class_name>G</class_name>
			</code> denotes this type.
		</paragraph>
		<paragraph>A class such as these doesn't quite yet describe a type, but a type template, since 
			<code>
				<class_name>G</class_name>
			</code> itself denotes an unknown type.  To derive a directly usable list or array type, you must provide a type corresponding to 
			<code>
				<class_name>G</class_name>
			</code>, called an 
			<bold>actual generic parameter</bold>; this may be either an expanded type, including basic types such as 
			<code>
				<class_name>INTEGER</class_name>
			</code>, or a reference type.  Here are some possible generic derivations:
		</paragraph>
		<code_block>il<symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>INTEGER</class_name><symbol>]</symbol>
aa<symbol>:</symbol> <class_name>ARRAY</class_name> <symbol>[</symbol><class_name>ACCOUNT</class_name><symbol>]</symbol>
aal<symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>ARRAY</class_name> <symbol>[</symbol><class_name>ACCOUNT</class_name><symbol>]</symbol><symbol>]</symbol></code_block>
		<paragraph>As the last example indicates, an actual generic parameter may itself be generically derived.  </paragraph>
		<paragraph>It would not be possible, without genericity, to have static type checking in a realistic object-oriented language.  </paragraph>
		<paragraph>A variant of this mechanism, constrained genericity, will enable a class to place specific requirements on possible actual generic parameters.  Constrained genericity will be described after inheritance.
		</paragraph>
	</paragraph></document>
