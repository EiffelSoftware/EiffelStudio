indexing

description: "A trick to achieve the semantics of static features as in %
             %C++ or Java. Various enumerated types are also available here.";
keywords: "static", "global";
status: "See notice at end of class";
date: "$Date$";
revision: "$Revision$"
class CODESET_STATICS

inherit
    THE_OSF_CS_REGISTRY

feature

-------- Statics needed by codesets --------------

    Special_min  : INTEGER is -1
    Native_cs    : INTEGER is 0
    Native_wcs   : INTEGER is 1
    Fallback_cs  : INTEGER is 2
    Fallback_wcs : INTEGER is 3
    Default_cs   : INTEGER is 4
    Default_wcs  : INTEGER is 5
    Special_max  : INTEGER is 5
----------------------
feature { NONE }


    special : DICTIONARY [CODESET, INTEGER] is

        once
            create result.make
        end
----------------------
feature { ANY }

    special_cs (csid : INTEGER) : CODESET is

        require
            valid_csid : Special_min <= csid and then
                         csid <= Special_max
        do
            if special.has (csid) then
                result := special.at (csid)
            end
        end
----------------------

    set_special_cs (csid : INTEGER; cs : CODESET) is

        require
            valid_csid : Special_min <= csid and then
                         csid <= Special_max
        do
            special.put (cs, csid)
        end
----------------------
feature -- The various codeset types; unfortunately Eiffel does not
        -- permit the definition of manifest constants in hex
        -- representation. These values were generated by a small
        -- C program.

    C_ascii7       : INTEGER is -65535
    C_ebcdic       : INTEGER is -65534
    C_html3        : INTEGER is -65533
    C_macintosh    : INTEGER is -65532
    C_ko18_r       : INTEGER is -65530
    C_iso8859_1    : INTEGER is 65537
    C_iso8859_2    : INTEGER is 65538
    C_iso8859_3    : INTEGER is 65539
    C_iso8859_4    : INTEGER is 65540
    C_iso8859_5    : INTEGER is 65541
    C_iso8859_6    : INTEGER is 65542
    C_iso8859_7    : INTEGER is 65543
    C_iso8859_8    : INTEGER is 65544
    C_iso8859_9    : INTEGER is 65545
    C_iso8859_10   : INTEGER is 65546
    C_ibm_437      : INTEGER is 268566965
    C_ibm_850      : INTEGER is 268567378
    C_ibm_852      : INTEGER is 268567380
    C_ibm_860      : INTEGER is 268566810
    C_ibm_863      : INTEGER is 268567391
    C_ibm_865      : INTEGER is 268566805
    C_win31_latin1 : INTEGER is -65531
    C_ucs4         : INTEGER is 65798
    C_utf16        : INTEGER is 65801
    C_utf8         : INTEGER is 83951617
    C_utf7         : INTEGER is -65529
----------------------
feature -- Line types; another enum

    C_line_crlf  : INTEGER is 1
    C_line_lf    : INTEGER is 2
    C_line_cr    : INTEGER is 3
    C_line_amiga : INTEGER is 2
    C_line_calwa : INTEGER is 1
    C_line_mac   : INTEGER is 3
    C_line_msdos : INTEGER is 1
    C_line_unix  : INTEGER is 2
    C_line_win31 : INTEGER is 1
    C_line_winnt : INTEGER is 1
    
----------------------
feature -- Characters to insert if conversion fails

    C_ascii7_unknown      : INTEGER is 63 -- '?'
    C_ebcdic_unknown      : INTEGER is 111 -- also '?'
    C_html3_unknown       : INTEGER is 63  -- actally supposed to be
                                           -- the string"iquest"
    C_macintosh_unknwn    : INTEGER is 192
    C_ko18_r_unknown      : INTEGER is 148
    C_iso8859_1_unknown   : INTEGER is 191
    C_iso8859_2_unknown   : INTEGER is 255
    C_iso8859_3_unknown   : INTEGER is 255
    C_iso8859_4_unknown   : INTEGER is 255
    C_iso8859_5_unknown   : INTEGER is 173
    C_iso8859_6_unknown   : INTEGER is 173
    C_iso8859_7_unknown   : INTEGER is 173
    C_iso8859_8_unknown   : INTEGER is 173
    C_iso8859_9_unknown   : INTEGER is 173
    C_iso8859_10_unknown  : INTEGER is 173
    C_ibm_437_unknown     : INTEGER is 219
    C_ibm_850_unknown     : INTEGER is 219
    C_ibm_852_unknown     : INTEGER is 219
    C_ibm_860_unknown     : INTEGER is 219
    C_ibm_863_unknown     : INTEGER is 219
    C_ibm_865_unknown     : INTEGER is 219
    C_win31_latin1_unknwn : INTEGER is 191
    C_ucs4_unknown        : INTEGER is 9608
    C_utf16_unknwn        : INTEGER is 9608
    C_utf8_unknown        : INTEGER is 9608
    C_utf7_unknown        : INTEGER is 9608
----------------------
feature { NONE}

    special_codesets : ARRAY [CODESET] is

        once
            create result.make (Special_min + 1, Special_max)
        end
----------------------

    find_codeset_info_by_id (id : INTEGER) : CODESET_INFO is

        do
            if osf_cs_registry.has (id) then
                result := osf_cs_registry.at (id)
            end
        end
----------------------

    find_codeset_info_by_pattern (pat : STRING) : CODESET_INFO is

        local
            it : ITERATOR
            e1 : ANY
            e2 : ANY

        do
            from
                it := osf_cs_registry.iterator
                e2 := pat.to_c
            until
                it.finished
            loop
                e1 := osf_cs_registry.item (it).desc.to_c
--                if fn_match ($e1, $e2) then
                if local_match (osf_cs_registry.item (it).desc, pat) then
                    it.stop
                else
                    it.forth
                end
            end
            if it.inside then
                result := osf_cs_registry.item (it)
            end
        end
----------------------

    local_match (str, pat : STRING) : BOOLEAN is
        -- This is a stop-gap measure, since mico_fnmatch
        -- doesn't seem to be working and I don't really
        -- understand it.

        local
            matcher : MATCHER
            idx     : INTEGER
            pat1    : STRING

        do
            idx := pat.index_of ('*', 1)
            if idx > 0 then
                pat1 := pat.substring (idx + 1, pat.count)
                idx  := pat1.index_of ('*', 1)
                if idx > 0 then
                    pat1 := pat1.substring (1, idx - 1)
                end
            end
            check
                no_asterisk : pat1.index_of ('*', 1) = 0
            end
            create {BM_MATCHER} matcher.make (pat1)
            matcher.set_text (str)
            matcher.first
            result := (matcher.index > 0)
        end
----------------------
feature { ANY}

    create_codeset_with_id (id : INTEGER) : CODESET is

        local
            info : CODESET_INFO

        do
            info := find_codeset_info_by_id (id)
            if info /= void then
                create result.make_with_info (info)
            end
        end
----------------------

    create_codeset_with_pattern (pat : STRING) : CODESET is

        local
            info : CODESET_INFO

        do
            info := find_codeset_info_by_pattern (pat)
            if info /= void then
                create result.make_with_info (info)
            end
        end
----------------------

    valid_codeset_id (id : INTEGER) : BOOLEAN is

        do
            result := (Special_min < id and then id <= Special_max)
        end
----------------------

    get_special_codeset (id : INTEGER) : CODESET is

        require
            valid_codeset_id : valid_codeset_id (id)

        do
            result := special_codesets.item (id)
        end
----------------------

    set_special_codeset (cs : CODESET; id : INTEGER) is

        require
            valid_codeset_id : valid_codeset_id (id)

        do
            special_codesets.put (cs, id)
        end
----------------------

    create_converter (from_cs, to_cs : CODESET) : CODESET_CONVERTER is

        require
            nonvoid_args : from_cs /= void and then to_cs /= void

        do
            if can_convert (from_cs.id, to_cs.id) then
                create {UNICODESET_CONVERTER} result.make2 (from_cs, to_cs)
            end
        end
----------------------

    can_convert (f, t : INTEGER) : BOOLEAN is

        do
            result := (supported_csid (f) and then supported_csid (t))
        end
----------------------

    supported_csid (id : INTEGER) : BOOLEAN is

        do
            result := (id = C_iso8859_1    or else
                       id = C_iso8859_2    or else
                       id = C_iso8859_3    or else
                       id = C_iso8859_4    or else
                       id = C_iso8859_5    or else
                       id = C_iso8859_6    or else
                       id = C_iso8859_7    or else
                       id = C_iso8859_8    or else
                       id = C_iso8859_9    or else
                       id = C_iso8859_10   or else
                       id = C_ibm_437      or else
                       id = C_ibm_850      or else
                       id = C_ibm_852      or else
                       id = C_ibm_860      or else
                       id = C_ibm_863      or else
                       id = C_ibm_865      or else
                       id = C_ucs4         or else
                       id = C_utf16        or else
                       id = C_utf8         or else
                       id = C_win31_latin1 or else
                       id = C_ascii7       or else
                       id = C_ebcdic       or else
                       id = C_macintosh    or else
                       id = C_ko18_r       or else
                       id = C_utf7         or else
                       id = C_html3)
        end
----------------------

    the_codeset_db : CODESET_CONVERTER_DB is

        once
            create result.make
        end
----------------------

    create_unicodeset_converter (from_cs,
                                 to_cs : CODESET) : CODESET_CONVERTER is

        do
            if unicodeset_can_convert (from_cs.id, to_cs.id) then
                create {UNICODESET_CONVERTER} result.make2 (from_cs, to_cs)
            end
        end
----------------------

    unicodeset_can_convert (from_id,
                            to_id : INTEGER) : BOOLEAN is

        do
            result := (unicode_supported_csid (from_id)
                       and then
                       unicode_supported_csid(to_id))
        end
----------------------

    unicode_supported_csid (id : INTEGER) : BOOLEAN is

        do
            inspect (id)

            when C_ascii7,
                 C_ebcdic,
                 C_macintosh,
                 C_ko18_r,
                 C_iso8859_1,
                 C_iso8859_2,
                 C_iso8859_3,
                 C_iso8859_4,
                 C_iso8859_5,
                 C_iso8859_6,
                 C_iso8859_7,
                 C_iso8859_8,
                 C_iso8859_9,
                 C_iso8859_10,
                 C_ibm_437,
                 C_ibm_850,
                 C_ibm_852,
                 C_ibm_860,
                 C_ibm_863,
                 C_ibm_865,
                 C_win31_latin1,
                 C_ucs4,
                 C_utf16,
                 C_utf8,
                 C_utf7,
                 C_html3 then
                result := true
            else
                result := false
            end
        end
----------------------

    Codeset_disabled (yes_no : BOOLEAN) : BOOLEAN is

        once
            result := yes_no
        end
----------------------
feature { NONE }

    codeset_init is

        local
            csi : CODESET_INIT

        do
            create csi.make
        end
----------------------

    fn_match (sp, pp : POINTER) : BOOLEAN is

        external "C"
        alias "MICO_fnmatch"

        end

end -- class CODESET_STATICS

------------------------------------------------------------------------
--                                                                    --
--  MICO/E --- a free CORBA implementation                            --
--  Copyright (C) 1999 by Robert Switzer                              --
--                                                                    --
--  This library is free software; you can redistribute it and/or     --
--  modify it under the terms of the GNU Library General Public       --
--  License as published by the Free Software Foundation; either      --
--  version 2 of the License, or (at your option) any later version.  --
--                                                                    --
--  This library is distributed in the hope that it will be useful,   --
--  but WITHOUT ANY WARRANTY; without even the implied warranty of    --
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU --
--  Library General Public License for more details.                  --
--                                                                    --
--  You should have received a copy of the GNU Library General Public --
--  License along with this library; if not, write to the Free        --
--  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.--
--                                                                    --
--  Send comments and/or bug reports to:                              --
--                 micoe@math.uni-goettingen.de                       --
--                                                                    --
------------------------------------------------------------------------
