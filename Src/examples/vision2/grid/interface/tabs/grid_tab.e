indexing
	description: "Objects that represent an EV_TITLED_WINDOW.%
		%The original version of this class was generated by EiffelBuild."
	date: "$Date$"
	revision: "$Revision$"

class
	GRID_TAB

inherit
	GRID_TAB_IMP
	
	GRID_ACCESSOR
		undefine
			copy, default_create, is_equal
		end
		
	PROFILING_SETTING
		undefine
			copy, default_create, is_equal
		end

feature {NONE} -- Initialization

	user_initialization is
			-- Called by `initialize'.
			-- Any custom user initialization that
			-- could not be performed in `initialize',
			-- (due to regeneration of implementation class)
			-- can be added here.
		local
			f_name: FILE_NAME
			list_item: EV_LIST_ITEM
			l_color: EV_COLOR
		do
			grid.set_dynamic_content_function (agent compute_item)
			add_color_to_combo ((create {EV_STOCK_COLORS}).red, set_background_color_combo)
			add_color_to_combo ((create {EV_STOCK_COLORS}).green, set_background_color_combo)
			add_color_to_combo ((create {EV_STOCK_COLORS}).blue, set_background_color_combo)
			add_color_to_combo ((create {EV_STOCK_COLORS}).yellow, set_background_color_combo)
			add_color_to_combo ((create {EV_STOCK_COLORS}).white, set_background_color_combo)
			
				-- Now load pixmaps for exapnd/collapse nodes.
			expand1 := grid.expand_node_pixmap
			collapse1 := grid.collapse_node_pixmap
			create f_name.make_from_string (current_working_directory)
			f_name.extend ("icon_bpenabled.png")
			create expand2
			expand2.set_with_named_file (f_name.out)
			create f_name.make_from_string (current_working_directory)
			f_name.extend ("icon_bpdisabled.png")
			create collapse2
			collapse2.set_with_named_file (f_name)
			
			create f_name.make_from_string (current_working_directory)
			f_name.extend ("large_expand.png")
			create expand3
			expand3.set_with_named_file (f_name.out)
			create f_name.make_from_string (current_working_directory)
			f_name.extend ("large_collapse.png")
			create collapse3
			collapse3.set_with_named_file (f_name)
			
			create list_item.make_with_text ("9x9")
			list_item.set_pixmap (expand1)
			subnode_pixmaps_combo.extend (list_item)
			create list_item.make_with_text ("12x12")
			list_item.set_pixmap (expand2)
			subnode_pixmaps_combo.extend (list_item)
			create list_item.make_with_text ("32x32")
			list_item.set_pixmap (expand3)
			subnode_pixmaps_combo.extend (list_item)

			add_default_colors_to_combo (foreground_color_combo)
			add_default_colors_to_combo (background_color_combo)
			background_color_combo.select_actions.block
				if grid.background_color /= Void then
					from
						background_color_combo.start
					until
						background_color_combo.off
					loop
						l_color ?= background_color_combo.item.data		
						if l_color /= Void and then l_color.is_equal (grid.background_color) then
							background_color_combo.item.enable_select
							background_color_combo.go_i_th (background_color_combo.count)
						end
						background_color_combo.forth
					end
				else
					background_color_combo.first.enable_select
				end
				background_color_combo.select_actions.resume
				foreground_color_combo.select_actions.block
				if foreground_color /= Void then
					from
						foreground_color_combo.start
					until
						foreground_color_combo.off
					loop
						l_color ?= foreground_color_combo.item.data		
						if l_color /= Void and then l_color.is_equal (grid.foreground_color) then
							foreground_color_combo.item.enable_select
							foreground_color_combo.go_i_th (foreground_color_combo.count)
						end
						foreground_color_combo.forth
					end
				else
					foreground_color_combo.first.enable_select
				end
				foreground_color_combo.select_actions.resume
		end
		
	expand1, expand2, expand3, collapse1, collapse2, collapse3: EV_PIXMAP
		-- Pixmaps used for expand/collapse nodes

feature {NONE} -- Implementation

	is_header_displayed_button_selected is
			-- Called by `select_actions' of `is_header_displayed_button'.
		do
			if is_header_displayed_button.is_selected then
				grid.show_header
			else
				grid.hide_header
			end
		end

	is_tree_enabled_button_selected is
			-- Called by `select_actions' of `is_tree_enabled_button'.
		do
			if is_tree_enabled_button.is_selected then
				grid.enable_tree
			else
				grid.disable_tree
			end
		end

	new_label_button_selected is
			-- Called by `select_actions' of `new_label_button'.
		local
			new_label_item_dialog: NEW_ITEM_DIALOG
		do
			create new_label_item_dialog
			new_label_item_dialog.show_relative_to_window (main_window)
		end
		
	is_vertical_divider_displayed_button_selected is
			-- Called by `select_actions' of `is_vertical_divider_displayed_button'.
		do
			if is_vertical_divider_displayed_button.is_selected then
				grid.enable_resizing_divider
				is_vertical_divider_dashed_button.enable_sensitive
				is_vertical_divider_solid_button.enable_sensitive
			else
				grid.disable_resizing_divider
				is_vertical_divider_dashed_button.disable_sensitive
				is_vertical_divider_solid_button.disable_sensitive
			end
		end
		
	is_vertical_divider_solid_button_selected is
			-- Called by `select_actions' of `is_vertical_divider_solid_button'.
		do
			grid.enable_solid_resizing_divider
		end
	
	is_vertical_divider_dashed_button_selected is
			-- Called by `select_actions' of `is_vertical_divider_dashed_button'.
		do
			grid.disable_solid_resizing_divider
		end
		
	is_horizontal_scrolling_per_item_selected is
			-- Called by `select_actions' of `is_horizontal_scrolling_per_item'.
		do
			if is_horizontal_scrolling_per_item.is_selected then
				grid.enable_horizontal_scrolling_per_item
			else
				grid.disable_horizontal_scrolling_per_item
			end
		end
	
	is_vertical_scrolling_per_item_selected is
			-- Called by `select_actions' of `is_vertical_scrolling_per_item'.
		do
			if is_vertical_scrolling_per_item.is_selected then
				grid.enable_vertical_scrolling_per_item
			else
				grid.disable_vertical_scrolling_per_item
			end
		end
		
	is_row_height_fixed_selected is
			-- Called by `select_actions' of `is_row_height_fixed'.
		do
			if is_row_height_fixed.is_selected then
				grid.enable_row_height_fixed
				fixed_row_height_spin_button.enable_sensitive
			else
				grid.disable_row_height_fixed
				fixed_row_height_spin_button.disable_sensitive
			end
		end
	
	fixed_row_height_spin_button_changed (a_value: INTEGER) is
			-- Called by `change_actions' of `fixed_row_height_spin_button'.
		do
			grid.set_row_height (a_value)
		end
		
	is_partially_dynamic_selected is
			-- Called by `select_actions' of `is_partically_dynamic'.
		do
			if is_partially_dynamic.is_selected then
				grid.enable_partial_dynamic_content
				resize_rows_columns_box.enable_sensitive
				is_completely_dynamic.select_actions.block
				is_completely_dynamic.disable_select
				is_completely_dynamic.select_actions.resume
			else
				if not is_completely_dynamic.is_selected then
					resize_rows_columns_box.disable_sensitive
					grid.disable_dynamic_content
				end
			end
		end
	
	is_completely_dynamic_selected is
			-- Called by `select_actions' of `is_completely_dynamic'.
		do
			if is_completely_dynamic.is_selected then
				grid.enable_complete_dynamic_content
				resize_rows_columns_box.enable_sensitive
				is_partially_dynamic.select_actions.block
				is_partially_dynamic.disable_select
				is_partially_dynamic.select_actions.resume
			else
				if not is_partially_dynamic.is_selected then
					resize_rows_columns_box.disable_sensitive
					grid.disable_dynamic_content
				end
			end
		end

	resize_columns_to_button_selected is
			-- Called by `select_actions' of `resize_columns_to_button'.
		do
			if resize_columns_to_button.is_selected then
				resize_columns_to_entry.enable_sensitive
				resize_columns_to_entry.change_actions.call ([resize_columns_to_entry.value])
			else
				resize_columns_to_entry.disable_sensitive
			end
		end
	
	resize_columns_to_entry_selected (a_value: INTEGER) is
			-- Called by `change_actions' of `resize_columns_to_entry'.
		do
			grid.set_column_count_to (a_value)
		end
		
	resize_row_to_button_selected is
			-- Called by `select_actions' of `resize_rows_to_button'.
		do
			if resize_rows_to_button.is_selected then
				resize_rows_to_entry.enable_sensitive
				resize_rows_to_entry.change_actions.call ([resize_rows_to_entry.value])
			else
				resize_rows_to_entry.disable_sensitive
			end
		end
	
	resize_rows_to_entry_changed (a_value: INTEGER) is
			-- Called by `change_actions' of `resize_rows_to_entry'.
		do
			grid.set_row_count_to (a_value)
		end
		
	add_items (an_xcount, a_ycount: INTEGER) is
			--
		local
			l_ycount, l_xcount: INTEGER
			grid_label_item: EV_GRID_COMBO_ITEM -- EDITABLE_ITEM
		do
			from
				l_ycount := 1
			until
				l_ycount > a_ycount
			loop
				from
					l_xcount := 1
				until
					l_xcount > an_xcount
				loop
					create grid_label_item
					grid_label_item.set_text ("Item" + " " + l_xcount.out + ", " + l_ycount.out)
					grid.set_item (l_xcount, l_ycount, grid_label_item)
					l_xcount := l_xcount + 1
				end
				l_ycount := l_ycount + 1
			end
		end
		
		
	misc_button_selected is
			-- Called by `select_actions' of `misc_button'.
		local
			counter: INTEGER
			counter2: INTEGER
			time1, time2: DATE_TIME
			grid_label_item: EV_GRID_LABEL_ITEM
			grid_editable_item: EV_GRID_EDITABLE_ITEM
			grid_combo_item: EV_GRID_COMBO_ITEM
			current_row: EV_GRID_ROW
			font: EV_FONT
		do
			if profile_cell.item then
				start_profiling
			end
			create time1.make_now
			add_items (5, 400)			
			grid.column (1).set_title ("One")
			grid.column (2).set_title ("Two")
			grid.column (3).set_title ("Three")
			grid.column (4).set_title ("Four")
			grid.column (5).set_title ("Five")
			grid.enable_tree
			grid.row (1).add_subrow (grid.row (2))
			grid.row (1).add_subrow (grid.row (3))
			grid.row (3).add_subrow (grid.row (4))
			grid.row (4).add_subrow (grid.row (5))
			grid.row (5).add_subrow (grid.row (6))
			grid.row (6).add_subrow (grid.row (7))
			grid.row (7).add_subrow (grid.row (8))
			grid.row (8).add_subrow (grid.row (9))
			grid.row (9).add_subrow (grid.row (10))
			from
				counter := 11
			until
				counter > 26
			loop
				grid.row (1).add_subrow (grid.row (counter))
				counter := counter + 1
			end
			from
				counter := 27
			until
				counter > 31
			loop
				grid.row (counter - 1).add_subrow (grid.row (counter))
				counter := counter + 1
			end

			from
				counter := 50
			until
				counter = 100
			loop
				grid.row (counter).add_subrow (grid.row (counter + 1))
				counter := counter + 1
			end
			grid.insert_new_row (110)
			grid.set_item (3, 110, create {EV_GRID_LABEL_ITEM}.make_with_text ("Deep subnode"))
			grid.row (109).add_subrow (grid.row (110))
			
			from
				counter := 111
			until
				counter = 113
			loop
				grid.insert_new_row (counter)
				grid.set_item (3, counter, create {EV_GRID_LABEL_ITEM}.make_with_text ("Subnode"))
				grid.row (counter - 1).add_subrow (grid.row (counter))
				counter := counter + 1
			end
			from
				counter := 113
			until
				counter = 121
			loop
				grid.remove_item (1, counter)
				grid.remove_item (2, counter)
				grid.remove_item (3, counter)
				grid.remove_item (4, counter)
				grid.set_item (5, counter, create {EV_GRID_LABEL_ITEM}.make_with_text ("Subnode"))
				grid.row (112).add_subrow (grid.row (counter))
				counter := counter + 1
			end
			grid.remove_item (1, 121)
			grid.remove_item (2, 121)
			grid.row (112).add_subrow (grid.row (121))
			from
				counter := 122
			until
				counter = 128
			loop
				grid.remove_item (1, counter)
				grid.remove_item (2, counter)
				grid.remove_item (3, counter)
				grid.set_item (3, counter, create {EV_GRID_LABEL_ITEM}.make_with_text ("Subnode"))
				grid.row (counter - 1).add_subrow (grid.row (counter))
				counter := counter + 1
			end
			
			fixme ("Uncomment this code and replace that just above to show a redrawing bug.")
--			from
--				counter := 121
--			until
--				counter = 128
--			loop
--				grid.remove_item (1, counter)
--				grid.remove_item (2, counter)
--				grid.set_item (3, counter, create {EV_GRID_LABEL_ITEM}.make_with_text ("Subnode"))
--				grid.row (110).add_subrow (grid.row (counter))
--				counter := counter + 1
--			end

			
			from
				counter := 150
			until
				counter > 155
			loop
				grid.insert_new_row (counter + 1)
				grid.set_item (1, counter + 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Subnode"))
				grid.row (150).add_subrow (grid.row (counter + 1))
				
				counter := counter + 1
			end
			
				-- Now perform a heavy test of the vertical tree lines.
			from
				counter := 160
			until
				counter = 259
			loop
				grid.row (counter).add_subrow (grid.row (counter + 1))
				counter := counter + 1
			end
			from
				counter := 259
				counter2 := 259
			until
				counter = 359
			loop
				grid.row (counter2).add_subrow (grid.row (counter + 1))
				counter := counter + 1
				counter2 := counter2 - 1
			end
			create time2.make_now
			set_status_message (("Items added in : " + ((time2.fine_second - time1.fine_second).out)))

			grid.disable_row_height_fixed
			grid.row (3).set_height (100)


			grid.row (32).clear
			grid.row (32).set_item (1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Expand Me"))
			grid.row (32).add_subrow (grid.row (33))
			grid.row (33).clear
			grid.row (33).set_item (1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Move Over Me"))
			grid_label_item ?=  grid.row (33).item (1)
			grid_label_item.set_pixmap (image5)
			grid.row (33).set_height (100)
			grid.column (1).set_width (200)
			grid.pointer_motion_item_actions.extend (agent motion_on_grid)
			grid.row (34).clear
			grid.row (34).set_item (1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Show Editable Items"))
			grid.row (34).add_subrow (grid.row (35))
			grid.row (35).clear
			from
				counter := 1
			until
				counter > 5
			loop
				create grid_editable_item.make_with_text ("Edit Me")
				if counter > 1 then
					grid_editable_item.set_pixmap (image3)
				end
				grid.row (35).set_item (counter, grid_editable_item)
				counter := counter + 1
			end
			grid.row (36).clear
			grid.row (36).set_item (1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Show Editable Combo Items"))
			grid.row (36).add_subrow (grid.row (37))
			grid.row (37).clear
			from
				counter := 1
			until
				counter > 5
			loop
				create grid_combo_item.make_with_text ("Edit Me")
				if counter > 1 then
					grid_combo_item.set_pixmap (image3)
				end
				grid.row (37).set_item (counter, grid_combo_item)
				counter := counter + 1
			end
			grid.pointer_double_press_item_actions.extend (agent pointer_double_press_received_on_grid)
			current_row := grid.row (38)
			current_row.clear
			current_row.set_item (1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Show Font Sizes"))
			from
				counter := 1
			until
				counter = 16
			loop
				current_row.insert_subrow (counter)
				create grid_label_item.make_with_text ("Font Height : " + ((counter + 3) * 2).out)
				current_row.subrow (counter).set_item (1, grid_label_item)
				create font
				font.set_height ((counter + 3) * 2)
				grid_label_item.set_font (font)
				current_row.subrow (counter).set_height (grid_label_item.text_height)
				counter := counter + 1
			end






--			from
--				counter := 1
--			until
--				counter > grid.row_count
--			loop
--				grid_label_item ?= grid.item (1, counter)
--				if grid_label_item /= Void then
--					grid_label_item.set_background_color (light_red)
--				end
--				counter := counter + 1				
--			end
			grid.column (1).set_background_color (light_red)
			from
				counter := 1
			until
				counter > grid.row_count
			loop
				grid_label_item ?= grid.item (1, counter)
				if grid_label_item /= Void then
					grid_label_item.set_pixmap (image1)
				end

				grid_label_item ?= grid.item (4, counter)
				if grid_label_item /= Void then
					grid_label_item.set_pixmap (image2)
				end
				counter := counter + 1
			end
			if profile_cell.item then
				stop_profiling
			end
		end

	pointer_double_press_received_on_grid (an_x, a_y, button: INTEGER; grid_item: EV_GRID_ITEM) is
			--
		local
			editable_item: EV_GRID_EDITABLE_ITEM
			combo_item: EV_GRID_COMBO_ITEM
		do
			editable_item ?= grid_item
			if editable_item /= Void then
				editable_item.activate
			end
			combo_item ?= grid_item
			if combo_item /= Void then
				combo_item.activate
			end
		end
		

	animate is
			--
		local
			label_item: EV_GRID_LABEL_ITEM
		do
			label_item ?= grid.item (1, 33)
			if x < 0 or x > label_item.column.width - label_item.text_width - label_item.pixmap.width - label_item.spacing - label_item.horizontal_indent - x_vel  then
				x_vel := 0 - x_vel
			end
			if y < 0 or y > label_item.row.height - label_item.text_height - y_vel- label_item.pixmap.height then
				y_vel := 0 - y_vel
			end
			x := x + x_vel
			y := y + y_vel
			if y_vel > 0 then
				y_vel := y_vel - 0.04
			else
				y_vel := y_vel + 0.04
			end
			if x_vel > 0 then
				x_vel := x_vel - 0.04
			else
				x_vel := x_vel + 0.04
			end
			if x_vel.abs < 0.04 and y_vel.abs < 0.04 then
				animating := False
				animation_timer.destroy
				redraw_timer.destroy
			end
		end

	redraw is
			--
		do
			grid.item (1, 33).redraw
		end

	layout_procedure (an_item: EV_GRID_LABEL_ITEM; layout: EV_GRID_LABEL_ITEM_LAYOUT) is
			--
		do
			layout.set_pixmap_x (x.truncated_to_integer + an_item.text_width // 2 - an_item.pixmap.width // 2)
			layout.set_pixmap_y (y.truncated_to_integer)
			layout.set_text_x (x.truncated_to_integer)
			layout.set_text_y (y.truncated_to_integer + an_item.pixmap.height)
		end
		

	x, y: REAL

	x_vel, y_vel: REAL

	animating: BOOLEAN
		

	start_animation is
			--
		do
			create animation_timer.make_with_interval (10)
			animation_timer.actions.extend (agent animate)
			create redraw_timer.make_with_interval (20)
			redraw_timer.actions.extend (agent redraw)
			x_vel := 6
			y_vel := 8
			animating := True
		end
		
	animation_timer, redraw_timer: EV_TIMEOUT

	motion_on_grid (an_x, a_y: INTEGER; an_item: EV_GRID_ITEM) is
			--
		local
			label_item: EV_GRID_LABEL_ITEM
		do
			if an_item /= Void and then an_item.row.index = 33 and an_item.column.index = 1 and not animating then
				label_item ?= an_item
				label_item.set_layout_procedure (agent layout_procedure)
				start_animation
			end
		end
		
	compute_item (an_x, a_y: INTEGER): EV_GRID_ITEM is
			--
		local
			drawable_item: EV_DRAWABLE_GRID_ITEM
		do
			if an_x = 2 then
				do_nothing
			end
			if a_y \\ 2 = 1 then
				create {EV_GRID_LABEL_ITEM} Result.make_with_text ("Item at position : " + an_x.out + ", " + a_y.out)
			else
				create drawable_item
				drawable_item.expose_actions.extend (agent draw_grid_item (?, ?, ?, ?, ?, drawable_item))
				Result := drawable_item
			end
		end
		
	draw_grid_item (an_x, a_y, a_width, a_height: INTEGER; drawable: EV_DRAWABLE; an_item: EV_DRAWABLE_GRID_ITEM) is
			--
		local
			back_color: EV_COLOR
		do
			if back_color = Void then
				back_color := grid.background_color
			end
			drawable.set_foreground_color (back_color)
			drawable.fill_rectangle (an_x, a_y, a_width, a_height)
			drawable.set_foreground_color (create {EV_COLOR}.make_with_8_bit_rgb (((a_y + an_x).abs // 8) \\ 255, ((a_y + an_x).abs // 8) \\ 255, ((a_y + an_x).abs // 8) \\ 255))
			drawable.fill_ellipse (an_x, a_y, a_width, a_height)
		end
		
	set_selected_row_as_subnode_button_selected is
			-- Called by `select_actions' of `set_selected_row_as_subnode_button'.
		local
			selected_items: ARRAYED_LIST [EV_GRID_ITEM]
			selected_rows: ARRAYED_LIST [EV_GRID_ROW]
			current_row: EV_GRID_ROW
		do
			if grid.is_multiple_item_selection_enabled then
				selected_items := grid.selected_items
			else
				selected_rows := grid.selected_rows
				from
					selected_rows.start
				until
					selected_rows.off
				loop
					current_row := selected_rows.item
					grid.row (current_row.index - 1).add_subrow (current_row)
					selected_rows.forth
				end
			end
		end

	subrow_indent_button_changed (a_value: INTEGER) is
			-- Called by `change_actions' of `subrow_indent_button'.
		do
			grid.set_subrow_indent (a_value)
		end
		
	set_background_color_button_selected is
			-- Called by `select_actions' of `set_background_color_button'.
		do
		end
	
	set_background_color_combo_selected is
			-- Called by `select_actions' of `set_background_color_combo'.
		local
			selected_items: ARRAYED_LIST [EV_GRID_ITEM]
			color: EV_COLOR
		do
			color ?= set_background_color_combo.selected_item.data
			if set_tree_node_connector_button.is_selected then
				grid.set_tree_node_connector_color (color)
			elseif set_background_of_selection_button.is_selected then
				selected_items := grid.selected_items
				if not selected_items.is_empty then
					from
						selected_items.start
					until
						selected_items.off
					loop
						selected_items.item.set_background_color (color)
						selected_items.forth
					end
				end
			end
		end
		
	subnode_pixmaps_combo_selected is
			-- Called by `select_actions' of `subnode_pixmaps_combo'.
		local
			l_index: INTEGER
		do
			l_index := subnode_pixmaps_combo.index_of (subnode_pixmaps_combo.selected_item, 1)
			if l_index = 1 then
				grid.set_node_pixmaps (expand1, collapse1)
			elseif l_index = 2 then
				grid.set_node_pixmaps (expand2, collapse2)
			elseif l_index = 3 then
				grid.set_node_pixmaps (expand3, collapse3)
			end
		end
		
	expand_all_button_selected is
			-- Called by `select_actions' of `expand_all_button'.
		local
			counter: INTEGER
			current_row: EV_GRID_ROW
		do
			from
				counter := 1
			until
				counter > grid.row_count
			loop
				current_row := grid.row (counter)
				if current_row.subrow_count > 0 then
					current_row.expand			
				end
				counter := counter + 1
			end
		end
	
	collapse_all_button_selected is
			-- Called by `select_actions' of `collapse_all_button'.
		local
			counter: INTEGER
			current_row: EV_GRID_ROW
		do
			from
				counter := 1
			until
				counter > grid.row_count
			loop
				current_row := grid.row (counter)
				if current_row.subrow_count > 0 then
					current_row.collapse			
				end
				counter := counter + 1
			end
		end
		
	tree_lines_enabled_selected is
			-- Called by `select_actions' of `tree_lines_enabled'.
		do
			if tree_lines_enabled.is_selected then
				grid.show_tree_node_connectors
			else
				grid.hide_tree_node_connectors
			end
		end
		
	custom_button_selected is
			-- Called by `select_actions' of `custom_button'.
		local
			l_item: EV_GRID_ITEM
			r, row: EV_GRID_ROW
			grid_label_item: EV_GRID_LABEL_ITEM
			counter: INTEGER
		do
--			l_item := grid.item_at_virtual_position (200, 16)
--			misc_button_selected
--			grid.column (3).set_width (200)
--			grid.column (4).set_width (200)
--			grid.enable_horizontal_scrolling_per_item

--			grid.enable_tree
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			grid.set_item (1, 2, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			grid.set_item (2, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			grid.set_item (2, 2, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			r := grid.row (grid.row_count)
--			grid.insert_new_row (r.index + 1)
--            row := grid.row (r.index + 1)
--			r.add_subrow (row)            
--                -- and then create the item
--            create grid_label_item
--            grid_label_item.set_text ("POP")
--            row.set_item (1, grid_label_item)


--			grid.insert_new_row (r.index + 2)
			
--			r.add_subrow (row)  
--			grid.enable_tree
--			grid.set_item (8, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Sub Sub row"))
--			grid.set_item (1, 2, create {EV_GRID_LABEL_ITEM}.make_with_text ("Parent Row"))
--			grid.set_item (4, 3, create {EV_GRID_LABEL_ITEM}.make_with_text ("Sub row"))
--			grid.set_item (8, 4, create {EV_GRID_LABEL_ITEM}.make_with_text ("Sub Sub row"))
--			grid.row (2).add_subrow (grid.row (3))
--			grid.row (3).add_subrow (grid.row (4))
--			grid.row (4).set_item (5, create {EV_GRID_LABEL_ITEM}.make_with_text ("New item"))
--			grid.row (4).set_item (4, create {EV_GRID_LABEL_ITEM}.make_with_text ("New item"))
----			grid.set_item (4, 4, create {EV_GRID_LABEL_ITEM}.make_with_text ("New item"))
--			grid.row (4).set_item (4, create {EV_GRID_LABEL_ITEM}.make_with_text ("New item"))
--			--grid.column (3).set_item (4, create {EV_GRID_LABEL_ITEM}.make_with_text ("New item"))
--			grid.column (4).set_item (4, create {EV_GRID_LABEL_ITEM}.make_with_text ("New item"))


--			-- Test 3
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Top level 1"))
--			from
--				counter := 2
--			until
--				counter > 5
--			loop
--				grid.set_item (1, counter, create {EV_GRID_LABEL_ITEM}.make_with_text ("Sub row " + counter.out))
--				grid.row (counter - 1).add_subrow (grid.row (counter))
--				counter := counter + 1
--			end
--			grid.set_item (1, 6, create {EV_GRID_LABEL_ITEM}.make_with_text ("New Row 6"))
--			grid.set_item (2, 6, create {EV_GRID_LABEL_ITEM}.make_with_text ("New Row 6"))
--			grid.remove_row (5)

			--Test 4
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Top level 1"))
--			grid.row (1).ensure_expandable
--			grid.row_expand_actions.extend (agent expand_row)


--			-- Test 5
--				grid.enable_tree
--            grid.enable_partial_dynamic_content
--            grid.set_column_count_to (3)
--            grid.set_dynamic_content_function (agent compute_grid_item (grid, ?, ?))
--            grid.set_row_count_to (10)

--			-- Test 6
--			grid.enable_tree
--            grid.enable_partial_dynamic_content
--            grid.set_column_count_to (3)
--            grid.set_dynamic_content_function (agent compute_grid_item (grid, ?, ?))
--            grid.set_row_count_to (1)
--            create grid_label_item.make_with_text ("Root dynamic node")
--            grid.set_item (1, 1, grid_label_item)
--			grid.row (1).ensure_expandable
--            grid.row_expand_actions.extend (agent add_subrows)


--			-- Test 7
--			grid.enable_tree
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Top level 1"))

			-- Test 8
--			grid.enable_tree
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Top level 1"))
--			grid.set_item (1, 2, create {EV_GRID_LABEL_ITEM}.make_with_text ("Subrow"))
--			grid.row (1).add_subrow (grid.row (2))
--			grid.row (1).ensure_expandable

--			-- Test 9
--			grid.enable_tree
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Top level 1"))
--			grid.set_item (3, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Top level 1"))
--			grid.insert_new_row_parented (2, grid.row (1))

			-- Test 9
--			create grid_label_item
--			grid_label_item.set_text ("A text")

			-- Test 10
--			grid.enable_tree
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Top level 1"))
--			grid.set_item (3, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Top level 1"))
--			grid.insert_new_row_parented (2, grid.row (1))

			-- Test 11
--			add_items (10, 10)
--			grid.set_item (3, 3, Void)
--			grid.column (5).set_item (5, Void)
--			grid.row (7).set_item (7, Void)
--			grid.row (7).clear
--			grid.column (5).clear
--			grid.clear

--			-- Test 12
--			add_items (10, 10)
--			grid.insert_new_row_parented (6, grid.row (5))
--			grid.row (6).set_item (3, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			grid.row (6).insert_subrow (1)
--			grid.row (6).subrow (1).set_item (3, create {EV_GRID_LABEL_ITEM}.make_with_text ("Second item"))
--			grid.row (6).insert_subrow (1)
--			grid.row (6).subrow (1).set_item (3, create {EV_GRID_LABEL_ITEM}.make_with_text ("First item"))
--			grid.row (6).insert_subrow (3)
--			grid.row (6).subrow (3).set_item (3, create {EV_GRID_LABEL_ITEM}.make_with_text ("Third item"))
--			grid.row (6).insert_subrow (4)
--			grid.row (6).subrow (4).set_item (3, create {EV_GRID_LABEL_ITEM}.make_with_text ("Fourth item"))
--			grid.row (6).insert_subrow (1)
--			grid.row (6).subrow (1).set_item (3, create {EV_GRID_LABEL_ITEM}.make_with_text ("Sneaky Final first item"))
--			grid.row (6).subrow (1).ensure_expandable
--			grid.row_expand_actions.extend (agent expand_row2)

--			-- Test 13
--			grid_label_item ?= grid.item (1, 102)
--			from
--				counter := 1
--			until
--				counter > 10000
--			loop
--				grid_label_item.set_text (counter.out)
--				((create {EV_ENVIRONMENT}).application).process_events
--				counter := counter + 1
--			end

--			-- Test 14
--			add_items (10, 10)
--			grid.enable_single_row_selection
--			grid.row (5).enable_select
--			from
--			until
--				grid.row_count = 0
--			loop
--				grid.remove_row (grid.row_count)
--			end

			-- Test 15
--			create grid_label_item.make_with_text ("A text")
--			GRID.set_item (1, 1, grid_label_item)
--			GRID.set_row_height (50)
--			GRID.column (1).set_width (50)
--			grid.pointer_motion_actions.extend (agent motion_on_item)
--			grid_label_item.set_layout_procedure (agent layout_called)

			-- Test 16
--			grid.enable_tree
--			clean_grid
--			fill_grid
--			clean_grid
--			fill_grid

--			-- Test 17
--			grid.enable_tree
--			grid.insert_new_row (1)
--			grid.insert_new_row (2)
--			grid.row ((2)).insert_subrow (1)
--
--			GRID.ROW (1).SET_DATA (1)
--			GRID.ROW (2).SET_DATA (2)
--			GRID.ROW (3).SET_DATA (3)
----			grid.row ((2)).insert_subrow (2)
--			from
--			until
--				grid.row_count = 0
--			loop
--				grid.remove_row (1)
--			end

			-- Test 18
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			grid.set_item (2, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			grid.remove_row (1)
--			grid.remove_column (2)
--			grid.remove_column (1)
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			grid.insert_new_row (1)
--			grid.insert_new_row (2)
--			print (grid.row_count)
--			row := grid.row (2)
			grid.enable_partial_dynamic_content
			grid.set_column_count_to (3)
			end

	clean_grid is
		do
			from
			until
				grid.row_count = 0
			loop
				grid.remove_row (1)
			end
		ensure
			grid.row_count = 0
		end
		

	fill_grid is
		do
			add_row (1)
			add_row (2)
			add_subrow (grid.row ((2)), 1)
			add_subrow (grid.row ((2)), 2)
			grid.row (2).expand
			add_row (5)
			grid.row (3).enable_select
		end

	add_subrow (r: EV_GRID_ROW; i: INTEGER) is
		local
		do
			r.insert_subrow (i)
			grid.set_item (1, r.index + i, label ((1).out + ":" + (r.index + i).out))
			grid.set_item (2, r.index + i, label ((2).out + ":" + (r.index + i).out))		
			grid.set_item (3, r.index + i, label ((3).out + ":" + (r.index + i).out))			
		end

	add_row (r: INTEGER) is
		do
			grid.insert_new_row (r)
			grid.set_item (1, r, label ((1).out + ":" + r.out))
			grid.set_item (2, r, label ((2).out + ":" + r.out))		
			grid.set_item (3, r, label ((3).out + ":" + r.out))			
		end
	
	label (s: STRING): EV_GRID_LABEL_ITEM is
		do
			create Result.make_with_text (s)
		end

	layout_called (an_item: EV_GRID_LABEL_ITEM; label_item_layout: EV_GRID_LABEL_ITEM_LAYOUT) is
			--
		do
			ii := ii + 1
			if ii > an_item.width then
				ii := 0
			end
			label_item_layout.set_text_x (ii)
		end
		
	ii: INTEGER

	expand_row2 (a_row: EV_GRID_ROW) is
			--
		local
			counter: INTEGER
		do
			if a_row.index = 7 then
				from
					counter := 1
				until
					counter = 100
				loop
					grid.row (7).insert_subrow (1)
					grid.row (7).subrow (1).set_item (3, create {EV_GRID_LABEL_ITEM}.make_with_text ("counter " + counter.out))
					counter := counter + 1
				end
			end
		end
		
		
	add_subrows (a_row: EV_GRID_ROW) is
			--
		local
			counter: INTEGER
		do
			from
				counter := 1
			until
				counter > 200
			loop
				grid.insert_new_row_parented (a_row.index + a_row.subrow_count + 1, a_row)
				counter := counter + 1
			end
		end
		
		
	compute_grid_item (g: EV_GRID; c,r: INTEGER): EV_GRID_ITEM is
		local
			label_item: EV_GRID_LABEL_ITEM
			time: DATE_TIME
	    do
	    	create time.make_now
	 		create label_item.make_with_text (time.out)
	    	Result := label_item
	    end

		
	expand_row (a_row: EV_GRID_ROW) is
			--
		local
			counter: INTEGER
			l_item: EV_GRID_LABEL_ITEM
			new_row: EV_GRID_ROW
		do
			if a_row.subrow_count = 0 then
				from
					counter := 1
				until
					counter > 20
				loop
					create l_item.make_with_text ("Item " + counter.out)
					grid.insert_new_row_parented (a_row.index + a_row.subrow_count + 1, a_row)
					new_row := grid.row (a_row.index + a_row.subrow_count)
					new_row.set_item (1, l_item)
					new_row.ensure_expandable
					counter := counter + 1
				end
			end
		end
		
		
	draw_tree_check_button_selected is
			-- Called by `select_actions' of `draw_tree_check_button'.
		do
			if draw_tree_check_button.is_selected then
				grid.disable_selection_on_click
				grid.pointer_motion_item_actions.wipe_out
				grid.pointer_button_press_item_actions.wipe_out
				grid.pointer_button_release_item_actions.wipe_out
				grid.pointer_button_press_item_actions.extend (agent draw_tree_item_press)
				grid.pointer_button_release_item_actions.extend (agent draw_tree_item_release)
				grid.pointer_motion_item_actions.extend (agent draw_tree_item_motion)
			else
				grid.enable_selection_on_click
				grid.pointer_motion_item_actions.wipe_out
				grid.pointer_button_press_item_actions.wipe_out
				grid.pointer_button_release_item_actions.wipe_out
			end
		end
		
	offsets: ARRAY [INTEGER]	
	
	start_x, start_y: INTEGER
	
	start_item: EV_GRID_ITEM
	
	max_set: INTEGER
		
	draw_tree_item_press (an_x, a_y, button: INTEGER; an_item: EV_GRID_ITEM) is
			--
		do
			if button = 1 and an_item /= Void then
				create offsets.make (1, 100)
				start_x := an_x
				start_y := a_y
				start_item := an_item
				max_set := 0
			else
				start_item := Void
			end
		end
		
		
	draw_tree_item_release (an_x, a_y, button: INTEGER; an_item: EV_GRID_ITEM) is
			--
		local
			counter: INTEGER
			current_indent: INTEGER
			previous_indent: INTEGER
			new_row: EV_GRID_ROW
			parent_row: EV_GRID_ROW
			column_to_check: INTEGER
			column_counter: INTEGER
			total_column_indent: INTEGER
			row_counter: INTEGER
			i: INTEGER
			j: INTEGER
			found: BOOLEAN
			new_row_index: INTEGER
		do
			if button = 1 then

				previous_indent := 0
				from
					counter := 1
				until
					counter > max_set
				loop
					
					current_indent := offsets.item (counter) - start_x
					if offsets.item (counter) = 360 then
						do_nothing
					end

				--	grid.insert_new_row (start_item.row.index + counter)
				--	new_row := grid.row (start_item.row.index + counter)
					new_row_index := start_item.row.index + counter
					
					current_indent := current_indent.max (0)
					parent_row := Void
					column_to_check := start_item.column.index
					total_column_indent := 0
					from
						column_counter := column_to_check
					until
						column_counter > grid.column_count or total_column_indent > current_indent
					loop
						if current_indent > total_column_indent then
							column_to_check := column_counter
						end						
						total_column_indent := total_column_indent + grid.column (column_counter).width
						column_counter := column_counter + 1
					end
					i := 0
					from
						j := 1
					until
						j = column_to_check
					loop
						i := i + grid.column (j).width
						j := j + 1
					end
					found := False
					if parent_row = Void then		
						from
							row_counter := new_row_index - 1
						until
							found or row_counter = start_item.row.index
						loop
							if (grid.item (column_to_check, row_counter) /= Void and grid.row (row_counter).index + grid.row (row_counter).subrow_count_recursive + 1 = new_row_index) then
								if (grid.item (column_to_check, row_counter)).horizontal_indent <= offsets.item (counter) - i then--current_indent then
									--parent_row := grid.row (counter2)
									found := True
								end						
							end
							if not found then
								row_counter := row_counter - 1
							end
						end
						parent_row := grid.row (row_counter)
					end
					
					
					
--					i < row_count and row (i - 1).parent_row_root /= Void and row (i).parent_row_root /= Void implies row (i - 1).parent_row_root /= row (i).parent_row_root
--					grid.insert_new_row (start_item.row.index + counter)
					grid.insert_new_row_parented (new_row_index, parent_row)
					new_row := grid.row (start_item.row.index + counter)
					grid.set_item (column_to_check, new_row_index, create {EV_GRID_LABEL_ITEM}.make_with_text (offsets.item (counter).out))
--					parent_row.add_subrow (new_row)
					if not parent_row.is_expanded then
						parent_row.expand
					end
					counter := counter + 1
					previous_indent := current_indent
				end
				start_item := Void
				draw_tree_check_button.disable_select
			end
		end
		
		
	draw_tree_item_motion (an_x, a_y: INTEGER; an_item: EV_GRID_ITEM) is
			--
		local
			distance_down: INTEGER
			item_index: INTEGER
		do
			if start_item /= Void then
				distance_down := a_y - start_item.virtual_y_position
				item_index := (distance_down // 16) + 1
				if item_index >= offsets.count or else offsets @ item_index < an_x then
					offsets.force (an_x, item_index)
					max_set := item_index.max (item_index)
				end
			end
		end
		
	red: EV_COLOR is
			--
		once
			Result := (create {EV_STOCK_COLORS}).red
		end
		
	enable_pick_and_drop_button_selected is
			-- Called by `select_actions' of `enable_pick_and_drop_button'.
		do
			if enable_pick_and_drop_button.is_selected then
					-- Enable grid item PND
				grid.set_item_pebble_function (agent item_pebble_function)
				grid.set_item_veto_pebble_function (agent item_veto_pebble_function)
				grid.item_drop_actions.extend (agent item_drop_actions)				
			else
					-- Disable grid item PND
				grid.set_item_pebble_function (Void)
				grid.set_item_veto_pebble_function (Void)
				grid.item_drop_actions.wipe_out
			end
		end

	item_pebble_function (a_item: EV_GRID_ITEM): ANY is
			-- Return the text of `a_item' as pebble for Pick And Drop if `a_item' is an EV_GRID_LABEL_ITEM .
		local
			lab_item: EV_GRID_LABEL_ITEM
		do
			lab_item ?= a_item
			if lab_item /= Void then
				Result := lab_item.text
			end
		end

	item_veto_pebble_function (a_item: EV_GRID_ITEM; a_pebble: ANY): BOOLEAN is
			-- Only allow drops on EV_GRID_LABEL_ITEMS.
		local
			lab_item: EV_GRID_LABEL_ITEM
		do
			lab_item ?= a_item
			Result := lab_item /= Void
		end

	item_drop_actions (a_item: EV_GRID_LABEL_ITEM; a_pebble: STRING) is
			-- Set the text to `a_pebble'  if indeed `a_item' is an EV_GRID_ITEM
		do
			if a_item /= Void then
				a_item.set_text (a_pebble)
			end
		end

	icon_view_button_selected is
			-- Called by `select_actions' of `icon_view_button'.
		local
			a_x, a_y: INTEGER
			grid_label_item: EV_GRID_EDITABLE_ITEM--LABEL_ITEM
			pixmaps: ARRAYED_LIST [EV_PIXMAP]
			stock_pixmaps: EV_STOCK_PIXMAPS
		do
			create pixmaps.make (4)
			create stock_pixmaps
			pixmaps.extend (stock_pixmaps.error_pixmap.twin)
			pixmaps.extend (stock_pixmaps.information_pixmap.twin)
			pixmaps.extend (stock_pixmaps.question_pixmap.twin)
			pixmaps.extend (stock_pixmaps.warning_pixmap.twin)
			from
				pixmaps.start
			until
				grid.row_count = 0
			loop
				grid.remove_row (grid.row_count)
			end
			from
			until
				grid.column_count = 0
			loop
				grid.remove_column (grid.column_count)
			end
			grid.hide_header
			from
				a_x := 1
			until
				a_x > 5
			loop
				from	
					a_y :=1
				until
					a_y > 200
				loop
					create grid_label_item.make_with_text ("Item " + a_x.out + ",  " + a_y.out)
					grid_label_item.set_pixmap (pixmaps.item)
					grid_label_item.disable_full_select
					grid_label_item.set_layout_procedure (agent icon_item_layout)
					grid.set_item (a_x, a_y, grid_label_item)
					pixmaps.forth
					if pixmaps.off then
						pixmaps.start
					end
					a_y := a_y + 1
				end
				a_x := a_x + 1
			end
			grid.set_row_height (grid.column (1).width)
			grid.pointer_double_press_item_actions.extend (agent pointer_double_press_received_on_grid)
			grid.resize_actions.force_extend (agent move_items)
		end

	icon_item_layout (an_item: EV_GRID_LABEL_ITEM; layout: EV_GRID_LABEL_ITEM_LAYOUT) is
			--
		local
			total_heights: INTEGER
		do
			total_heights := an_item.pixmap.height + an_item.text_height + an_item.spacing
			layout.set_pixmap_x ((an_item.width - an_item.pixmap.width) // 2)
			layout.set_pixmap_y ((an_item.height - total_heights) // 2)
			layout.set_text_x ((an_item.width - an_item.text_width) // 2)
			layout.set_text_y (layout.pixmap_y + an_item.pixmap.height + an_item.spacing)
		end

	move_items is
			--
		local
			l_width: INTEGER
			an_x, a_y: INTEGER
			items: ARRAYED_LIST [EV_GRID_ITEM]
		do
			create items.make (10)
			l_width := grid.width
			from
				an_x := 1
			until
				an_x > grid.row_count
			loop
				from
					a_y := 1
				until
					a_y > grid.column_count
				loop
					if grid.item (a_y, an_x) /= Void then
						items.extend (grid.item (a_y, an_x))
						grid.set_item (a_y, an_x, Void)
					end
					a_y := a_y + 1
				end
				an_x := an_x + 1
			end
			an_x := 1
			a_y := 1
			from
				items.start
			until
				items.off
			loop
				grid.set_item (an_x, a_y, items.item)
				an_x := an_x + 1
				if an_x * 80 > l_width - 20 then
					from
					until
						grid.column_count < an_x
					loop
						grid.remove_column (grid.column_count)
					end
					an_x := 1
					a_y := a_y + 1
				end
				items.forth
			end
			from
			until
				grid.row_count < a_y
			loop
				grid.remove_row (grid.row_count)
			end
		end

	colored_button_selected is
			-- Called by `select_actions' of `colored_button'.
		local
			i: INTEGER
		do
			grid.enable_tree
			add_items (5, 100)--500)
			grid.column (1).set_background_color (light_blue)
			grid.column (2).set_background_color (light_red)
			grid.set_background_color (light_green)
			from
				i := 5
			until
				i > 10
			loop
				grid.row (i).add_subrow (grid.row (i + 1))
				grid.row (i).expand
				i := i + 1
			end
			grid.column (1).set_width (200)
			from
				i := 1
			until
				i > grid.row_count
			loop
				if i \\ 2 = 1 then
					grid.item (4, i).set_background_color (stock_colors.white)
				else
					grid.item (4, i).set_background_color (light_blue)
				end
				i := i + 1
			end
			from
				i := 15
			until
				i = 20
			loop
				grid.row (i).set_background_color (stock_colors.yellow)
				grid.row (i).set_item (2, Void)
				i := i + 1
			end
			grid.row (7).set_background_color (stock_colors.yellow)
			grid.row (8).set_background_color (stock_colors.yellow)
			grid.pointer_double_press_item_actions.extend (agent item_double_pressed)
		end

	item_double_pressed (an_x, a_y, a_button: INTEGER; an_item: EV_GRID_ITEM) is
			--
		local
			editable_item: EV_GRID_COMBO_ITEM
		do
			editable_item ?= an_item
			if editable_item /= Void then
				editable_item.activate
			end
		end
		

	columns_drawn_above_rows_button_selected is
			-- Called by `select_actions' of `columns_drawn_above_rows_button'.
		do
			if columns_drawn_above_rows_button.is_selected then
				grid.enable_columns_drawn_above_rows
			else
				grid.disable_columns_drawn_above_rows
			end
		end

	foreground_color_combo_selected is
			-- Called by `select_actions' of `foreground_color_combo'.
		local
			color: EV_COLOR
		do
			color ?= foreground_color_combo.selected_item.data
			if color /= Void then
				grid.set_foreground_color (color)
			end
		end
	
	background_color_combo_selected is
			-- Called by `select_actions' of `background_color_combo'.
		local
			color: EV_COLOR
		do
			color ?= background_color_combo.selected_item.data
			if color /= Void then
				grid.set_background_color (color)
			end
		end

	is_column_resize_immediate_button_selected is
			-- Called by `select_actions' of `is_column_resize_immediate_button'.
		do
			if is_column_resize_immediate_button.is_selected then
				grid.enable_column_resize_immediate
			else
				grid.disable_column_resize_immediate
			end
		end

	remove_all_row_button_selected is
			-- Called by `select_actions' of `remove_all_rows_button'.
		do
			from
			until
				grid.row_count = 0
			loop
				grid.remove_row (grid.row_count)
			end
		end
	
	remove_all_columns_button_selected is
			-- Called by `select_actions' of `remove_all_columns_button'.
		do
			from
			until
				grid.column_count = 0
			loop
				grid.remove_column (grid.column_count)
			end
		end
		
end -- class GRID_TAB

