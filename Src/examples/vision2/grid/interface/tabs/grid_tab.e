indexing
	description: "Objects that represent an EV_TITLED_WINDOW.%
		%The original version of this class was generated by EiffelBuild."
	date: "$Date$"
	revision: "$Revision$"

class
	GRID_TAB

inherit
	GRID_TAB_IMP
	
	GRID_ACCESSOR
		undefine
			copy, default_create, is_equal
		end
		
	PROFILING_SETTING
		undefine
			copy, default_create, is_equal
		end
	
feature {NONE} -- Initialization

	user_initialization is
			-- Called by `initialize'.
			-- Any custom user initialization that
			-- could not be performed in `initialize',
			-- (due to regeneration of implementation class)
			-- can be added here.
		local
			f_name: FILE_NAME
			list_item: EV_LIST_ITEM
		do
			grid.set_dynamic_content_function (agent compute_item)
			add_default_colors_to_combo (set_background_color_combo)
			
				-- Now load pixmaps for exapnd/collapse nodes.
			expand1 := grid.expand_node_pixmap
			collapse1 := grid.collapse_node_pixmap
			create f_name.make_from_string (current_working_directory)
			f_name.extend ("icon_bpenabled.png")
			create expand2
			expand2.set_with_named_file (f_name.out)
			create f_name.make_from_string (current_working_directory)
			f_name.extend ("icon_bpdisabled.png")
			create collapse2
			collapse2.set_with_named_file (f_name)
			
			create f_name.make_from_string (current_working_directory)
			f_name.extend ("large_expand.png")
			create expand3
			expand3.set_with_named_file (f_name.out)
			create f_name.make_from_string (current_working_directory)
			f_name.extend ("large_collapse.png")
			create collapse3
			collapse3.set_with_named_file (f_name)
			
			create list_item.make_with_text ("9x9")
			list_item.set_pixmap (expand1)
			subnode_pixmaps_combo.extend (list_item)
			create list_item.make_with_text ("12x12")
			list_item.set_pixmap (expand2)
			subnode_pixmaps_combo.extend (list_item)
			create list_item.make_with_text ("32x32")
			list_item.set_pixmap (expand3)
			subnode_pixmaps_combo.extend (list_item)

			add_default_colors_to_combo (foreground_color_combo)
			add_default_colors_to_combo (background_color_combo)
			add_default_colors_to_combo (separator_color_combo)
			select_color_from_combo (background_color_combo, grid.background_color)
			select_color_from_combo (foreground_color_combo, grid.foreground_color)
			select_color_from_combo (separator_color_combo, grid.separator_color)
		end
		
	expand1, expand2, expand3, collapse1, collapse2, collapse3: EV_PIXMAP
		-- Pixmaps used for expand/collapse nodes

feature {NONE} -- Implementation

	is_header_displayed_button_selected is
			-- Called by `select_actions' of `is_header_displayed_button'.
		do
			if is_header_displayed_button.is_selected then
				grid.show_header
			else
				grid.hide_header
			end
		end

	is_tree_enabled_button_selected is
			-- Called by `select_actions' of `is_tree_enabled_button'.
		do
			if is_tree_enabled_button.is_selected then
				grid.enable_tree
			else
				grid.disable_tree
			end
		end

	new_label_button_selected is
			-- Called by `select_actions' of `new_label_button'.
		local
			new_label_item_dialog: NEW_ITEM_DIALOG
		do
			create new_label_item_dialog
			new_label_item_dialog.show_relative_to_window (main_window)
		end
		
	is_vertical_divider_displayed_button_selected is
			-- Called by `select_actions' of `is_vertical_divider_displayed_button'.
		do
			if is_vertical_divider_displayed_button.is_selected then
				grid.enable_resizing_divider
				is_vertical_divider_dashed_button.enable_sensitive
				is_vertical_divider_solid_button.enable_sensitive
			else
				grid.disable_resizing_divider
				is_vertical_divider_dashed_button.disable_sensitive
				is_vertical_divider_solid_button.disable_sensitive
			end
		end
		
	is_vertical_divider_solid_button_selected is
			-- Called by `select_actions' of `is_vertical_divider_solid_button'.
		do
			grid.enable_solid_resizing_divider
		end
	
	is_vertical_divider_dashed_button_selected is
			-- Called by `select_actions' of `is_vertical_divider_dashed_button'.
		do
			grid.disable_solid_resizing_divider
		end
		
	is_horizontal_scrolling_per_item_selected is
			-- Called by `select_actions' of `is_horizontal_scrolling_per_item'.
		do
			if is_horizontal_scrolling_per_item.is_selected then
				grid.enable_horizontal_scrolling_per_item
			else
				grid.disable_horizontal_scrolling_per_item
			end
		end
	
	is_vertical_scrolling_per_item_selected is
			-- Called by `select_actions' of `is_vertical_scrolling_per_item'.
		do
			if is_vertical_scrolling_per_item.is_selected then
				grid.enable_vertical_scrolling_per_item
			else
				grid.disable_vertical_scrolling_per_item
			end
		end
		
	is_row_height_fixed_selected is
			-- Called by `select_actions' of `is_row_height_fixed'.
		do
			if is_row_height_fixed.is_selected then
				grid.enable_row_height_fixed
				fixed_row_height_spin_button.enable_sensitive
			else
				grid.disable_row_height_fixed
				fixed_row_height_spin_button.disable_sensitive
			end
		end
	
	fixed_row_height_spin_button_changed (a_value: INTEGER) is
			-- Called by `change_actions' of `fixed_row_height_spin_button'.
		do
			grid.set_row_height (a_value)
		end
		
	is_partially_dynamic_selected is
			-- Called by `select_actions' of `is_partically_dynamic'.
		do
			if is_partially_dynamic.is_selected then
				grid.enable_partial_dynamic_content
				resize_rows_columns_box.enable_sensitive
				is_completely_dynamic.select_actions.block
				is_completely_dynamic.disable_select
				is_completely_dynamic.select_actions.resume
			else
				if not is_completely_dynamic.is_selected then
					resize_rows_columns_box.disable_sensitive
					grid.disable_dynamic_content
				end
			end
		end
	
	is_completely_dynamic_selected is
			-- Called by `select_actions' of `is_completely_dynamic'.
		do
			if is_completely_dynamic.is_selected then
				grid.enable_complete_dynamic_content
				resize_rows_columns_box.enable_sensitive
				is_partially_dynamic.select_actions.block
				is_partially_dynamic.disable_select
				is_partially_dynamic.select_actions.resume
			else
				if not is_partially_dynamic.is_selected then
					resize_rows_columns_box.disable_sensitive
					grid.disable_dynamic_content
				end
			end
		end

	resize_columns_to_button_selected is
			-- Called by `select_actions' of `resize_columns_to_button'.
		do
			if resize_columns_to_button.is_selected then
				resize_columns_to_entry.enable_sensitive
				resize_columns_to_entry.change_actions.call ([resize_columns_to_entry.value])
			else
				resize_columns_to_entry.disable_sensitive
			end
		end
	
	resize_columns_to_entry_selected (a_value: INTEGER) is
			-- Called by `change_actions' of `resize_columns_to_entry'.
		do
			grid.set_column_count_to (a_value)
		end
		
	resize_row_to_button_selected is
			-- Called by `select_actions' of `resize_rows_to_button'.
		do
			if resize_rows_to_button.is_selected then
				resize_rows_to_entry.enable_sensitive
				resize_rows_to_entry.change_actions.call ([resize_rows_to_entry.value])
			else
				resize_rows_to_entry.disable_sensitive
			end
		end
	
	resize_rows_to_entry_changed (a_value: INTEGER) is
			-- Called by `change_actions' of `resize_rows_to_entry'.
		do
			grid.set_row_count_to (a_value)
		end
		
	add_items (an_xcount, a_ycount: INTEGER) is
			--
		local
			l_ycount, l_xcount: INTEGER
			grid_label_item: EV_GRID_COMBO_ITEM -- EDITABLE_ITEM
		do
			from
				l_ycount := 1
			until
				l_ycount > a_ycount
			loop
				from
					l_xcount := 1
				until
					l_xcount > an_xcount
				loop
					create grid_label_item
					grid_label_item.set_text ("Item" + " " + l_xcount.out + ", " + l_ycount.out)
					grid_label_item.set_tooltip (grid_label_item.text.twin)
					grid.set_item (l_xcount, l_ycount, grid_label_item)
					l_xcount := l_xcount + 1
				end
				l_ycount := l_ycount + 1
			end
		end
		
	reset_grid is
			-- Reset grid from one test to another.
		do
			grid.wipe_out
			grid.resize_actions.wipe_out
			grid.enable_row_height_fixed
			grid.post_draw_overlay_actions.wipe_out
			grid.fill_background_actions.wipe_out
			grid.pre_draw_overlay_actions.wipe_out
			grid.pointer_button_press_actions.wipe_out
			grid.item_select_actions.wipe_out
			grid.item_deselect_actions.wipe_out
			grid.enable_single_item_selection
			grid.disable_tree
--			grid.set_row_height (16)
			if ball_animation_timer /= Void then
				ball_animation_timer.destroy
				ball_animation_timer := Void
			end
			if animation_timer /= Void then
				animation_timer.destroy
				animation_timer := Void
			end
			if redraw_timer /= Void then
				redraw_timer.destroy
				redraw_timer := Void
			end
		end
		
		
	misc_button_selected is
			-- Called by `select_actions' of `misc_button'.
		local
			counter: INTEGER
			counter2: INTEGER
			time1, time2: DATE_TIME
			grid_label_item: EV_GRID_LABEL_ITEM
			grid_editable_item: EV_GRID_EDITABLE_ITEM
			grid_combo_item: EV_GRID_COMBO_ITEM
			grid_drawable_item: EV_GRID_DRAWABLE_ITEM
			current_row, current_subrow: EV_GRID_ROW
			font: EV_FONT
		do
			if profile_cell.item then
				start_profiling
			end
			create time1.make_now
			reset_grid
			add_items (5, 400)
			grid.column (1).set_title ("One")
			grid.column (2).set_title ("Two")
			grid.column (3).set_title ("Three")
			grid.column (4).set_title ("Four")
			grid.column (5).set_title ("Five")
			grid.enable_tree
			grid.row (1).add_subrow (grid.row (2))
			grid.row (1).add_subrow (grid.row (3))
			grid.row (3).add_subrow (grid.row (4))
			grid.row (4).add_subrow (grid.row (5))
			grid.row (5).add_subrow (grid.row (6))
			grid.row (6).add_subrow (grid.row (7))
			grid.row (7).add_subrow (grid.row (8))
			grid.row (8).add_subrow (grid.row (9))
			grid.row (9).add_subrow (grid.row (10))
			from
				counter := 11
			until
				counter > 26
			loop
				grid.row (1).add_subrow (grid.row (counter))
				counter := counter + 1
			end
			from
				counter := 27
			until
				counter > 31
			loop
				grid.row (counter - 1).add_subrow (grid.row (counter))
				counter := counter + 1
			end

			from
				counter := 50
			until
				counter = 100
			loop
				grid.row (counter).add_subrow (grid.row (counter + 1))
				counter := counter + 1
			end
			grid.insert_new_row (110)
			grid.set_item (3, 110, create {EV_GRID_LABEL_ITEM}.make_with_text ("Deep subnode"))
			grid.row (109).add_subrow (grid.row (110))
			
			from
				counter := 111
			until
				counter = 113
			loop
				grid.insert_new_row (counter)
				grid.set_item (3, counter, create {EV_GRID_LABEL_ITEM}.make_with_text ("Subnode"))
				grid.row (counter - 1).add_subrow (grid.row (counter))
				counter := counter + 1
			end
			from
				counter := 113
			until
				counter = 121
			loop
				grid.remove_item (1, counter)
				grid.remove_item (2, counter)
				grid.remove_item (3, counter)
				grid.remove_item (4, counter)
				grid.set_item (5, counter, create {EV_GRID_LABEL_ITEM}.make_with_text ("Subnode"))
				grid.row (112).add_subrow (grid.row (counter))
				counter := counter + 1
			end
			grid.remove_item (1, 121)
			grid.remove_item (2, 121)
			grid.row (112).add_subrow (grid.row (121))
			from
				counter := 122
			until
				counter = 128
			loop
				grid.remove_item (1, counter)
				grid.remove_item (2, counter)
				grid.remove_item (3, counter)
				grid.set_item (3, counter, create {EV_GRID_LABEL_ITEM}.make_with_text ("Subnode"))
				grid.row (counter - 1).add_subrow (grid.row (counter))
				counter := counter + 1
			end
			fixme ("Uncomment this code and replace that just above to show a redrawing bug.")
--			from
--				counter := 121
--			until
--				counter = 128
--			loop
--				grid.remove_item (1, counter)
--				grid.remove_item (2, counter)
--				grid.set_item (3, counter, create {EV_GRID_LABEL_ITEM}.make_with_text ("Subnode"))
--				grid.row (110).add_subrow (grid.row (counter))
--				counter := counter + 1
--			end


			from
				counter := 150
			until
				counter > 155
			loop
				grid.insert_new_row (counter + 1)
				grid.set_item (1, counter + 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Subnode"))
				grid.row (150).add_subrow (grid.row (counter + 1))
				
				counter := counter + 1
			end
			
				-- Now perform a heavy test of the vertical tree lines.
			from
				counter := 160
			until
				counter = 259
			loop
				grid.row (counter).add_subrow (grid.row (counter + 1))
				counter := counter + 1
			end
			from
				counter := 259
				counter2 := 259
			until
				counter = 359
			loop
				grid.row (counter2).add_subrow (grid.row (counter + 1))
				counter := counter + 1
				counter2 := counter2 - 1
			end
			create time2.make_now
			set_status_message (("Items added in : " + ((time2.fine_second - time1.fine_second).out)))

			grid.disable_row_height_fixed
			grid.row (3).set_height (100)


			grid.row (32).clear
			grid.row (32).set_item (1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Expand Me"))
			grid.row (32).add_subrow (grid.row (33))
			grid.row (33).clear
			grid.row (33).set_item (1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Move Over Me"))
			grid_label_item ?=  grid.row (33).item (1)
			grid_label_item.set_pixmap (image5)
			grid.row (33).set_height (100)
			grid.column (1).set_width (200)
			grid.pointer_motion_item_actions.extend (agent motion_on_grid)
			grid.row (34).clear
			grid.row (34).set_item (1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Show Editable Items"))
			grid.row (34).add_subrow (grid.row (35))
			grid.row (35).clear
			from
				counter := 1
			until
				counter > 5
			loop
				create grid_editable_item.make_with_text ("Edit Me")
				if counter > 1 then
					grid_editable_item.set_pixmap (image3)
				end
				grid.row (35).set_item (counter, grid_editable_item)
				counter := counter + 1
			end
			grid.row (36).clear
			grid.row (36).set_item (1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Show Editable Combo Items"))
			grid.row (36).add_subrow (grid.row (37))
			grid.row (37).clear
			from
				counter := 1
			until
				counter > 5
			loop
				create grid_combo_item.make_with_text ("Edit Me")
				if counter > 1 then
					grid_combo_item.set_pixmap (image3)
				end
				grid.row (37).set_item (counter, grid_combo_item)
				counter := counter + 1
			end
			grid.pointer_double_press_item_actions.extend (agent pointer_double_press_received_on_grid)
			current_row := grid.row (38)
			current_row.clear
			current_row.set_item (1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Show Font Sizes"))
			from
				counter := 1
			until
				counter = 16
			loop
				current_row.insert_subrow (counter)
				create grid_label_item.make_with_text ("Font Height : " + ((counter + 3) * 2).out)
				current_row.subrow (counter).set_item (1, grid_label_item)
				create font
				font.set_height ((counter + 3) * 2)
				grid_label_item.set_font (font)
				current_row.subrow (counter).set_height (grid_label_item.text_height)
				counter := counter + 1
			end

			current_row := grid.row (54)
			current_row.clear
			current_row.set_item (1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Show Drawable Items"))
			from
				counter := 1
			until
				counter = 16
			loop
				current_row.insert_subrow (1)
				if counter > 1 then
					current_row.expand
				end
				current_subrow := current_row.subrow (1)
				from
					counter2 := 1
				until
					counter2 > 5
				loop
					create grid_drawable_item
					grid_drawable_item.set_required_width (200)
					grid_drawable_item.expose_actions.extend (agent draw_ellipse (?, grid_drawable_item))
					current_subrow.set_item (counter2, grid_drawable_item)
					counter2 := counter2 + 1
				end
				current_row := current_subrow
				counter := counter + 1
			end
			grid.column (1).set_background_color (light_red)
			from
				counter := 1
			until
				counter > grid.row_count
			loop
				grid_label_item ?= grid.item (1, counter)
				if grid_label_item /= Void then
					grid_label_item.set_pixmap (image1)
				end

				grid_label_item ?= grid.item (4, counter)
				if grid_label_item /= Void then
					grid_label_item.set_pixmap (image2)
				end
				counter := counter + 1
			end
			if profile_cell.item then
				stop_profiling
			end

			grid.column (1).set_pixmap (image1)
			grid.column (2).set_pixmap (image2)
			grid.column (3).set_pixmap (image3)
			grid.column (4).set_pixmap (image4)
			grid.column (5).set_pixmap (image5)
			grid.column (1).header_item.pointer_double_press_actions.extend (agent resize_column (?, ?, ?, ?, ?, ?, ?, ?, 1))
			grid.column (2).header_item.pointer_double_press_actions.extend (agent resize_column (?, ?, ?, ?, ?, ?, ?, ?, 2))
			grid.column (3).header_item.pointer_double_press_actions.extend (agent resize_column (?, ?, ?, ?, ?, ?, ?, ?, 3))
			grid.column (4).header_item.pointer_double_press_actions.extend (agent resize_column (?, ?, ?, ?, ?, ?, ?, ?, 4))
			grid.column (5).header_item.pointer_double_press_actions.extend (agent resize_column (?, ?, ?, ?, ?, ?, ?, ?, 5))
		end
		
	resize_column (an_x, a_y, a_button: INTEGER; d1, d2, d3: DOUBLE; i1, i2, a_column_index: INTEGER) is
			--
		do
			if ((create {EV_ENVIRONMENT}).application).shift_pressed then
				grid.column (a_column_index).set_width (grid.column (a_column_index).required_width_of_item_span (grid.first_visible_row.index, grid.last_visible_row.index))
			else
				grid.column (a_column_index).resize_to_content
			end
		end
		
		
	build_ball_demo_button_selected is
			-- Called by `select_actions' of `build_ball_demo_button'.
		local
			current_row: EV_GRID_ROW
			counter: INTEGER
			current_subrow: EV_GRID_ROW
			counter2: INTEGER
			grid_drawable_item: EV_GRID_DRAWABLE_ITEM
			grid_editable_item: EV_GRID_EDITABLE_ITEM
		do
			reset_grid
			balls := 10
			grid.enable_tree
			grid.enable_multiple_item_selection
			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Expand To See animation"))
			create grid_editable_item.make_with_text ("10")
			grid.set_item (2, 1, grid_editable_item)
			grid_editable_item.pointer_double_press_actions.force_extend (agent grid_editable_item.activate)
			grid_editable_item.set_text_validation_agent (agent validate_text)
			current_row := grid.row (1)
			from
				counter := 1
			until
				counter = 16
			loop
				current_row.insert_subrow (counter)
				current_subrow := current_row.subrow (counter)
				from
					counter2 := 1
				until
					counter2 > 5
				loop
					create grid_drawable_item
					grid_drawable_item.expose_actions.extend (agent draw_ellipse_with_balls (?, grid_drawable_item))
					current_subrow.set_item (counter2, grid_drawable_item)
					counter2 := counter2 + 1
				end
				counter := counter + 1
			end
			grid.set_item (1, 16, create {EV_GRID_LABEL_ITEM}.make_with_text ("Blocking"))
			grid.item (1, 16).set_background_color (red)
			grid.set_item (1, 15, create {EV_GRID_LABEL_ITEM}.make_with_text ("Blocking"))
			grid.item (1, 15).set_background_color (red)
			grid.set_item (1, 14, create {EV_GRID_LABEL_ITEM}.make_with_text ("Blocking"))
			grid.item (1, 14).set_background_color (red)
			grid.set_item (1, 13, create {EV_GRID_LABEL_ITEM}.make_with_text ("Blocking"))
			grid.item (1, 13).set_background_color (red)
			grid.set_item (1, 12, create {EV_GRID_LABEL_ITEM}.make_with_text ("Blocking"))
			grid.item (1, 12).set_background_color (red)


			grid.set_item (3, 4, create {EV_GRID_LABEL_ITEM}.make_with_text ("Blocking"))
			grid.item (3, 4).set_background_color (red)
			grid.set_item (3, 5, create {EV_GRID_LABEL_ITEM}.make_with_text ("Blocking"))
			grid.item (3, 5).set_background_color (red)
			grid.set_item (3, 6, create {EV_GRID_LABEL_ITEM}.make_with_text ("Blocking"))
			grid.item (3, 6).set_background_color (red)
			grid.set_item (3, 7, create {EV_GRID_LABEL_ITEM}.make_with_text ("Blocking"))
			grid.item (3, 7).set_background_color (red)
			grid.set_item (3, 8, create {EV_GRID_LABEL_ITEM}.make_with_text ("Blocking"))
			grid.item (3, 8).set_background_color (red)


			grid.set_item (5, 5, create {EV_GRID_LABEL_ITEM}.make_with_text ("Blocking"))
			grid.item (5, 5).set_background_color (red)
			grid.set_item (5, 6, create {EV_GRID_LABEL_ITEM}.make_with_text ("Blocking"))
			grid.item (5, 6).set_background_color (red)

			current_row.expand_actions.extend (agent start_ball_animation)
			current_row.collapse_actions.extend (agent end_ball_animation)
		end
		
	validate_text (a_text: STRING): BOOLEAN is
			--
		do
			if a_text.is_integer then
				Result := True
				balls := a_text.to_integer
				if grid.row (1).is_expanded then
					end_ball_animation
					start_ball_animation
				end
			end
		end


	animating_ball: BOOLEAN

	balls: INTEGER

	ball_x_vel, ball_y_vel: ARRAY [REAL]

	ball_x, ball_y: ARRAY [REAL]

	start_ball_animation is
			--
		local
			counter: INTEGER
			random: RANDOM
			l_start_x, l_start_y: INTEGER
			i, j: REAL
			random_counter: INTEGER
			time1, time2: DATE_TIME
			fine_seconds: REAL
		do
			create random.make
			create redraw_timer.make_with_interval (20)
			create ball_x.make (1, balls)
			create ball_y.make (1, balls)
			create ball_x_vel.make (1, balls)
			create ball_y_vel.make (1, balls)
			l_start_x := grid.row (5).item (3).virtual_x_position
			l_start_y := grid.row (5).virtual_y_position + 5
			from
				counter := 1
			until
				counter > balls
			loop
				ball_x.put (100, counter)
				ball_y.put (100, counter)
				ball_x_vel.put (-5 + (random.next_random (random_counter) \\ 5000) / 500, counter)
				random_counter := random_counter + 1
				ball_y_vel.put (-5 + (random.next_random (random_counter) \\ 5000) / 500, counter)
				i := ball_x_vel.item (counter)
				j := ball_y_vel.item (counter)
				random_counter := random_counter + 1
				counter := counter + 1
			end
			animating_ball := True
			if profile_cell.item then
				create time1.make_now
				start_profiling
				from
					counter := 0
				until
					counter = 1000
				loop
					counter := counter + 1
					animate_ball
				end
				stop_profiling
				create time2.make_now
				fine_seconds := time2.fine_second - time1.fine_second
				if time2.fine_second < time1.fine_second then
					fine_seconds := fine_seconds + 60
				end

				set_status_message ("1000 iterations performed in : " + fine_seconds.out)
			else
				create animation_timer.make_with_interval (20)
				animation_timer.actions.extend (agent animate_ball)
			end

		end

	ball_width: INTEGER is 10

	animate_ball is
			--
		local
			grid_item: EV_GRID_ITEM
			grid_item_column_index, grid_item_row_index: INTEGER
			next_item: EV_GRID_DRAWABLE_ITEM
			l_ball_x, l_ball_y, l_ball_x_vel, l_ball_y_vel: REAL
			counter: INTEGER
			previous_row: EV_GRID_ROW
			previous_column: EV_GRID_COLUMN
		do
			from
				counter := 1
			until
				counter > balls
			loop
				l_ball_x := ball_x.item (counter)
				l_ball_y := ball_y.item (counter)
				l_ball_x_vel := ball_x_vel.item (counter)
				l_ball_y_vel := ball_y_vel.item (counter)

				grid_item := grid.item_at_virtual_position (l_ball_x.truncated_to_integer, l_ball_y.truncated_to_integer)
				grid_item_column_index := grid_item.column.index
				grid_item_row_index := grid_item.row.index
				if l_ball_x_vel > 0 then
					if grid_item_column_index < grid.column_count then
						next_item ?= grid.item (grid_item_column_index + 1, grid_item_row_index)
					else
						next_item := Void
					end
					if l_ball_x + l_ball_x_vel + ball_width > grid_item.virtual_x_position + grid_item.width and next_item = Void then
						l_ball_x_vel := 0 - l_ball_x_vel
					end
					if grid_item_column_index > 1 then
						previous_column := grid.column (grid_item_column_index - 1)
					else
						previous_column := Void
					end
					if previous_column /= Void then
						previous_column.redraw
					end
				else
					if grid_item_column_index > 1 then
						next_item ?= grid.item (grid_item_column_index - 1, grid_item_row_index)
					else
						next_item := Void
					end
					if l_ball_x + l_ball_x_vel < grid_item.virtual_x_position and next_item = Void then
						l_ball_x_vel := 0 - l_ball_x_vel
					end
					if grid_item_column_index < grid.column_count then
						previous_column := grid.column (grid_item_column_index + 1)
					else
						previous_column := Void
					end
					if previous_column /= Void then
						previous_column.redraw
					end
				end
				if l_ball_y_vel > 0 then
					if grid_item_row_index < grid.row_count then
						next_item ?= grid.item (grid_item_column_index, grid_item_row_index + 1)
					else
						next_item := Void
					end
					if l_ball_y + l_ball_y_vel + ball_width > grid_item.virtual_y_position + grid_item.height and next_item = Void then
						l_ball_y_vel := 0 - l_ball_y_vel
					end
					if grid_item_row_index > 1 then
						previous_row := grid.row (grid_item_row_index - 1)
					else
						previous_row := Void
					end
					if previous_row /= Void then
						previous_row.redraw
					end
				else
					if grid_item_row_index > 1 then
						next_item ?= grid.item (grid_item_column_index, grid_item_row_index - 1)
					else
						next_item := Void
					end
					if l_ball_y + l_ball_y_vel < grid_item.virtual_y_position and next_item = Void then
						l_ball_y_vel := 0 - l_ball_y_vel
					end
					if grid_item_row_index < grid.row_count then
						previous_row := grid.row (grid_item_row_index + 1)
					else
						previous_row := Void
					end
					if previous_row /= Void then
						previous_row.redraw
					end
				end
				l_ball_x := l_ball_x + l_ball_x_vel
				l_ball_y := l_ball_y + l_ball_y_vel
				ball_x.put (l_ball_x, counter)
				ball_y.put (l_ball_y, counter)
				ball_x_vel.put (l_ball_x_vel, counter)
				ball_y_vel.put (l_ball_y_vel, counter)
				counter := counter + 1
				grid_item.redraw
			end
		end
		
		
	end_ball_animation is
			--
		do
			if animation_timer /= Void then
				animation_timer.destroy
			end
			if redraw_timer /= Void then
				redraw_timer.destroy
			end
		end
		
	ball_animation_timer, ball_redraw_timer: EV_TIMEOUT

	draw_ellipse (drawable: EV_DRAWABLE; an_item: EV_GRID_DRAWABLE_ITEM) is
			--
		do
			drawable.set_foreground_color (grid.background_color)
			drawable.fill_rectangle (0, 0, an_item.width, an_item.height)
			if an_item.is_selected then
				if grid.has_focus then
					drawable.set_foreground_color (grid.focused_selection_color)
				else
					drawable.set_foreground_color (grid.non_focused_selection_color)
				end
				drawable.fill_ellipse (0, 0, an_item.width, an_item.height)
			end
			drawable.draw_ellipse (0, 0, an_item.width, an_item.height)
			drawable.set_foreground_color (grid.foreground_color)
			drawable.draw_ellipse (0, 0, an_item.width, an_item.height)
		end
		
	draw_ellipse_with_balls (drawable: EV_DRAWABLE; an_item: EV_GRID_DRAWABLE_ITEM) is
			--
		local
			l_virtual_x, l_virtual_y: INTEGER
			counter: INTEGER
			l_ball_x, l_ball_y: REAL
		do
			drawable.set_foreground_color (grid.background_color)
			drawable.fill_rectangle (0, 0, an_item.width, an_item.height)
			if an_item.is_selected then
				if grid.has_focus then
					drawable.set_foreground_color (grid.focused_selection_color)
				else
					drawable.set_foreground_color (grid.non_focused_selection_color)
				end
				drawable.fill_ellipse (0, 0, an_item.width, an_item.height)
			end
			drawable.draw_ellipse (0, 0, an_item.width, an_item.height)
			drawable.set_foreground_color (grid.foreground_color)
			drawable.draw_ellipse (0, 0, an_item.width, an_item.height)


			l_virtual_y := an_item.virtual_y_position
			l_virtual_x := an_item.virtual_x_position

			from
				counter := 1
			until
				counter > balls
			loop
				l_ball_x := ball_x.item (counter)
				l_ball_y := ball_y.item (counter)
				if l_ball_x + ball_width >= an_item.virtual_x_position and l_ball_x < l_virtual_x + an_item.width and
					l_ball_y + ball_width >= l_virtual_y and l_ball_y < l_virtual_y + an_item.height then
					drawable.set_foreground_color (red)
					drawable.fill_ellipse (l_ball_x.truncated_to_integer - l_virtual_x, l_ball_y.truncated_to_integer - l_virtual_y, ball_width, ball_width) --draw_point (ball_x - an_item.virtual_x_position, ball_y - an_item.virtual_y_position)
					drawable.set_foreground_color (grid.foreground_color)					
					drawable.draw_ellipse (l_ball_x.truncated_to_integer - l_virtual_x, l_ball_y.truncated_to_integer - l_virtual_y, ball_width, ball_width)
				end
				counter := counter + 1
			end
		end

	pointer_double_press_received_on_grid (an_x, a_y, button: INTEGER; grid_item: EV_GRID_ITEM) is
			--
		local
			editable_item: EV_GRID_EDITABLE_ITEM
			combo_item: EV_GRID_COMBO_ITEM
		do
			editable_item ?= grid_item
			if editable_item /= Void then
				editable_item.activate
			end
			combo_item ?= grid_item
			if combo_item /= Void then
				combo_item.activate
			end
		end
		

	animate is
			--
		local
			label_item: EV_GRID_LABEL_ITEM
		do
			label_item ?= grid.item (1, 33)
			if x < 0 or x > label_item.column.width - label_item.text_width - label_item.pixmap.width - label_item.spacing - label_item.horizontal_indent - x_vel  then
				x_vel := 0 - x_vel
			end
			if y < 0 or y > label_item.row.height - label_item.text_height - y_vel- label_item.pixmap.height then
				y_vel := 0 - y_vel
			end
			x := x + x_vel
			y := y + y_vel
			if y_vel > 0 then
				y_vel := y_vel - 0.04
			else
				y_vel := y_vel + 0.04
			end
			if x_vel > 0 then
				x_vel := x_vel - 0.04
			else
				x_vel := x_vel + 0.04
			end
			if x_vel.abs < 0.04 and y_vel.abs < 0.04 then
				animating := False
				animation_timer.destroy
				redraw_timer.destroy
			end
		end

	redraw is
			--
		do
			grid.item (1, 33).redraw
		end

	layout_procedure (an_item: EV_GRID_LABEL_ITEM; layout: EV_GRID_LABEL_ITEM_LAYOUT) is
			--
		do
			layout.set_pixmap_x (x.truncated_to_integer + an_item.text_width // 2 - an_item.pixmap.width // 2)
			layout.set_pixmap_y (y.truncated_to_integer)
			layout.set_text_x (x.truncated_to_integer)
			layout.set_text_y (y.truncated_to_integer + an_item.pixmap.height)
		end
		

	x, y: REAL

	x_vel, y_vel: REAL

	animating: BOOLEAN
		

	start_animation is
			--
		do
			create animation_timer.make_with_interval (10)
			animation_timer.actions.extend (agent animate)
			create redraw_timer.make_with_interval (20)
			redraw_timer.actions.extend (agent redraw)
			x_vel := 6
			y_vel := 8
			animating := True
		end
		
	animation_timer, redraw_timer: EV_TIMEOUT

	motion_on_grid (an_x, a_y: INTEGER; an_item: EV_GRID_ITEM) is
			--
		local
			label_item: EV_GRID_LABEL_ITEM
		do
			if an_item /= Void and then an_item.row.index = 33 and an_item.column.index = 1 and not animating then
				label_item ?= an_item
				label_item.set_layout_procedure (agent layout_procedure)
				start_animation
			end
		end
		
	compute_item (an_x, a_y: INTEGER): EV_GRID_ITEM is
			--
		local
			drawable_item: EV_GRID_DRAWABLE_ITEM
		do
			if an_x = 2 then
				do_nothing
			end
			if a_y \\ 2 = 1 then
				create {EV_GRID_LABEL_ITEM} Result.make_with_text ("Item at position : " + an_x.out + ", " + a_y.out)
			else
				create drawable_item
				drawable_item.expose_actions.extend (agent draw_grid_item (?, drawable_item))
				Result := drawable_item
			end
		end
		
	draw_grid_item (drawable: EV_DRAWABLE; an_item: EV_GRID_ITEM) is
			--
		local
			back_color: EV_COLOR
			virtual_y, virtual_x: INTEGER
		do
			virtual_x := an_item.virtual_x_position
			virtual_y := an_item.virtual_y_position
			if back_color = Void then
				back_color := grid.background_color
			end
			drawable.set_foreground_color (back_color)
			drawable.fill_rectangle (0, 0, an_item.width, an_item.height)
			drawable.set_foreground_color (create {EV_COLOR}.make_with_8_bit_rgb (((virtual_y + virtual_x).abs // 8) \\ 255, ((virtual_y + virtual_x).abs // 8) \\ 255, ((virtual_y + virtual_x).abs // 8) \\ 255))
			drawable.fill_ellipse (0, 0, an_item.width, an_item.height)
		end
		
	set_selected_row_as_subnode_button_selected is
			-- Called by `select_actions' of `set_selected_row_as_subnode_button'.
		local
			selected_items: ARRAYED_LIST [EV_GRID_ITEM]
			selected_rows: ARRAYED_LIST [EV_GRID_ROW]
			current_row: EV_GRID_ROW
		do
			if grid.is_multiple_item_selection_enabled then
				selected_items := grid.selected_items
			else
				selected_rows := grid.selected_rows
				from
					selected_rows.start
				until
					selected_rows.off
				loop
					current_row := selected_rows.item
					grid.row (current_row.index - 1).add_subrow (current_row)
					selected_rows.forth
				end
			end
		end

	subrow_indent_button_changed (a_value: INTEGER) is
			-- Called by `change_actions' of `subrow_indent_button'.
		do
			grid.set_subrow_indent (a_value)
		end
		
	set_background_color_button_selected is
			-- Called by `select_actions' of `set_background_color_button'.
		do
		end
	
	set_background_color_combo_selected is
			-- Called by `select_actions' of `set_background_color_combo'.
		local
			selected_items: ARRAYED_LIST [EV_GRID_ITEM]
			color: EV_COLOR
		do
			color ?= set_background_color_combo.selected_item.data
			if set_tree_node_connector_button.is_selected then
				grid.set_tree_node_connector_color (color)
			elseif set_background_of_selection_button.is_selected then
				selected_items := grid.selected_items
				if not selected_items.is_empty then
					from
						selected_items.start
					until
						selected_items.off
					loop
						selected_items.item.set_background_color (color)
						selected_items.forth
					end
				end
			end
		end
		
	subnode_pixmaps_combo_selected is
			-- Called by `select_actions' of `subnode_pixmaps_combo'.
		local
			l_index: INTEGER
		do
			l_index := subnode_pixmaps_combo.index_of (subnode_pixmaps_combo.selected_item, 1)
			if l_index = 1 then
				grid.set_node_pixmaps (expand1, collapse1)
			elseif l_index = 2 then
				grid.set_node_pixmaps (expand2, collapse2)
			elseif l_index = 3 then
				grid.set_node_pixmaps (expand3, collapse3)
			end
		end
		
	expand_all_button_selected is
			-- Called by `select_actions' of `expand_all_button'.
		local
			counter: INTEGER
			current_row: EV_GRID_ROW
		do
			from
				counter := 1
			until
				counter > grid.row_count
			loop
				current_row := grid.row (counter)
				if current_row.subrow_count > 0 then
					current_row.expand			
				end
				counter := counter + 1
			end
		end
	
	collapse_all_button_selected is
			-- Called by `select_actions' of `collapse_all_button'.
		local
			counter: INTEGER
			current_row: EV_GRID_ROW
		do
			from
				counter := 1
			until
				counter > grid.row_count
			loop
				current_row := grid.row (counter)
				if current_row.subrow_count > 0 then
					current_row.collapse			
				end
				counter := counter + 1
			end
		end
		
	tree_lines_enabled_selected is
			-- Called by `select_actions' of `tree_lines_enabled'.
		do
			if tree_lines_enabled.is_selected then
				grid.show_tree_node_connectors
			else
				grid.hide_tree_node_connectors
			end
		end
		
	custom_button_selected is
			-- Called by `select_actions' of `custom_button'.
		local
--			l_item: EV_GRID_ITEM
--			r, row: EV_GRID_ROW
--			grid_label_item: EV_GRID_LABEL_ITEM
--			counter, counter2: INTEGER
--			i: INTEGER
		do
			reset_grid
--			l_item := grid.item_at_virtual_position (200, 16)
--			misc_button_selected
--			grid.column (3).set_width (200)
--			grid.column (4).set_width (200)
--			grid.enable_horizontal_scrolling_per_item

--			grid.enable_tree
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			grid.set_item (1, 2, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			grid.set_item (2, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			grid.set_item (2, 2, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			r := grid.row (grid.row_count)
--			grid.insert_new_row (r.index + 1)
--            row := grid.row (r.index + 1)
--			r.add_subrow (row)            
--                -- and then create the item
--            create grid_label_item
--            grid_label_item.set_text ("POP")
--            row.set_item (1, grid_label_item)


--			grid.insert_new_row (r.index + 2)
			
--			r.add_subrow (row)  
--			grid.enable_tree
--			grid.set_item (8, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Sub Sub row"))
--			grid.set_item (1, 2, create {EV_GRID_LABEL_ITEM}.make_with_text ("Parent Row"))
--			grid.set_item (4, 3, create {EV_GRID_LABEL_ITEM}.make_with_text ("Sub row"))
--			grid.set_item (8, 4, create {EV_GRID_LABEL_ITEM}.make_with_text ("Sub Sub row"))
--			grid.row (2).add_subrow (grid.row (3))
--			grid.row (3).add_subrow (grid.row (4))
--			grid.row (4).set_item (5, create {EV_GRID_LABEL_ITEM}.make_with_text ("New item"))
--			grid.row (4).set_item (4, create {EV_GRID_LABEL_ITEM}.make_with_text ("New item"))
----			grid.set_item (4, 4, create {EV_GRID_LABEL_ITEM}.make_with_text ("New item"))
--			grid.row (4).set_item (4, create {EV_GRID_LABEL_ITEM}.make_with_text ("New item"))
--			--grid.column (3).set_item (4, create {EV_GRID_LABEL_ITEM}.make_with_text ("New item"))
--			grid.column (4).set_item (4, create {EV_GRID_LABEL_ITEM}.make_with_text ("New item"))


--			-- Test 3
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Top level 1"))
--			from
--				counter := 2
--			until
--				counter > 5
--			loop
--				grid.set_item (1, counter, create {EV_GRID_LABEL_ITEM}.make_with_text ("Sub row " + counter.out))
--				grid.row (counter - 1).add_subrow (grid.row (counter))
--				counter := counter + 1
--			end
--			grid.set_item (1, 6, create {EV_GRID_LABEL_ITEM}.make_with_text ("New Row 6"))
--			grid.set_item (2, 6, create {EV_GRID_LABEL_ITEM}.make_with_text ("New Row 6"))
--			grid.remove_row (5)

			--Test 4
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Top level 1"))
--			grid.row (1).ensure_expandable
--			grid.row_expand_actions.extend (agent expand_row)


--			-- Test 5
--				grid.enable_tree
--            grid.enable_partial_dynamic_content
--            grid.set_column_count_to (3)
--            grid.set_dynamic_content_function (agent compute_grid_item (grid, ?, ?))
--            grid.set_row_count_to (10)

--			-- Test 6
--			grid.enable_tree
--            grid.enable_partial_dynamic_content
--            grid.set_column_count_to (3)
--            grid.set_dynamic_content_function (agent compute_grid_item (grid, ?, ?))
--            grid.set_row_count_to (1)
--            create grid_label_item.make_with_text ("Root dynamic node")
--            grid.set_item (1, 1, grid_label_item)
--			grid.row (1).ensure_expandable
--            grid.row_expand_actions.extend (agent add_subrows)


--			-- Test 7
--			grid.enable_tree
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Top level 1"))

			-- Test 8
--			grid.enable_tree
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Top level 1"))
--			grid.set_item (1, 2, create {EV_GRID_LABEL_ITEM}.make_with_text ("Subrow"))
--			grid.row (1).add_subrow (grid.row (2))
--			grid.row (1).ensure_expandable

--			-- Test 9
--			grid.enable_tree
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Top level 1"))
--			grid.set_item (3, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Top level 1"))
--			grid.insert_new_row_parented (2, grid.row (1))

			-- Test 9
--			create grid_label_item
--			grid_label_item.set_text ("A text")

			-- Test 10
--			grid.enable_tree
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Top level 1"))
--			grid.set_item (3, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Top level 1"))
--			grid.insert_new_row_parented (2, grid.row (1))

			-- Test 11
--			add_items (10, 10)
--			grid.set_item (3, 3, Void)
--			grid.column (5).set_item (5, Void)
--			grid.row (7).set_item (7, Void)
--			grid.row (7).clear
--			grid.column (5).clear
--			grid.clear

--			-- Test 12
--			add_items (10, 10)
--			grid.insert_new_row_parented (6, grid.row (5))
--			grid.row (6).set_item (3, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			grid.row (6).insert_subrow (1)
--			grid.row (6).subrow (1).set_item (3, create {EV_GRID_LABEL_ITEM}.make_with_text ("Second item"))
--			grid.row (6).insert_subrow (1)
--			grid.row (6).subrow (1).set_item (3, create {EV_GRID_LABEL_ITEM}.make_with_text ("First item"))
--			grid.row (6).insert_subrow (3)
--			grid.row (6).subrow (3).set_item (3, create {EV_GRID_LABEL_ITEM}.make_with_text ("Third item"))
--			grid.row (6).insert_subrow (4)
--			grid.row (6).subrow (4).set_item (3, create {EV_GRID_LABEL_ITEM}.make_with_text ("Fourth item"))
--			grid.row (6).insert_subrow (1)
--			grid.row (6).subrow (1).set_item (3, create {EV_GRID_LABEL_ITEM}.make_with_text ("Sneaky Final first item"))
--			grid.row (6).subrow (1).ensure_expandable
--			grid.row_expand_actions.extend (agent expand_row2)

--			-- Test 13
--			grid_label_item ?= grid.item (1, 102)
--			from
--				counter := 1
--			until
--				counter > 10000
--			loop
--				grid_label_item.set_text (counter.out)
--				((create {EV_ENVIRONMENT}).application).process_events
--				counter := counter + 1
--			end

--			-- Test 14
--			add_items (10, 10)
--			grid.enable_single_row_selection
--			grid.row (5).enable_select
--			from
--			until
--				grid.row_count = 0
--			loop
--				grid.remove_row (grid.row_count)
--			end

			-- Test 15
--			create grid_label_item.make_with_text ("A text")
--			GRID.set_item (1, 1, grid_label_item)
--			GRID.set_row_height (50)
--			GRID.column (1).set_width (50)
--			grid.pointer_motion_actions.extend (agent motion_on_item)
--			grid_label_item.set_layout_procedure (agent layout_called)

			-- Test 16
--			grid.enable_tree
--			clean_grid
--			fill_grid
--			clean_grid
--			fill_grid

--			-- Test 17
--			grid.enable_tree
--			grid.insert_new_row (1)
--			grid.insert_new_row (2)
--			grid.row ((2)).insert_subrow (1)
--
--			GRID.ROW (1).SET_DATA (1)
--			GRID.ROW (2).SET_DATA (2)
--			GRID.ROW (3).SET_DATA (3)
----			grid.row ((2)).insert_subrow (2)
--			from
--			until
--				grid.row_count = 0
--			loop
--				grid.remove_row (1)
--			end

			-- Test 18
----			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
----			grid.set_item (2, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
----			grid.remove_row (1)
----			grid.remove_column (2)
----			grid.remove_column (1)
----			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
----			grid.insert_new_row (1)
----			grid.insert_new_row (2)
----			print (grid.row_count)
----			row := grid.row (2)
----			grid.enable_partial_dynamic_content
----			grid.set_column_count_to (3)
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			grid.set_item (1, 2, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			grid.set_item (1, 3, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			grid.set_item (1, 4, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
--			grid.set_item (1, 5, create {EV_GRID_LABEL_ITEM}.make_with_text ("An item"))
----			grid.row (1).set_height (16)
----			grid.row (2).set_height (32)
----			grid.row (3).set_height (48)
--			grid.row (4).set_height (128)
----			grid.row (5).set_height (80)
--			grid.enable_tree
--			grid.row (3).add_subrow (grid.row (4))
--			grid.disable_row_height_fixed


			-- Test 19
--			grid.enable_tree
--			grid.insert_new_row (1)
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("An Item"))


--			-- Test 20
--			grid.enable_tree
--			grid.insert_new_row (1)
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("An Item"))
--			grid.row (1).ensure_expandable
--			grid.row (1).expand_actions.extend (agent expand)
--			grid.item (1, 1).pointer_button_press_actions.force_extend (agent wipe_out_row)

			-- Test 21
--			grid.enable_tree
--			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("item 1"))
--			grid.set_item (1, 2, create {EV_GRID_LABEL_ITEM}.make_with_text ("item 2"))
--			grid.set_item (1, 3, create {EV_GRID_LABEL_ITEM}.make_with_text ("item 2.1"))
--			grid.set_item (1, 4, create {EV_GRID_LABEL_ITEM}.make_with_text ("item 2.1.1"))
--			grid.set_item (1, 5, create {EV_GRID_LABEL_ITEM}.make_with_text ("item 2.1.2"))
--			grid.set_item (1, 6, create {EV_GRID_LABEL_ITEM}.make_with_text ("item 2.2"))
--			grid.row (2).add_subrow (grid.row (3))
--			grid.row (3).add_subrow (grid.row (4))
--			grid.row (3).add_subrow (grid.row (5))
--			grid.row (2).add_subrow (grid.row (6))
--			grid.row (2).remove_subrow (grid.row (6))



--			grid.enable_tree
--			grid.enable_partial_dynamic_content
--			grid.set_dynamic_content_function (agent display)
----			create ordering.make_empty
--			grid.set_row_count_to (10)
--			grid.set_column_count_to (10)
--
--			set_titles(titles)
--			from i := 1 until i > 10 loop
--			--	grid.row(i).set_data(rows.item(i))
--				grid.row(i).ensure_expandable
----				ordering.extend(i)
--				i := i + 1
--			end

--			grid.enable_tree
--		--	grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("item 1"))
--			grid.set_item (1, 2, create {EV_GRID_LABEL_ITEM}.make_with_text ("item 2"))
--			grid.row (1).add_subrow (grid.row (2))
--		--	grid.row (1).clear


			--grid.clear
--			grid.enable_tree
--			add_items (1, 10000)
--			GRID.column (1).set_width (10000)
--			from
--				counter := 1
--			until
--				counter = 5000
--			loop
--				grid.row (counter).add_subrow (grid.row (counter + 1))
--				counter := counter + 1
--			end
--			from
--				counter := 5000
--				counter2 := 5000
--			until
--				counter = 10000
--			loop
--				grid.row (counter2).add_subrow (grid.row (counter + 1))
--				counter := counter + 1
--				counter2 := counter2 - 1
--			end
--			-- Test 22
--			grid.enable_partial_dynamic_content
--			grid.set_column_count_to (10)
--			grid.set_row_count_to (10)
--			grid.set_dynamic_content_function (agent compute_item2)

			-- Test 23
			grid.enable_tree
			grid.set_item (1, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Expand Me"))
			grid.row (1).ensure_expandable
			grid.row (1).expand_actions.extend (agent expand_row3)
		end
	
	expand_row3 is
			--
		do
			if grid.row (1).is_expanded then
				
			end
		end
		
		
	compute_item2 (a_column, a_row: INTEGER): EV_GRID_ITEM is
			--
		do
			if a_column = 1 and a_row = 1 then
				create {EV_GRID_LABEL_ITEM} Result.make_with_text ("1")
				grid.set_item (2, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("2"))
				grid.set_item (3, 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("3"))
			end
		end
		

	display (an_x, a_y: INTEGER): EV_GRID_ITEM is
			--
		do
			create {EV_GRID_LABEL_ITEM} Result.make_with_text ("An item")
			grid.row (a_y).ensure_expandable
		end


	titles: ARRAY [STRING] is
		once
			Result := <<"ONE", "TWO", "THREE">>
		end
		
	set_titles (a_titles : ARRAY[STRING]) is
		local
			i : INTEGER
		do
		--	titles := a_titles
			from i := a_titles.lower until i > a_titles.upper loop
				if i > grid.column_count then
					grid.insert_new_column(i)
				end
				grid.column(i).set_title(a_titles.item(i))
				i := i + 1
			end
		end

	expand is
			--
		do

		end

	wipe_out_row is
			--
		do
	--		grid.row (1).insert_subrow (1)
	--		grid.set_item (1, 2, create {EV_GRID_LABEL_ITEM}.make_with_text ("An Item"))
	--		grid.remove_row (2)
			GRID.ROW (1).ensure_non_expandable
		end
		

	clean_grid is
		do
			from
			until
				grid.row_count = 0
			loop
				grid.remove_row (1)
			end
		ensure
			grid.row_count = 0
		end
		

	fill_grid is
		do
			add_row (1)
			add_row (2)
			add_subrow (grid.row ((2)), 1)
			add_subrow (grid.row ((2)), 2)
			grid.row (2).expand
			add_row (5)
			grid.row (3).enable_select
		end

	add_subrow (r: EV_GRID_ROW; i: INTEGER) is
		local
		do
			r.insert_subrow (i)
			grid.set_item (1, r.index + i, label ((1).out + ":" + (r.index + i).out))
			grid.set_item (2, r.index + i, label ((2).out + ":" + (r.index + i).out))		
			grid.set_item (3, r.index + i, label ((3).out + ":" + (r.index + i).out))			
		end

	add_row (r: INTEGER) is
		do
			grid.insert_new_row (r)
			grid.set_item (1, r, label ((1).out + ":" + r.out))
			grid.set_item (2, r, label ((2).out + ":" + r.out))		
			grid.set_item (3, r, label ((3).out + ":" + r.out))			
		end
	
	label (s: STRING): EV_GRID_LABEL_ITEM is
		do
			create Result.make_with_text (s)
		end

	layout_called (an_item: EV_GRID_LABEL_ITEM; label_item_layout: EV_GRID_LABEL_ITEM_LAYOUT) is
			--
		do
			ii := ii + 1
			if ii > an_item.width then
				ii := 0
			end
			label_item_layout.set_text_x (ii)
		end
		
	ii: INTEGER

	expand_row2 (a_row: EV_GRID_ROW) is
			--
		local
			counter: INTEGER
		do
			if a_row.index = 7 then
				from
					counter := 1
				until
					counter = 100
				loop
					grid.row (7).insert_subrow (1)
					grid.row (7).subrow (1).set_item (3, create {EV_GRID_LABEL_ITEM}.make_with_text ("counter " + counter.out))
					counter := counter + 1
				end
			end
		end
		
		
	add_subrows (a_row: EV_GRID_ROW) is
			--
		local
			counter: INTEGER
		do
			from
				counter := 1
			until
				counter > 200
			loop
				grid.insert_new_row_parented (a_row.index + a_row.subrow_count + 1, a_row)
				counter := counter + 1
			end
		end
		
		
	compute_grid_item (g: EV_GRID; c,r: INTEGER): EV_GRID_ITEM is
		local
			label_item: EV_GRID_LABEL_ITEM
			time: DATE_TIME
	    do
	    	create time.make_now
	 		create label_item.make_with_text (time.out)
	    	Result := label_item
	    end

		
	expand_row (a_row: EV_GRID_ROW) is
			--
		local
			counter: INTEGER
			l_item: EV_GRID_LABEL_ITEM
			new_row: EV_GRID_ROW
		do
			if a_row.subrow_count = 0 then
				from
					counter := 1
				until
					counter > 20
				loop
					create l_item.make_with_text ("Item " + counter.out)
					grid.insert_new_row_parented (a_row.index + a_row.subrow_count + 1, a_row)
					new_row := grid.row (a_row.index + a_row.subrow_count)
					new_row.set_item (1, l_item)
					new_row.ensure_expandable
					counter := counter + 1
				end
			end
		end
		
		
	draw_tree_check_button_selected is
			-- Called by `select_actions' of `draw_tree_check_button'.
		do
			if draw_tree_check_button.is_selected then
				grid.disable_selection_on_click
				grid.pointer_motion_item_actions.wipe_out
				grid.pointer_button_press_item_actions.wipe_out
				grid.pointer_button_release_item_actions.wipe_out
				grid.pointer_button_press_item_actions.extend (agent draw_tree_item_press)
				grid.pointer_button_release_item_actions.extend (agent draw_tree_item_release)
				grid.pointer_motion_item_actions.extend (agent draw_tree_item_motion)
			else
				grid.enable_selection_on_click
				grid.pointer_motion_item_actions.wipe_out
				grid.pointer_button_press_item_actions.wipe_out
				grid.pointer_button_release_item_actions.wipe_out
			end
		end
		
	offsets: ARRAY [INTEGER]	
	
	start_x, start_y: INTEGER
	
	start_item: EV_GRID_ITEM
	
	max_set: INTEGER
		
	draw_tree_item_press (an_x, a_y, button: INTEGER; an_item: EV_GRID_ITEM) is
			--
		do
			if button = 1 and an_item /= Void then
				create offsets.make (1, 100)
				start_x := an_x
				start_y := a_y
				start_item := an_item
				max_set := 0
			else
				start_item := Void
			end
		end
		
		
	draw_tree_item_release (an_x, a_y, button: INTEGER; an_item: EV_GRID_ITEM) is
			--
		local
			counter: INTEGER
			current_indent: INTEGER
			previous_indent: INTEGER
			new_row: EV_GRID_ROW
			parent_row: EV_GRID_ROW
			column_to_check: INTEGER
			column_counter: INTEGER
			total_column_indent: INTEGER
			row_counter: INTEGER
			i: INTEGER
			j: INTEGER
			found: BOOLEAN
			new_row_index: INTEGER
		do
			if button = 1 then

				previous_indent := 0
				from
					counter := 1
				until
					counter > max_set
				loop
					
					current_indent := offsets.item (counter) - start_x
					if offsets.item (counter) = 360 then
						do_nothing
					end

				--	grid.insert_new_row (start_item.row.index + counter)
				--	new_row := grid.row (start_item.row.index + counter)
					new_row_index := start_item.row.index + counter
					
					current_indent := current_indent.max (0)
					parent_row := Void
					column_to_check := start_item.column.index
					total_column_indent := 0
					from
						column_counter := column_to_check
					until
						column_counter > grid.column_count or total_column_indent > current_indent
					loop
						if current_indent > total_column_indent then
							column_to_check := column_counter
						end						
						total_column_indent := total_column_indent + grid.column (column_counter).width
						column_counter := column_counter + 1
					end
					i := 0
					from
						j := 1
					until
						j = column_to_check
					loop
						i := i + grid.column (j).width
						j := j + 1
					end
					found := False
					if parent_row = Void then		
						from
							row_counter := new_row_index - 1
						until
							found or row_counter = start_item.row.index
						loop
							if (grid.item (column_to_check, row_counter) /= Void and grid.row (row_counter).index + grid.row (row_counter).subrow_count_recursive + 1 = new_row_index) then
								if (grid.item (column_to_check, row_counter)).horizontal_indent <= offsets.item (counter) - i then--current_indent then
									--parent_row := grid.row (counter2)
									found := True
								end						
							end
							if not found then
								row_counter := row_counter - 1
							end
						end
						parent_row := grid.row (row_counter)
					end
					
					
					
--					i < row_count and row (i - 1).parent_row_root /= Void and row (i).parent_row_root /= Void implies row (i - 1).parent_row_root /= row (i).parent_row_root
--					grid.insert_new_row (start_item.row.index + counter)
					grid.insert_new_row_parented (new_row_index, parent_row)
					new_row := grid.row (start_item.row.index + counter)
					grid.set_item (column_to_check, new_row_index, create {EV_GRID_LABEL_ITEM}.make_with_text (offsets.item (counter).out))
--					parent_row.add_subrow (new_row)
					if not parent_row.is_expanded then
						parent_row.expand
					end
					counter := counter + 1
					previous_indent := current_indent
				end
				start_item := Void
				draw_tree_check_button.disable_select
			end
		end
		
		
	draw_tree_item_motion (an_x, a_y: INTEGER; an_item: EV_GRID_ITEM) is
			--
		local
			distance_down: INTEGER
			item_index: INTEGER
		do
			if start_item /= Void then
				distance_down := a_y - start_item.virtual_y_position
				item_index := (distance_down // 16) + 1
				if item_index >= offsets.count or else offsets @ item_index < an_x then
					offsets.force (an_x, item_index)
					max_set := item_index.max (item_index)
				end
			end
		end
		
	red: EV_COLOR is
			--
		once
			Result := (create {EV_STOCK_COLORS}).red
		end
		
	enable_pick_and_drop_button_selected is
			-- Called by `select_actions' of `enable_pick_and_drop_button'.
		do
			if enable_pick_and_drop_button.is_selected then
					-- Enable grid item PND
				grid.set_item_pebble_function (agent item_pebble_function)
				grid.set_item_veto_pebble_function (agent item_veto_pebble_function)
				grid.item_drop_actions.extend (agent item_drop_actions)				
			else
					-- Disable grid item PND
				grid.set_item_pebble_function (Void)
				grid.set_item_veto_pebble_function (Void)
				grid.item_drop_actions.wipe_out
			end
		end

	item_pebble_function (a_item: EV_GRID_ITEM): ANY is
			-- Return the text of `a_item' as pebble for Pick And Drop if `a_item' is an EV_GRID_LABEL_ITEM .
		local
			lab_item: EV_GRID_LABEL_ITEM
		do
			lab_item ?= a_item
			if lab_item /= Void then
				Result := lab_item.text
			end
		end

	item_veto_pebble_function (a_item: EV_GRID_ITEM; a_pebble: ANY): BOOLEAN is
			-- Only allow drops on EV_GRID_LABEL_ITEMS.
		local
			lab_item: EV_GRID_LABEL_ITEM
		do
			lab_item ?= a_item
			Result := lab_item /= Void
		end

	item_drop_actions (a_item: EV_GRID_LABEL_ITEM; a_pebble: STRING) is
			-- Set the text to `a_pebble'  if indeed `a_item' is an EV_GRID_ITEM
		do
			if a_item /= Void then
				a_item.set_text (a_pebble)
			end
		end

	icon_view_button_selected is
			-- Called by `select_actions' of `icon_view_button'.
		local
			a_x, a_y: INTEGER
			grid_label_item: EV_GRID_EDITABLE_ITEM--LABEL_ITEM
			pixmaps: ARRAYED_LIST [EV_PIXMAP]
			stock_pixmaps: EV_STOCK_PIXMAPS
		do
			reset_grid
			grid.enable_row_height_fixed
			create pixmaps.make (4)
			create stock_pixmaps
			pixmaps.extend (stock_pixmaps.error_pixmap.twin)
			pixmaps.extend (stock_pixmaps.information_pixmap.twin)
			pixmaps.extend (stock_pixmaps.question_pixmap.twin)
			pixmaps.extend (stock_pixmaps.warning_pixmap.twin)
			from
				pixmaps.start
			until
				grid.row_count = 0
			loop
				grid.remove_row (grid.row_count)
			end
			from
			until
				grid.column_count = 0
			loop
				grid.remove_column (grid.column_count)
			end
			grid.hide_header
			from
				a_x := 1
			until
				a_x > 5
			loop
				from	
					a_y :=1
				until
					a_y > 200
				loop
					create grid_label_item.make_with_text ("Item " + a_x.out + ",  " + a_y.out)
					grid_label_item.set_pixmap (pixmaps.item)
					grid_label_item.disable_full_select
					grid_label_item.set_layout_procedure (agent icon_item_layout)
					grid.set_item (a_x, a_y, grid_label_item)
					pixmaps.forth
					if pixmaps.off then
						pixmaps.start
					end
					a_y := a_y + 1
				end
				a_x := a_x + 1
			end
			grid.set_row_height (grid.column (1).width)
			grid.pointer_double_press_item_actions.extend (agent pointer_double_press_received_on_grid)
			grid.resize_actions.force_extend (agent move_items)
		end

	icon_item_layout (an_item: EV_GRID_LABEL_ITEM; layout: EV_GRID_LABEL_ITEM_LAYOUT) is
			--
		local
			total_heights: INTEGER
		do
			total_heights := an_item.pixmap.height + an_item.text_height + an_item.spacing
			layout.set_pixmap_x ((an_item.width - an_item.pixmap.width) // 2)
			layout.set_pixmap_y ((an_item.height - total_heights) // 2)
			layout.set_text_x ((an_item.width - an_item.text_width) // 2)
			layout.set_text_y (layout.pixmap_y + an_item.pixmap.height + an_item.spacing)
		end

	move_items is
			--
		local
			l_width: INTEGER
			an_x, a_y: INTEGER
			items: ARRAYED_LIST [EV_GRID_ITEM]
		do
			create items.make (10)
			l_width := grid.width
			from
				an_x := 1
			until
				an_x > grid.row_count
			loop
				from
					a_y := 1
				until
					a_y > grid.column_count
				loop
					if grid.item (a_y, an_x) /= Void then
						items.extend (grid.item (a_y, an_x))
						grid.set_item (a_y, an_x, Void)
					end
					a_y := a_y + 1
				end
				an_x := an_x + 1
			end
			an_x := 1
			a_y := 1
			from
				items.start
			until
				items.off
			loop
				grid.set_item (an_x, a_y, items.item)
				an_x := an_x + 1
				if an_x * 80 > l_width - 20 then
					from
					until
						grid.column_count < an_x
					loop
						grid.remove_column (grid.column_count)
					end
					an_x := 1
					a_y := a_y + 1
				end
				items.forth
			end
			from
			until
				grid.row_count < a_y
			loop
				grid.remove_row (grid.row_count)
			end
		end

	colored_button_selected is
			-- Called by `select_actions' of `colored_button'.
		local
			i: INTEGER
		do
			reset_grid
			grid.enable_tree
			add_items (5, 100)--500)
			grid.column (1).set_background_color (light_blue)
			grid.column (2).set_background_color (light_red)
			grid.set_background_color (light_green)
			from
				i := 5
			until
				i > 10
			loop
				grid.row (i).add_subrow (grid.row (i + 1))
				grid.row (i).expand
				i := i + 1
			end
			grid.column (1).set_width (200)
			from
				i := 1
			until
				i > grid.row_count
			loop
				if i \\ 2 = 1 then
					grid.item (4, i).set_background_color (stock_colors.white)
				else
					grid.item (4, i).set_background_color (light_blue)
				end
				i := i + 1
			end
			from
				i := 15
			until
				i = 20
			loop
				grid.row (i).set_background_color (stock_colors.yellow)
				grid.row (i).set_item (2, Void)
				i := i + 1
			end
			grid.row (7).set_background_color (stock_colors.yellow)
			grid.row (8).set_background_color (stock_colors.yellow)
			grid.pointer_double_press_item_actions.extend (agent item_double_pressed)
		end

	item_double_pressed (an_x, a_y, a_button: INTEGER; an_item: EV_GRID_ITEM) is
			--
		do
			if an_item /= Void then
				an_item.activate
			end
		end		

	columns_drawn_above_rows_button_selected is
			-- Called by `select_actions' of `columns_drawn_above_rows_button'.
		do
			if columns_drawn_above_rows_button.is_selected then
				grid.enable_columns_drawn_above_rows
			else
				grid.disable_columns_drawn_above_rows
			end
		end

	foreground_color_combo_selected is
			-- Called by `select_actions' of `foreground_color_combo'.
		local
			color: EV_COLOR
		do
			color ?= foreground_color_combo.selected_item.data
			if color /= Void then
				grid.set_foreground_color (color)
			end
		end
	
	background_color_combo_selected is
			-- Called by `select_actions' of `background_color_combo'.
		local
			color: EV_COLOR
		do
			color ?= background_color_combo.selected_item.data
			if color /= Void then
				grid.set_background_color (color)
			end
		end

	is_column_resize_immediate_button_selected is
			-- Called by `select_actions' of `is_column_resize_immediate_button'.
		do
			if is_column_resize_immediate_button.is_selected then
				grid.enable_column_resize_immediate
			else
				grid.disable_column_resize_immediate
			end
		end

	remove_all_row_button_selected is
			-- Called by `select_actions' of `remove_all_rows_button'.
		do
			from
			until
				grid.row_count = 0
			loop
				grid.remove_row (grid.row_count)
			end
		end
	
	remove_all_columns_button_selected is
			-- Called by `select_actions' of `remove_all_columns_button'.
		do
			from
			until
				grid.column_count = 0
			loop
				grid.remove_column (grid.column_count)
			end
		end

	are_row_separators_enabled_button_selected is
			-- Called by `select_actions' of `are_row_separators_enabled_button'.
		do
			if are_row_separators_enabled_button.is_selected then
				grid.enable_row_separators
			else
				grid.disable_row_separators
			end
		end
	
	are_column_separators_enabled_button_selected is
			-- Called by `select_actions' of `are_column_separators_enabled_button'.
		do
			if are_column_separators_enabled_button.is_selected then
				grid.enable_column_separators
			else
				grid.disable_column_separators
			end
		end

	separator_color_combo_selected is
			-- Called by `select_actions' of `separator_color_combo'.
		local
			a_color: EV_COLOR
		do
			a_color ?= separator_color_combo.selected_item.data
			if a_color /= Void then
				grid.set_separator_color (a_color)
			end
		end
		
	clear_items_button_selected is
			-- Called by `select_actions' of `clear_items_button'.
		do
			grid.clear
		end
		
	overlay_test_button_selected is
			-- Called by `select_actions' of `overlay_test_button'.
		do
			reset_grid
			add_items (6, 50)
			grid.enable_multiple_item_selection
			grid.item_select_actions.extend (agent item_selection_changed)
			grid.item_deselect_actions.extend (agent item_selection_changed)
			grid.post_draw_overlay_actions.extend (agent post_draw_event)
		end

	black: EV_COLOR is
			--
		once
			create Result.make_with_8_bit_rgb (0, 0, 0)
		end

	item_selection_changed (an_item: EV_GRID_ITEM) is
			--
		local
			an_x: INTEGER
			a_y: INTEGER
			final_x, final_y: INTEGER
		do

			final_x := (an_item.column.index + 1).min (grid.column_count)
			final_y := (an_item.row.index + 1).min (grid.row_count)
			from
				an_x := (an_item.column.index - 1).max (1)
			until
				an_x > final_x
			loop
				from
				a_y := (an_item.row.index - 1).max (1)
				until
					a_y > final_y
				loop
					grid.item (an_x, a_y).redraw
					a_y := a_y + 1
				end
				an_x := an_x + 1
			end
		end

	post_draw_event (a_drawable: EV_DRAWABLE; an_item: EV_GRID_ITEM; a_column_index, a_row_index: INTEGER) is
			--
		local
			item1, item2, item3, item4, item5, item6, item7, item8: EV_GRID_ITEM
		do
			if an_item /= Void then
				a_drawable.set_foreground_color (black)
				if an_item.is_selected then
					if an_item.column.index = 1 then
						a_drawable.fill_rectangle (0, 0, 4, an_item.height)
					else
						item4 := grid.item (an_item.column.index - 1, an_item.row.index)
						if not item4.is_selected then
							a_drawable.fill_rectangle (0, 0, 4, an_item.height)
						end
					end
	
					if an_item.column.index = grid.column_count then
						a_drawable.fill_rectangle (an_item.width - 4, 0, 4, an_item.height)
					else
						item5 := grid.item (an_item.column.index + 1, an_item.row.index)
						if not item5.is_selected then
							a_drawable.fill_rectangle (an_item.width - 4, 0, 4, an_item.height)
						end
					end
					if an_item.row.index = 1 then
						a_drawable.fill_rectangle (0, 0, an_item.width, 4)
					else
						item2 := grid.item (an_item.column.index, an_item.row.index - 1)
						if not item2.is_selected then
							a_drawable.fill_rectangle (0, 0, an_item.width, 4)
						end
					end
	
					if an_item.row.index = grid.row_count then
						a_drawable.fill_rectangle (0, an_item.height - 4, an_item.width, 4)
					else
						item7 := grid.item (an_item.column.index, an_item.row.index + 1)
						if not item7.is_selected then
							a_drawable.fill_rectangle (0, an_item.height - 4, an_item.width, 4)
						end
					end
					if an_item.row.index > 1 then
						if an_item.column.index > 1 then
							item1 := grid.item (an_item.column.index - 1, an_item.row.index - 1)
						end
						if an_item.column.index < grid.column_count then
							item3 := grid.item (an_item.column.index + 1, an_item.row.index - 1)
						end
					end
					if an_item.row.index < grid.row_count then
						if an_item.column.index > 1 then
							item6 := grid.item (an_item.column.index - 1, an_item.row.index + 1)
						end
						if an_item.column.index < grid.column_count then
							item8 := grid.item (an_item.column.index + 1, an_item.row.index + 1)
						end
					end
					if item4 /= Void and item7 /= Void and then item7.is_selected and then item4.is_selected and then not item6.is_selected then
						a_drawable.fill_rectangle (0, an_item.height - 4, 4, 4)
					end
					if item4 /= Void and item2 /= Void and then item4.is_selected and then item2.is_selected and then not item1.is_selected then
						a_drawable.fill_rectangle (0, 0, 4, 4)
					end
					if item5 /= Void and item2 /= Void and then item5.is_selected and then item2.is_selected and then not item3.is_selected then
						a_drawable.fill_rectangle (an_item.width - 4, 0, 4, 4)
					end
					if item5 /= Void and item7 /= Void and then item5.is_selected and then item7.is_selected and then not item8.is_selected then
						a_drawable.fill_rectangle (an_item.width - 4, an_item.height - 4, 4, 4)
					end
				end
			end
		end

	texture_test_button_selected is
			-- Called by `select_actions' of `texture_test_button'.
		local
			combo_item: EV_GRID_COMBO_ITEM
			counter: INTEGER
		do
			reset_grid
			grid.enable_tree
			add_items (5, 100)
			from
				counter := 20
			until
				counter > 40
			loop
				grid.row (counter).add_subrow (grid.row (counter + 1))
				counter := counter + 1
			end
			grid.insert_new_row (1)
			grid.column (1).set_width (200)
			grid.column (2).set_width (150)
			grid.disable_row_height_fixed
			grid.row (1).set_height (32)
			from
				counter := 5
			until
				counter > 20
			loop
				grid.remove_item (3, counter)
				grid.remove_item (2, counter)
				counter := counter + 1
			end
			grid.pointer_button_press_item_actions.extend (agent grid_pressed)
			create combo_item.make_with_text ("Texture applied to : None")
			combo_item.activate_actions.extend (agent build_combo_box1 (?, combo_item))

			grid.set_item (1, 1, combo_item)
			create combo_item.make_with_text ("Scroll Texture : True")
			combo_item.activate_actions.extend (agent build_combo_box2 (?, combo_item))
			grid.set_item (2, 1, combo_item)
			grid.pre_draw_overlay_actions.extend (agent draw_texture)
			grid.post_draw_overlay_actions.extend (agent draw_borders)
			grid.fill_background_actions.extend (agent draw_background)
			texture_style := 1
			scroll_style := 1
		end

	build_combo_box1 (window: EV_POPUP_WINDOW; combo: EV_GRID_COMBO_ITEM) is
			--
		local
			list_item: EV_LIST_ITEM
		do
			combo.combo_box.select_actions.block
			create list_item.make_with_text ("None")
			combo.combo_box.extend (list_item)
			create list_item.make_with_text ("Background")
			combo.combo_box.extend (list_item)
			create list_item.make_with_text ("All")
			combo.combo_box.extend (list_item)
			if texture_style = 2 then
				combo.combo_box.i_th (2).enable_select
			elseif texture_style = 3 then
				combo.combo_box.i_th (3).enable_select
			end
			combo.combo_box.select_actions.extend (agent combo_item_selected (combo.combo_box))
			combo.combo_box.select_actions.resume
		end

	build_combo_box2 (window: EV_POPUP_WINDOW; combo: EV_GRID_COMBO_ITEM) is
			--
		local
			list_item: EV_LIST_ITEM
		do
			combo.combo_box.select_actions.block
			create list_item.make_with_text ("True")
			combo.combo_box.extend (list_item)
			create list_item.make_with_text ("False")
			combo.combo_box.extend (list_item)
			if scroll_style = 2 then
				combo.combo_box.i_th (2).enable_select
			end
			combo.combo_box.select_actions.extend (agent combo_scroll_item_selected (combo.combo_box))
			combo.combo_box.select_actions.resume
		end

	combo_item_selected (a_combo_box: EV_COMBO_BOX) is
			--
		require
			a_combo_box_not_void: a_combo_box /= Void
		local
			selected_index: INTEGER
			label_item: EV_GRID_LABEL_ITEM
		do
			selected_index := a_combo_box.index_of (a_combo_box.selected_item, 1)
			label_item ?= grid.item (1, 1)
			inspect selected_index
			when 1 then
				texture_style := 1
				label_item.set_text ("Texture applied to : None")
			when 2 then
				texture_style := 2
				label_item.set_text ("Texture applied to : Background")
			else
				texture_style := 3
				label_item.set_text ("Texture applied to : All")
			end
			grid.redraw
		end
		
	combo_scroll_item_selected (a_combo_box: EV_COMBO_BOX) is
			--
		require
			a_combo_box_not_void: a_combo_box /= Void
		local
			selected_index: INTEGER
			label_item: EV_GRID_LABEL_ITEM
		do
			selected_index := a_combo_box.index_of (a_combo_box.selected_item, 1)
			label_item ?= grid.item (2, 1)
			inspect selected_index
			when 1 then
				scroll_style := 1
				label_item.set_text ("Scroll Texture : True")
				grid.disable_full_redraw_on_virtual_position_change
			when 2 then
				scroll_style := 2
				label_item.set_text ("Scroll Texture : False")
				grid.enable_full_redraw_on_virtual_position_change
			end
			grid.redraw
		end
		
	scroll_style: INTEGER

	texture_style: INTEGER		

	grid_pressed (an_x, a_y, a_button: INTEGER; grid_item: EV_GRID_ITEM) is
			--
		do
			if grid_item /= Void and then a_button = 1 then
				if grid_item.column.index <= 2 and grid_item.row.index = 1 then
					grid_item.activate
				end
			end
		end
		
	draw_background (drawable: EV_DRAWABLE; a_virtual_x, a_virtual_y, a_width, a_height: INTEGER) is
			--
		local
			an_x, a_y: INTEGER
			virtual_x, virtual_y: INTEGER
		do
			if texture_style > 1 then
				virtual_x := a_virtual_x
				if scroll_style = 2 then
					virtual_x := virtual_x - grid.virtual_x_position
				end
				an_x := (virtual_x \\ texture_width)
				virtual_y := a_virtual_y
				if scroll_style = 2 then
					virtual_y := virtual_y - grid.virtual_y_position
				end
				a_y := (virtual_y \\ texture_height)
				if (texture_style = 2) or texture_style = 3 then
					internal_draw_texture (drawable, an_x, a_y, a_width, a_height)
				end
			else
				drawable.set_foreground_color (grid.background_color)
				drawable.fill_rectangle (0, 0, a_width, a_height)
			end
		end


	draw_texture (drawable: EV_DRAWABLE; grid_item: EV_GRID_ITEM; a_column_index, a_row_index: INTEGER) is
			--
		local
			an_x, a_y: INTEGER
			virtual_x, virtual_y: INTEGER
			a_height, a_width: INTEGER
			indent: INTEGER
		do
			if texture_style > 1 then
				if a_row_index > 1 or a_column_index > 2 then
					virtual_x := grid.column (a_column_index).virtual_x_position
					if scroll_style = 2 then
						virtual_x := virtual_x - grid.virtual_x_position
					end
					an_x := (virtual_x \\ texture_width)
					virtual_y := grid.row (a_row_index).virtual_y_position
					if scroll_style = 2 then
						virtual_y := virtual_y - grid.virtual_y_position
					end
					a_y := (virtual_y \\ texture_height)
					if grid.is_row_height_fixed then
						a_height := grid.row_height
					else
						a_height  := grid.row (a_row_index).height
					end
					a_width := grid.column (a_column_index).width
					if (texture_style = 2 and grid_item = Void) or texture_style = 3 then
						internal_draw_texture (drawable, an_x, a_y, a_width, a_height)
					else
						indent := grid_item.horizontal_indent
						if indent > 0 then
							internal_draw_texture (drawable, an_x, a_y, indent, a_height)
						end
					end
				end
			end
		end
		
	internal_draw_texture (drawable: EV_DRAWABLE; texture_x, texture_y, a_width, a_height: INTEGER) is
			--
		local
			an_x, a_y: INTEGER
			last_x_segment, last_y_segment: INTEGER
			current_texture_x, current_texture_Y: INTEGER
		do
			from
				an_x := 0
				current_texture_x := texture_x
			until
				an_x >= a_width
			loop
				last_x_segment := (texture_width - current_texture_x).min (a_width - an_x)
				from
					a_y := 0
					current_texture_y := texture_y
				until
					a_y >= a_height
				loop
					last_y_segment := (texture_height - current_texture_y).min (a_height - a_y)
					drawable.draw_sub_pixmap (an_x, a_y, marble, create {EV_RECTANGLE}.make (current_texture_x, current_texture_y, last_x_segment, last_y_segment))
					current_texture_y := 0
					a_y := a_y + last_y_segment
				end
				drawable.draw_sub_pixmap (an_x, a_y, marble, create {EV_RECTANGLE}.make (current_texture_x, current_texture_y, last_x_segment, last_y_segment))
				current_texture_x := 0
				an_x := an_x + last_x_segment
			end
		end
		

	draw_borders (drawable: EV_DRAWABLE; grid_item: EV_GRID_ITEM; a_column_index, a_row_index: INTEGER) is
			--
		do

			if a_row_index = 1 then
				if grid_item /= Void then
					drawable.set_foreground_color (black)
					drawable.fill_rectangle (0, grid_item.height - 4, grid.column (a_column_index).width, grid_item.height)
					drawable.set_foreground_color (black)
					drawable.fill_rectangle (0, 0, grid.column (a_column_index).width, 4)
				end
				if a_column_index = 1 then
					drawable.set_foreground_color (black)
					drawable.fill_rectangle (0, 0, 4, grid_item.height - 4)
				elseif a_column_index = 2 then
					drawable.set_foreground_color (black)
					drawable.fill_rectangle (grid.column (a_column_index).width - 4, 0, grid.column (a_column_index).width - 4, grid_item.height - 4)
				end
			end
		end

	bubbles_pixmap: EV_PIXMAP is
			--
		once
			create Result
			Result.set_size (texture_width * 2, texture_height * 2)
			Result.draw_pixmap (0, 0, marble)
			Result.draw_pixmap (texture_width, 0, marble)
			Result.draw_pixmap (0, texture_height, marble)
			Result.draw_pixmap (texture_width, texture_height, marble)
		end

	texture_width: INTEGER is 256

	texture_height: INTEGER is 256
		
end -- class GRID_TAB

