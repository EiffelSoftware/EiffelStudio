<!DOCTYPE HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<HTML>
	<HEAD>
		<TITLE>Thread library overview</TITLE>
		<META NAME="MS-HKWD" CONTENT="thread library overview">
		<LINK REL=Stylesheet HREF="../../../default.css" TYPE="text/css">
	</HEAD>

	<BODY>
<H1>Thread library overview</H1>
<p>This is only a quick overview of the <A HREF="/libraries/thread/index.html">Thread library</a>. The reference of this
library should give all its content.</p>
<h2>Creating and launching threads: the class <SPAN CLASS="eclass">THREAD</SPAN> (deferred)</h2>
<p>The class of the thread object you want to create should inherit the <SPAN CLASS="eclass">THREAD</SPAN> class.<br>
Your thread is represented by a class which inherits from <SPAN CLASS="eclass">THREAD</SPAN> (deferred
class).<br>
<pre>	<SPAN CLASS="ekeyword">class</SPAN>
		<SPAN CLASS="eclass">MY_THREAD</SPAN>

	<SPAN CLASS="ekeyword">inherit</SPAN>
		<SPAN CLASS="eclass">THREAD></SPAN>
		...

	<SPAN CLASS="ekeyword">feature</SPAN>

		<SPAN CLASS="efeature">execute</SPAN> <SPAN CLASS="ekeyword">is</SPAN>
			<SPAN CLASS="ecomment">-- define the deferred feature from THREAD.</SPAN>
		<SPAN CLASS="ekeyword">do</SPAN>
			...
		<SPAN CLASS="ekeyword">end</SPAN>
		...

	<SPAN CLASS="ekeyword">end</SPAN> <SPAN CLASS="ecomment">--class MY_THREAD</SPAN>

</pre>
Creating a thread is like creating an Eiffel object:
<pre>	<SPAN CLASS="elocal">my_thread</SPAN><SPAN CLASS="esymbol">:</SPAN> <SPAN CLASS="eclass">MY_THREAD</SPAN>
		<SPAN CLASS="ecomment">-- MY_THREAD inherits from THREAD and defines</SPAN>
		<SPAN CLASS="ecomment">-- the deferred procedure `execute'</SPAN>

	<SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">my_thread</SPAN></pre>
<p class="note"><b>Note</b>: You have created a thread object but have not started the thread itself yet.<br>
To run the thread, use the feature <SPAN CLASS="efeature">launch</SPAN> from <SPAN CLASS="eclass">THREAD</SPAN>.</P>
<pre>	<SPAN CLASS="elocal">my_thread</SPAN><SPAN CLASS="esymbol">.</SPAN><SPAN CLASS="efeature">launch</SPAN></pre>
On the Eiffel side, the procedure <SPAN CLASS="efeature">execute</SPAN> will be launched. This procedure
is deferred in class <SPAN CLASS="eclass">THREAD</SPAN>, you have to define it in <SPAN CLASS="eclass">MY_THREAD</SPAN>.&nbsp;
<p>On the C side, a C thread will be created and launched.<p class="warning"><B>Caution</B>: you may call <SPAN CLASS="efeature">join_all</SPAN> and the end of the exceution of the
parent thread if you do not want it to die before its child, otherwise
they may prematurily terminate.
<h2>The class <SPAN CLASS="eclass">MUTEX</SPAN></h2>
<p>The implementation of the class <SPAN CLASS="eclass">MUTEX</SPAN> is mapped on the C standard thread
library. An instance of class <SPAN CLASS="eclass">MUTEX</SPAN> can be shared between different thread.
<p><SPAN CLASS="elocal">my_mutex</SPAN><SPAN CLASS="esymbol">.</SPAN><SPAN CLASS="efeature">pointer</SPAN> is the pointer to the nested C mutex of <SPAN CLASS="elocal">my_mutex</SPAN>.
<UL>
<LI>Declaration of the mutex:
<pre>	<SPAN CLASS="elocal">my_mutex</SPAN><SPAN CLASS="esymbol">:</SPAN> <SPAN CLASS="eclass">MUTEX</SPAN></pre>
<LI>Creation of mutex:
<pre>	<SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">my_mutex</SPAN><SPAN CLASS="esymbol">.</SPAN><SPAN CLASS="efeature">make</SPAN></pre>
<LI>Locking the mutex:
<pre>	<SPAN CLASS="elocal">my_mutex</SPAN><SPAN CLASS="esymbol">.</SPAN><SPAN CLASS="efeature">lock</SPAN></pre>
<LI>Unlocking the mutex:
<pre>	<SPAN CLASS="elocal">my_mutex</SPAN><SPAN CLASS="esymbol">.</SPAN><SPAN CLASS="efeature">unlock</SPAN></pre>
<LI><SPAN CLASS="efeature">try_lock</SPAN>: if it is not locked yet, lock the mutex and return True, otherwise
it returns False.
<pre>	<SPAN CLASS="elocal">my_mutex</SPAN><SPAN CLASS="esymbol">.</SPAN><SPAN CLASS="efeature">try_lock</SPAN></pre>
<LI>Is my mutex initialized?
<pre>	<SPAN CLASS="elocal">my_mutex</SPAN><SPAN CLASS="esymbol">.</SPAN><SPAN CLASS="efeature">is_set</SPAN></pre>
</UL>
<P CLASS="note"><B>Note</B>: on Windows: The <SPAN CLASS="eclass">MUTEX</SPAN> objects on Windows are recursive while they are not on Unix. A
recursive mutex can be locked twice by the same thread.</P>
<p CLASS="warning"><B>Caution</B>: be sure that a mutex is unlocked when it is disposed.</P>
<h2>The class <SPAN CLASS="eclass">SEMAPHORE</SPAN></h2>
<p>Like <SPAN CLASS="eclass">MUTEX</SPAN>, the features of this class are mapped on the C thread library. An
instance of class <SPAN CLASS="eclass">SEMAPHORE</SPAN> can be shared between thread.
<UL>
<LI>Declaration of the semaphore :
<pre>	<SPAN CLASS="elocal">my_sem</SPAN><SPAN CLASS="esymbol">:</SPAN> <SPAN CLASS="eclass">SEMAPHORE</SPAN></pre>
Creation of semaphore: initialize semaphore with nb_tokens, it requires
nb_tokens &gt;= 0
<pre>	<SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">my_sem</SPAN><SPAN CLASS="esymbol">.</SPAN>make (nb_tokens)</pre>
<LI>Wait for a token:
<pre>	<SPAN CLASS="elocal">my_sem</SPAN><SPAN CLASS="esymbol">.</SPAN>wait</pre>
<LI>Give back a token:
<pre>	<SPAN CLASS="elocal">my_sem</SPAN><SPAN CLASS="esymbol">.</SPAN>post</pre>
<LI><SPAN CLASS="efeature">try_wait</SPAN>, similar to try_lock from <SPAN CLASS="eclass">MUTEX</SPAN>, if a token is available, take
it and return <SPAN CLASS="esymbol">True</SPAN>, otherwise return <SPAN CLASS="esymbol">False</SPAN>.
<pre>	<SPAN CLASS="elocal">my_sem</SPAN><SPAN CLASS="esymbol">.</SPAN>try_wait</pre>
</UL>
<p class="warning"><B>Caution</B>: be sure that a semaphore does not wait for a token when it is
disposed</p>
<h2>The class <SPAN CLASS="eclass">CONDITION_VARIABLE</SPAN></h2>
<p>This class allows to use condition variables in Eiffel. An instance of class
<SPAN CLASS="eclass">CONDITION_VARIABLE</SPAN> can be shared between threads.<br>
<UL>
<LI>Declaration of the condition variable
<pre>	<SPAN CLASS="elocal">my_cond</SPAN><SPAN CLASS="esymbol">:</SPAN> <SPAN CLASS="eclass">CONDITION_VARIABLE</SPAN></pre>
<LI>Creation:
<pre>	<SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">my_cond</SPAN><SPAN CLASS="esymbol">.</SPAN><SPAN CLASS="efeature">make</SPAN></pre>
<LI>Wait for a signal (send by <SPAN CLASS="efeature">signal</SPAN>). You need to use a mutex.
<pre>	<SPAN CLASS="elocal">my_mutex</SPAN><SPAN CLASS="esymbol">:</SPAN> <SPAN CLASS="eclass">MUTEX</SPAN>

	<SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">my_mutex</SPAN><SPAN CLASS="esymbol">.</SPAN><SPAN CLASS="efeature">make</SPAN></pre>
<p><SPAN CLASS="elocal">my_mutex</SPAN> must be locked by the calling thread so as <SPAN CLASS="efeature">wait</SPAN> can be called.
<SPAN CLASS="efeature">wait</SPAN> atomically unlocks <SPAN CLASS="elocal">my_mutex</SPAN> and waits for the condition variable
<SPAN CLASS="elocal">my_mutex</SPAN> to receive a signal. As soon as it received a signal, <SPAN CLASS="elocal">my_cond</SPAN> locks
<SPAN CLASS="elocal">my_mutex</SPAN>;
<pre>	<SPAN CLASS="elocal">my_mutex</SPAN><SPAN CLASS="esymbol">.</SPAN><SPAN CLASS="efeature">lock</SPAN>
		<SPAN CLASS="ecomment">-- You must lock `my_mutex' before calling <SPAN CLASS="efeature">wait</SPAN>.</SPAN>

	<SPAN CLASS="elocal">my_cond</SPAN><SPAN CLASS="esymbol">.</SPAN><SPAN CLASS="efeature">wait</SPAN> <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">my_mutex</SPAN><SPAN CLASS="esymbol">)</SPAN>
		<SPAN CLASS="ecomment">-- Here the critical code to execute when `my_cond' received a signal.</SPAN>

	<SPAN CLASS="elocal">my_mutex</SPAN><SPAN CLASS="esymbol">.</SPAN>unlock
		<SPAN CLASS="ecomment">-- Unlock the mutex at the end of the critical section.</SPAN>

	</pre>
<LI>Send a signal one thread blocked on the condition variable `my_cond'.
<pre>	<SPAN CLASS="elocal">my_cond</SPAN><SPAN CLASS="esymbol">.</SPAN><SPAN CLASS="efeature">signal</SPAN></pre>
<LI>Send a signal to all the threads blocked on the condition variable `my_cond'.
<pre>	<SPAN CLASS="elocal">my_cond</SPAN><SPAN CLASS="esymbol">.</SPAN><SPAN CLASS="efeature">broadcast</SPAN></pre>
</UL>
<p class="warning"><B>Caution</B>: be sure that a condition variable is unblocked when it is
disposed.</p>
<h2>Miscellaneous classes</h2>
<p>class <SPAN CLASS="eclass">THREAD_ATTRIBUTES</SPAN>: defines the
attributes of an Eiffel Thread regarding the thread scheduling policy and
priority.<br>
<h2>Controlling execution: <SPAN CLASS="eclass">THREAD_CONTROL</SPAN></h2>
<UL>
<LI><SPAN CLASS="efeature">yield</SPAN>: the calling thread yields its execution in favor of an other
thread of same priority.
<LI><SPAN CLASS="efeature">join_all</SPAN>: the calling thread waits for all other threads to finished (all
its children).
<LI>A parent thread can wait for the termination of a child process through
the feature <SPAN CLASS="efeature">join</SPAN> of class <SPAN CLASS="eclass">THREAD_CONTROL</SPAN> (inherited by <SPAN CLASS="eclass">THREAD</SPAN>):
<pre>	<SPAN CLASS="elocal">thr</SPAN><SPAN CLASS="esymbol">:</SPAN> <SPAN CLASS="eclass">MY_THREAD</SPAN>
	<SPAN CLASS="esymbol">...</sPAN>
	<SPAN CLASS="elocal">thr</SPAN><SPAN CLASS="esymbol">.</SPAN><SPAN CLASS="efeature">launch</SPAN>
	<SPAN CLASS="esymbol">...</SPAN>
	<SPAN CLASS="elocal">thr</SPAN><SPAN CLASS="esymbol">.</SPAN><SPAN CLASS="efeature">join</SPAN></pre>

</BODY>
</HTML>