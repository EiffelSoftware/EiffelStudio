note
	description: "Summary description for {DATA_THREAD_POOL_MANAGER}."
	author: "sandro"
	date: "$Date$"
	revision: "$Revision$"

class
	DATA_THREAD_POOL_MANAGER [G]

inherit
	THREAD_POOL_MANAGER [G]
		redefine
			make_thread_available,
			add_work
		end

create
	make_with_managed_target

feature {NONE} -- Access

	target_pool: POOL [G]
			-- Holds data for reuse, if needed

feature -- Access

	target_count: NATURAL
		do
			Result := target_pool.count
		end
			-- Counts the number of spawned data objects

feature {NONE} -- Initialization

	make_with_managed_target (max_number_of_threads: NATURAL; a_target_spawner: FUNCTION [ANY, TUPLE, G])
		-- The targets are generated by the `a_target_spawner'
		-- The maximal number of threads that can be spawned is stored in `max_number_of_threads'.
		-- If this limit is reached, the requests are queued, until one of the threads is completed.
	require
		data_spawner_has_no_open_arguments: a_target_spawner.valid_operands (Void)
		non_negative_number: max_number_of_threads >= 0
	do
		make (max_number_of_threads)
		create target_pool.make (max_number_of_threads, a_target_spawner)
	end

feature -- Access

	add_work (a_work: PROCEDURE [G, TUPLE])
			-- Launches a thread with the a target spawned with the target_spawner (see constructor).
			-- Pooling of thread and target.
		local
			l_thread: POOLED_THREAD [G]
			l_target: G
		do
				-- Wait, until possible to lock
			pool_mutex.lock

			if thread_pool.unused_objects_count = 0 and thread_pool.count = max_threads then
				queue (a_work)
				--print ("queue " + count.out + " data " +  work_queue.count.out+ " " + available_count.out + "%N")
			else
				l_thread := retrieve_available_thread
				l_target := retrieve_available_target
				l_thread.launch_work_with_data(a_work, l_target)
				--print ("launch " + count.out + " data " +  work_queue.count.out+ " " + available_count.out + "%N")
			end

				-- Let the other threads launch/lock		
			pool_mutex.unlock
		end

feature {DATA_THREAD_POOL_MANAGER} -- Internal

	retrieve_available_target: G
			-- Returns an unused thread, this method is thread safe
		require else
			not_too_many_data_objects: target_count <= maximal_thread_number
		do
			if not target_pool.has_unused_objects then
				target_pool.spawn_new_object
			end
			Result := target_pool.retrieve_available_object
			--print ("retrieve_target " + count.out + " " + target_count.out + " " +  work_queue.count.out+ " " + available_count.out + "%N")
		ensure then
			not_too_many_data_objects: target_count <= max_threads
		end

	make_thread_available (a_thread: POOLED_THREAD [G])
			-- This method only exists to make the ensure thread safe
		do
			--print ("reentrant thread " + count.out + " " + target_count.out + " " +  work_queue.count.out+ " " + available_count.out + "%N")
			target_pool.ready (a_thread.fetch_data)
			thread_pool.ready (a_thread)
			a_thread.wait
		ensure then
			more_threads_available: thread_pool.unused_objects_count > old thread_pool.unused_objects_count
			more_targets_available: target_pool.unused_objects_count > old target_pool.unused_objects_count
		end

end
