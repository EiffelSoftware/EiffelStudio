<document title="Similar Types Occurring in Both Libraries"><meta_data ><help ><toc ><envision_pseudo_name>50</envision_pseudo_name><envision_location>Eiffel, The Language\The Eiffel for .NET Language\Conventions</envision_location><envision_title >Similar Types</envision_title><studio_location /><studio_title /></toc></help></meta_data><paragraph ><heading ><size >1</size>Similar Types Occurring in Both Libraries</heading><heading ><size >2</size>Whose String is it anyway?</heading><paragraph >Over the last 15 years or so, the Eiffel class libraries have been a source for reusable software components for developers. </paragraph><paragraph >The Eiffel Base library contains classes for commonly used objects like different kinds of numbers, strings, files, and data structures. </paragraph><paragraph >But there are also libaries of Eiffel classes for sophisticated purposes like lexical analysis andparsing, data access,and graphical user interface development. </paragraph><paragraph >Likewise .NET is delivered with assemblies containing thousands of powerful types with similar purposes. </paragraph><heading ><size >3</size>Working in Both Worlds</heading><paragraph >When we build software that has access to both the rich Eiffel libraries and the many useful .NET types, we inevitably run into types from both worlds that have similar names and purposes, but are still different types with different semantics. </paragraph><heading ><size >3</size>The Case of Strings</heading><paragraph >The example of these similar types which will almost certainly get in your face is the string types. You may remember that we looked briefly at the case of the string types in<link ><url /><label >Naming Conventions and Name Handling</label></link>. </paragraph><paragraph >The Eiffel Base Library contains class <code ><class_name >STRING</class_name></code>; the .NET assembly contains type <code ><class_name >System. String</class_name></code>, which Eiffel for .NETusers see as <code ><class_name >SYSTEM_STRING</class_name></code>. At an abstract level both of these model sequences of characters. But they are not the same type. In fact, they are different in some important ways. For example, instances of <code ><class_name >System. String</class_name></code> are immutable. So you cannot append to an instance of <code ><class_name >System. String</class_name></code>. If you want to build a string by appending, you should use an instance of <code ><class_name >System. Text. StringBuilder</class_name></code> to do the appending, then extract the instance of <code ><class_name >System. String</class_name></code> from it. With <code ><class_name >STRING</class_name></code> it is permissible to append, so you don't need a helper likethe <code ><class_name >System. Text. StringBuilder</class_name></code> type. </paragraph><paragraph >So the two types are similar at an abstract level, but different semantically.  There are reasonable arguments for the design of each. </paragraph><paragraph >Many types in the delivered assemblies have properties which are strings or methods which return or take strings as arguments. In all these cases, the strings in question are instances of <code ><class_name >System. String</class_name></code>. </paragraph><paragraph >Many classes in the delivered Eiffel libraries have features involving strings, that is <link ><url /><label >FIXME</label></link> which are strings or <link ><url /><label >FIXME</label></link> which return or take strings as <link ><url /><label >FIXME</label></link>.  In all these cases, the strings are instances of <code ><class_name >STRING</class_name></code> (except for those designed for .NET compliance). </paragraph><paragraph >In C# and VB.NET, if you specify a quoted string like <code ><string >"Hello World!"</string></code> in your code, that string will conform to type <code ><class_name >System.String</class_name></code>. If you do the same in Eiffel, then <code ><string >"Hello World!"</string></code> will be an instance of <code ><class_name >STRING</class_name></code>. In Eiffel terminology, <code ><string >"Hello World!"</string></code> appearing in source code is a <link ><url /><label >FIXME</label></link>. </paragraph><paragraph >What all this means to you is that you cannot use an instance of <code ><class_name >System. String</class_name></code> when an instance of <code ><class_name >STRING</class_name></code> is called for, and vice versa. Three out of four of the executable lines in the following code sample are invalid:</paragraph>


<code_block >
local
    my_string: STRING
    my_system_string: SYSTEM_STRING
do
    my_system_string := "Hello World!"           -- Invalid
    my_string := "Hello World!"                  -- Valid
    my_string := my_system_string                -- Invalid
    my_system_string := my_string                -- Invalid
        .
        .
end
</code_block>

<paragraph >To handle this issue, the Eiffel for .NET class <code ><class_name >STRING</class_name></code> has two features which can be used when a string of the other type is needed. </paragraph><paragraph >The firstof these features isa query <code ><feature_name >to_cil</feature_name></code> which returns an object of type <code ><class_name >System. String</class_name></code> which hasa sequence of characters equivalent to that of the <code ><class_name >STRING</class_name></code> to which <code ><feature_name >to_cil</feature_name></code> is applied. The <code ><feature_name >to_cil</feature_name></code> can be applied to manifest strings by enclosing the manifest string in parentheses. </paragraph><paragraph >The other feature is a creation procedure named <code ><feature_name >make_from_cil</feature_name></code> which takes as an argument an instance of <code ><class_name >System. String</class_name></code> and initializes its target <code ><class_name >STRING</class_name></code> with a sequence of characters equivalent to that of the argument. </paragraph><paragraph >In the following sample,we use these features of <code ><class_name >STRING</class_name></code> to make all the linesfrom the previous sample valid. </paragraph>


<code_block >
local
    my_string: STRING
    my_system_string: SYSTEM_STRING
do
    my_system_string := ("Hello World!").to_cil     -- Valid
    my_string := "Hello World!"                     -- Valid
    my_string.make_from_cil (my_system_string)      -- Valid
    my_system_string := my_string.to_cil            -- Valid
        .
        .
end
</code_block>

<note ><bold >Note:</bold> As shown in the above example, it is necessary to apply <code ><feature_name >to_cil</feature_name></code> to a manifest string if you are assigning it to a <code ><class_name >System. String</class_name></code> or passing it as an argument where a <code ><class_name >System. String</class_name></code> is called for. <paragraph >This is expected to change in a future release. It should be come unnecesary to apply <code ><feature_name >to_cil</feature_name></code> to manifest strings. Instead, whether a <code ><class_name >STRING</class_name></code> or <code ><class_name >System. String</class_name></code> is needed will be determined by the context in which the manifest string is being used, and the proper type of object will be generated. </paragraph></note><heading ><size >3</size>Other Similar Types</heading><paragraph >There are many other cases of types available from the .NET assemblies which have similar purpose and semantics to those found in the Eiffel libraries. Fortunately, there is none that you will have to deal with as often as strings. </paragraph></paragraph></document>