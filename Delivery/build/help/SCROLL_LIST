WIDGET     : Scroll List
DESCRIPTION: Rectangle, with or without scrollbars, which contains a 
             list of selectable strings.
 
CLIENT INTERFACE:
-----------------

class interface
	SCROLL_LIST

creation 
	make,
	make_unmanaged,
	make_fixed_size,
	make_fixed_size_unmanaged

feature

	font: FONT
			-- Font name of label
			-- (from FONTABLE)
		require -- from FONTABLE
			exists: not destroyed
		
	set_font (a_font: FONT)
			-- Set font label to font_name.
			-- (from FONTABLE)
		require -- from FONTABLE
			exists: not destroyed;
			a_font_exists: not (a_font = void);
			a_font_specified: a_font.is_specified
		
	set_font_name (a_font_name: STRING)
			-- Set font label to a_font_name.
			-- (from FONTABLE)
		require -- from FONTABLE
			exists: not destroyed;
			a_font_name_exists: not (a_font_name = void)
		
feature  -- Access

	item: STRING
			-- Item at cursor position
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			not_off: not off
		
	last: STRING
			-- Item at last position
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			not_empty: not empty
		
	search_equal (v: STRING)
			-- Move cursor to first position
			-- (at or after current cursor position)
			-- where item is equal to v (shallow equality);
			-- go off right if none.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			search_element_exists: v /= void
		ensure -- from LIST_MAN
			(not off) implies (v.is_equal (item))
		
feature  -- Callback (adding and removing)

	add_selection_action (a_command: COMMAND; argument: ANY)
			-- Add a_command to the list of action to be executed when items are
			-- selected.
			-- argument will be passed to a_command whenever it is
			-- invoked as a callback.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			valid_command: a_command /= void
		
	remove_selection_action (a_command: COMMAND; argument: ANY)
			-- Remove a_command with argument to the list of action to execute
			-- when items are selected.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			valid_command: a_command /= void
		
feature  -- Color

	foreground_color: COLOR
			-- Foreground color of Current widget
			-- (from PRIMITIVE)
		require -- from PRIMITIVE
			exists: not destroyed
		ensure -- from PRIMITIVE
			valid_result: Result /= void
		
	set_foreground_color (new_color: COLOR)
			-- Set foreground color to new_color.
			-- (from PRIMITIVE)
		require -- from PRIMITIVE
			exists: not destroyed;
			valid_color: new_color /= void
		ensure -- from PRIMITIVE
			foreground_set: foreground_color = new_color
		
	after: BOOLEAN
			-- Is cursor off right edge?
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		
	back
			-- Move cursor backward one position.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		ensure -- from LIST_MAN
			index = old index - 1
		
	before: BOOLEAN
			-- Is cursor off left edge?
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		
	empty: BOOLEAN
			-- Is current series empty?
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		
	finish
			-- Move cursor to last position
			-- (no effect if series is empty).
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		ensure -- from LIST_MAN
			is_empty_or_last: empty or islast
		
	first: STRING
			-- Item at first position
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			not_empty: not empty
		
	forth
			-- Move cursor forward one position.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			not_after: not empty and then index <= count
		ensure -- from LIST_MAN
			index >= 1 and index <= count + 1
		
	go_i_th (i: INTEGER)
			-- Move cursor to position i.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			index_large_enough: i >= 0;
			index_small_enough: i <= count + 1;
			not_empty_unless_zero: empty implies i = 0
		ensure -- from LIST_MAN
			index = i
		
	has (v: STRING): BOOLEAN
			-- Does v appear in current series?
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			valid_v: v /= void
		
	i_th (i: INTEGER): STRING
			-- Item at i_th position
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			index_large_enough: i >= 1;
			index_small_enough: i <= count
		
	index: INTEGER
			-- Current cursor index
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		
	index_of (v: STRING; i: INTEGER): INTEGER
			-- Index of i-th item v; 0 if none
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			positive_occurrence: i > 0
		ensure -- from LIST_MAN
			Result >= 0
		
	isfirst: BOOLEAN
			-- Is cursor at first position in current series?
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		ensure -- from LIST_MAN
			Result implies (not empty)
		
	islast: BOOLEAN
			-- Is cursor at last position in current series?
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		ensure -- from LIST_MAN
			Result implies (not empty)
		
	move (i: INTEGER)
			-- Move cursor i positions.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			stay_right: index + i >= 0;
			stay_left: index + i <= count + 1;
			not_empty_unless_zero: empty implies i = 0
		ensure -- from LIST_MAN
			index = old index + i
		
	off: BOOLEAN
			-- Is cursor off?
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		
	start
			-- Move cursor to first position.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		ensure -- from LIST_MAN
			empty or isfirst
		
feature  -- Deletion

	remove
			-- Remove current item.
			-- Move cursor to its right neighbor
			-- (or after if no right neighbor).
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		ensure -- from LIST_MAN
			count = old count - 1;
			not empty implies index = old index
		
	remove_all_occurrences (an_item: STRING)
			-- Remove all items identical to v.
			-- Leave cursor off.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		ensure -- from LIST_MAN
			is_off: off
		
	remove_left (n: INTEGER)
			-- Remove min (n, position - 1) items
			-- to the left of cursor position.
			-- Do not move cursor
			-- (but its position will be decreased by up to n).
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			not_before: not before;
			non_negative_argument: n >= 0
		
	remove_right (n: INTEGER)
			-- Remove min (n, count - position) items
			-- to the right of cursor position.
			-- Do not move cursor.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			not_after: not after;
			non_negative_argument: n >= 0
		
	wipe_out
			-- Make list empty
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		
feature  -- Duplication

	duplicate (n: INTEGER): LINKED_LIST [STRING]
			-- Copy of the sub-list beginning at cursor position
			-- and comprising min (n, count-position+1) items
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			not_off: not off;
			valid_sublist: n >= 0
		
feature  -- Insertion

	merge_left (other: LIST [STRING])
			-- Merge other into the current list before
			-- cursor position.
			-- Do not move cursor.
			-- Empty other.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			other_exists: other /= void
		ensure -- from LIST_MAN
			count = old count + old other.count;
			other.empty
		
	merge_right (other: LIST [STRING])
			-- Merge other into the current list after
			-- cursor position.
			-- Do not move cursor.
			-- Empties other.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			other_exists: other /= void
		ensure -- from LIST_MAN
			other.empty
		
	put (an_item: STRING)
			-- Put an_item at cursor position.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			not_off: not off
		
	put_i_th (an_item: STRING; i: INTEGER)
			-- Put an_item at i-th position.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			index_large_enough: i >= 1;
			index_small_enough: i <= count
		ensure -- from LIST_MAN
			not empty
		
	put_left (an_item: STRING)
			-- Put an_item to the left of cursor index.
			-- Do not move cursor.
			-- Synonym for put_left.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		ensure -- from LIST_MAN
			count = old count + 1
		
	put_right (an_item: STRING)
			-- Put item v to the right of cursor position.
			-- Do not move cursor.
			-- Synonym for put_right.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		ensure -- from LIST_MAN
			count = old count + 1;
			index = old index
		
	swap (i: INTEGER)
			-- Exchange item at i-th position with item
			-- at cursor position.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			cursor_not_off: not off;
			index_large_enough: i >= 1;
			index_small_enough: i <= count
		
feature  -- Number of elements

	count: INTEGER
			-- Number of items in current series
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		
feature  -- Obsolete

	add_single_action (a_command: COMMAND; argument: ANY)
			-- (from LIST_MAN)
		
	set_single_selection
			-- (from LIST_MAN)
		
feature  -- Selection

	deselect_item
			-- Deselect current selected items.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		ensure -- from LIST_MAN
			selected_list_is_empty: selected_count = 0
		
	first_visible_item_position: INTEGER
			-- Position of the first visible item in the list
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		ensure -- from LIST_MAN
			Result <= count;
			empty = (Result = 0)
		
	scroll_to_current
			-- Make item the first visible item in the list if
			-- position < first_visible_item_position.
			-- Make item the last visible item in the list if
			-- position >= first_visible_item_position+visible_item_count.
			-- Do nothing if item is visible.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			not_off: not off
		
	select_i_th (i: INTEGER)
			-- Select item at i-th position.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			index_large_enough: i >= 1;
			index_small_enough: i <= count
		
	select_item
			-- Select item at current position.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			not_off: not off
		
	selected_count: INTEGER
			-- Number of selected items in current list
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		
	selected_item: STRING
			-- Selected item if single or browse selection mode is selected
			-- Void if nothing is selected
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		
	selected_position: INTEGER
			-- Position of selected item if single or browse selection mode is
			-- selected
			-- Null if nothing is selected
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		
feature  -- Visibilty

	set_visible_item_count (a_count: INTEGER)
			-- Set the number of visible items to a_count.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			a_count_large_enough: a_count > 0
		
	show_current
			-- Make item at current position visible.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			not_off: not off
		
	show_first
			-- Make first item visible.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		
	show_i_th (i: INTEGER)
			-- Make item at i-th position visible.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed;
			index_large_enough: i >= 1;
			index_small_enough: i <= count
		
	show_last
			-- Make last item visible.
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		
	visible_item_count: INTEGER
			-- Number of visible item of list
			-- (from LIST_MAN)
		require -- from LIST_MAN
			exists: not destroyed
		ensure -- from LIST_MAN
			count_large_enough: Result > 0
		
feature  -- Widget hierarchy

	parent: COMPOSITE
			-- Parent of Current widget
			-- (from PRIMITIVE)
		require -- from STACKABLE
			exists: not destroyed
		
invariant
	-- from PRIMITIVE
	has_parent: not destroyed implies parent /= void;
	
end -- class SCROLL_LIST
