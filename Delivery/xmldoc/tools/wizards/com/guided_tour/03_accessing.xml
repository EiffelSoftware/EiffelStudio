<document title="Accessing a COM component" output="studio">
	<meta_data>
		<help>
			<meta>
				<meta_content>EiffelCOM</meta_content>
				<name>MS-HKWD</name>
			</meta>
			<meta>
				<meta_content>EiffelCOM Wizard</meta_content>
				<name>MS-HKWD</name>
			</meta>
			<meta>
				<meta_content>EiffelCOM Wizard, Guided Tour</meta_content>
				<name>MS-HKWD</name>
			</meta>
			<meta>
				<meta_content>EiffelCOM Wizard, Guided Tour, Accessing a COM component</meta_content>
				<name>MS-HKWD</name>
			</meta>
		</help>
	</meta_data>
	<paragraph>
		<paragraph>
		<link/>This third tutorial describes how to access a COM component. It will build a client of the 
		<class_name>StringManipulator</class_name> component built in the first tutorial.
		<heading>
			<size>2</size> Step by step instructions
		</heading>
		<list ordered="true">
			<item>
				In <bold>Project</bold>, in the <bold>Current project</bold> input field, type in <italic>string_manipulator_client</italic>
				 and press <bold>enter</bold>.
			</item>
			<item>
				In <bold>Project Type</bold>, choose 
				<italic>Access an existing COM component</italic>.
			</item>
			<item>
				In <bold>Component Information</bold>, click the browse button (the button with <bold>...</bold>) and open the file 
				<italic>$ISE_EIFFEL\examples\com\wizard\string_manipulator\string_manipulator.idl</italic> where 
				<italic>$ISE_EIFFEL</italic> represents the path to the EiffelStudio installation directory.
			</item>
			<item>
				<link/>Click 
				<bold>Next</bold>.
			</item>
			<item>
				In <bold>Component Type</bold>, choose  
				<italic>In-process (*.dll)</italic>.
			</item>
			<item>
				In <bold>Generation Options</bold>, click the browse button and select the directory where the project should be created (later referenced as <italic>destination folder</italic>). Choose 
				<italic>$ISE_EIFFEL\examples\com\wizard\string_manipulator\generated\client</italic> where 
				<italic>$ISE_EIFFEL</italic> represents the path to the EiffelStudio directory.
			</item>
			<item>
				Make sure both <bold>Compile C code</bold> and <bold>Compile Eiffel code</bold> are checked.
			</item>
			<item>
				Select <bold>Overwrite existing files</bold>.
			</item>
			<item>
				Click <bold>Generate</bold>.
			</item>
			<item>
				Wait until the wizard is done.
			</item>
		</list>
		<heading>
			<size>2</size> First look at the generated code
		</heading><link/>At the end of the processing the <bold>EiffelStudio</bold> button becomes enabled. Click on it. This will automatically start EiffelStudio with the generated project so you can more easily navigate through the created Eiffel classes. 
		<note>
			<bold>Note</bold>:
			When accessing a COM component the EiffelCOM Wizard will generate a precompiled library which includes all the generated classes. 
			This allows for easy browsing of the generated classes, however a precompilation project is read-only, so you need to start
			another EiffelStudio to reuse the generated classes. The interesting classes are all related to the coclass proxy 
		<class_name>STRING_MANIPULATOR_PROXY</class_name>. The proxy is the Eiffel class that gives access to the component. Each feature on 
		the proxy calls the corresponding interface function on the component. You can use the EiffelStudio opened by the wizard to browse 
		through the generated classes and study the class hierarchy.</note>
		<heading>
			<size>2</size> Implementing a client
		</heading>
		To implement a client of the <class_name>StringManipulator</class_name> component open a new EiffelStudio. Create the project in 
		<italic>$ISE_EIFFEL\examples\com\wizard\string_manipulator\client</italic> using the ace file found in that directory. 
		Freeze and run the project. You are now accessing the previously built component and calling functions on its interfaces!. The class 
		<class_name>MY_STRING_MANIPULATOR</class_name> inherits from the generated 
		<class_name>STRING_MANIPULATOR_PROXY</class_name> and redefines the feature 
		<italic>replace_substring_user_precondition</italic>.The generated interfaces include contracts for each exposed function. 
		You can redefine the 
		<italic>user_precondition</italic> features to implement your own preconditions.
		<heading>
			<size>2</size> Contracts
		</heading>
		Contracts can be broken directly on the proxy in which case you will get a standard contract violation or in the server. 
		If contracts are broken on the server then the exception will be forwarded by the EiffelCOM runtime to the client. The feature 
		replace_substring_user_precondition in 
		<class_name>MY_STRING_MANIPULATOR</class_name> includes the following commented line:
<code_block>
<comment>-- Result := True</comment>
</code_block>
		Un-comment this line by removing the preceding ` 
		<code>
			<comment>--</comment>
		</code> ' and comment out the rest of the feature. Now the contract of the 
		<code>
			<link>
				<url>../../../../libraries/base/reference/kernel/classic/string_chart.xml</url><anchor_name>f_replace_substring</anchor_name>
				<label>replace_substring</label>
			</link>
		</code> feature is wrong and erroneous calls can be made. Quick melt the changes and run the client. Enter some invalid numbers in 
		the fields used to call this feature. After you click <bold>Replace</bold> you will see an error message box warning you that 
		a precondition was violated on the server side. This demonstrates contracts `over the wire'. The preconditions was violated 
		in the server, this exception was caught by the EiffelCOM runtime and sent back to the client.
		<seealso>
			<bold>See Also</bold>
			<line_break/>
			<link>
				<url>01_new_from_com.xml</url>
				<label>Creating a new COM component</label>
			</link>
			<line_break/>
			<link>
				<url>02_new_from_eiffel.xml</url>
				<label>Creating a new component from an Eiffel Project</label>
			</link>
		</seealso>
		</paragraph>
	</paragraph>
</document>
