<!DOCTYPE HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">

<HTML>
	<HEAD>
		<TITLE>EiffelCOM Wizard Guided Tour</TITLE>
		<LINK REL=StyleSheet HREF="../../../../default.css">
	</HEAD>

	<BODY>
		<H1>EiffelCOM Wizard Guided Tour</H1>

		<p>
		<A NAME="pgfId=370500"></A>
		 This chapter details the wizard and code generation. The wizard has seven
		 different dialogs. The third dialog is different depending on whether the
		 wizard have started from an Eiffel system, an IDL file, or a Type Library. Once
		 the dialogs have been completed, the wizard generates a Type Library if needed,
		 then analyzes the Type Library, and generates the code.
		</p>
		<h2>
		<A NAME="pgfId=370574">
		 </A>
		 Introduction Dialog and Main Window</h2>
		<p>
		<A NAME="pgfId=370629">
		 </A>
		The EiffelCOM wizard can be launched from the Windows start menu:
		</p>
		<p>
		<p class="code">
		Start-&gt;Programs-&gt;EiffelXX-&gt;EiffelCOM Wizard
		<p>
		<A NAME="pgfId=370657">
		 </A>
        where EiffelXX corresponds to your Eiffel installation (e.g. Eiffel45). 
		The following window will be displayed:
		</p>
		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=370590">
		 </A>
		EiffelCOM Wizard Main Window and Introduction Dialog</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=370588">
		 </A>
		<IMG SRC="../images/com_Image2.gif" ALIGN="LEFT" width="619" height="420">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>
		<p>
		<A NAME="pgfId=370661">
		 </A>
		The introduction dialog lets you choose between opening an existing project or creating a new
		one either from a COM definition or from an Eiffel project. Creating a new project will 
		open the <A HREF="wizard.html#28307" CLASS="XRef">
		Generated Code Type Dialog.</A>
		Opening an existing project will display an Open File Dialog from which you can 
		select a previously saved EiffelCOM project.
		<p>
		The four buttons at the bottom of the dialog <i>Back</i>, <i>Next</i>,
		<i>Cancel</i> and <i>Help</i> are common to all dialogs displayed throughout the
		execution of the wizard. <i>Next</i> validates all the values entered in the
		current dialog and activates the next one. <i>Back</i> discards all the values
		entered in current dialog and displays the previous one. <i>Cancel</i> exits the
		dialog and discards all the values entered. Finally, <i>Help</i> brings up this
		manual.
		<p>
		</p>
		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=370590">
		 </A>
		EiffelCOM
				Wizard Main Window</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=370588">
		 </A>
		<IMG SRC="../images/com_Image3.gif" ALIGN="LEFT" width="575" height="383">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>
		<p>


		<A NAME="pgfId=375318">
		 </A>
		 The main window includes a toolbar and a menu. The first three buttons on the toolbar correspond to the first three entries in the File menu: New, Open and Save. New resets all the information previously entered in the wizard. Open brings up an Open File Dialog that can be used to retrieve a previously saved EiffelCOM project. Save is used to save the current project. A project is defined by all the values entered in the wizard. A project can be saved only after the wizard has been run. The file extension for an EiffelCOM project is ewz.
		  <p>
		<A NAME="pgfId=373265">
		 </A>
		The second menu, Build, includes the entries Launch Wizard and Generate (no wizard) corresponding respectively to the last two toolbar buttons. The former activates the <A HREF="wizard.html#28307" CLASS="XRef">
		Generated Code Type Dialog.</A>
		 while the later launches the generation with the current settings and bypasses the dialogs. This last button can be used only when a project has been loaded or when the wizard has been run once.
		  <p>
		<A NAME="pgfId=375357">
		 </A>
		 The third menu, <i>Help</i>, includes <i>Help</i> and <i>About EiffelCOM</i>. <i>Help</i>
		brings up this manual. <i>About EiffelCOM </i>brings<i> </i>About EiffelCOM
		Dialog that gives the version number.
		</p>
		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=370590">
		 </A>
		About EiffelCOM Dialog</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=370588">
		 </A>
		<IMG SRC="../images/com_Image4.gif" ALIGN="LEFT" width="575" height="352">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>
		<p>

		<DIV>
		<h2>
		<A NAME="pgfId=370579">
		 </A>
		Required File</h2>
		<p>
		<A NAME="pgfId=373200"></A>
		 Before you launch the wizard make sure you have a COM definition file or an
		 Eiffel project ready for processing.
		</p>
		</DIV>
		<h2>
		<A NAME="pgfId=373199">
		 </A>
		<A NAME="28307">
		</A> Generated Code Type Dialog</h2>
		<p>
		<A NAME="pgfId=370516">
		 </A>
		The first dialog asks if you want to access or build a component. 
		If you want to access an existing component then the generated code 
		will be for a client. If you choose to build a new one, the generated code 
		will be for a COM server. Choose the server or client check box to specify 
		which kind of project you want to work on. You may specify both in the case 
		where both the component and its client(s) will be written in Eiffel.
		</p>
		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=370524">
		</A> Generated Code Type Dialog</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=370522">
		 </A>
		<IMG SRC="../images/com_Image5.jpg" ALIGN="LEFT" width="576" height="384">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>
		<p>
		<p >
		<a name="pgfId_370533"></a>EiffelCOM supports the following
		component executable types:</p>
		<p align="justify"><a name="pgfId_370534"></a>In-Process: These components are
		Dynamic Link Libraries (DLLs) that will be loaded into the client process. The
		server runs in the same process as the client.</p>
		<p align="justify"><a name="pgfId_370539"></a>Out-of-process: These components
		are executable files that can be accessed through the network. Clients and
		servers run in different processes and may even run on different machines.</p>
		<p align="justify"><a name="pgfId_370561"></a>In-process components are Active-X
		like components; they are usually smaller than local or remote components and
		used by bigger application (often through a high level language). Local
		components run on the same machine as a client. Remote components run on
		different machine and can act as middleware in a three-tier client server
		architecture. Choose the kind of component you want to access or create.</p>
		<p align="justify">If you do not want to compile the generated code
		automatically, check the checkboxes at the bottom of the dialog.</p>

		<DIV>
		<h2>
		<A NAME="pgfId=370681">
		 </A>
		 Definition File Dialog</h2>
		<p>
		<A NAME="pgfId=370565"></A>
		 This dialog asks for the location of a COM definition file for the project. A
		 COM definition file is either an IDL file or a Type Library. An IDL file is
		 usually provided when building a new component since all the sources are
		 available. However, when it comes to accessing an existing component, the
		 sources might not be available. A Type Library is often embedded into the
		 component and includes enough information for the wizard to generate the code.
		</p>
		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=370544">
		 </A>
		Definition File Dialog</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=370542">
		 </A>
		<IMG SRC="../images/com_Image6.gif" ALIGN="LEFT" width="576" height="384">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>

		<p>
		<a name="pgfId_370572"></a>The wizard accepts the following type extensions: <i>idl</i>,
		<i>tlb</i>, <i>ocx</i>, <i>olb</i>, <i>dll</i>, and <i>exe</i>.
		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=370544">
		 </A>
		Definition File Dialog, file extensions</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=370542">
		 </A>
		<IMG SRC="../images/com_Image7.gif" ALIGN="LEFT" width="576" height="384">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>


		<p>
		<A NAME="pgfId=370572">
		</A>The destination folder is the directory where the wizard saves generated
		files. The directory should be empty. If the wizard were to overwrite an
		existing file it would first back it up and emit a warning message. If any of
		the entered values are not correct when the <i>Next</i> button is pressed the
		wizard displays a warning message.
		</p>
		</DIV>

		<DIV>
		<h2>
		<A NAME="pgfId=370683">
		</A> Eiffel Project File Dialog</h2>
		<p>
		<A NAME="pgfId=370567"></A>
		 The Eiffel project file Dialog asks for the location of an Eiffel project file 
		(*.<I>epr</I>), the Ace file of the project, the name of the Eiffel class that 
		will be converted into an IDL file, and the cluster name to which the Eiffel 
		class belongs. </p>
		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=370544">
		 </A>
		 Eiffel Project File Dialog</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=370542">
		 </A>
		<IMG SRC="../images/com_Image8.gif" ALIGN="LEFT" width="576" height="384">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>

		</DIV>
		<DIV>
		<h2>
		<A NAME="pgfId=370682">
		</A> Destination Folder Dialog</h2>
		<p>
		<A NAME="pgfId=370568"></A>
		The Destination Folder Dialog asks for the destination
		folder path where the wizard can safe generated files. 
		</p>
		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=370544">
		</A> Destination Folder Dialog</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=370542">
		 </A>
		<IMG SRC="../images/com_Image9.gif" ALIGN="LEFT" width="576" height="383">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>

		</DIV>


		<DIV>
		<H6 CLASS="dd-sec3">
		&nbsp;</H6>
		<h2>
		<A NAME="pgfId=370326">
		 </A>
		 IDL Marshalling Definition Dialog</h2>
		<p>
		<A NAME="pgfId=370735">
		 </A>
		This dialog is displayed only for a server project and if the chosen definition file is an IDL file. It is used to specify how marshalling will work for the component. The first choice that has to be made is whether the component will be accessed through Automation (using IDispatch) or through the interface's virtual table (for additional information on Automation versus virtual table access, please consult COM).
		</p>
		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=370740">
		 </A>
		IDL Marshalling Definition Dialog</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=370738">
		 </A>
		<IMG SRC="../images/com_Image10.gif" ALIGN="LEFT" width="576" height="383">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>
		<p>
		<A NAME="pgfId=370780"></A>
		 If you choose Automation, then the Universal marshaler will be used (for
		 additional information on Marshalling please see the chapter COM). If you
		 specify Virtual Table access, then you have the choice between using the
		 Windows Universal marshaler and the marshaler generated from the definition
		 file. Since this dialog is displayed only when the definition file is an IDL
		 file, choosing Standard Marshalling will force the wizard to compile the
		 marshaler from the code generated with the MIDL compiler. Standard marshalling
		 should be used whenever some interface functions make use of non-Automation
		 compatible types.
		</p>
		</DIV>
		<DIV>
		<h2>
		<A NAME="pgfId=370781">
		 </A>
		Type Library Marshalling Definition Dialog</h2>
		<p>
		<A NAME="pgfId=370792">
		</A>The Type Library Definition Dialog is displayed only for a server project
		when the definition file is a Type Library. You have to choose between
		Automation and Virtual Table access and between Universal and Standard
		marshaling.
		</p>
		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=370797">
		 </A>
		Type Library Marshalling Definition Dialog</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=370795">
		 </A>
		<IMG SRC="../images/com_Image11.gif" ALIGN="LEFT" width="576" height="384">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>
		<p>
		<A NAME="pgfId=370818"></A>
		 Because the definition file is a Type Library, the wizard cannot compile the
		 Standard marshaler without additional information. This is the reason for
		 having an extra text field for the path to the marshaler (also known as
		 Proxy/Stub pair or just Proxy/Stub). The Proxy/Stub is a Dynamic Link Library
		 that is used to marshal the data on the wire for a given component.
		</p>
		</DIV>
		<h2>
		<A NAME="pgfId=370782">
		 </A>
		<A NAME="23940">
		 </A>
		 Final Dialog</h2>
		<p>
		<A NAME="pgfId=374219">
		 </a>The last dialog offers a choice of different output
		 levels. By default, the wizard will display errors, warnings and generic
		 information. You can choose not to see warnings and/or extra information.

		 </p>
		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=374227">
		 </A>
		Final Dialog</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=374225">
		 </A>
		<IMG SRC="../images/com_Image12.gif" ALIGN="LEFT" width="576" height="383">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>
		<p>
		<A NAME="pgfId=370907">
		 </A>
		This dialog also asks whether you wish to continue even though an error occurred while compiling a file.
		  <p>
		<A NAME="pgfId=375399">
		 </A>
		 The Finish button closes the dialog and starts the processing. You can save the
		project after the wizard finishes.
		</p>
		<h2>
		<A NAME="pgfId=370908">
		 </A>
		 COM Definition File Processing</h2>
		<p>
		<A NAME="pgfId=374194">
		</A>Six phases are involved in the COM definition file processing:<p>
		<A NAME="pgfId=374195">
		 </A>
		 <i>IDL Compilation</i>: If the definition file is an IDL file, the wizard
		compiles the IDL file into a Type Library and if Standard Marshalling have been
		chosen, produces the marshaler from the generated C files.
		  <p>
		<A NAME="pgfId=374196">
		 </A>
		 Type Library Parsing: The wizard analyzes the type library and transforms the
		information it needs to generate the code into internal representation.
		  <p>
		<A NAME="pgfId=374197"></A>
		<i>Code Generation</i>: The
		wizard generates both the Eiffel and C/C++ code from the information gathered
		during the previous step.

		  <p>
		<A NAME="pgfId=374203">
		 </A>
		 C/C++ Compilation: The wizard compiles the generated C and C++ code into object
		files and libraries that will be linked with the Eiffel system.
		  <p>
		<A NAME="pgfId=375402">
		 </A>
		 Eiffel Compilation: For a client project the wizard compiles the generated
		Eiffel code into a precompiled library that can be reused from other projects.
		For a server project the wizard compiles the generated Eiffel code into a
		standard project with the registration class as root class. If the location is
		In-process then the project corresponds to a DLL whereas if the location of the
		server is out-of-process then the project corresponds to a standard executable.
		<p align="justify"><a name="pgfId_375648"></a>Finally, the wizard launches
		EiffelBench and automatically opens the generated Eiffel system.</p>
		<p align="justify"><a name="pgfId_370902"></a>During processing, the name and
		progress of each phase is displayed.</p>
		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<H6 CLASS="figuretitle">
		<A NAME="pgfId=370888">
		 </A>
		Wizard Progress Dialog</H6>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=370886">
		 </A>
		<IMG SRC="../images/wizard-8.gif" ALIGN="LEFT" width="476" height="131">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>
		<p>
		<A NAME="pgfId=370920"></A>
		While processing the wizard displays information in real
		time in the main window if this option was chosen in the Final Dialog. Displayed
		information includes output of calls to external compilers (C, Eiffel and IDL)
		and description of the current analyzed or generated Type Library item.
		</p>
		<h2>
		<A NAME="pgfId=370908">
		 </A>
		 Eiffel Project Processing</h2>


		<p>


		  Eiffel project processing has an additional phase: <i>IDL
		file generation</i>. During the phase the wizard translates an Eiffel class into
		an IDL file. Preferably, you should write a special class to serve as a Facade
		to your system. After IDL generation the wizard proceeds as above.
		</p>


		<h2>
		<A NAME="pgfId=370940">
		 </A>
		 Generated Files</h2>
		<p>
		<A NAME="pgfId=374235">
		</A>The wizard generates code into the specified destination folder. The file
		hierarchy is the following:

		<p>


		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=374314">
		 </A>
		Generated Files Hierarchy</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=374312">
		 </A>
		<MAP NAME="wizard-9">
		</MAP>
		<IMG SRC="../images/com_Image23.gif" ALIGN="LEFT" width="559" height="325">
		</H6>
		</TD>
		</TR>
		</TABLE>
        &nbsp;
		<p>
		<A NAME="pgfId=374315">
		 </A>
		 The root folder has two files and four subclusters.</p>
		  <p>
		<A NAME="pgfId=374316">
		 </A>
		 The file generated.txt includes a list of all the files generated by the
		wizard.
		  <p>
		<A NAME="pgfId=371121">
		 </A>
		 The file <i>component</i>.<i>log</i> contains a summary of the processing done
		by the wizard. The name of the file is the name of the definition file appended
		with log (so Figure 10 presumes that the definition file was e.g. <i>component</i>.<i>idl</i>)
		  <p>
		The folder <i>idl</i> contains the generated IDL file.
		  <p>
		<A NAME="pgfId=371124">
		 </A>
		 The folders <i>Client</i> and <i>Server</i> include the files generated
		respectively for reusing a component or creating a new component. Each consists
		of three subdirectories: <i>Include</i> comprises header files needed to compile
		the Eiffel code, <i>CLib</i> contains the generated C and C++ code as well as
		the library files. <i>Component</i> holds Eiffel code that wraps or defines the
		component. The <i>Component</i> subfolder of <i>Server</i> also includes the
		registration class. This Eiffel class contains the code needed to activate the
		component; it depends whether the component is in-process or out-of-process. You
		do not need to read or edit the C and C++ code included in <i>CLib</i> because
		the wizard automatically compiles it. It is given for information only and can
		be deleted (you need to keep the library file though). The <i>Client</i> and <i>Server</i>
		folders also have an Ace file used to compile the generated Eiffel code. In the
		case of a client, the generated code is precompiled whereas in the case of a
		server it is compiled in a normal system with the registration class being the
		root class of the system. In the case of an in-process server the Eiffel system
		is compiled into a DLL whereas in the case of an out-of-process server, it is
		compiled in a standard executable.
		  <p>
		<A NAME="pgfId=371132">
		 </A>
		 The Common folder comprises code that is used for both the server and the
		client parts. The <i>Include</i> and <i>CLib</i> directories contain
		respectively the header files and the C and C++ code. The C and C++ sources are
		not needed and can be deleted, only the library file needs to be kept for the
		Eiffel system to compile. The <i>Interfaces</i> subdirectory include Eiffel
		classes corresponding to the component interfaces and the <i>Structures</i>
		subdirectory includes Eiffel classes wrapping data structures specified in the
		definition file.
		</p>
		<h2>
		<A NAME="pgfId=371722">
		 </A>
		 Class Hierarchy</h2>
		<p>
		<A NAME="pgfId=372785"></A>
		 The generated Eiffel code reflects the architecture of the component described
		 in the definition file. Each interface corresponds to a deferred Eiffel class
		 that includes one deferred feature per interface function. The deferred
		 features are implemented in the heir inheriting from all interfaces. This
		 central class will be referred to as Eiffel coclass in the rest of this
		 document.

		<p>


		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=372925">
		 </A>
		EiffelCOM System Basic Architecture</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=372923">
		 </A>
		<MAP NAME="wizard-10">
		</MAP>
		<IMG SRC="../images/com_Image24.gif" USEMAP="#wizard-10" ALIGN="LEFT" width="439" height="283">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>
		<A NAME="pgfId=373158"></A>In a client application the Eiffel coclass inherits from the class 
		<span class="eclass">ECOM_QUERIABLE, 	</span>
		which is part of the EiffelCOM library. This class includes the feature <span class="efeature">make_from_other
		</span>to initialize the component from another instance of <span class="eclass">ECOM_INTERFACE</span>.&nbsp;

		<p>


		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=372925">
		 </A>
		EiffelCOM System Basic Architecture</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=372923">
		 </A>
		<MAP NAME="FPMap0">
		</MAP>
		<IMG SRC="../images/com_Image25.gif" USEMAP="#FPMap0" ALIGN="LEFT" width="430" height="390">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>
		<A NAME="pgfId=373158"></A>In a server application the Eiffel coclass inherits from the class
		<span class="eclass">ECOM_STUB,
		</span>which is part of the EiffelCOM library. This class includes the feature 
		<span class="efeature">create_item
		</span>to initialize the component for COM.&nbsp;
		<p>
		The <i>Interface_proxy</i> folder includes Eiffel classes wrapping interfaces
		that are sent to or received by the component. Such interfaces will be referred
		to as client implemented interfaces in the rest of the document. These classes inherit
		from both the deferred interface class and <span class="eclass">ECOM_QUERIABLE</span>.</p>

		<p>


		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=373273">
		</A>Client&nbsp; Implemented Interfaces</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=373271">
		 </A>
		<MAP NAME="wizard-11">
		</MAP>
		<IMG SRC="../images/com_Image26.gif" USEMAP="#wizard-11" ALIGN="LEFT" width="348" height="267">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>
		<p>
		The <i>Interface_stub</i> folder includes Eiffel classes implementing interfaces
		that are sent by the component. Such interfaces will be referred
		to as server implemented interfaces in the rest of the document. These classes inherit
		from both the deferred interface class and <span class="eclass">ECOM_STUB</span>.</p>

		<p>


		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=373273">
		</A>Server Implemented Interfaces</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=373271">
		 </A>
		<MAP NAME="FPMap1">
		</MAP>
		<IMG SRC="../images/com_Image27.gif" USEMAP="#FPMap1" ALIGN="LEFT" width="363" height="268">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>
        &nbsp;
		<p>
		<A NAME="pgfId=373336">
		 </A>
		 For both Eiffel coclass and Implemented interfaces,
		 the <span class="eclass">INTERFACE</span> class contains no implementation; it only defines the
		 signatures of the functions that are part of the interface. The actual
		 implementation lies in the heir of that class.</p>
		  <p>
		<A NAME="pgfId=373366">
		 </A>
		 How you should use the generated classes in your system depends on whether you
		want to access an existing component (client) or build a new component in Eiffel
		(server).
		</p>
		<h1>
		<A NAME="pgfId=371723">
		 </A>
		 ACCESSING A COMPONENT</h1>
		<p>
		<A NAME="pgfId=373349"></A>
		The wizard generates all the necessary code to access the
		existing component. The plumbing is already done, so instantiating an Eiffel
		coclass actually initializes COM internals.
		</p>
		<h2>
		<A NAME="pgfId=371724">
		 </A>
		 Using the Generated Code</h2>
		<p>
		<A NAME="pgfId=373367"></A>
		 To access the component, you need to call features of the coclass. The data
		 types of function arguments are either Eiffel types defined in Eiffel data
		 structure libraries (EiffelBase), standard COM data types defined in the
		 EiffelCOM library, or component COM data types specified in the definition
		 file. For example, from the following IDL line

		<p>


		<P CLASS="code">
		<A NAME="pgfId=373375">
		 </A>
		 HRESULT InterfaceFunction ([in] int a, [out, retval] MyStruct * b)</P>
		<A NAME="pgfId=373411">
		</A>The wizard generates the following feature in the Eiffel coclass:

		<p>


		<P CLASS="code">
		interface_function (a: <span class="eclass">INTEGER</span>): <span class="eclass">MY_STRUCT_RECORD</span></p>

		<A NAME="pgfId=373436">
		</A>
		where <span class="eclass">MY_STRUCT_RECORD</span> is a generated Eiffel class wrapping <em>MyStruct</em>.
		<p align="justify">Here is a more difficult example:</p>
		<p>
		  <p>
			<p class="code">HRESULT a_function ([in] IsomeInterface * p_interface)</p>
		<p align="justify">The wizard generates the following Eiffel feature:</p>
		<p>
		  <p>
			<p class="code">a_function (p_interface: <span class="eclass">ISOME_INTERFACE_INTERFACE</span>)</p>
		<p align="justify">where <span class="eclass">ISOME_INTERFACE_INTERFACE</span> is a generated
		deferred class.
		Where can you obtain an instance of the class? First, you may receive from other
		function. Second, you can create an implemented server interface <span class="eclass">ISOME_INTERFACE_IMPL_STUB</span>.
		In the later case you should provide your own implementation.</p>
		<h2>
		<A NAME="pgfId=373348">
		 </A>
		 Contracts</h2>

		<p>


		<A NAME="pgfId=373448">
		</A>The wizard cannot generate fully specified contracts. Indeed, the tool has
		no domain specific knowledge and can only generate contracts that are domain
		independent. Such contracts, although useful, are not enough to describe
		entirely the behavior of the component. Generated contracts include void Eiffel
		objects as well as C pointer validity (for wrappers) checking. There might be
		other conditions to allow calls to an Eiffel coclass feature. Invariants and
		postconditions can be enforced in an heir of the generated Eiffel coclass.
		Preconditions, however, cannot be strengthened. A workaround provided by the
		wizard is to generate a precondition function for each feature in the interface.
		The default implementation of these functions always returns <em>True</em>. They
		should be redefined to implement the correct behavior:


		<DIV >
		<P CLASS="code">
		&nbsp;&nbsp;&nbsp;&nbsp;interface_function (a: <span class="eclass">INTEGER</span>): <span class="eclass">MY_STRUCT</span> <span CLASS="ekeyword">
		is</span>
		<br>
				<span CLASS="ecomment">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Example of a generated Eiffel coclass feature</span>
		
		<br>
		<A NAME="pgfId=373465">
		 </A>
			<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;require</span>
		
		<br>
		 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interface_function_user_precondition: interface_function_user_precondition 
		<br>
			<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do</span>
		
		  
		<br>
		 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...
		<br>
			<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ensure</span>
		
		  
		<br>
		 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;non_void_my_struct: <span CLASS="ereserved">
		Result</span>
		 /= <span CLASS="ereserved">
		Void</span>
		
		<br>
			<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</span>
		
		</DIV>
		<A NAME="pgfId=373481">
		 </A>
		So the complete class hierarchy for an Eiffel client coclass is the following:

		<p>


		<DIV>
		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=373486">
		 </A>
		EiffelCOM Client System</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=373484">
		 </A>
		<MAP NAME="wizard-12">
		</MAP>
		<IMG SRC="../images/wizard-12.gif" USEMAP="#wizard-12" ALIGN="LEFT" width="483" height="180">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>
		</DIV>
		<A NAME="pgfId=371725">
		</A> Another advantage of the previous hierarchy is that it adds incrementality to
		 the EiffelCOM system. Indeed, should the definition file be modified and the
		 wizard run once more against it, your code would not be changed. Only the
		 generated Eiffel coclass would be, and it would suffice to adapt your heir
		 accordingly.
		<h2>
		<A NAME="pgfId=373560">
		 </A>
		<A NAME="41902">
		 </A>
		 Exceptions</h2>

		<p>


		<A NAME="pgfId=373569"></A>
		 COM standard requires that any interface function
		 returns a status value (known as a HRESULT). This corresponds to side effect
		 features which the Eiffel methodology tends to avoid. The workaround used in
		 EiffelCOM systems is to map these return values into Eiffel exceptions. If the
		 server returns an error code, the EiffelCOM runtime raises an Eiffel exception
		 that your code should catch.

		<p>


		<OL>
		<TABLE BORDER="1">
		<CAPTION>
		<p class="figuretitle">
		<A NAME="pgfId=373577">
		 </A>
		EiffelCOM Client System Exception Raising</p>
		</CAPTION>
		<TR>
		<TD ROWSPAN="1" COLSPAN="1">
		<H6 CLASS="mm.celltitle">
		<A NAME="pgfId=373575">
		 </A>
		<MAP NAME="wizard-13">
		</MAP>
		<IMG SRC="../images/wizard-13.gif" USEMAP="#wizard-13" ALIGN="LEFT" width="483" height="158">
		</H6>
		</TD>
		</TR>
		</TABLE>
		</OL>
		<A NAME="pgfId=373694"></A>
		 As a result, any feature in the coclass client
		 making calls to the user defined Eiffel coclass should include a rescue clause.
		 The processing done in this clause might depend on the nature of the exception.
		 All the standard COM exceptions can be found in the library class <span class="eclass">ECOM_EXCEPTION_CODES,</span>
		 which is inherited from by <span class="eclass">ECOM_EXCEPTION</span>. The later also inherits
		 from the kernel class <span class="eclass">EXCEPTIONS</span> and can consequently be used by the
		 coclass client to catch the exceptions.
		  <p>
		<A NAME="pgfId=373848">
		 </A>
		 The following code snippet illustrates how a client can process exceptions raised in the Eiffel coclass:

		<p>


		<P CLASS="code">
		<span CLASS="ekeyword">
		indexing</span>
		
		


		<br>
		 &nbsp;&nbsp;&nbsp;&nbsp;description: <span class="estring">&quot;Eiffel coclass client example&quot;</span>
		
		<br>
		
		<br>
		<span CLASS="ekeyword">
		class</span>
				
		<br>
			&nbsp;&nbsp;&nbsp;&nbsp;<span CLASS="eclass">COCLASS_CLIENT</span>
		<br>
		
		<br>
		<span CLASS="ekeyword">
		inherit</span>
		
		
		<br>
			&nbsp;&nbsp;&nbsp;&nbsp;<span CLASS="eclass">ECOM_EXCEPTION</span>
		  
		<br>
				<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;export</span>
		
			
		<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span CLASS="eclass">NONE</span>} <span class="ekeyword">all</span>
		<br>
				<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</span>
		
		<br>
		
		<br>
		<span CLASS="ekeyword">
		create</span>
		
		
		<br>
			&nbsp;&nbsp;&nbsp;&nbsp;make
		<br>
		
		<br>
		<span CLASS="ekeyword">
		feature</span>
		 {<span CLASS="eclass">NONE</span>} <span CLASS="ecomment">
		-- Initialization</span>
		
		<br>
		
		
		<br>
			&nbsp;&nbsp;&nbsp;&nbsp;make <span CLASS="ekeyword">
		is</span>
		
		  			
		<br>
					<span CLASS="ecomment">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Initialize Eiffel coclass.</span>
		
		<br>
				<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do</span>
		
			
		<br>
					<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;create</span>
		 coclass.make
		<br>
				<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</span>
		  
		<br><br>
		<span CLASS="ekeyword">
		feature </span>
		<span CLASS="ecomment">
		-- Basic Operations</span>
		
		<br>
		
		
		<br>
			&nbsp;&nbsp;&nbsp;&nbsp;coclass_feature_client <span CLASS="ekeyword">
		is</span>
				  
			
		<br>
		<span CLASS="ecomment">
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Example of a coclass feature caller</span>
		
		<br>
				<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;local</span>
		
			
		<br>
					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retried: <span CLASS="eclass">BOOLEAN</span>
		<br>
		 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coclass: <span CLASS="eclass">EIFFEL_COCLASS_PROXY</span>
		<br>
				<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do</span>
		
			
		<br>
					<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;create </span>
		coclass.make
		<br>
					<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
		 not</span> retried <span CLASS="ekeyword">
		then</span>
		
			  
		<br>
		 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coclass.coclass_feature<span CLASS="ecomment">
		 -- Actual call</span>
		
		<br>
					<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</span>
		
		<br>
				<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rescue</span>
		
			
		<br>
					<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if</span>
		 hresult = E_notimpl<span CLASS="ekeyword">
		 then</span>
		
			  
		<br>
						<span CLASS="ecomment">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Process non implemented function error.</span>
		
		<br>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retried := <span class="ereserved">True</span>
		<br>
						<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retry</span>
		
		<br>
					<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elseif</span>
		 hresult = E_invalidarg<span CLASS="ekeyword">
		 then</span>
		
			  
		<br>
						<span CLASS="ecomment">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Process invalid argument error.</span>
		
		<br>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retried := <span class="ereserved">True</span>
		<br>
						<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retry</span>
		
		<br>
					<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</span>
		
			  
		<br>
						<span CLASS="ecomment">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Forward exception to caller.</span>
		
		<br>
					<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</span>
		
		<br>
				<span CLASS="ekeyword">
		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</span>
		
		<br>
		
		<br>
		<span CLASS="ekeyword">
		end</span>
		<span CLASS="ecomment">
		 -- class COCLASS_CLIENT</span>
		
		
		</p>
		<h2>
		<A NAME="pgfId=373971">
		 </A>
		 Summary</h2>

		<p>


		<p align="justify"><a name="pgfId_371703"></a>There are a few rules to follow
		when building an Eiffel coclass client, but they are straightforward and do not
		add any constraints. First, inherit from the generated Eiffel coclass to
		implement the preconditions. Second, any feature call to the Eiffel coclass
		should include a rescue clause.</p>

		<p>


		<p align="justify">&nbsp;</p>
		<h1>
		<A NAME="pgfId=373966">
		 </A>
		 BUILDING A COMPONENT</h1>


		<A NAME="pgfId=373983">
		</A>

		<p>


				<p align="justify">The EiffelCOM wizard enables the development of COM
			components in Eiffel. To build a COM component you can start either from an
			IDL file or from an Eiffel project. In the later case the wizard generates
			an IDL file for you.</p>
		<h2>
		<A NAME="pgfId=370372">
		 </A>
		 Choosing an Eiffel Class</h2>

		<p>



		<p>If you start building a COM component from an Eiffel system,
		you need to give an Eiffel class to the wizard. The wizard translates the
		Flat-Short form of the class into an IDL file, which is a formal specification
		of the COM component. Clients of the component are able to access only features
		specified in the IDL file. You need to supply the wizard with a Facade class
		that provides clients with a higher-level, single interface (do not confuse with
		COM interface) to the facilities of a system.</p>
		<p>The Facade class should satisfy the following requirements:</p>
		<ul>
		  <dir>
			<dir>
			  <ul>
				<p align="justify">&nbsp;
			  </ul>
			</dir>
		  </dir>
				<li>It should have a creation routine &quot;make&quot; without
				  arguments. The wizard does not enforce the rule, but breaking it
				  causes a runtime error.
				<li>Features of the class may only have arguments and return values of
				  the following types: <span class="eclass">CHARACTER</span>, <span class="eclass">INTEGER</span>, <span class="eclass">REAL</span>, <span class="eclass">DOUBLE</span>,
				  <span class="eclass">BOOLEAN</span>, <span class="eclass">INTEGER_REF</span>, <span class="eclass">BOOLEAN_REF</span>, <span class="eclass">REAL_REF</span>,
				  <span class="eclass">CHARACTER_REF</span>, <span class="eclass">DOUBLE_REF</span>, <span class="eclass">STRING</span>, <span class="eclass">DATE_TIME</span>,
				  <span class="eclass">ECOM_CURRENCY</span>, <span class="eclass">ECOM_DECIMAL</span>, <span class="eclass">ECOM_UNKNOWN_INTERFACE</span>,
				  <span class="eclass">ECOM_AUTOMATION_INTERFACE</span>, and <span class="eclass">CELL</span> and <span class="eclass">ECOM_ARRAY</span>
				  of above types. Features with arguments or return values of other
				  types are excluded from the generated IDL file and are not accessible
				  to the COM runtime.
				<li>Feature names should not be C++ keywords or names of standard
				  library functions such as min, max, etc. The wizard is able to handle
				  this correctly and to create a COM component; however, other languages
				  may not be able to access it.
				<li>The class must belong to a compiled Eiffel project.</li>
		</ul>
			<p>In most Eiffel systems functionality is spread out throughout many
			classes. A system may not contain a class that can render all services of
			the system and can serve as a Facade to the outside world. If you cannot
			find such a class you should write one.</p>
		<h2>
		<A NAME="pgfId=370371">
		 </A>
		 Using the Generated Code</h2>

		<p>


		<p><a name="pgfId_373984"></a>If you start from an Eiffel
		project, the wizard produces a ready-to-use component, and you do not need to
		modify or to implement any generated code.</p>
		<p align="justify">If you start from a COM definition file, you are able to
		design a more flexible component that has more than one interface and/or coclass
		and user defined types, but you have to implement features of the generated
		coclass. The generated Eiffel coclass features are empty. You should redefine
		them in heir to implement the intended behavior. Unlike client generated code,
		the server generated code will differ whether you have chosen to implement an
		in-process or an out-of-process component. The difference lies in the component
		activation code in the class ECOM_&lt;Name_of_system&gt;_REGISTRATION. If the
		component is in-process then this class includes the four functions that need to
		be exported from an in-process COM component (<i>DllRegisterServer</i>, <i>DllUnregisterServer</i>,
		<i>DllGetClassObject</i>, and <i>DllCanUnloadNow</i>). If the component is
		out-of-process then the registration class includes a feature initializing the
		component and its graphical user interface.</p>
		<p align="justify"><a name="pgfId_374337"></a>The architecture of generated code
		for the server is similar to the one for the client: the generated Eiffel
		coclass should be inherited from and the contract features redefined. The
		default feature implementation of the generated Eiffel coclass is empty.
		Features should be redefined to implement the intended behavior. These features
		will be called by the EiffelCOM runtime whenever a client accesses an interface.</p>
		  <p>
		<A NAME="pgfId=374337">
		 </A>
		 The architecture remains the same as when accessing a component: the generated Eiffel coclass should be inherited from and the contract features redefined. The default implementation for features from the generated Eiffel coclass are empty. They should also be redefined to implement the intended behavior. These features will be called by the EiffelCOM runtime whenever a client access an interface.

		<p class="note">	Note: For this first release, the name of the user defined coclass has to 
		be &lt;Name_of_generated_coclass&gt;_IMP. So if the generated coclass name 
		is MY_COCLASS then the user defined coclass name must be MY_COCLASS_IMP.</P>
				
		
		
		
		<h2>
		<A NAME="pgfId=370378">
		 </A>
		<A NAME="34604">
		 </A>
		 Component's GUI</h2>

		<p>


		<A NAME="pgfId=375550"></A>
		In the case of an out-of-process server, you might want
		to add a Graphical User Interface to your component. There are two different
		scenarios in which the component can be activated: either its user launched it
		explicitly (e.g. by double clicking the executable icon) or it was launched by
		the COM runtime to satisfy a client request. The GUI should appear only in the
		former case, when the user has explicitly launched the application. The
		generated registration class for an out-of-process server includes the feature:


		<p class="code">	 main_window: <span CLASS="eclass">WEL_FRAME_WINDOW</span></P>
				
		
		<A NAME="pgfId=375570"></A>
		 This feature is a once function that can be
		 redefined in a child class to return the class corresponding to the component
		 window. This window is displayed only if COM does not start the component. When
		 COM loads an out-of-process component, it appends the option
		 &quot;-embedding&quot; to the executable. The generated registration class
		 looks for this option and if it is part of the process argument list then it
		 sets the default window appearance to hidden.
		  <p>
		<A NAME="pgfId=375583">
		 </A>
		 As a summary, when building a server from a COM definition you need to
		implement classes that inherit from coclasses and implement interface functions.
		The names of the children classes should be the names of the parent classes
		appended with _<i>IMP</i>. You will also have to inherit from the registration
		class in the case of an out-of-process component to provide the class that
		implements the component GUI.
		</p>
		<h2>
		<A NAME="pgfId=375549">
		 </A>
		 Exceptions</h2>

		<p>


		<A NAME="pgfId=374350"></A>
		The COM provides error status to the client by returning
		an HRESULT from the interface function. Such behavior is not acceptable in
		Eiffel and is replaced with exceptions. In the case of accessing an existing
		component, EiffelCOM runtime will raise exceptions with error code 24 (developer
		exception) and your code should catch
		them. When creating a component it will be your code that will raise exceptions
		and the EiffelCOM runtime that will catch them. Here is what the Eiffel code for
		a server should look like:

		<DIV>
		<P class="code">
			<span CLASS="ekeyword">
			indexing</span><br>
			&nbsp;&nbsp;&nbsp;&nbsp;description: <span class="estring">&quot;Eiffel coclass server example&quot;</span><br>
			<span CLASS="ekeyword">
			class</span><br>
			&nbsp;&nbsp;&nbsp;&nbsp;<span CLASS="eclass">ECOM_SERVER_COCLASS_IMP</span><br><br>
			<span CLASS="ekeyword">
			inherit</span><br>
			&nbsp;&nbsp;&nbsp;&nbsp;<span CLASS="eclass">ECOM_SERVER_COCLASS</span> <span CLASS="ecomment">	-- Generated by the wizard</span><br>
			&nbsp;&nbsp;&nbsp;&nbsp;<span CLASS="eclass">ECOM_EXCEPTION</span><br>
			<span CLASS="ekeyword">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;export</span><br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span CLASS="eclass">NONE</span>} <span CLASS="ekeyword">all</span><br>
			<span CLASS="ekeyword">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</span><br>
			<span CLASS="ekeyword"><br>
			
			feature </span>
			<span CLASS="ecomment">
			-- Basic Operations</span><br>
			&nbsp;&nbsp;&nbsp;&nbsp;coclass_feature (an_argument: <span CLASS="eclass">ARGUMENT_TYPE</span>) <span CLASS="ekeyword">
			is</span><br>
			<span CLASS="ecomment">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Example of a coclass feature</span><br>
			<span CLASS="ekeyword">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do</span><br>
			<span CLASS="ekeyword">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
			not</span> is_valid (an_argument) <span CLASS="ekeyword">
			then</span><br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trigger (E_invalidargument)<br>
			<span CLASS="ekeyword">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else</span><br>
			<span CLASS="ecomment">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Normal processing</span><br>
			<span CLASS="ekeyword">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</span><br>
			<span CLASS="ekeyword">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</span><br><br>
			<span CLASS="ekeyword">
			feature</span>
			{NONE}<span CLASS="ecomment">
			-- Implspanentation</span><br>
			&nbsp;&nbsp;&nbsp;&nbsp;is_valid (an_argument: <span CLASS="eclass">ARGUMENT_TYPE</span>): <span CLASS="eclass">BOOLEAN</span> <span CLASS="ekeyword">
			is</span><br>
			<span CLASS="ecomment">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Is an_argument a valid argument?</span><br>
			<span CLASS="ekeyword">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do</span><br>
			<span CLASS="ecomment">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- Test of validity of an_argument</span><br>
			<span CLASS="ekeyword">
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end</span><br>
			<span CLASS="ekeyword">
			end</span>
			<span CLASS="ecomment">
			-- class ECOM_SERVER_COCLASS_IMP</span><br>
		</P>
		</DIV>
		<A NAME="pgfId=374678"></A>
		 This class inherits from the generated Eiffel coclass and from ECOM_EXCEPTION.
		 It redefines the feature coclass_feature from the generated coclass. This
		 feature is part of the interface functions that can be called by clients of the
		 component. Its implementation uses the feature trigger from ECOM_EXCEPTION to
		 raise exceptions in case the feature cannot be executed normally (invalid
		 argument e.g.). The EiffelCOM runtime catches the exception and maps it into an
		 HRESULT that is sent back to the client.
		<h2>
		<A NAME="pgfId=374682">
		 </A>
		 Summary</h2>

		<p>
		  <p ><a name="pgfId_374686"></a>Implementing EiffelCOM
		  components consists in inheriting from the generated Eiffel coclasses and
		  implementing their features. The only specific rules to follow relate to the
		  redefinition of precondition features and the use of exceptions to return
		  error status to the client. In the case of an out-of-process server, the
		  registration class should be inherited from and the feature corresponding to
		  the component window redefined to return the correct class.</p>


		<p>



	</BODY>
</HTML>
