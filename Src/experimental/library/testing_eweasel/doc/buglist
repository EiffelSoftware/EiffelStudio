    
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Known Bugs in ISE Eiffel Compiler</title> 
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
</head>  
<body bgcolor="white" text="black">

<pre>

Status of Eiffel 5.4.0515
=========================

This file documents the status of release 5.4.0515 of ISE Eiffel on Solaris 8.

Some of the following "bugs" may not actually be bugs if the language
definition in the book "Eiffel: The Language" has been changed.  Also,
I may have made a few mistakes.  If you think a bug which is still on
the list has been fixed, please contact me.

======================================================================

Not fully implemented
---------------------

1. System-level validity
2. Conformance
3. Repeated inheritance
4. Class renaming in Lace

======================================================================

ETL Needs to be Updated
-----------------------

1. A class with a Multi_branch whose only Choice seems to be
   syntactically illegal (uniq1..-3) is accepted by the compiler.
   ETL page 239.  [illegal-multi-branch]
   

======================================================================
   
Possible bugs
-------------

1. I'm not certain this is a bug, but it is rather inconsistent.
   The inspect instruction below fails with "Unmatched inspect value".
   This seems counter-intuitive.

   Also, compiler accepts `when c then' where `c' is of type INTEGER_64
   but won't accept `when 0x7FFFFFFFFFFFFFFF then' even though the
   constant `0x7FFFFFFFFFFFFFFF' is the value of `c'.

   Are these bugs?  Should I report them?  Enquiring minds want to know.


class TEST
create
	make
feature
	make is
		local
			b: INTEGER_64
		do
			b := 0x7FFFFFFFFFFFFFFF
			inspect b
			when c then
				print ("Matched%N")
			-- If uncomment this line, reports VOMB(2) error
			-- when 0x7FFFFFFFFFFFFFF0 then
			end
		end

	c: INTEGER_64 is 0x7FFFFFFFFFFFFFFF
end

2. Compiler correctly reports a VOMB(2) error on this class, but reports
   the wrong line number for the error (reports line with the `print' 
   instruction instead of the line containing `x').

class TEST
create
	make
feature
	make is
		do
			inspect 1
			when 1 then
				print ("Matched%N")
			when x then
			end
		end

	x: INTEGER
end
    
3. Compiler correctly reports a VEEN error on this class, but reports
   the wrong line number for the error (reports line with the `print' 
   instruction instead of the line containing the call to `make').

class TEST
create
	make
feature
	make is
		do
			try
		end
	
	try is
        	indexing
            		attribute: create {TEST2}.make 
        	end
		do
			print ("Weasel");
		end     
end
    
4. Documentation for VGCC constraint, both in new ETL3 and in estudio
   delivery, says that a creation procedure cannot be `once'.  But the
   compiler does not enforce this restriction.  I'm assuming that the
   documentation needs to be corrected or that this issue is still
   being debated.  Let me know if this is a bug for which a test
   should be added.

5. Compiling a class that has a manifest string with 20000 null characters
   (actual nulls - not %/0/) takes 98 seconds!  If each null
   character in the string is replaced by %/0/, compilation finishes
   in 3.5 seconds.

======================================================================

Known syntax bugs:  syntax should be accepted but is not
--------------------------------------------------------

1. An empty Choices in a When_part of a Multi_branch is reported as
   a syntax error.  ETL page 239.  [empty-multi-branch-choices]
   [I argue that spec is correct and compiler is wrong.  If Choices
   is empty then that branch is never executed.  Manu says he could
   fix it but is not sure whether he should.  05-jun-2003]

2. The free operator `prefix "##%%"' should be legal, since non-first
   characters may be any printable characters.  But the compiler
   reports a syntax error for a declaration of this free operator.
   ETL page 419.  [free-operator-reject]
   [Syntax of free operator still in flux.  05-jun-2003]

3. An assignment whose source is an address expression `$x' (which is
   of type pointer) and whose target is of type POINTER should be
   accepted, but the compiler reports a syntax error.  Replacing `$x'
   with `ptr ($x)', where `ptr' just returns its argument, causes the
   compiler to accept the class.  [assign-addr-expr-to-pointer]

4. A class with a declaration and call of an operator feature which
   contains an embedded double-quote character (written %") appears to
   be valid but the compiler reports a syntax error.
   [weird-operator-feat-name]
   [Syntax of free operator still in flux.  05-jun-2003]

5. An external routine has a Special_external_decl which casts the
   arguments.  If the type to which an argument is cast is "(long,
   float, int * (*) (long, float, void (*) (long, long)), struct
   weasel, enum wimp)", the compiler reports a syntax error.
   [cast-arg-type-with-parens]
   [Manu says to leave the test.  He thinks he should add function pointer
    as an allowed Type_identifier.  06-jun-2003]

6. A class with an attribute right before a trailing indexing clause
   causes the compiler to report a syntax error, but only if
   the attribute declaration does not end with a semicolon.
   [trailing-indexing-no-semicolon]
   [Manu says to leave it as an error until ECMA resolves issue.  
    Caused by compiler assuming that indexing is the indexing clause of
    attribute, so it thinks there is no final "end" to the class.  05-jun-2003]

7. A generic class with a Constraint_creators that has an empty
   Feature_list should be accepted, but the compiler reports a syntax
   error.  [generic-create-empty-feat-list]


Known syntax bugs:  syntax should not be accepted but is
--------------------------------------------------------

1. A number of words which are supposed to be reserved words are
   actually not reserved, since one can declare a feature with their
   names.  ETL page 418.  [reserved-words-not]
   [Compiler currently accepts the following reserved words as
    feature name:  assign, attribute, pure, reference, TUPLE]

2. The character constant ''' is accepted, but should not be. 
   ETL page 423. [syntax-disagreements-2]
   [Manu says lexer has comment that this is not valid Eiffel, but
    allows it anyway.  Says he will add a warning and support it
    for awhile longer.  06-jun-2003]

3. A manifest string in the extended form which contains lines with
   only white space (blanks and tabs) but no leading and trailing
   percent sign is accepted, but should not be.  ETL page 390.
   [manifest-string-blank-lines]
   [Manu says he will discuss with ECMA.  06-jun-2003]

4. A manifest string which contains the illegal "character" '% '
   (percent followed by space) is accepted, but only if there are an
   even number of consecutive occurrences of this invalid character.
   ETL page 420.  [manifest-string-percent-space]
   [Manu says he will discuss with ECMA.  06-jun-2003]

5. Compiler accepts but completely ignores many characters at certain
   positions inside an external routine declaration.  These characters
   include !#$%^-=+\|`~{}[];'./?%/0/%/1/ and probably others.
   [external-nonwhite-chars-ignored]



Known syntax bugs:  possible language design flaw
-------------------------------------------------

1. An anchored declaration whose anchor is the final name of an
   operator feature is rejected by the compiler as a syntax error.
   This is really a language design problem.  ETL page 197.  
   [valid-anchored-decl]

2. An operator feature which is a prefix feature implemented as an
   attribute cannot be named in a strip expression.  This is
   (possibly) a language design problem rather than a compiler bug,
   since ETL allows only a list of Identifiers inside the parentheses
   of a strip expression.  ETL page 397.  [strip-no-prefix-opers]

======================================================================

Known validity bugs:  validity constraint not fully enforced
------------------------------------------------------------

1. An assignment with source type `PARENT' and target type `like
   Current' is incorrectly allowed in a feature of the class PARENT.
   ETL pages 225-226. [inherited-assign-violation]
   [Sent my comments to Manu, indicating that I think compiler is wrong.
    He agrees that compiler should complain about the descendant class.
    06-jun-2003]

2. A feature name appears in the Redefine subclause and the Features
   part of the class contains a redeclaration which effects the
   feature.  The compiler does not complain although this appears to
   violate VDRS4.  ETL page 159.  [redefine-subclause-violation]
   [Sent my comments to Manu, indicating that I think compiler is wrong.
    07-jun-2003]

3. A class with an external or deferred routine whose Locals part is
   just `local', with an Entity_declaration_list which is completely
   empty, violates VRRR but the compiler accepts the class.
   ETL page 113. [validity-vrrr-basic]
   [Sent my comments to Manu, indicating that if the compiler is
    right then the spec must be changed so that it is only a VRRR(2)
    error if the Entity_declaration_list is not empty.  07-jun-2003]

4. A system has a class which inherits from another class three times,
   renaming one of its features in two of the Parent parts and
   selecting the renamed feature twice.  This violates the letter of
   VMRC(2), but the compiler does not complain.  ETL page 191.
   [replicated-feat-multiple-select]

5. An assignment of an entity of type DOUBLE to an entity of type
   REAL should be a VJAR violation, but the compiler accepts it.  ETL
   pages 229 and 311.  [double-assigned-to-real]

6. Class A has an operator feature exported only to itself and its
   descendants.  When class B (which is not a descendant of class A)
   tries to call this feature, the compiler should report a VUEX(2)
   error.  Instead, it accepts the invalid classes.  If the feature
   is an identifier feature, the compiler correctly reports VUEX(2).
   [operator-feat-export-to-self]

7. A routine with a secret precondition does not violate VAPE because
   the routine itself is also exported to {NONE}.  But the class
   containing this routine is inherited by another class and the
   routine export status is changed to {ANY}, yielding a generally
   available routine with a secret precondition.  The compiler does
   not detect the VAPE error.  [secret-precondition-heir-export]

8. The type `expanded TEST1 [DOUBLE]' should not conform to the type
   `expanded TEST1 [STRING]'.  But the compiler accepts an assignment
   involving these two types.  Executing the resulting system
   naturally ends in disaster.  [expanded-generic-conformance]

9. An Ace has a visible clause for a class which exists but is not
   reachable from the root class, which violates VD31.  If the class
   is in a cluster which is not part of a precompiled library, the
   VD31 violation is not detected.  [vd31-nonprecompiled-sneak]
   [Sent message proposing that this one be changed to pass, since
    it looks like VD31 has been abandoned.  17-jun-2003]

10. An Ace has two clusters with path names that are identical except
    that one has a trailing "/" character.  This violates the spirit
    of VD28, but the compiler does not detect the VD28 error.
    [vd28-trailing-slash]

11. A system has an Ace which specifies a visible class FOO, where FOO
    is reachable from the root class.  After initial compilation where
    the system is frozen or finalized, a local is removed, making class
    FOO unreachable from the root.  When the system is recompiled, the
    compiler correctly detects the VD31 error.  But when the local is
    added back in and compilation is resumed, the compiler dies during
    degree -3 (during dead code removal if system was finalized).
    Note: with 4.3, the VD31 error is not detected at all, even
    without incrementality.
    [make-visible-class-unreachable]
    [Sent message proposing that this one be changed to pass, since
     it looks like VD31 has been abandoned.  17-jun-2003]
    
12. Compiling a system whose Ace has a visible clause with an export
    restriction which lists a nonexistent feature name does not cause
    the compiler to report any validity violations.
    [visible-export-nonexistent-feat]

13. The compiler accepts variable and constant attributes which
    violate VFFD1 because they have a Formal_arguments part, even
    though its Entity_declaration_list is empty.  [illegal-attributes]

14. The precursor construct is used in a routine inherited twice from
    the same generic class with different actual generic parameters.
    The compiler thinks the precursor routine returns one type, but
    it actually returns a child type so system execution fails.
    If the order of the parent clauses is switched, the compiler
    reports a VJAR error instead of accepting the classes.
    [two-generic-precursors]

15. A reference to `$Result' is allowed in a class invariant,
    but should be a VEEN(2) error.  [invariant-result-address]

16. A class inherits from a second class and renames two effective
    features to a new name, redefining that new feature name.
    The redefinition calls precursor.  The compiler should report
    a VUPR(3) error, but it accepts the classes.  [two-precursors-same-parent]

17. A system's root class has a `create make' clause.  The Ace file specifies
    `default_create' as the root creation procedure.  The compiler
    should report a VD27 error, but does not. [default-create-no-vd27]

18. According to page 229 (and general conformance on page 219), NONE
    does not conform to an expanded type or to a Bit_type.  But the
    compiler accepts assignment of Void to entities declared of these
    types.  [none-conform-bit-expanded]

19. A creation instruction `create {C} f' where f is of type C
    becomes invalid in a descendant when the type of f is redefined to
    be a descendant of C.  The compiler should report some kind of
    validity violation, but it does not.  [inherited-vgcc]

20. An assignment  `e1 := e2' where e1 and e2 are both of type E
    becomes invalid in a descendant when the type of e1 is redefined to
    be a descendant of E.  The compiler should report some kind of
    validity violation, but it does not.  [inherited-vjar]

21. A call to a static feature `feature {FOO [DOUBLE]}.value' where
    FOO is declared as FOO [G -> STRING] should elicit a VTCG error
    but the compiler accepts the invalid type.
    [generic-static-vtcg]
    
22. A class TEST1 that contains an attribute of type "like Current" is used
    in a declaration for a local of type "expanded TEST1".  This
    creates an expanded client cycle, so the compiler should report a
    validity error, but does not.  [indirect-vlec]
    
23. A class has a generic parameter G of type XXX with a generic
    creation clause `create default_create end'.  It also has a
    creation instruction whose target is an attribute of type G.  If
    XXX is a deferred class, the compiler should report a VGCC(1)
    error but it does not.  [generic-create-deferred]
    
24. A class whose generic parameter is constrained by `DD [BIT name]',
    where "name" is an unknown identifier, is accepted by the compiler
    but should not be.  [bit-identifier-in-generic]
    
25. A class has a call to a static feature `feature {FOO [BIT weasel]}.value'
    where FOO is an unconstrained generic class, but `weasel' is an
    unknown identifier.  The compiler accepts the class but should
    not.  Executing melting system prints "Error: could not read
    Eiffel update file".  [bad-bit-identifier-in-static]
    
26. An assignment of `expanded TEST2' to `expanded TEST1' where TEST2
    inherits from TEST1 should be a VJAR error, but the compiler
    accepts it. [expanded-expanded-conformance]

27. A precompiled library includes a cluster whose tag is `foo',
    which contains a class TEST.  An Ace file that uses this
    precompiled library also includes a cluster with tag `foo' that
    has its own class TEST, but this cluster has a different path.
    The compiler should report a VDCN error but does not.
    [precompiled-vdcn-sneak]

28. A call `io.put_string (<< << "A" >> , << 47 >> >> @ 2 @ 1)' should
    be rejected as a VUAR(2) error but the compiler accepts it.
    [nested-manifest-array-vuar]



Known validity bugs:  valid but compiler reports validity violation
-------------------------------------------------------------------

1. A system with a case of repeated inheritance which appears to be
   valid is reported to violate the Feature Name rule.  ETL page 170.
   [valid-repeated-inheritance]

2. In a generic class TEST1 [G, H -> NONE], an assignment of Void
   (which is of type NONE) to an entity of type G is permitted.  But
   an assignment of an entity of type H (which conforms to NONE) to an
   entity of type G is rejected as a violation of the Assignment Rule
   (VJAR).  [conformance-inconsistency]

3. An attribute of type `TEST1 [TEST1 [DOUBLE]]' where TEST1 is
   declared as an expanded class causes the compiler to report a VLEC
   error.  But TEST1 has no attributes at all so there cannot be an
   expanded client cycle.  ETL page 94.  [nonexistent-vlec]

4. A class calls (on an entity of another type) a feature which is
   exported to it.  The compiler rejects the class as violating
   VUEX(2), but only if the feature is an operator feature.
   [selective-export-operator-feat]

5. A class TEST calls (on an entity of type TEST1) a feature which
   should be exported to it.  The compiler incorrectly rejects the
   class as violating VUEX(2).  If an export restriction is changed
   from `{TEST1}' to `{NONE}', which if anything ought to make fewer
   features exported to TEST, the compiler correctly accepts the
   classes.  [join-features-invalid-vuex]

6. The compiler incorrectly reports a VUEX(2) error on class which
   tries to call a feature on an entity of type FOO.  If the order of
   the parent clauses in the inheritance inside FOO is switched the
   VUEX error magically disappears.  [switch-parents-vuex-gone]

7. A system has a generic class with constraint `-> ARRAY [TEST2]'.
   If another class inherits from the generic class, providing
  `ARRAY [TEST2]' as actual generic parameter *and* if TEST2 is an
   expanded class, then the compiler incorrectly reports a VTCG
   error.  [bogus-vtcg]

8. A feature `z: TEST2 [like w, like w]' where TEST2 is a generic
   class with two unconstrained formal generic parameters should be
   valid, but the compiler says it violates VTAT(1).
   [two-anchored-actual-generics]

9. Two features are both declared as `z: like out' in separate
   classes.  A third class inherits from both of these classes.  The
   features appear to have identical signatures, since they both have
   the same version of `out', but the compiler reports a VDJR error.
   [merge-anchored-bogus-vdjr]

10. A class inherits twice from the same parent and renames the single
    inherited feature, thereby replicating it.  But when an heir of
    this class tries to give these two feature the same name by
    renaming one of them (sharing under repeated inheritance) the
    compiler reports a VMFN error.  [replicate-then-share]

11. A generic class with an explicit creation type in an instruction that
    creates an attribute of a generic type appears to be valid, but
    the compiler reports a VGCC(3) error.
    [simple-explicit-generic-create]

12. A class has Generic #2 constrained by Generic #1, but the
    compiler won't use this fact to allow an inheritance of
    another generic class that requires Generic #2 to conform
    to Generic #1. [generic-constraint-not-used]

13. A class inherits twice from another class, redefining the single
    feature and also renaming it.  When the redefinition attempts to
    call precursor, the compiler reports a VUPR(2) error though it
    appears that it should accept the classes.  [bogus-vupr2]

14. A call to a static feature `feature {FOO [like Current]}.value' where
    FOO is declared as FOO [G] causes the compiler to report a VSTA(1)
    error, which says to make sure "FOO [like Current]" is just a
    class name and not a type specification.  But the compiler accepts
    `feature {FOO [STRING]}.value' and "FOO [STRING]" is a type
    specification.  [inconsistent-vsta1]

15. A class A has a deferred routine with an argument anchor to an attribute 
    `a'.  A second class B inherits A and has an identical deferred
    routine with the same name, where the routine in B is also
    anchored to `a'.  Class C inherits both A and B.  The compiler
    incorrectly reports a VDJR error.
    [anchored-argument-bogus-vdjr]

16. A class that has an assignment of a manifest INTEGER constant
    whose value is the minimum value for an INTEGER (-2147483648)
    is rejected by the compiler as a VJAR error.  Similarly for INTEGER_8,
    and INTEGER_16 (INTEGER_64 works correctly).
    [assign-minimum-integer-vjar]

17. A class has a routine with a single argument `a: ARRAY [like c]' where
    `c: expanded TEST1'.  A call to this routine with actual argument
    << c >> should be accepted but is rejected as a VUAR(2) error.
    If `c' is not of an expanded type, compiler accepts the class.
    [pass-manifest-array-expanded]

18. An Ace file with a cluster which explicitly includes one of
    the files (test.e) contained in the corresponding directory
    causes the compiler to report a VSCN error, even though there
    is really only one file containing a class named TEST.
    The error message is quite confusing.
    [cluster-include-std-class-file]

19. A class that attempts to undefine an external routine causes 
    the compiler to incorrectly report a VDUS(2) error.
    [undefine-external-vdus2]




Known validity bugs:  possible missing or incomplete constraint
---------------------------------------------------------------

1. In the Undefine, Redefine and Select inheritance subclauses,
   ETL does not address the case where `fname' is the final name in C of
   more than one feature inherited from B, due to renaming.  How
   can one merge two features inherited from the same class, one of which
   is effective and the other deferred, and have the resulting feature
   be deferred?  [undef-mult-precursors]

2. A class has a secret procedure with a precondition which references
   a secret attribute.  This procedure is available to {ANY} as a
   creation procedure.  The compiler should report a VAPE violation
   but it accepts the class.  Actually, I believe that VAPE may need
   to be extended to say that "every feature whose final name appears
   in any Assertion_clause is also available to every class to which
   `r' is available for *creation*".  Otherwise, the creation
   procedure can have a secret precondition. [creation-proc-secret-precond]

3. A class with a clients part that includes two or more occurrences
   of the same class name should possibly be a validity violation,
   but there is no validity constraint which prevents this.
   [clients-duplicate-class-name]


Known validity bugs:  undocumented or wrong validity code reported
------------------------------------------------------------------

1. If both class A and B inherit from A, then there is an
   inheritance cycle which involves only A.  But if A is a client of
   B, then the compiler incorrectly reports that both A and B are
   involved in an inheritance cycle.  The error code is correct; only
   the names of the classes involved in the cycle is wrong.
   [a-inherit-a-client-b]

2. A multi-branch with a unique constant which occurs in more than one
   "when" branch is reported as violating VOMB(4), which is correct.
   But the compiler also reports a spurious VOMB(3) error (VOMB(3)
   does not apply since there are no non-Unique inspect constants in
   the example).  [all-unique-bogus-vomb-3]

3. A call `!!x' with `x' of type TEST1 where TEST1 has a Creators part
   with no creation procedures listed should be a VGCC(5) error but
   the compiler reports VGCC(6).  [vgcc5-called-vgcc6]

4. A call `!!x.make' with `x' of type TEST1 where TEST1 has no
   Creators part at all should be a VGCC(4) error but the compiler
   reports VGCC(6).  [vgcc4-called-vgcc6]

5. A constant attribute which has declared type of `like Current'
   causes the compiler to report a bogus VFFD(7) error when the
   constant used in the declaration is a string or a bit type (i.e.
   in addition to the VQMC(5) or VQMC(6) error).  [vqmc-extra-bogus-vffd7]

6. An assignment to a feature which is a function violates VJAW.  When
   this function takes no arguments, the compiler reports VJAW.  But
   when the feature which is the target of the assignment takes
   arguments, the compiler incorrectly reports a VUAR(1) error.  This
   cannot be correct since no feature calls are involved in the
   instruction.  An attempt to add arguments to the feature produces 
   a syntax error.  [vjaw-called-vuar1]

7. A system with two classes of the same name in different clusters
   causes the compiler to incorrectly report a VSCN violation.
   [validity-vscn-diff-cluster]

8. A creation instruction whose target is a procedure or function should be
   a VGCC violation.  The compiler instead reports a VUAR(1) error,
   but only if the routine takes arguments.  [vgcc-called-vuar1]




Known validity bugs:  wrong or missing information in error message
-------------------------------------------------------------------

1. Specifying `assertion ("require")' in the Ace results in an error
   message which says "Invalid option value: require".  This could be
   very confusing since `require' is definitely a valid value for the
   `assertion' option.  [lace-quoted-option-value]

2. Using an unsupported language in a Generate or External clause in
   the Ace correctly elicits a VD33 or VD34 error.  But the error
   message says that only `C' is supported.  In fact, `Object' is also
   allowed.  [lace-vd33-vd34-object-ok]

3. A class that declares `bit_constant: BIT 2 is 1111b' correctly
   elicits a VQMC error, but the compiler says the type of the
   constant is BIT 0 instead of BIT 4.

4. A VMFN error is correctly reported when two inherited
   infix features are renamed into the same feature without redefining
   that feature.  But the feature names given are `infix ""'
   instead of `infix "+"' and `infix "-"'.  [infix-missing-name]
    
5. A constrained generic class with a creation clause that names
   an existing attribute `x' causes the compiler to report 
   that "feature `x' does not exist".  Also, a generic creation clause
   that names an existing feature that is not an attribute but is also
   not a procedure or not a creation procedure causes the compiler to
   report a very confusing error message.  [bad-generic-creation-constraint]
    
======================================================================

Known incrementality bugs:  silent premature compiler termination
	when "automatic_backup" is true
-----------------------------------------------------------------

1. After initial compilation, a cluster in the Ace file is changed from
   the form "all root_cluster" to a list of the two specific clusters
   in the root cluster directory.  Recompilation works fine.  However,
   when the Ace is then changed to indicate a new root class and
   and the class name inside one file is also changed, a second
   recompile ends with a segmentation fault in `backup_directory'.
   This only happens if "automatic_backup" is true.
   [backup-directory-disaster]


Known incrementality bugs:  silent premature compiler termination
	(terminates with exception trace if `fail_on_rescue (yes)'
-----------------------------------------------------------------

1. After initial compilation, a constraint is added to the formal
   generic parameter of a class which is used in the generic
   constraint of another class.  When the system is recompiled, the
   compiler correctly reports a VTCG error.  But when the newly
   added constraint is removed and compilation is resumed, the
   compiler dies with a segmentation fault during degree 5.
   [vtcg-in-generic-constraint]
   
2. After initial compilation, the type of an entity in a generic class
   is changed from `FOO [G]' (where G is the name of the formal
   parameter of the enclosing generic class) to `FOO [STRING]', thereby
   introducing a VEEN error.  When the system is recompiled, the
   compiler terminates with a bus error during degree 5.
   [generic-veen-sneak]

3. After initial compilation, an extra unused formal generic parameter
   is added to a generic class and an extra actual generic parameter
   is added to the only generic derivation of this class.  When the
   system is recompiled, the compiler terminates during degree 5.
   [add-unused-formal-generic]
    
4. After initial compilation, a constraint on a formal generic
   parameter of a class that is used in the generic constraint of
   another class is changed.  When the system is recompiled, the
   compiler correctly reports a VTCG error.  But when the constraint
   is changed back to its original valid form and compilation is
   resumed, the compiler dies with a bus error.
   [add-remove-constraint-vtcg]
   
5. A pair of generic classes that mention each other in their
   formal generic constraints is invalid.  When some of the actual
   generic parameters are NONE, the compiler correctly detects the
   VTCG error.  But when compilation is resumed without any change to
   the classes, the compiler dies with a bus error.
   [resume-vtcg-none-actual]
   
6. A pair of generic classes that mention each other in their
   formal generic constraints is invalid.  After the compiler
   correctly detects the VTCG error, one of the actual generics in the
   constraint is changed.  Compilation then terminates with a
   segmentation violation and no exception trace at all.
   [constraint-cycle-change-generic]
   
7. A system compiles correctly without a precompiled cluster.  Then
   file "any.e" is excluded from the kernel cluster.  After the VD23
   errors are reported, the exclude clause is removed.  When
   compilation is resumed, the compiler dies with a run-time panic.
   [exclude-any-add-back]

8. A system has a class that inherits a deferred feature `value',
   which is of type string, and effects it with a string constant.
   After initial compilation, the effecting feature name is changed,
   introducing a VCCH(1) error.  When compiler reports the error,
   feature is changed back to `value' and compilation finishes.
   But when the system is then frozen, the compiler dies
   with a segmentation fault in `real_body_id'.  
   [In 5.4.0403, after the change back to `value', compilation finishes
    but system execution fails with a segmentation fault.]
   [add-remove-vcch-freeze]

9. After initial compilation, a generic class TEST1 [G] is changed to
   a non-generic class and the class that inherits from TEST1 is
   changed correspondingly.  When the system is frozen, the compiler
   dies in degree -1.  [remove-formal-generic]
   
10. A class with a generic parameter with a constraint 
    `-> STRING create xxx end' is compiled.  The compiler correctly
    reports a VTCG error.  When `xxx' is changed to `make' and
    compilation is resumed, compilation should finish but the compiler 
    dies in degree 4 on the class.  [change-generic-create]
   
11. A generic class whose formal generic parameter G is constrained by
    STRING has a call to `n.count' where `n: G'.
    After initial compilation, the generic constraint is removed.
    When the system is recompiled, the compiler does not detect
    the newly introduced VEEN error and dies during degree 2 on
    the class.  [remove-constraint-veen-die]

12. An expanded class with an attribute of type `like Current' 
    is correctly reported as a VLEC error.  But when compilation is
    resumed with no change to any classes, the compiler goes into
    infinite recursion in SKELETON.equiv.
    [expanded-like-current-vlec]




Known incrementality bugs:  invalid class or system accepted
------------------------------------------------------------

1. When a second precompiled cluster is added to the Ace after
   compilation and the system is recompiled, the VD38 violation is not
   detected.  [vd38-sneak]

2. After initial compilation, an `adapt' clause which specifies that
   another cluster should be ignored is deleted from the Ace.  When
   the system is recompiled, the compiler does not detect the VSCN
   error introduced by this change.  [delete-adapt-vscn-weasel]

3. After initial compilation, an inherited integer constant attribute
   which is an inspect constant in the heir is changed to a function
   with no arguments.  The compiler does not detect the VOMB error.
   [vomb-sneak]

4. When an inherited constant integer attribute used as the number of
   bits in a BIT type is changed to a function with no arguments, the
   compiler does not detect the newly introduced VTBT error if the
   modified class is not an immediate ancestor.  [vtbt-granddad-weasel]
   
5. A system with two classes compiles fine.  A violation of the
   Expanded Client rule (VLEC) is introduced and the compiler detects
   it.  But when the formal generic parameter of the class violating
   the rule is removed, compilation is resumed and then the formal
   generic parameter is added back, the VLEC violation is still there
   but the compiler does not detect it.  [vlec-sneak]

6. After initial compilation, the value of a constant integer
   attribute is changed, thereby introducing a VTBT violation in a
   type used as an actual generic parameter.  When the system is
   recompiled, the compiler does not detect the VTBT violation.
   [actual-generic-vtbt-sneak]

7. After initial compilation, an actual generic parameter in a
   generic constraint is changed, thereby introducing a VTCG error.
   When the system is recompiled, the compiler does not detect the
   error, but only if the generic class is also an expanded class.
   [vtcg-sneak]

8. After initial compilation, a creation feature named in
   a generic constraint is removed entirely from the class.
   When the system is recompiled, the VTCG validity error is
   not detected.  [vtcg-remove-creation-feat]

9. After initial compilation, the creation procedure named in a generic
   constraint is removed from the creation clause in its class, but the
   feature is left there.  When the system is recompiled, the VTCG
   validity error is not detected.  [vtcg-remove-creation-clause]

10. After initial compilation, a VJAR error is introduced and the
    system is recompiled.  The compiler does not detect the VJAR
    error.  This case involves changing an actual generic parameter
    in an inheritance clause from G to STRING.  The redefined
    function calls precursor. [vjar-sneak]

11. After initial compilation, a VUPR(3) error is introduced by
    removing an inheritance clause, yielding no effective precursors.
    The compiler does not detect the VUPR(3) error.  [vupr-sneak]

12. After initial compilation, formal generics in an inheritance
    clause are switched, causing a class to no longer conform to the
    generic constraint.  The class is used as an actual generic in a
    generic constraint.  The compiler does not detect the newly
    introduced VTCG error.  [switch-generics-tricky-vtcg]

13. After initial compilation, an inheritance clause is deleted,
    thereby introducing a VTCG error because actual generic #2
    no longer conforms to actual generic #1, as required by generic class.
    The compiler does not detect the error.  [delete-parent-vtcg-sneak]

14. After initial compilation, formal generics in an inheritance
    clause are switched, causing a type involved in a redefined
    feature to no longer conform to the ancestor feature's type.  The
    compiler does not detect the newly introduced VDRD(2) error.
    [switch-generics-tricky-vdrd]

15. After initial compilation, two routines which were declared separately 
    are changed so that they share a single redeclaration, which calls
    precursor.  When the system is recompiled, the compiler does not
    detect the VUPR(1) error.  [make-synonyms-vupr-sneak]

16. A system with a generic class with formal parameter G compiles
    fine.  When a new class G is added to the universe and the system
    is recompiled, the compiler does not detect the VCFG error.
    [vcfg-sneak]

17. After initial compilation, an integer constant attribute is
    changed to a function with no arguments.  The compiler does not 
    detect the newly introduced VSTA error (reference to a static feature
    which is not a constant or external). [vsta-sneak]

18. A system with two classes is compiled.  Both classes are in the same 
    cluster and the Ace file uses "all" to include all classes in the
    entire directory tree.  Then a new sub-directory is created and a
    class with the same name is added to it.  When the system is
    recompiled, the compiler does not detect the VSCN error.
    [new-cluster-vscn-sneak]

19. After initial compilation, a VGCC(6) error is introduced by
    removing an inheritance clause, making a feature that is
    selectively available for creation no longer available.  The
    compiler does not detect the error.  [vgcc-weasel]

20. After initial compilation, a VTEC(2) error is introduced by removing
    an inheritance clause.  When the system is recompiled, the
    compiler does not detect the error.  [vtec-weasel]

21. After initial compilation, a procedure name is removed from
    a generic constraint.  When the system is recompiled, the
    VGCC(8) error is not detected. [vgcc-remove-generic-creator]

22. After initial compilation, the tag in an indexing clause is changed
    from "weasel" to "attribute".  This introduces a VEEN error but
    the compiler does not detect it.  [chg-indexing-tag-to-attribute]
   
23. After initial compilation, a VUPR(2) error is introduced by
    removing an inheritance clause for ANY, where a routine is calling
    `{ANY} precursor'.  The compiler does not detect the newly
    introduced VUPR(2) error.  [uninherit-any-vupr2-sneak]

24. A generic class whose formal generic parameter G is constrained by
    STRING has a call to an agent whose open target is {G}.
    After initial compilation, the generic constraint is removed.
    When the system is recompiled, the compiler does not detect
    the newly introduced VEEN error.
    [remove-constraint-veen-sneak]

25. Class A has a qualified call to one of its own features, where the 
    feature is exported only to B and its descendants.  This is valid
    since class A is a descendant of B.  But when the inheritance
    clause is removed, so that A is no longer a descendant of B, and
    the system is recompiled, the VUEX violation is not detected.
    [vuex-weasel]

26. After initial compilation, a VUPR(3) error is introduced by
    changing an inherited deferred feature to effective, so that a
    routine calling precursor has two precursors.  On recompile, the
    compiler does not detect the VUPR(3) error.  [vupr-weasel]

   

Known incrementality bugs:  valid class or system rejected
----------------------------------------------------------

1. A system with an Expanded client rule violation (VLEC) is compiled.
   When the compiler correctly detects the violation, the violation is
   removed and the compilation is resumed, but the compiler still
   reports a VLEC violation.  [vlec-compiler-wrong]

2. The compiler correctly detects and reports a VCFG(1) violation when a
   generic class has a formal generic parameter with the same name as
   a class in the universe.  But when an inheritance clause is
   deleted, thereby removing the generic class from the universe, the
   compiler still reports a VCFG(1) violation on the generic class.
   [bogus-vcfg]

3. After initial compilation, the type of an actual generic parameter
   which is part of a generic derivation is changed.  When the system
   is recompiled, the compiler reports a nonexistent VLEC violation.
   [bogus-vlec]
   
4. A system whose root class inherits from a class TEST2 which exists
   in two different clusters correctly elicits a VSCN error report
   from the compiler.  But when the Ace is changed to indicate a
   different root class, which does not depend on TEST2, the compiler
   still reports a VSCN error.  If the final versions of the classes
   are compiled from scratch, no errors are reported.
   [new-ace-root-still-vscn]

5. After initial compilation an inherited variable attribute in a
   grandparent is changed to a constant attribute, thereby introducing
   a VDRS(2) violation.  But when the constant attribute is changed back
   to a variable attribute, the compiler still reports a VDRS(2) error
   though none is present.  [bogus-vdrs]

6. After initial compilation, the Ace is changed to indicate a new
   root class, which happens to be generic.  The compiler detects the
   VSRC(1) error.  But when the Ace is changed to indicate a new (and
   newly added) root cluster with a valid root class the compiler
   reports a bogus VSCN error.  [new-root-cluster-bogus-vscn]

7. A system has an Ace which specifies the precompiled cluster EiffelBase
   and also has a cluster with Cluster_tag `kernel'.  After initial
   compilation, the tag `kernel' is changed to `other' and the system
   is recompiled.  The compiler then reports an erroneous VD28 error.
   [bogus-vd28]

8. A system with two classes is compiled.  The compiler detects the
   syntax error on the second class.  Then the root class is changed
   so that the second class is no longer reachable from the root.
   When compilation is resumed, the compiler still reports a syntax
   error on the unreachable class.
   [unreachable-syntax-error]

9. A system with two classes is compiled, where one of the classes
   is mentioned in an option clause in the Ace file.  Both classes are
   in the same cluster and the Ace file uses "all" to include all
   classes in the entire directory tree.  Then a new sub-directory is
   created and the class is moved into that sub-directory.  When the
   system is recompiled, the compiler reports a bogus VD16 error.
   [move-class-bogus-vd16]

10. A system with one cluster preceded by the keyword "all" in the Ace
    file is compiled, where the cluster does not exist.  The compiler
    correctly reports a VD01 error (nonexistent cluster path in Ace
    file).  Then the cluster is created with one sub-cluster `sub'
    which contains the root class.  When compilation is resumed, the
    compiler reports a bogus VD30 error.  [create-sub-cluster-bogus-vd30]

11. After initial compilation an expanded class is changed to a
    deferred class but another class still tries to create an instance
    of it.  The compiler correctly detects the VGCC(2) error.  But
    when the create instructions are removed, the compiler reports a
    bogus VTEC(1) error.  [bogus-vtec]

12. A system has its own STRING class, excluding the one from
    EiffelBase.  This STRING class does not inherit from
    TO_SPECIAL [CHARACTER], which causes a VEEN error.  After
    the compiler correctly detects this error, the missing inheritance
    clause is added to STRING.  The compiler then reports a bogus
    VGCC(5) error in class MISMATCH_CORRECTOR.  [own-string-bogus-vgcc5]




Known incrementality bugs:  wrong error reported
------------------------------------------------

1. After initial compilation a constant attribute in an ancestor class
   is changed from a unique constant to a constant integer, thereby
   introducing a VOMB(5) error.  When the compiler detects the error,
   the constant integer is changed to an integer function with no
   arguments.  The compiler still reports a VOMB(5) error when there
   is actually a VOMB(2) error.  [vomb2-called-vomb5]

2. A class with a once function whose return type is a formal generic
   parameter is correctly reported to violate VFFD(7).  Then a class
   with the same name as the formal parameter is added to one of the
   clusters.  When compilation is resumed, the compiler still reports
   VFFD(7) instead of VCFG(1).  [vcfg1-called-vffd7]

3. After initial compilation, a class is changed to an expanded
   class.  The compiler detects the newly introduced VDRD(2)
   violation.  When an invalid creation instruction is added, the
   compiler reports a bogus VDRD(2) error instead of the
   expected VGCC error. [vdrd-weasel]


Known incrementality bugs:  exception displaying error message
--------------------------------------------------------------

1. A generic class has a formal generic parameter constrained by
   a nonexistent and invalid creation procedure `infix "@"'.  The
   compiler correctly reports VTCG error.  Then a syntax error is
   added to the class.  The compiler detects the error, but says
   "Exception occurred while displaying error message" when it tries
   to print the name of the class.  [vtcg-then-syntax-error]


Known incrementality bugs:  wrong results when melting involved
---------------------------------------------------------------

1. The "Hello weasel" program compiles and executes fine with
   `assertion (all)' and no precompiled cluster.  Then file "string.e"
   is excluded from the kernel cluster.  When the system is
   recompiled, it compiles fine but execution ends with an exception
   trace. [name-exists-invariant]

2. A class has an attribute of type `BIT Weasel_bits', where
   `Weasel_bits' is a very large constant integer.  After initial
   compilation where the system is melted, the integer value is
   changed to a very small number.  But system execution still ends
   with an "unknown attribute type" panic.  [reduce-bit-attribute-size]
   
3. After initial compilation, a class TEST2 which is used as an actual
   generic parameter (where the corresponding formal generic parameter
   is used to declare an attribute) is changed so that it is an
   expanded class.  When system is recompiled, system execution should
   call the creation procedure of TEST2 but it does not.
   [expand-generic-no-creation-call]
   
4. After initial compilation where the system is melted, the name of a
   routine in a parent class is changed, yielding a third inherited
   version of a redefined feature.  The new inherited version of the
   feature has no precondition, which should make the alternative
   precondition of the redefined feature true.  But the precondition
   is violated when the system is executed.  Execution works correctly
   when the system is melted from scratch.
   [add-alternative-precondition]
   
5. A class inherits from a generic class which has a routine that
   creates an entity of the generic type and prints its generating
   type.  After initial compilation where the system is melted, the
   printed result is correct.  Then the type of the actual generic is
   changed from STRING to SEQ_STRING and changes are melted.
   Execution then produces the wrong result (the same result as
   before).  [change-created-actual-generic]
   
6. After initial compilation where the system is melted,
   the default assertion level for a cluster obtain from a "Use" file
   is changed from "no" to "require".  When changes are melted and the
   system is executed, preconditions are not monitored.
   [change-use-assertion-level]
   
7. A system creates an instance of a class and prints the value
   of its only feature, which is a constant INTEGER attribute.  After
   initial compilation, the constant is changed to an INTEGER
   variable.  System execution still produces the correct result.
   Then the feature is changed back to an INTEGER constant and
   changes are melted.  System execution then dies with a
   segmentation violation.  [constant-variable-constant]
   
8. After initial compilation where the system is frozen, a class
   with routines which raise and rescue a developer exception is
   modified to add another routine into the call chain.  Also, the
   routine that raises the developer exception is modified by adding
   a `print (Void)' instruction.  After melting changes, system
   execution uses an enormous amount of memory (nearly 2 GB) before
   execution ends with a segmentation fault.  [huge-memory-leak]
   
9. After initial compilation where the system is melted, an expanded
   class with no creation procedure adds a redefinition of
   default_create.  The system is recompiled without error but the
   creation procedure of the expanded class is called twice (it is
   only called once if final classes are compiled from scratch).
   [expanded-add-default-create]
   
10. A class creates an instance of a second class, stores it in a file
    using `independent_store' and then opens the file and retrieves
    what was previously stored.  After initial compilation, system
    execution works correctly.  Then an instruction is added to a
    routine and changes are melted.  Execution then incorrectly ends
    with a mismatch retrieval error.  [melt-retrieval-mismatch]

11. After initial compilation, a class TEST2 which is used as an actual
    generic parameter (where the corresponding formal generic
    parameter has creation procedures specified and is used to declare
    attributes) is changed so that it is an expanded class.  One of
    the creation procedure names is also removed from the generic
    constraint.  When the system is recompiled, system execution dies with
    a segmentation fault.  [expand-generic-remove-creation]
   
12. After initial compilation, a class TEST1 is changed so that it
    is no longer expanded.  A class that inherits from TEST1 should
    now conform to it, but when changes are melted
    `type_conforms_to (dynamic_type (t2), dynamic_type (t1))' returns
    False. [unexpand-class-no-conformance]
   
13. A generic class whose formal generic parameter G is constrained by
    non-expanded class FOO has a routine that takes an argument of
    type G and passes it as the target in a call to an agent with an
    open target of type FOO.  A second class inherits this class and
    provides FOO as actual generic parameter.  The actual argument in
    the call to the routine is of type `expanded FOO'.  After initial
    compilation where the system is frozen, the actual generic
    parameter is changed to `expanded FOO' and changes are melted.
    Then the actual generic is changed back to `FOO'.  System
    execution then dies with a segmentation fault.
    [expand-unexpand-agent-target]
   
14. A simple system is frozen.  Then the system name is changed in the
    Ace file and changes are melted.  System execution then dies
    with "Error could not open Eiffel update file ./eiffelbase.melted".
    [change-system-name]
   
15. A system creates an instance of a class and prints the value
    of its only feature, which is a function returning INTEGER.  After
    initial compilation where the system is frozen, the constant is
    changed to an INTEGER attribute and changes are melted.  System
    execution still produces the correct result.  Then the feature is
    changed to an INTEGER constant and changes are melted.  System
    execution then produces the wrong result (the value returned by
    the original function).  [function-attribute-constant]
   
16. A system is compiled with an Ace file which specifies a nonexistent
    library via `object: "-lweasel"'.  Then the `object' clause is
    removed completely from the Ace and system is melted.
    When the previously generated C code is compiled, it won't link because
    the (nonexistent) library is still referenced.
    [remove-ace-object-clause]
   

Known incrementality bugs:  wrong results when refreezing involved
-------------------------------------------------------------------

1. Initially, the system is frozen with an Ace file using no precompiled
   library that specifies either `multithreaded (yes)' or
   `shared_library_definition ("/foo/bar")'.  Then the Ace file is
   changed to indicate `multithreaded (no)' or to delete the line with
   the shared_library_definition specification and the system is
   refrozen.  The compiled C code is not removed first, so the
   non-multithreaded code won't link.
   [turn-off-multithreaded]
    
2. After initial freezing of a generic class FOO whose formal
   generic parameter is constrained by DOUBLE, the constraint is
   changed to TEST2 with a generic creation procedure `default_create'
   and all references to FOO [DOUBLE] are removed.
   When the system is refrozen, the C code won't compile.
   [chg-constraint-add-create]
    
   
   
Known incrementality bugs:  wrong results when refinalizing is involved
-----------------------------------------------------------------------

1. After initial compilation where the system is finalized, a creation
   procedure is changed to take an argument, introducing a VUAR error.
   When the system is re-finalized, the compiler detects the error.
   Then the error is removed and compilation completes successfully,
   but the generated C code won't compile, due to conflicting declarations
   for the creation procedure's routine.  [add-vuar-remove-finalize]
   
2. A system has a root class which explicitly names `default_create'
   as creation procedure and redefines `default_create' to print
   something.  The Ace file specifies the root class, but does not
   specify a creation procedure.  After initial compilation where the
   system is melted, system execution correctly calls the redefined
   default_create.  But when the system is finalized with no changes,
   the finalized system produces no output and the redefined
   `default_create' has been removed by dead code removal.
   [implicit-def-create-finalize]
   
3. A class has a routine `try (t: like n): like t' which just returns
   its argument, where `n: INTEGER is 47'.  After initial compilation
   where the system is melted, the declaration of `n' is changed to
   `n: DOUBLE is 13.25' and the system is finalized.  System execution
   then produces the wrong result (13 if finalized with inlining, -NaN
   if finalized without inlining and -O2, internal compiler error in
   gcc 3.2.2 if finalized without inlining and -O3).
   [change-anchor-type-finalize]
   

Known incrementality bugs:  wrong results when recompilation involved
---------------------------------------------------------------------

1. After initial compilation, a constant integer attribute referenced
   in a BIT type which is the return type of a function is given a
   different (larger) value.  After recompilation, the function should
   return a larger BIT type during system execution but it does not.
   The initial compilation and recompilation can each be either a melt
   or a freeze - the problem occurs regardless.  [bigger-bit-func-wrong-value]

2. After initial compilation where the system is frozen, but without
   C code compilation, an inheritance clause is removed, which removes
   a class from the system.  Changes are melted.  When system cannot be
   executed (because C code wasn't compiled), an attempt is made to
   compile the C code.  However, it won't link due to an undefined
   symbol.  [freeze-no-c-compile-melt]
 
   
Known incrementality bugs:  wrong results when re-precompilation involved
-------------------------------------------------------------------------

1. After initial compilation where a class plus EiffelBase is precompiled
   the system is precompiled again using precomp.epr file.  The
   compiler dies with a segmentation fault in FILE_NAME.make_from_string.  
   Compiler should probably say that project is read-only.
   [precompile-again]



Known incrementality bugs:  wrong results when interrupt involved
-----------------------------------------------------------------

1. After initial compilation, a system is recompiled with no changes
   made.  When the message "Melting changes" is displayed, control-C
   is typed immediately, resulting in the message "Error: could not
   write to ./EIFGENs/test/project.eif" and a resume prompt.  Then the
   compilation is resumed and it appears to complete successfully.
   However, a subsequent attempt to run the compiler again results in
   the message "Project in: . is corrupted. Cannot continue".
   [control-c-corrupts-project]

2. After initial compilation, a system is recompiled with no changes
   made.  When the message "Melting changes" is displayed, control-C
   is typed immediately, resulting in the message "Error: could not
   write to ./EIFGENs/test/project.eif" and a resume prompt.  Then `q' is
   typed to quit the compilation.  However, a subsequent attempt to
   run the compiler results in an infinite loop.
   [control-c-infinite-loop]

3. After initial compilation where the system is finalized, a small
   change is made (doesn't matter what the change is) and the system
   is refinalized.  If a control-C is typed after dead code removal is
   finished but before degree -3 starts, the compiler starts degree -3
   instead of terminating execution.  [control-c-interrupt-ignored]

======================================================================

Known melting bugs:  exception or panic when melted, but not when frozen
------------------------------------------------------------------------

1. A routine which conditionally raises an exception has a rescue
   clause which at first calls the routine itself before retrying,
   then later just unconditionally retries.  Executing the system
   gives the expected output when the system is frozen, but when it is
   melted a run-time panic occurs during execution.  
   [raise-exception-call-self]

2. A class has a procedure with a local entity of type BIT N, where N
   is >= 2 ^ 24.  The system compiles fine, but when executed it dies
   with a run-time panic if it was melted.  Frozen code works fine for
   BIT sizes up to at least 200_000_000.  [bit-two-to-the-twenty-four]

3. A routine passes `clone (b)' where `b' is of type BIT 8 to a
   routine whose formal argument is of type BIT 8.  If the system is
   melted, system execution ends with a "Create on deferred"
   exception.  Frozen code works fine.  [cloned-bit-actual-argument]

4. A class has a call to a function which takes an argument of type
   BIT N and just returns its argument.  The system compiles fine,
   but when executed it dies with the exception "object allocation:
   No more memory" if it was melted and if N >= 32768 (2 ^ 15).
   Frozen code works fine for BIT sizes up to at least 1_000_000.
   [bit-two-to-the-fifteen]

5. Melting a system which prints the address of an attribute works fine,
   but when the system is executed it dies with an illegal
   metamorphose type panic.  [melted-attribute-address]
   
6. A system has a call whose target is of an expanded type `expanded FOO',
   where class FOO is not declared as an expanded class.  The call is
   to a function whose return type is `like Current'.  Melting the
   system works fine but when the system is executed it dies with a
   segmentation fault.  Frozen code works fine.
   [melted-expanded-like-current]
   
7. A system with a class name longer than 256 characters compiles fine
   when melted but dies with a run-time panic when executed.  Frozen
   and finalized code work fine.  [melted-long-class-name]
   
8. A class has a routine which prints `t.count' where `t' is of type
   `expanded LINKED_LIST [like Current]'.  The root class, which is expanded,
   inherits this routine and makes it a creation procedure.
   If the system is melted, execution dies with a segmentation fault.
   Frozen code works fine.  [expanded-list-like-current]
   
   
   


Known melting bugs:  wrong result when melted, but not when frozen
------------------------------------------------------------------

1. A class has a routine with a postcondition which references `old
   arg' where `arg' (the routine's argument) is of an expanded type.
   When postconditions are monitored and the system is melted,
   evaluation of the postcondition appears to incorrectly cause some
   creations of objects of the expanded type.  Frozen code works as
   expected, with no hidden object creations.
   [old-expanded-melted-creations]

2. A routine has a postcondition which references an "old" expression.
   The body of the routine raises an exception which is retried by the
   rescue clause.  When postconditions are monitored and the system is
   melted, the "old" expression is incorrectly evaluated again when
   the retry instruction is executed.  Frozen code does not
   re-evaluate the "old" expression when it does a retry.  
   [evaluate-old-when-retry]

3. A routine has a local of an expanded type, where the base class of
   this type has a creation procedure that raises an exception.  If
   the system is melted, the recipient of the exception is not the
   routine containing the declaration of the local but that routine's
   caller.  If the system is frozen, the routine containing the
   declaration of the expanded local is the recipient of the
   exception.  [who-gets-exp-local-exception]
   
4. A routine has a precondition, postcondition, old expression in the
   postcondition and a local entity of an expanded type.  The local of
   expanded type is initialized at the wrong time (before the
   routine's precondition is even checked), but only if the system is
   melted.  Frozen code works correctly.
   [when-init-expanded-local]
   
5. A routine has a manifest array, each of whose elements is a
   function call.  The elements of the array are evaluated in reverse
   order of their appearance when the code is melted, but in order of
   appearance when frozen.  [manifest-array-elem-eval-order]
   
6. A routine has a postcondition which includes more than one `old'
   expression.  The old expressions are evaluated in reverse order of
   their appearance when the code is melted, but in order of
   appearance when it is frozen.  [old-expression-eval-order]
   
7. A routine whose rescue clause tries to display the meaning of the
   exception gives incorrect output if the original exception is two
   levels down, the called routine also has a rescue clause and the
   code is melted.  Frozen code works fine.  [melted-two-level-rescue]

8. A system which calls a once function whose result type is BIT type
   should execute correctly, but gives wrong output if melted.
   [once-bit-type-result]
   
9. A routine `try' which has a precondition calls another routine `try2'
   which raises an exception.  If the calling routine catches the
   exception and retries, the precondition is evaluated again if code
   is melted.  Frozen code works correctly - it does not re-evaluate
   the precondition in the routine which catches the exception.
   [eval-precondition-on-retry]

10. A system calls a routine `double_to_integer (n: DOUBLE): INTEGER' 
    and passes `i.bit_shift (1)', where `i' is an INTEGER.  If the
    system is melted, execution ends with an "illegal cast operation"
    panic.  Frozen code works correctly.  [melt-pass-bit-shift]
   
11. A class that does an inspect of `x', whose type is INTEGER_64
    and which has value 1, does not match value 1 but only when code
    is melted.  Frozen and finalized code work correctly.
    [inspect-integer-64-one]
   
12. A system whose Ace specifies `profile (yes)' is melted.
    When the system is executed with the EIFGENs/test/W_code directory as
    the current directory with the MELT_PATH environment variable not
    set, system execution fails with "Unable to open to output file
    for profile".  [melted-profile-system]
   
13. Executing a system with a class invariant violation works
    correctly when melted and invariants are monitored.
    However, the top of the exception trace shows Invalid_object
    as the object when code is melted.  Frozen code works correctly.
    [melted-invariant-invalid-object]
   
14. A system creates a TWO_WAY_LIST, each of whose elements is
    an object of an expanded type.  The list is stored in a file,
    using `independent_store'.  When the list is retrieved, system
    execution dies with a retrieve error but only if the system is
    melted.  [melted-retrieve-list-expanded]
    
15. A system puts a string into a list 3 times and then calls `referers' 
    from class MEMORY and prints its count.  If the list is a local
    (not an attribute) and if code is melted, execution incorrectly
    prints 0 instead of 3.  [melted-local-referers]
   
16. A system whose Ace specifies `profile (yes)' is melted.
    When the system is executed with the EIFGENs/test/W_code directory as
    the current directory with the MELT_PATH environment variable not
    set, system execution attempts to create the "profinfo" file
    in the wrong place (not in the EIFGENs/test/W_code directory).  
    [melted-profinfo-wrong-dir]
   
17. A root class has an attribute of type `expanded TEST1 [STRING]'
    where the creation procedure of TEST1 declares a local
    of type `expanded TEST2 [like Current]' and prints its
    generating type.  Code compiles fine when melted, but dies with
    a panic when executed.  Frozen and finalized code work correctly.
    [expanded-generic-anchored-local]
   
18. A function that returns an expanded type has a postcondition that 
    states that `old Result' is not equal to the value of the
    function, where the body of the function sets an attribute of
    Result to a non-default value.  Melted code incorrectly violates
    the postcondition, while frozen code does not.
    [melted-old-expanded-result]
   
   

Known freezing bugs:  wrong result when frozen, but not when melted
-------------------------------------------------------------------

1. In a call to a routine whose formal argument is a BIT type with a
   larger number of bits than the actual argument, the actual argument
   is not extended with trailing zeros but only when the code is
   frozen.  [bit-arg-extend-frozen]

2. A routine has a postcondition with an `old' expression which
   involves a function call.  An exception is raised during execution
   of this function.  If the system is frozen, the recipient of the
   exception is not the routine containing the `old' expression, but
   that routine's caller.  If the system is melted, the routine
   containing the `old' expression is the recipient of the exception.
   [who-gets-old-exception]
   
3. A routine `f' has a local of an expanded type, but does not
   reference this local in the routine body.  The base class of the
   expanded type has a creation procedure.  When the system is
   executed, the creation procedure of the expanded class is not
   invoked when `f' is called, but only if the system was frozen.  A
   melted system works correctly.  [expanded-local-no-creation]
   
4. A routine has a local of an expanded type.  The body of the routine
   raises an exception which is retried by the rescue clause.  If the
   system is frozen, the expanded local is incorrectly initialized
   again when the retry instruction is executed.  Melted code works
   correctly.  [init-expanded-local-when-retry]

5. A routine redefines an inherited routine that returns an expanded
   type or a BIT type and replaces it with an attribute.  It also
   includes references to the attribute.  The code compiles fine, but
   dies with a segmentation fault or "feature applied to void
   reference" if it was frozen.  Melted code works fine.  This appears
   to be a code generation bug.  [redefine-expanded-to-attribute]

6. A class has a routine which obtains the address of a procedure via $p.  
   A descendant class redefines procedure `p'.  In the descendant, $p
   incorrectly returns the address of the ancestor's version of the 
   routine instead of the redefined routine. [address-of-redefined-routine]

7. A class has agents which are calls to a routine that takes a numeric type
   (DOUBLE, REAL, INTEGER_64, INTEGER, INTEGER_16, INTEGER_8) and
   prints its argument.  If a lighter type is passed as the actual
   argument (e.g., INTEGER_8 is passed to a routine expecting an INTEGER)
   the arguments are passed incorrectly, resulting in wrong output,
   but only if the routine is frozen.   Melted code works fine.
   [frozen-agent-lighter-argument]

8. A class with a prefix feature that is an attribute compiles fine
   when frozen, but the generated C code won't compile.  Melted code
   works fine.  Fixing the generated C code by adding the missing "\"
   escape characters before double quote characters inside a C string
   allows the code to compile and produce the correct result.
   [frozen-prefix-attribute]

9. A class which prints `<< i16 + i8, i >> @ 1' prints -32642 when
   code is melted, but 32894 when frozen.  [tuple-i16-plus-i8]

10. A class calls a routine and violates its precondition.  The
    exception is not rescued but printing of exception trace on
    failure is turned off.  The class has a `dispose' routine which
    does nothing, but has an empty rescue clause.  System execution
    ends with a segmentation fault when the system is frozen.  Melted
    code works correctly.  [dispose-with-rescue]

11. A class has a routine `value (r: DOUBLE): like r' which
    just returns the value of `r'.  When the routine is called with
    an INTEGER_8 actual argument, the result is wrong but only if
    the system is frozen.  Melted code works correctly.  
    [anchored-double-function]



Known finalizing bugs:  wrong result when finalized, but not when melted/frozen
-------------------------------------------------------------------------------

1. Finalizing a particular system with a couple of levels of expanded
   types which are generic and using `BIT 8' as actual generic at the
   top level generates C code which produces the wrong output.  If the
   system is instead melted or frozen, system execution works as
   expected.  [finalize-expanded-generic-bit]

2. A system has an attribute of an expanded type, where the base class
   of this type also has an expanded attribute.  The system compiles
   fine when finalized, but when the system is executed the creation
   procedures are called in the wrong order.  If the system is instead
   melted or frozen, system execution works as expected.
   [finalize-expand-creation-order]

3. A C routine tries to get the address of an Eiffel routine which is
   actually implemented as an external C routine, using the Cecil
   library.  If the system is finalized, the address of the external
   routine cannot be obtained.  In a frozen system, the address of the
   external routine can be obtained and the routine can be called.
   [finalize-external-routine-address]

4. System execution does not check the class invariant before and
   after a qualified call to a routine, but only if the system is
   finalized and assertions are kept.
   [finalize-skip-invariant]

5. A generic class `TEST1 [G]' has a routine `value2: G is do end'.
   If the actual generic parameter is an expanded class, then `value2'
   returns Void when the system is finalized with inlining, but should
   not.  Melted code, frozen code and finalized code without inlining
   work correctly. [expanded-generic-return-type]

6. A class `TEST1' has a routine `f (x: like Current): like x'
   with body `Result := x'.  A second class `expanded TEST2' inherits
   from TEST1.  A third class calls `f' and passes it an object of
   type TEST2.  System execution dies with a segmentation fault, but
   only if the system is finalized with inlining.  Melted code, frozen
   code and finalized code without inlining work
   correctly.  [inline-pass-expanded]

7. A class creates an ARRAYED_LIST [FOO] where FOO is an expanded class
   and appends two elements to it and then prints the `value'
   attribute of the first item in the list.  The system dies
   with a bus error but only if the system is finalized 
   with inlining.  [inline-arrayed-list-expanded]


======================================================================

(non-incrementality)

   
Known compiler termination bugs:  silent premature termination before freezing
	(terminates with exception trace if `fail_on_rescue (yes)'
------------------------------------------------------------------------------

1. A system which appears to violate the Call rule on page 367 causes
   silent termination of the compiler.  The example involves a class
   which inherits from a constrained generic class and provides NONE
   as actual generic parameter.  [none-as-actual-generic]

2. Specifying the system-level option `precompiled' without any
   parenthesized value after it causes the compiler to terminate
   silently.  Specifying one of the system-level options
   `dead_code_removal', `fail_on_rescue' or `exception_stack_managed'
   without any parenthesized value after it now causes the compiler to
   correctly report a VD15 error.  [system-option-no-parens]

3. A deferred function of type INTEGER in an inherited class is
   effected by an attribute of type NONE.  The compiler does not
   report any validity violations, but it terminates silently while
   melting changes (after pass -3 if freezing system).
   [def-int-func-redefine-none]

4. A system is compiled with an Ace which specifies NONE as the root
   class and also specifies a root creation procedure.  Compilation
   proceeds without problems until the compiler tries to melt
   changes, when it silently terminates.  Also dies if the system is
   frozen.  [root-none-creation-proc]

5. A class with a `strip' expression which references an attribute of
   type NONE causes silent termination of the compiler during pass 2.
   [strip-attribute-of-type-none]
   
6. A system name which includes characters special to the shell causes
   compiler to die. [lace-system-special-chars]

7. A generic class has a function with a generic result type.  If
   this function tries to reference the delayed call expression
   `Result~make', the compiler dies in degree 3. 
   [generic-delayed-call-result]
    
8. A generic class with the header
   "class TEST2 [G -> STRING create make end, H -> G create make end]" 
   causes the compiler to die in degree 4. [creation-constrained-by-generic]
    
9. A generic class with the header
   "class TEST2 [G -> NONE create make end]" 
   causes the compiler to die in degree 4. [generic-constrained-by-none]
    
10. A generic class whose generic parameter is constrained by itself
    (G -> G) and that also creates a result of this generic type
    causes the compiler to go into infinite recursion in
    `internal_conform_to' and eventually run out of memory and die.
    [generic-constrained-by-self]
    
11. An Ace file that specifies a "use" file which looks like part of 
    a normal Ace file with no clusters causes the compiler to die with
    a segmentation fault in `process_options'.
    [use-file-like-ace]
    
12. An Ace file with a cluster named "a/b" causes the compiler to die 
    while trying to create a directory in `backup_directory', but only
    if "automatic_backup" is true.  [slash-in-cluster-tag]
    
13. A long class name (130K characters) causes the compiler to
    die while trying to compile the class, but only if "automatic_backup"
    is true. [long-identifiers]

14. The classes below are compiled fine, but trying to get the flat form of
    of `TEST.make' causes "ec" to die.

class TEST

creation
	make

feature
	make is
		local
			a: A
			s: STRING
		do
			s := "weasel"
			create a.make (clone (s) + Constant_string)
		end

	Constant_string: STRING is "stoat"
end

class A
create
	make

feature
        make (s: like name) is
		do
		end

	name: STRING

end

15. The class below compiles fine, but trying to get the flat form of
    of `TEST.try' causes "ec" to die (estudio doesn't die but cannot
    display the flat form or clickable form of TEST or the flat form
    of `TEST.try').

class TEST
creation
	make

feature

	make is
		do
		end

	try is
		local
			a, b, c: STRING
		do
			c := my_list (a, b).first
		end

	my_list (c, d: STRING): LIST [like d] is
		do
		end

end

16. A class with a creation expression `create {like x}' where `x: NONE'
    causes compiler to die during degree 3.
    [creation-expr-anchor-none]
   
    

Known compiler termination bugs:  silent premature termination while freezing
	(terminates with exception trace if `fail_on_rescue (yes)'
------------------------------------------------------------------------------

1. An Ace file that specifies a long system name (512 characters)
   causes the compiler to die after generation of auxiliary files with
   "file name too long".  If the system is melted instead, the
   compiler does not die but reports the problem creating the file.
   [long-system-name]

2. An inspect instruction with when clause `when 0..2000000000 then'
   causes the compiler to die with "no more memory" when the system
   is frozen.  The problem does not occur if code is melted instead.
   [inspect-big-range]



Known compiler termination bugs:  silent premature termination while finalizing
	(terminates with exception trace if `fail_on_rescue (yes)'
------------------------------------------------------------------------------

1. The creation procedure of a class creates an instance of another
   class and calls a feature on it which contains a "strip"
   expression.  If the system is finalized and the Ace specifies
   `inlining (yes)' the compiler dies during degree -3 on the first
   class.  [finalize-inline-strip-expr]

2. A generic class whose formal generic parameter is constrained by
   NUMERIC has a function `value: G is do Result := x + x end'
   where `x' is of type G.  Another class has a call to this function.
   If the system is finalized with inlining, the compiler dies during
   degree -3 on the class.  [inline-numeric-plus-numeric]






Known compiler nontermination bugs: infinite loops
--------------------------------------------------


1. A violation of VLEC involving an expanded client cycle where both
   classes in the cycle are generic should cause the compiler to
   report a VLEC error.  Instead, the compiler goes into an infinite
   loop.  [vlec-cycle-with-generics] [validity-vlec1-other-generic]

    
======================================================================

Known Lace syntax bugs: syntax should be accepted, but is not
-------------------------------------------------------------

1. There are some identifiers which are not supposed to be reserved
   words in Lace, but they are: make, assertion, debug, optimize, c,
   object.  ETL page 518.  [lace-keywords]
   
2. A Cluster_tag is an optional part of a Cluster_clause.  But es3
   reports a syntax error if the tag is missing.  ETL page 520.
   [lace-opt-cluster-tag]

3. An Ace with a Visible section which has just one Class_visibility
   that consists of a Class_name without any Visibility_adaptation
   should be syntactically legal.  But es3 reports a syntax
   error.  ETL page 531.  [lace-valid-visible]

4. In most places in an Ace where a comma-separated or
   semicolon-separated list can appear, extra leading and trailing
   separators can appear without causing the compiler to report a
   syntax error.  In addition, a separator may be replaced by multiple
   separators.  For example, `option debug (yes): A,,B,,, C ,,,'
   is allowed.  But there are exceptions to this rule, which are
   presumably bugs.  The known exceptions are:  
	A. The File_list of an Include or Exclude (no leading
	   or multiple semicolons allowed, but one trailing semicolon
	   is allowed)
	B. The Cluster_rename_clause of a Cluster_adaptation_list
	   (no leading, trailing or multiple commas allowed)
	C. The Target_list of an Option_clause 
	   (no leading commas allowed, but trailing and multiple commas
	    are allowed)
	D. The Externals clause
	   (no leading semicolons allowed before the first
	    Language_contribution, no multiple semicolons allowed, no
	    leading semicolons before first File_list, no trailing
	    semicolons after File_list)
   [lace-extra-separators]


Known Lace validity bugs:  valid, but not accepted
--------------------------------------------------

1. A Visible clause in the Ace which names a class (or a feature in
   its export subclause) is case-sensitive if the name is enclosed in
   double quotes, but should not be since it does not refer to an
   outside element.  The compiler incorrectly reports a VD25
   violation.  In the case of a feature, the compiler does not
   lower-case the name so the feature is removed by dead code removal.
   [visible-cluster-case-sensitive]

2. Syntactically legal Ace with no cluster properties not accepted.
   [lace-no-cluster-props]



Known Lace validity bugs:  accepted, but should not be
------------------------------------------------------

1. A class named NONE should probably elicit some kind of validity
   error (VD??) from the compiler.  [class-named-none]

2. An Ace which includes the option `assertion' or `profile' or 
   `debug' without any parenthesized value after it is accepted by the
   compiler without any complaints, but should be a VD15 error.
   [assertion-option-no-parens]

3. An Ace with a Visible clause which makes two classes visible to
   external software under the same name is accepted by the compiler,
   but should not be.  Similarly, an Ace with a Visible clause which
   makes two features in a class visible under the same name should
   not be accepted.  [visible-under-same-name]


Known Lace validity bugs:  wrong error reported
-----------------------------------------------

1. An Ace which uses the precompiled "base" cluster and uses the same
   cluster tag for its added cluster as one of the cluster tags used
   in the precompiled cluster should be reported as a VDCN error (two
   clusters have the same name).  Instead, the compiler reports a VD20
   error (unknown root class).  This problem only occurs when a
   precompiled cluster is used.  This is extremely confusing to a
   beginning user, who is certain that he/she has a class with the
   name specified for the root class in the only cluster listed in
   the Ace.  [vdcn-called-vd20]

2. If an Ace uses an environment variable which has not been set in
   one of its path names, the unset variable is treated as though it
   is set and has the value "" (the empty string).  This can cause the
   compiler to report a VD01 error (non-existent or unreadable cluster
   path in Ace file) with a bogus path name instead of a more obvious
   error like "unset environment variable FOO".  It also causes the
   compiler to accept path names like `/dragon/mypath$weasel' for
   `/dragon/mypath' if `$weasel' is not set in the environment.
   [lace-unset-environment-var]


Known Lace operation bugs:  incorrect behavior
----------------------------------------------

1. An include or exclude in a Lace "Use" file has no effect.
    [use-include-exclude]
   

======================================================================

Known operation bugs:  generated C code won't compile or link
-------------------------------------------------------------

1. Class with assignment `Void := Void' compiles fine, but generated
   C code won't compile.  [void-gets-void]

2. A class with a declaration and call of an operator feature which
   ends with a backslash character appears to be valid and the
   compiler accepts it.  But the generated C code won't compile.
   Also, the same problems with characters %" and \ occur with debug
   keys.  [weird-operator-feat-name2]

3. A function which has a local of type `x: expanded FOO' has as its
   body `Result := x'.  When the system is finalized, the code
   generated for the enclosing class won't compile.
   [finalize-expanded-to-reference]

4. Finalizing a system with a call to a particular prefix feature on another
   object generates C code which won't compile if system is finalized,
   but only if `inlining (yes)' is specified.  [inline-prefix-call]

5. A system has a debug instruction with every character except null
   in its debug key.  When the system is frozen, the generated
   C code won't compile.  Melted and finalized code work correctly.
   [all-chars-debug-key]
   


   
   
Known operation bugs:  generated C code yields warnings when compiled
---------------------------------------------------------------------



Known operation bugs:  wrong results formatting
-----------------------------------------------
    
1. A class has a routine that violates a loop variant.  It compiles
   fine and produces an exception trace that indicates a loop variant
   violation, but the text is poorly formatted (doesn't line up with
   "Nature of exception" column).

-------------------------------------------------------------------------------
TEST                make                   stoat:                       
<000000000080ABA0>                                Non-decreasing loop variant or negative value reached.
                                                                         Fail
-------------------------------------------------------------------------------

class TEST

create
	make
feature
	make is
		do
			from
			variant
				stoat: 0
			until
				false
			loop
			end
		end

end
    

Known operation bugs:  wrong results when executed
--------------------------------------------------

1. REAL does not conform to double according to `conforms_to'.
   [real-conform-double]

2. If the precondition is violated on the first call to a once
   routine, the body of the routine is not executed on that call
   (naturally) or on any subsequent calls to the routine.
   [once-routine-precond-fail]

3. A divide by real zero (0.0) should trigger an exception, but does
   not.  When the result of the division is printed, it comes out as
   `Inf' or `NaN'.  [divide-by-real-zero]

4. A system with a generically derived type whose actual generic
   parameter is itself a generic derivation results in a class TEST1
   with an attribute of an expanded type.  When an instance of TEST1
   is created, the attribute is not initialized to the appropriate
   default value.  Instead, it seems to be Void, which should not be
   possible for an entity of an expanded type.
   [expanded-but-void-attribute]

5. A class inherits different versions of a routine with the same name
   and signature from different parents, but redefines the feature.
   The flatshort form looks as expected, with all preconditions of
   redefined versions of the feature in the expected order.  But when
   the system is executed, the preconditions are checked in a
   different order than that indicated by the flatshort form.  Same
   problem for postconditions.  Actually, the flatshort form now has
   the wrong order for preconditions and postconditions (alternative
   precondition and extra postcondition should be first in their
   respective lists) so the problem seems to be with the flatshort
   form itself.  [wrong-alt-precondition-order]

6. A class redefines an inherited function into an attribute.  The
   function has a postcondition, but this postcondition is not added to
   the class invariant.  [attribute-postcondition-lost]

7. The class invariant is not monitored for the root class, even with
   `assertion (all)'.  Test cannot be automated because EiffelWeasel
   doesn't support it.  [root-no-class-invariant]

8. A class inherits a deferred feature from one class and an
   effective feature of the same name from another class.  Both
   features have a precondition and a postcondition.  The flatshort
   form of the heir class looks as expected, with all alternative
   preconditions present.  But when the system is executed, the
   precondition and postcondition of the deferred precursor feature
   are not monitored.  [skip-deferred-feat-assertions]

9. The bit values `00B' and `11B' are deep equal according to
   deep_equal.  [diff-bit-constants-deep-equal]

10. Calls to `clone' with integer, boolean or character arguments do
    not return the expected result.  Also, frozen and melted code
    produce different results.  [clone-integer-boolean-character]

11. The class invariant should be checked after
    creation/initialization of an entity of an expanded type, but it
    is not.  Invariant checking works correctly for non-expanded
    types.  [expanded-skip-class-invariant]

12. An internal routine A with no rescue clause calls a second
    internal routine B, passing it some feature addresses.  Routine B
    raises an exception.  After initial compilation where the system
    is frozen, the routine B is modified to cause it to be melted.
    When routine A is called repeatedly, more and more C memory is
    used, which seems to indicate a memory leak.
    [internal-exception-memory-leak]

14. A non-expanded class FOO has a routine `bar' which passes Current
    to a routine which uses it to set an attribute in the object
    referenced by the passed argument.  Another class declares an
    entity of type `expanded FOO' and calls `bar' on it.  The
    attribute in this entity is changed by the call, though it should
    not be.  [expanded-pass-current]

15. A class creates an instance of a second class which has a
    `dispose' procedure that causes a floating exception.  When this
    instance is garbage collected, the `dispose' procedure is called
    and the exception is correctly raised.  However, garbage
    collection is turned off.  A subsequent creation and collection of
    another object causes program termination.  [exception-in-dispose]

16. A routine calls another routine and violates its precondition.
    The routine's rescue clause calls another routine to display the
    exception status and this routine calls a third routine.  If this
    last routine also has a non-empty rescue clause, then the meaning
    of `exception' is not available.  [rescue-show-exception-meaning]

17. Routine `is_integer' from STRING completely ignores null characters,
    which is incorrect ("%/0/1%/0/" is not a valid integer).  So do
    routines `is_real' and `is_double'.
    [is-integer-ignores-null]

18. Trying to print INTEGER_8 value -127 or INTEGER_16 value -32768
    when system was compiled with assertion (all) results in violation
    of class invariant "sign_times_abs". [print-max-negative-smallint]

19. A class FOO inherits a generic class twice providing different actual
    generic parameters and renaming the single routine `f' in the
    generic class.  Routine `f' creates a local of type G and prints
    its generating type.  The root class creates an instance of FOO
    and calls both versions of `f'.  The system compiles fine, but
    produces the wrong results when executed.
    [generic-generating-type]

20. A class has agents which are calls to a routine that takes a numeric type
    (DOUBLE, REAL, INTEGER_64, INTEGER, INTEGER_16, INTEGER_8) and
    prints its argument.  If the argument is left open and a lighter
    type is passed as the actual argument in a tuple at the time of
    the call (e.g., INTEGER_8 is passed to a routine expecting an
    INTEGER), the argument is passed incorrectly in some cases.
    [agent-lighter-tuple-arg]

21. The creation procedure is not called for an entity of an
    expanded type, but only if the creation procedure is the implicit
    `default_create' instead of an explicitly named creation procedure
    and only if entity is a local and class has no attribute of the
    same expanded type.  [expanded-no-default-create]

22. Compiling a system with a debug instruction with debug key that
    contains an interior null character ("weas%Uel") works fine, but
    when the system is executed with an Ace file that specifies `debug
    ("weas%Uxx")' the debug instructions inside the block with the tag
    are executed, but should not be.  [interior-null-in-debug-key]

23. Bit operations on INTEGER_64 do not always works correctly.
    Bit_shift causes an "operational stack botched" panic when code is
    melted.  Some of the values computed are wrong for
    frozen/finalized code - shift of 64 positions doesn't work
    correctly and all values are wrong for bit_shift.
    [bit-64-operations]

24. Printing `(<< << "A" >> , << 47 >> >>).generating_type' displays
    "ARRAY [ARRAY [STRING]]" but should display "ARRAY [ARRAY [ANY]]".
    [nested-manifest-array-gen-type]

25. A class has a creation instruction `create {expanded TEST1} x.make' where
    `x' is of type TEST1, which is not an expanded class.
    The system compiles fine but dies with a segmentation fault when
    executed.  [explicit-expanded-creation]

26. A routine which prints `(create {like Current}).generating_type'
    is written in class A and inherited by class B.  When the routine
    is called on an object of type B, it prints "A" instead of "B".
    If `create {like Current}' is assigned to an attribute of type
    `like Current', the generating type of this attribute is also
    incorrect in class B.  But if it is assigned to a local instead,
    the generating type in B is correct.  [inherit-create-like-current]

27. A class creates an object of type `ARRAY [BIT 70000]' and prints
    its generating type.  The generating type prints as "ARRAY [BIT
    4464]" instead of "ARRAY [BIT 70000]" or "ARRAY [BIT_REF]".  C
    compiler issues warnings about "overflow in implicit constant
    conversion".  [array-bit-two-to-sixteen]

28. A class has an inspect of a local of type INTEGER_64, which has
    value 12345678912345.  When executed, the value does not match
    a when clause whose constant value is 12345678912345.  It does not
    matter whether code is melted, frozen or finalized.
    [inspect-big-integer-64]

29. A constant declared as `value: INTEGER is -0xD' is accepted by
    the compiler, but is interpreted as 13 instead of -13.
    [negative-hex-constant]

30. A system repeatedly creates one thread (which has an empty
    `execute' procedure) and then calls join_all to wait for it to
    terminate.  As the number of threads which have been created
    increases, the memory used by the executing system keeps growing,
    apparently without limit.  After 4000 threads have been created,
    system memory usage is about 90 MB.  [multithreaded-memory-leak]


Known operation bugs:  exception trace / panic / core dump / loop when executed
-------------------------------------------------------------------------------

1. A class with a routine which has 1000 local variables compiles fine
   and the C code compiles (as long as one doesn't use the -O option).
   When the system is executed, it dies with an "out of locals"
   run-time panic.  [out-of-locals]

2. A system which allocates a number of fairly large strings (approx
   0.4 MB each) and calls routines allocate_tiny, full_collect and
   full_coalesce in class MEMORY compiles fine. When the system is
   executed it eventually runs out of memory, which appears to
   indicate a memory leak.  [memory-leak]

3. A clearer example of a system which obtains a reference to
   a sub-object and uses it to change that sub-object.
   [clearer-ref-to-sub-object]

4. A routine which conditionally raises an exception has a rescue
   clause which always retries, but which first calls the routine
   itself recursively the first time the rescue clause is executed.
   Executing the system with garbage collection off causes a run-time
   panic if the number of retries is moderately large (500 or
   greater). [rescue-recurse-many-retries]

5. A routine passes `clone (k)' where `k' is of type INTEGER to a
   routine whose formal argument is of type DOUBLE.  If the system is
   melted, system execution ends with an "Illegal cast operation"
   run-time panic.  Frozen code instead produces incorrect output.
   [cloned-int-passed-to-double]

6. A routine repeatedly does `deep_clone (b)' where `b' is of type
   BIT 32.  System execution ends with an exception trace (on the
   first iteration if system is frozen or after a large number of
   iterations if system is melted).  [deep-clone-bit]

7. A routine has a rescue clause and a local of an expanded type.
   The creation procedure of this type's base class raises an
   exception.  In the rescue clause, the expanded local is void
   which causes execution to terminate with a segmentation fault.
   [expanded-local-void-in-rescue]

8. A class has a routine which has 1000 instructions, each of which
   is `a := << 1 >>'.  The system compiles fine when frozen and the C code
   compiles (as long as one doesn't use the -O option).  When the
   system is executed, it dies with an "out of locals" run-time
   panic.  [manifest-array-waste-locals]

9. A class inherits twice from a generic class, using DOUBLE and
   STRING as the actual generic parameter and renaming the single
   routine in the generic class to replicate it.  The system compiles
   fine, but dies with a bus error when executed due to the fact that
   the wrong routine is being called.  [inherit-generic-wrong-call]

10. A class has a recursive routine `f' which at the depths of its
    recursion calls a routine `weasel' which raises an exception.
    Routine `weasel' has a rescue clause which first calls `f' and
    then retries and succeeds.  When the system is executed, it dies
    with a panic (segmentation fault) if the depth of "exception in
    rescue clause" nesting is greater than 256.  (Now it dies when
    depth of original recursion is 0 and depth of "exception in
    rescue clause" nesting is only 2).  [deep-exception-in-rescue]

11. A class calls the `strip' operator and has an attribute of an
    expanded type.  Executing the system results in a run-time panic.
    [strip-with-expanded-attr]

12. An expanded feature is redefined as an attribute in a descendant class.  
    System execution fails when assertion (all) is specified.
    [redefine-expanded-as-attribute]

13. A class repeatedly generates a small manifest array, each of whose
    elements is `strip ()'.  The system compiles fine, but when executed
    for a large number of iterations it eventually runs out of memory,
    which appears to indicate a memory leak.  [strip-memory-leak]

14. A class declares an attribute of type `expanded A', where A
    contains an attribute of type `expanded B' (a sub-object).
    Neither classes A nor B are themselves expanded.  Class B has a
    function which returns `Current' as its result.  It appears that a
    caller is able to get and save a reference to a sub-object.
    Wasting memory to cause a garbage collection then causes execution
    to terminate with a run-time panic.  [reference-to-sub-object]

15. A class calls a routine which recurses a few times and then raises
    a developer exception.  The exception is rescued and the rescue
    clause calls another routine which calls the recursive routine and
    retries the exception.  System execution should terminate
    normally, but ends with the second developer exception.
    [safe-call-from-rescue]

16. A class repeatedly calls a routine which creates a tuple with
    400 elements, each element being itself the tuple [13].
    The system compiles fine when melted or frozen, but dies with a
    bus error when executed, even if garbage collection is off.
    [create-tuple-of-tuples]

17. A class creates a hash table of ANY indexed by INTEGER.  Inserting
    an element under index 0 causes a postcondition violation.
    [insert-hash-table-zero]

18. A class creates an instance of a second class and calls a boolean feature
    `is_value_required' on it.  The second class has an invariant that
    changes the value of a CHARACTER attribute, which affects the
    result returned by `is_value_required'.  Code compiles fine when
    frozen with all assertions turned on, but when the system is
    executed it dies with a segmentation violation.  Finalized code
    does not die, but it incorrectly prints "False" instead of "True".
    [invariant-changes-current]

19. A class tries to retrieve an object which was stored into a file
    using `independent_store'.  If the file contents is manually
    modified to delete a character (to simulate a corrupted file), the
    retrieve operation goes into an infinite loop.
    [retrieve-corrupted-file]

20. A class calls a routine with a long name (> 600 characters)
    and the routine raises an exception.  The caller rescues the
    exception and then tries to get the exception trace.
    System execution ends with a segmentation fault.
    [long-name-exception-trace]

21. A system creates an instance of a class with 500 generic parameters,
    where the class has one attribute for every generic parameter.
    The system compiles fine when melted, frozen or finalized, but
    dies when executed.  [many-generic-parameters]
    [Manu says there is currently a hard limit of 256 generic parameters.]

22. A class has an attribute of an expanded type, which has 100 expanded
    attributes, where the class for each attribute has 100 attributes
    of type DOUBLE. The system compiles fine when melted or frozen, but
    dies with a panic when `full_collect' is called.  Finalized code
    works correctly.  [gc-expanded-expanded-attrs]

23. A class inherits from a second class and redefines an external
    "C inline" routine to an internal routine.  The internal routine
    calls precursor.  The system compiles fine but goes into an
    infinite recursion when executed.  [external-precursor]

24. If the environment variable EIF_MEMORY_CHUNK is set to 200000000,
    compiler dies with an "out of memory" exception.
    [very-big-gc-chunk-size]

25. An external function `value: INTEGER' which is "C inline" has a 
    postcondition `value = 29'.  If this feature is called via static
    access `feature {TEST1}.value', system execution dies with a
    segmentation fault in the postcondition.  [external-static-access]

26. A "C inline" external function `value (n: G): G' in a generic class
    has body "$n", so that it just returns its argument.  If this
    function is called normally from another routine in the class, the
    result is correct.  But if the function is called via a static
    access and if there is more than one generic derivation of the
    enclosing generic class, a class invariant is violated due to the
    wrong routine being called.  If code is finalized, generated C
    code won't compile due to conflicting function prototypes.  
    [static-access-generic-function]



Known operation bugs:  possible unspecified semantics
-----------------------------------------------------


Known operation bugs:  performance problem
------------------------------------------

1. A class calls `print (a)' where `a' is an ARRAY [SOME_EXPANDED_TYPE].
   The class compiles fine and system execution produces the correct
   output, but execution time seems to be O(N^2), where N is the size
   of the array.  [slow-print-array-of-expanded]



Known operation bugs:  features not fully implemented or wrong es3 behavior
------------------------------------------------------------------------------

1. If the root class is obsolete, no obsolete warnings are displayed.
   Similarly, if the root class is not obsolete but the root creation
   procedure is, no obsolete warnings are displayed.  [obsolete-root-class]

2. According to the last right margin note on page 166, an
   obsolescence message should be produced for a class which joins two
   or more features at least one of which is obsolete.  But the
   compiler does not produce such a message.  [obsolete-joined-feature]

Known class view bugs
---------------------
    
1. The flat and flatshort forms of class ANY show every feature repeated
   twice.


======================================================================

Known optimization deficiencies
-------------------------------

1. Putting parentheses around an entity of type ARRAY [STRING] which
   is a call target prevents the compiler from optimizing the
   instruction it is part of, when the system is finalized and the Ace
   specifies `array_optimization (yes)'.  [parens-around-array-call-target]

2. When a system is finalized with `inlining (yes)', only the last
   feature call in a multi-dot call is inlined.  Breaking the
   multi-dot call into the equivalent sequence of single dot calls
   using explicit temporaries causes the compiler to inline all of the
   calls.  [multi-dot-call-inline-last]

3. When a system is finalized with `inlining (yes)', a routine which
   contains only an assignment of a formal argument to a local is
   inlined.  The inlined code that is generated contains an RTAR macro
   call, while the code generated for the routine that was inlined
   does not.  The RTAR call appears to be unnecessary.
   [inline-extra-rtar]

======================================================================

Known library class bugs
------------------------

1. A call to UNIX_FILE routine `readchar' violates precondition
   `is_readable' of `readchar' when the file is in fact a pipe.
   Actually, now `is_fifo' does not work properly. [pipe-not-readable]

2. Calling `fill' in LINKED_LIST with a 20000 element ARRAY takes
   approximately 4 minutes of CPU on a SPARC 10 when code is frozen
   and `assertion (no)' is specified.  This is so slow that `fill' is
   useless for filling a LINKED_LIST from a container with a large
   number of elements.  [slow-linked-list-fill]

3. Routine `append' in UNIX_FILE has a precondition which is not
   sufficient to guarantee that the routine can do its job.  
   [unix-file-append-weak-precond]

4. Routines `has' in CONTAINER and `grow' in RESIZABLE need stronger
   preconditions.  Currently, the weak preconditions they have result
   in descendant routines which have incorrect preconditions
   (involving `require else Precursor: True').  [precursor-true]

5. Routine `copy_to' in FILE does not work correctly if file which is
   target of call is not positioned at beginning of file.
   [file-copy-to]

======================================================================

Fixed bugs
----------

1. Class with no leading white space at all no longer causes VD10
   violation to be reported. [no-leading-white-space]

2. Bit constants with uppercase B are now accepted.
   [no-upper-bit-constants]

3. Empty Feature_list now allowed in Creation_clause.
   [empty-creation-list]

5. Correct position is reported for syntax error in class even if
   there are manifest strings preceding the position of the error.
   [syntax-wrong-positions]

6. Empty Rename_list in inheritance clause is now accepted, instead of
   being reported as a syntax error.  [empty-rename-list]

7. Empty undefine, redefine and select subclauses are now allowed in
   an inheritance clause.  [empty-inheritance-clauses]

8. Program which allocates 1 MB string, 2 MB string, etc no longer
   dies with run-time panic.  [big-strings]

9. Class TEXT_O, feature is_read_only no longer violates VUAR.

10. Sequence of changes involving inheritance and unique attributes no
    longer causes violation of precondition index_small_enough in
    ARRAY put.  [inherit-index-small-enough]

11. Creation "procedures" which are actually functions are now
    correctly rejected as violating VGCP.  [creation-proc-function]

12. Operator features are now forced to start with one of the four
    allowed characters and cannot be completely empty (but invalid
    characters are still allowed).  [empty-free-operator]

13. Compiling a system, adding `class' to the indexing clause and
    recompiling no longer causes report of syntax error.  Instead, it
    causes VD20 violation to be reported.  [class-name-confusion]

14. A class with a feature which is both frozen and deferred no longer
    causes an exception trace.  Instead compiler correctly reports
    violation of VFFD.  [frozen-and-deferred]

15. An operator feature (infix or prefix) whose name is not all in
    lowercase can now be called.  Also, multiple declarations of the
    same operator feature in the same class , differing only by case,
    are no longer accepted.  [case-sensitive-feature]

16. Violation of precondition `has_a_new_name' seems to be fixed.
    [violate-has-a-new-name]

17. A violation of the Expanded Type rule is detected.  When the
    problem is fixed by removing the declaration of the offending
    feature, compiler no longer dies later when it starts freezing the
    system.  [expanded-type-violation]

18. A creation instruction with an explicit creation type which is
    expanded (violates constraint VGCC3) is now detected.
    [invalid-creation-instruction2]

19. Classes which are invalid due to the actual generic parameter not
    conforming to the formal generic parameter no longer cause an
    exception trace.  [invalid-actual-generic]

20. An empty Debug_key_list is now allowed in a Debug instruction.
    [empty-debug-key]

21. A Multi_branch which does not include the optional When_part_list
    is now accepted.  [empty-when-part-list]

22. An actual generic parameter which is invalid (because it is a
    generic derivation of a class which is *not* generic) is now
    correctly reported as a VTUG violation, instead of causing the
    compiler to die with an exception trace.  [invalid-actual-generic2]

23. An actual generic parameter which is invalid (because it is itself
    a generic class but no actual generic parameters are supplied) is
    now correctly reported as a VTUG violation, instead of causing the
    compiler to die with an exception trace.  [invalid-actual-generic3]

24. An actual generic parameter which is invalid (because it is itself
    a generic derivation but too many actual generic parameters are
    supplied) is now correctly reported as a VTUG violation, instead
    of causing the compiler to die with an exception trace.
    [invalid-actual-generic4]

25. A complicated invalid generic derivation for an actual generic
    parameter is now correctly reported as a VTUG violation, instead
    of causing an exception trace after all pass 5's have completed.
    [invalid-actual-generic5]
    
26. Occurrence of the predefined entity `Result' in a precondition is
    now detected as a violation of the Entity rule.  [result-in-precondition]

27. A system has a class which violates the Select Subclause rule
   (same feature name appears twice).  The compiler detects the VMSS
   violation.  Changing the inheritance structure and then hitting
   return at the "Another compilation needed..." prompt no longer
   causes an exception trace.  [invalid-select-change]

28. A violation of the assignment rule in an inherited class is
    correctly detected.  When the client structure is modified by
    removing two local declarations from the inheriting class and
    <return> is pressed to retry compilation, the VJAR violation is
    reported instead of the compiler dying with an exception trace.
    [assign-rule-client-change]

29. A class TEST has an entity of type TEST1 (non-BOOLEAN) as the
    Boolean_expression in a conditional instruction.  The compiler
    correctly detects the VWBE violation and reports it.  Removing an
    inheritance clause from TEST1 and hitting return to retry the
    compilation no longer causes the compiler to skip some passes on
    both TEST and TEST1.  It instead correctly reports the VWBE
    violation again.  [inherit-chg-skip-pass]

30. Compiling two classes fully, adding an inheritance clause to each
    (one with an error) and then removing one of the newly added
    inheritance clauses when the compiler correctly reports violation
    of VDCC no longer causes the compiler to die with an exception trace.
    Instead, it correctly reports the VDCC violation again.
    [precond-valid-cursor-index]

31. A generic class constrains its single formal generic parameter to
    conform to DOUBLE.  A class which inherits from this class twice
    with actual generic parameters of REAL and DOUBLE now gives the
    correct output.  [real-conform-double]

33. A Multi_branch with an Else_part whose Compound is empty no longer
    triggers an "Unmatched inspect value" exception.  
    [multi-branch-empty-else]

34. A Multi_branch instruction with an interval now executes correctly
    after melting.  If the value of the inspect expression falls
    within an interval, an "Unmatched inspect value" exception is no
    longer triggered.  [multi-branch-interval]

35. A Conditional with a true boolean expression and an empty Compound
    in a Then_part now correctly does nothing (after melting), instead
    of executing the "else" part of the conditional.
    [conditional-empty-then]

36. A routine violates the precondition of a routine it calls.  The
    calling routine has a rescue clause.  System execution no longer
    ends with a PANIC and core dump after less than 500 attempts.
    Instead it appears to keep running indefinitely, as it should.
    [repeated-rescue-panic]

37. A procedure which is a `once' routine is now accepted as a
    creation procedure.  [creation-once-routine]

38. If the compiler discovers a validity violation on the root class class
    (at least in pass 3) and stops and then the name of the root class is
    changed so that it is the same as the name of another class in the
    cluster, it no longer causes an exception trace.  Instead, VSCN
    violation is correctly reported.  [cluster-modified-viol]

39. A particular root class has a validity violation discovered in
    pass 3.  If when the compiler stops the name of the root class is
    changed so that it is different (but the class is left in the same
    file so that file name root and class name do not match), but the
    new class name does not match the name of any other classes in the
    universe, it no longer causes an exception trace.
    [chg-class-to-nonexistent]

40. An attempt to assign an entity declared of a BIT type to an entity
    declared of type ANY no longer results in violation of validity
    constraint VJAR.  BIT types have now been implemented.
    [bit-any-no-conform]

41. If the root class named in the Ace file cannot be found in the
    universe, VD20 violation is reported.  Hitting return to retry
    compilation no longer causes an exception trace.
    [nonexistent-root-class]

42. If a class in the universe has no class header or a malformed
    class header, VD10 violation is reported.  Hitting return to retry
    compilation no longer causes an exception trace.
    [missing-class-header]

43. Running es3 on an Ace file with a syntax error and then hitting
    return at the "Another compilation needed..." prompt without
    changing the Ace file at all no longer results in an exception trace.
    [lace-syntax-error-retry]

44. An actual generic parameter `TEST1 [like Current]' does not
    conform to a formal generic parameter constrained by `TEST2 [like
    Current]'.  The compiler detects the violation but dies with an
    error trying to report it.  [invalid-actual-generic6]

45. A boolean operator (and, or, and then, or else, xor, implies, not)
    whose first operand is a constant True or False no longer causes
    an exception trace.  [const-and-boolean-op]

46. According to page 518, letter case is not significant for strings
    in an Ace file which do not refer to outside elements and the
    compiler now implements this correctly.  [lace-string-case]

48. An Ace which is (presumably) invalid because the Class_name in the
    Root part of the Ace is empty (the Manifest_string "") no longer
    causes an exception trace.  [lace-invalid-root-name]

49. An Ace which appears to be valid and which has a Option_clause in
    the Defaults paragraph that lacks an Option_mark no longer causes an
    exception trace.  [lace-no-option-mark]

50. Options which do not exist (and are therefore presumably invalid)
    in the Default section of an Ace now elicit a warning from the
    compiler.  [lace-nonexistent-options]

51. The class name which is an empty Manifest_string ("") as the first
    name of a Class_rename_pair in Rename in an Ace no longer causes
    an exception trace.  [lace-null-class-name]

52. A class name which is an empty Manifest_string ("") in the
    Target_list of an Option_clause in an Ace no longer causes an
    exception trace.  [lace-null-class-name2]

53. An Ace with an Externals section which has a non-existent Language
    now elicits a warning from the compiler.  [lace-bogus-ext-lang]

54. A class name which is an empty Manifest_string ("") in the Visible
    of a Cluster_properties in an Ace no longer causes an exception
    trace.  [lace-null-class-name3]

55. Debug instructions which have a parenthesized list of debug keys
    following the keyword `debug' are now executed when the Ace
    specifies `debug (yes)'.  [debug-with-keys]

56. A compilation is started, but the compiler correctly reports a
    VSCN validity violation because there are two supplier classes
    TEST1, each in a different cluster.  If one of the clusters is
    removed from the Ace completely, the compiler now proceeds instead
    of just issuing the same VSCN error message.  [lace-remove-cluster]

57. A class with debug statements with various combinations of debug
    keys "1" and "2" executes the correct statements when compiled
    with Ace specifying `debug ("1")'.  It now also executes the
    correct debug statements when this is changed to `debug ("2")'.
    [change-debug-option]

58. After compilation, freezing and finish_freezing, a system prints
    `true' when executed, which is correct behavior.  When an
    `io.new_line' line is removed and es3 is rerun, the resulting
    system now still prints `true' instead of printing `false'.
    [wrong-real-arithmetic]

59. A call `print (True)' or `print (False)' now works as expected,
    instead of producing no visible output. [bool-const-no-output]

60. The C code generated for class HASH_TABLE (a very unique case)
    no longer has to be corrected by hand before it will compile.

61. Finalizing a system (producing a final executable which contains a
    copy of the run-time system and can be run on its own) now works.
    [finalize-appl]

62. Compiling a system and then changing an inherited class so that it
    is deferred causes a bogus VD27 error.  [deferred-feature-call]
    
63. Compiling a class with an attribute whose type is anchored and
    whose anchor has an expanded type works. Changing the anchor to a
    constant and recompiling no longer causes an exception trace.
    [expanded-anchor]

64. Changing an inherited class from non-generic to generic and then
    recompiling no longer results in an exception traceback.  Instead,
    the compiler correctly reports the VTUG violation.
    [nongeneric-to-generic]

65. Compiling a system where A inherits an effective feature from B
    and undefines and redefines it works fine.  If the feature in B is
    changed to a deferred feature and es3 is rerun, the compiler now
    correctly detects the violation of VDUS3 (Undefine Subclause
    rule).  [undefine-subclause-violation]

66. A small system compiles fine.  When the type of an argumentless
    function is changed from BOOLEAN to INTEGER, thereby violating
    validity constraint VWBE, the violation now is detected.
    [non-boolean-exit]

67. Compiling a system and then removing the creation procedure (which
    is called) from one of its classes causes a violation of the
    Entity Rule. The violation is detected and the compiler no longer
    dies while reporting it.  [entity-rule-violation]

68. Compiling a system and then making a particular sequence of
    changes no longer causes the compiler to report a violation of the
    Feature Name rule (VMFN), when in fact the error is violation of
    VCCH on page 51.  [misleading-vmfn-error]

69. A particular system is compiled, finish_freezing is done and the
    system executes correctly.  Then all instructions are deleted from
    the body of the root creation procedure and es3 is rerun.  The
    compiler no longer does just pass 1 on class TEST and no longer
    gets an exception trace when it is run again. [time-checker-error]

70. A system is compiled and frozen.  Then a new feature with a
    violation of the Entity rule is added.  The compiler correctly
    detects the violation and when it is corrected by adding an
    inheritance clause, the Assignment rule violation that is thereby
    introduced is now detected.  [intro-assign-rule-viol]

71. A once function now returns the same value on the second call as
    it does on the first call, after melting, [once-function-void]

----------------------------------------------------------------------

72. Adding an export restriction which causes a validity violation
    after compilation and then recompiling no longer causes an
    exception trace.  Instead, compiler correctly reports the VUEX
    violation.  And now, when I hit return to retry, the compiler
    still reports the VUEX violation instead of processing the class
    without complaint.  [vuex-violation]

73. A valid class compiles fine.  An assignment to an anchored local
    entity becomes invalid when the type of the anchor is changed and
    es3 now detects the VJAR violation on recompile.
    [invalid-local-entity-assign]
    
74. A particular sequence of changes no longer causes a compiler error
    and violation of precondition `good_cluster'.  Instead, the
    introduced syntax error is correctly reported. [precond-good-cluster]

75. If a client A of a class B has a valid creation instruction to
    create an instance of B, and B is then modified so that the
    creation instruction in A is no longer valid, the error is not
    detected.  [creation-instruction-sneak]

76. Compiling a system whose root class has a formal generic parameter
    causes the compiler to correctly report the VSRC violation.
    Removing the formal generic parameter from the root class and
    resuming compilation no longer causes an exception trace.
    [generic-root-to-nongeneric]

77. Compiling a system whose Ace specifies creation procedure `make'
    when the root class has no creation procedures causes the compiler
    to correctly report a validity violation (VD27).  When the
    creation procedure specification is removed from the Ace, the
    compiler now continues with the compilation instead of continuing
    to report violation of VD27.  [lace-remove-creation-proc]

78. According to page 245, letter case is not significant for a
    Debug_key.  A debug instruction with key "WEASEL" is now
    executed when the Ace specifies `debug ("weasel")'.
    [debug-keys-case-sensitive]

----------------------------------------------------------------------

79. A class with "identifiers" used as feature names which start with
    underscore ("_") are no longer accepted.  Previously, all the
    leading underscores in such names seemed to be ignored.
    [invalid-identifier]

80. According to page 120, an Assertion_clause is an optional Tag_mark
    followed by an Unlabeled_assertion_clause.  When the
    Unlabeled_assertion_clause is a Comment, a preceding tag is
    no longer rejected as a syntax error.  [comment-assertion-with-tag]

81. In many contexts, the following characters are no longer
    completely ignored: ~ % ? ` \ _ (tilde, percent, question mark,
    backquote, backslash, underscore).  Instead the compiler correctly
    reports a a syntax error.  [invalid-characters]

82. A class with a deferred feature but no "deferred" header mark is
    now correctly reported to violate VCCH, instead of the
    undocumented validity code VDCC.  [deferred-feature-bad-header]

83. A routine with an invalid redefine subclause (references old
    feature name) in inheritance clause is no longer accepted.
    [invalid-redefine-subclause]

84. An inherited feature is renamed via a Rename subclause and the
    compiler no longer accepts references to the old name in the
    New_exports, Undefine, Redefine and Select clauses.
    [old-name-inherit-clauses]

85. An assignment whose source appears to conform to its target
    according to the definition of General Conformance is no longer
    rejected as a violation of the Assignment rule (VJAR).
    [general-conformance]

86. According to condition 1 of constraint VAOL on page 124, an Old
    expression is not valid outside a postcondition.  The compiler no
    longer accepts an Old expression in a precondition.
    [old-in-precondition]

88. Deleting an inheritance clause after compiler reports validity
    violation and then retrying compilation no longer causes an
    exception trace.  [delete-inheritance]

89. Compiling a class, then removing an inheritance clause no longer
    causes the exception trace "not_empty precondition violated in
    make_byte_code".  [melt-inherit-bug]

90. Changing the number of formal generic parameters in an inherited
    class which is already generic no longer results in an exception
    traceback.  [change-generic-parm-count]

91. Violation of the Expanded Client rule (VLEC) is detected.  When
    the problem is corrected by removing the offending feature and
    compilation is resumed, the compiler no longer dies later.
    [expanded-client-violation]
   
92. Compiling a class and then introducing a violation of the Local
    Entity rule VRLE1 by changing the name of an attribute to match
    the name of a local of one of the routines no longer causes the
    violation to go undetected.  [local-entity-violation]

93. Compiling a class TEST which declares an attribute of type TEST
    but is not an expanded class works fine.  Changing the class to an
    expanded class and rerunning es3 results in an undetected
    violation of the Expanded Client rule (VLEC).
    [hidden-expanded-client]

94. Compiling a system and then introducing a violation of the
    Expanded Type rule in a particular manner no longer causes the
    violation to escape detection by the compiler.
    [expanded-type-hidden]

95. Introducing a type error by modifying the types of inherited
    attributes and then fixing the error causes the compiler to not
    recognize that the error has been corrected.
    [add-delete-type-error]

96. Removing one of the formal generic parameters from a generic class
    no longer causes the compiler to accept it as valid, when another
    class now has an entity with the wrong number of actual generic
    parameters.  [generic-deriv-slide]

97. A procedure which prints out some real and double constants
    executes correctly after first compile and freezing now also
    prints them correctly after melting.  [real-double-print]

98. A known sequence of changes no longer causes a system
    execution-time PANIC with "unknown entity type".
    [unknown-entity-type]

99. A class with a VUAR violation is compiled and the compiler detects
    the error.  When the type of the actual argument is changed to fix
    the error and compilation is resumed, the compiler no longer dies
    with an exception trace.  [fix-vuar-error]

100. A trivial system compiles fine.  When the Ace is changed to
     indicate a different root class which is almost identical to the
     original root class, but has one inheritance clause, the compiler
     no longer dies with an exception trace while refreezing the system.
     [freezing-good-type-id]

101. A correct system compiles fine.  Then the generic constraint in
     an inherited class is changed.  The compiler correctly detects
     the VTGG violation.  When the generic constraint is changed back
     to its original form, the compiler now accepts the correct class
     instead of reporting a VD27 violation.  [chg-generic-constraint]

102. A class with an external routine (which happens to be the root
     creation procedure) compiles fine.  When the routine is changed
     to an internal routine with three different declarations for the
     same local, the compiler detects the VREG violation.  When the
     error is corrected and compilation resumed, the compiler no
     longer dies with an exception trace.  [remove-external-routine]

103. A class with an internal routine compiles fine.  When the
     internal body is replaced by an external body and the system is
     recompiled, a compiler exception trace no longer occurs.
     [refreeze-table-size]

104. In a class which has an inheritance clause with a parent based on
     a generic class, replacing the actual generic parameter with a
     more complicated one and recompiling no longer causes an
     exception trace.  [inherit-generic-more-complex]

105. A particular sequence of changes no longer causes a segmentation
     fault in routine `make_update' while melting changes.
     [melting-make-update]

106. A class which redefines an inherited deferred feature and
     introduces two new declarations for it (one deferred and one
     effective) no longer causes an exception trace.
     [invalid-feature-redeclaration]

107. Compiling a system where A inherits from B and B has an attribute
     of type `expanded A' no longer results in an an illegal
     instruction.  Instead, the VLEC violation is reported.
     [expanded-client-inherited]

108. Violation of the Expanded Client rule (VLEC) in a class is
     detected and retrying the compilation by hitting return without
     changing the offending class no longer resumes the compilation.
     Instead, VLEC is reported again. [expanded-client-death]

109. Class with a loop invariant no longer causes exception trace with
     violation of precondition of `generate_workbench_tes'.
     [make-byte-code-void-ref]

110. A certain class no longer causes an exception trace in the
     compiler during freezing.  Previously it did, and adding the
     following line to the only feature in the class and compiling
     from scratch prevented the error from occurring:
		io.putstring ("In violate_loop%N");
     [unknown-problem]

111. A class with a constant attribute of type REAL or DOUBLE whose
     value is negative (e.g. -.54) no longer causes a run-time PANIC
     in the compiler.  [real-const-attr-panic]

112. A class with a single procedure with an empty body which has 125
     locals of type STRING no longer causes the compiler to die with
     an exception trace.  [many-locals]

113. A generic class which violates the Expanded Client rule
     (constraint VLEC) no longer causes a compiler exception trace.
     Instead, the VLEC violation is reported.
     [generic-expanded-client]

114. The compiler now accepts an Ace without the optional Cluster_mark
     part of a Root.  [lace-opt-cluster-mark]

115. The possible values for option `assertion' (require, ensure,
     invariant, loop, check, all) are no longer accepted as values
     for the `collect' option.  Then again, the collect option does
     not seem to be implemented.  [lace-invalid-collect-values]

116. Validity constraint VDOC on page 526 is enforced - the option
     `collect (no)' is not accepted in a Cluster-level Defaults
     clause.  Then again, the collect option does not seem to be
     implemented.  [lace-cluster-level-collect]

117. An Ace with a Generation section which has a non-existent
     Language now elicits an error message from the compiler.
     [lace-bogus-gen-lang]

118. The Lace `assertion' option now works correctly.  [lace-assertion-option]

119. Compiling a system without a precompiled cluster and then
     removing a particular cluster from the Ace file and recompiling
     violates VTCT, which compiler correctly reports.  Adding the
     cluster back in the Ace file and hitting return causes compiler
     to resume, and it dies with an internal error. [lace-remove-cluster2]

120. A particular system compiles fine.  Four clusters are removed
     from the Ace and the compiler detects and reports the VTCT
     violation.  When the clusters are added back to the Ace and
     compilation is resumed, it no longer causes a pass 2 exception
     trace.  [whip-that-ace]

121. Error messages (such as VSCN error) no longer have bad
     formatting, with \n and \t strings.  [bad-VSCN-format]

122. Obsolete clauses now causes warning messages to be issued.
     [obsolete-warning]

123. Concatenation of a manifest array of BIT constants now prints out
     correctly.  [concat-manifest-bit-array]

----------------------------------------------------------------------

124. A type with zero generic parameters (e.g., GENERIC []) is reported
     as a syntax error.  [generic-zero-parms]

125. Semicolons are not optional in the places where they should be.
     [semicolons-not-optional]

126. The assignment `b := 0 = 0 = True' is rejected as a syntax error.
     [zero-equals-zero]

127. Some things ETL says are OK are called syntax errors by the
     compiler.  All related to string, character, integer and real
     constants.  [syntax-disagreements-1]

128. If a Creation_clause has a non-empty Clients part and an empty
     Feature_list, it is reported as a syntax error even though it
     conforms to the syntax on page 285.  [creation-client-no-feats]

129. A strip expression with no attributes in its parenthesized
     attribute list (strip ()) is reported as a syntax error.
     [empty-strip-expression]

130. A manifest array with no expression in its list (<< >>) is
     reported as a syntax error.  [empty-manifest-array]

131. A declaration introducing an attribute whose type is a Bit_type
     appears to be valid, since the Constant is of type INTEGER and has
     a positive value (VTBT on page 210).  But the compiler reports a
     syntax error.  [bit-type-with-plus]

132. A class with an Indexing part which has a completely empty
     Index_list (no Index_clause's) should be legal according to page
     49.  But the compiler calls it a syntax error.  [empty-index-list]

133. A generic class with a single formal generic parameter which is
     constrained by `expanded TEST', which is not a Class_type, is
     accepted by the compiler.  [invalid-generic-constraint3]

134. A routine with postcondition `ensure (old (old n)) > 0' violates
     constraint VAOL, but is accepted.  [invalid-use-of-old]

135. A bit type which is `BIT 0' violates VTBT, but is accepted.
     [invalid-bit-type]

136. A constraint on a formal generic parameter which is syntactically
     illegal (and not even meaningful anyway since it references a
     non-existent entity) is accepted by the compiler when all generic
     derivations use the actual generic parameter NONE.
     [illegal-formal-generic]

138. A violation of condition 2 the Expanded Type rule (VTEC) is not
     detected, but only if the expanded type is introduced by by a
     declaration of the form `expanded CT'.  [expanded-type-violation2]

139. A generic class with a single formal generic parameter which is
     constrained by the invalid Class_type ARRAY (actual generic
     parameter missing) is accepted by the compiler.
     [invalid-generic-constraint2]

140. A violation of export validity (constraint VUEX on page 368) which
     involves a qualified call that is an operator expression (instead
     of being in dot notation) is not detected.  [export-validity-viol]

141. Compiler accepts a generic derivation which is invalid because the
     class on which it is based is not a generic derivation.  This only
     seems to happen when this base class is a basic class (INTEGER,
     REAL, DOUBLE, CHARACTER, BOOLEAN, POINTER).  [basic-type-generic-deriv]

142. A valid feature rename in an inheritance clause (x ==> y, y ==> z)
     is not accepted.  [valid-feature-rename]

143. A Redefine subclause which lists a feature name which is `once'
     routine in the parent class causes the compiler to complain about
     violation of VDRS, regardless of whether the new declaration is a
     `once' routine.  [valid-once-redefine]

144. An attempt to list a `once' routine in an Undefine inheritance
     subclause causes the compiler to report violation of validity
     constraint VDUS.  [valid-once-undefine]

145. A class which violates VDRD7 (Redeclaration rule) is not accepted
    by the compiler, but the validity constraint code reported is not
    VDRD7 but VE01, which is undocumented.  [redecl-violation]

146. A violation of the Entity rule (VEEN) involving the predefined
     entity `Result' is incorrectly reported by the compiler as a
     violation of the Local Entity rule (VRLE).  [local-entity-wrong-error]

147. The compiler correctly detects a VUAR violation, but reports it as
     `Error VUAR2 (VUAR2)' instead of `Error VUAR (VUAR2)'.
     [vuar-called-vuar2]

148. The compiler correctly detects a VTUG violation, but reports it as
     `Error VTUG3 (VTUG3)' instead of `Error VTUG (VTUG3)'.
     [vtug-called-vtug3]

149. After initial compilation, a VSCN violation is introduced.  The
     compiler detects the violation, but when return is pressed to
     resume compilation the compiler proceeds instead of reporting the
     VSCN violation again.  [vscn-sneak]

152. After initial compilation, a boolean variable referenced in the
     expression of a conditional is changed to an integer constant.  The
     compiler detects the VWBE violation.  But when the declaration is
     moved to a parent class, the compiler accepts the classes even
     though the VWBE violation is still present.  [vwbe-sneak]

153. After initial compilation, an attribute which is a string constant
     is changed to a variable attribute of another type, thereby
     introducing a VUAR violation.  The compiler detects the violation,
     but when return is pressed it continues with the compilation even
     though nothing has changed.  [vuar-sneak]

155. After initial compilation, an attribute is deleted, which
     introduces a VEEN violation.  The compiler reports the violation,
     but when return is pressed it proceeds with and finishes
     compilation, even though the violation is still there.  [veen-sneak]

156. After initial compilation, an Expanded Type rule violation (VTEC)
     is added.  When the compiler detects the violation, the creation
     clause is removed from the class which is being declared expanded
     by the client, thereby removing the violation.  But the compiler
     still reports a VTEC violation.  [vtec-compiler-wrong]

157. After initial compilation, the entire text of a class A is deleted
     and the system is recompiled.  The compiler correctly reports the
     VD10 violation.  But when compilation is resumed with no change to
     any files, the compiler reports a syntax error at position 0 on
     class A, though there is still no class A.  [vd10-becomes-syntax-error]

158. When a system is compiled and then a violation of the Expanded Type
     rule is introduced, the compiler detects the VTEC violation.  But
     when the offending class is returned to its original state (thereby
     removing the violation) and compilation is resumed, an exception
     trace results.  [expanded-deferred-exception]

159. When one of the formal generic parameters is removed from a generic
     class the compiler detects the VTUG violation thereby introduced.
     But resuming the compilation with no change to any classes results
     in an exception trace.  [vtug-retry]

160. A root class with one formal generic parameter is correctly
     reported to violate VSRC.  When a 2nd formal generic parameter of
     the same name is added, the newly introduced VCFG violation is
     detected but the compiler dies with an exception trace while trying
     to report it.  [generic-root-vcfg]

161. A system compiles fine.  Adding a feature to a generic class A
     which references a new class B where B inherits from A and then
     recompiling causes a compiler exception trace.  [pass4-melt-exception]

162. Changing a deferred function to a constant attribute after initial
     compilation and recompiling causes a compiler exception trace.
     [deferred-to-const-attr]

163. After initial compilation, changing an actual generic parameter
     from one expanded type to a different expanded type and
     recompiling causes a compiler exception trace while melting
     changes.  [chg-expanded-actual-generic]

164. After initial compilation, the name of an attribute in an
     inherited class is changed, thereby introducing a VHRC violation.
     The compiler detects the violation, but when it is removed by
     deleting both the attribute and the rename clause in the heir and
     compilation is resumed, the compiler dies with an exception trace.
     [cannot-update-types]

165. After initial compilation, a VWOE violation is introduced.  When
     the system is recompiled, the compiler detects the violation but
     correcting it by returning the class to its original state and
     resuming leads to a compiler exception trace.  [intro-vwoe-precondition]

166. After initial compilation, a VWOE error is introduced in the class
     invariant.  When the compiler complains, the entire class
     invariant is deleted and compilation is resumed.  This causes a
     compiler exception trace. [change-delete-invariant]

167. An `old' expression in a manifest array in a postcondition causes a
     run-time panic (illegal metamorphose type), but only after melting.
     [manifest-array-with-old]

168. A routine with precondition `false' is redefined with alternative
     precondition `true' in a descendant.  When the system is compiled
     via melting both classes, system execution results in a
     precondition violation (which is wrong).  When the same system is
     frozen and executed, there are no precondition violations.
     [chained-assertion-melt]

169. A class which assigns a bit constant to a local and writes it out
     compiles fine, but does not write anything out when executed.
     [bit-out-wrong]

170. In certain cases, the functions `bottom_int_div' and `up_int_div'
     in class BASIC_ROUTINES give the wrong results.  [wrong-int-div]

171. The standard binary operator infix "+" should have lower precedence
     (7) than a unary free operator (11), according to page 377, but it
     does not.  [plus-before-free-unary]

172. Binary free operators should have higher precedence than all other
     binary operators, but they have lower precedence than most binary
     operators.  [free-binary-wrong-precedence]

173. All default initializations are supposed to be applied before the
     creation procedure (if any) is called.  In the case of nested
     sub-objects, the creation procedures are called in the wrong
     order.  [expanded-creation-order]

175. A system which seems to be correct concatenates and prints the
     strings of a manifest array many times, but eventually dies with an
     exception trace.  The trace indicates that the array of string
     passed to the `concat' function contained a void reference, which
     appears to indicate a compiler or run-time system bug, since the
     actual argument is a manifest array with 3 elements which all look
     like they can not be void.  [manifest-array-concat]

176. Compiling a system with inheritance cycle results in an exception
     trace.  [add-inheritance-cycle]
    
177. A root class which does not contain the root creation procedure named 
     in the Ace causes an exception trace.  [remove-root-creation-proc]

178. A constrained generic class which is syntactically illegal because
     the constraint is `like Current' causes no complaints in pass 1 or
     pass 2.  But when es3 does pass 2 on the class which inherits from
     the illegal class, it dies with an exception trace.
     [like-current-generic-constraint]

179. A generic class with a single formal generic parameter which is
     constrained by a class with an invalid actual generic parameter
     (`STRING [STRING]') causes an exception trace.
     [invalid-generic-constraint]
    
180. A generic derivation of a generic class with a constraint which is
     a BIT type with (what looks like) a constant attribute expressing
     the number of bits in the BIT type causes a compiler exception
     trace.  [bit-constraint-with-attr]

181. A class with the keyword `class' in the indexing clause causes the
     compiler to get confused about what the actual name of the class
     is and causes an exception trace when introduced after initial
     compilation (equivalent to changing class name, apparently).
     [class-name-confusion]

182. A violation of the Expanded Client rule (VLEC) is not detected
     when it involves two classes, neither of which inherits from the
     other.  The compilation is terminated by an illegal instruction
     after pass 5.  [expanded-client-cycle]

183. Certain invalid es3 command line options cause an exception trace,
     instead of printing an error message like "class not in system".
     They are:
	es3 -senders BAD_CLASS BAD_FEATURE (if class not in system or
					    no such feature in class)
	es3 -fs BAD_CLASS (if class not in system)
	es3 -descendants BAD_CLASS (if class not in system)

184. A class with many formal generic parameters (512) which all have
     the same name causes the compiler to end with "illegal
     instruction".  [many-same-generics]

185. Renaming a feature to itself in an inheritance clause causes infinite
     loop in compiler.  [rename-feature-to-self]

186. A comment at the beginning of a class causes an infinite loop when
     taking the flat-short form of the class.  [flat-short-infinite-loop]
   
187. A class which inherits twice from one parent and simply renames
     the single inherited feature both times appears to be valid, but
     the compiler says it violates the Repeated Inheritance
     Consistency constraint (VMRC).  This was never really a bug - I
     just didn't fully understand the notion of "potential version".
     [repeat-inher-vmrc-violation]

----------------------------------------------------------------------

188. Trying to get the flat form of a particular class whose first
     feature is secret and which has a second (generally available)
     feature causes an infinite loop.  [secret-feat-flat-loop]

189. A class with a multiple declaration which includes both an
     immediate feature and an inherited feature uses assertion
     redeclaration.  A system with the class executes correctly, but the
     flat and flatshort forms are incorrect.  [wrong-flat-flatshort]

190. Trying to get the flat form of a particular class causes an
     infinite loop, which eats up more and more memory.
     [flat-loop-eat-memory]

191. Doing `es3 -flat two_way_circular' causes an exception trace.

192. Starting ebench, selecting a project directory for a new project
     and then clicking on the `Run' icon causes ebench to die with an
     exception trace.  Starting a class tool before compilation of a
     new project and typing a class name into its text field also
     causes an exception trace.  [run-new-project]

193. Various Eiffelbench bugs: part of following feature sometimes
    displayed in Feature Tool.  `End' missing in routines in flat form.
    Cannot grab infix features in Flat form.  [misc-eiffelbench-bugs]

194. After changing a class in Eiffelbench and recompiling, a feature
     can have the wrong anchor point and the wrong text when it is
     dragged into a Feature Tool.  [wrong-feature-position]

195. Freezing a system, setting breakpoints and executing the system
     via `execute/debug' works correctly.  When the system is melted
     (with no change to class texts or the Ace) and the same Feature
     Tool is used to set breakpoint and execute, the system being
     executed dies with a run-time panic.  [melt-debug-panic]

196. When the debugger reaches a breakpoint set on a routine which has
     locals, it seems to stop but the display of the breakpoint
     information in the Project Tool flashes by and then is invisible.
     [debug-locals-flash]

197. For certain syntax errors, the correct line number is printed but
     the arrow showing the position of the error points to the wrong
     character.  The position shown is wrong if the white space before
     the incorrect token is composed of tabs, but not if it is
     composed of blanks.  [leading-tabs-wrong-position]

198. A standard operator name which is not completely in lower case
     (has one or more uppercase letters) is not accepted, but it
     should be.  [std-operator-case-sensitive]

199. Operator features with the wrong number of arguments or results are
     accepted.  Operator features with invalid names are accepted, such
     as infix "| |", infix "&    ", infix "&", infix "not".
     [bad-infix-feature]

200. An external or deferred routine with local declarations is accepted
     without complaint (i.e. constraint VRRR is not enforced).
     [invalid-local-rescue]

201. A routine with a formal argument that has the same identifier as
     a local entity of the routine is accepted (i.e. constraint VRLE
     is not enforced).  [local-same-as-formal]

202. A feature rename clause which renames an infix feature to a prefix
     feature and *should* be invalid is accepted.  [rename-infix-to-prefix]

203. A class which violates the Creation Instruction rule (page 286)
     constraint VGCC5 causes an exception trace.
     [invalid-creation-instruction]
    
204. Validity constraint VZAA on page 405 of ETL states that in an
     actual argument of the Address form ($arg), `arg' must be the
     final name of a feature of the enclosing class which is not a
     constant attribute.  But the compiler does not enforce this
     constraint.  [illegal-address-use]

205. A class TEST which violates the Expanded Type rule by declaring
     an attribute of an expanded type, where the creation procedure of
     the expanded type's base class is secret (not available to TEST)
     is accepted by the compiler without complaint.
     [expanded-type-avail-viol]

206. An invalid generic derivation (STRING [STRING], which is invalid
     because STRING is not a generic class) is accepted by the
     compiler, but only when it is used as explicit creation type in a
     creation instruction.  [bad-generic-deriv-creation-type]

207. A class with a formal generic parameter G constrained by ARRAY
     [STRING] declares an attribute of type G.  An assignment of one
     of the elements of the attribute to the attribute itself violates
     the Assignment Rule, but the compiler does not detect the VJAR
     violation.  Compiler dies. [generic-parm-conform]

208. A system with a root class which is deferred violates the Root
     Class rule (VSRC) [as modified by Bertrand following my
     suggestion], but is accepted by the compiler.  Executing the
     system results in a "Create on deferred" exception.
     [deferred-root-class]

209. A generic derivation of a class with a constrained formal generic
     parameter (using `like Current' as actual generic parameter) is
     rejected as violating validity constraint VHPR, but only when
     used as a type in an inheritance clause.  Hitting return to retry
     compilation with no change causes an exception trace.
     [valid-like-generic-deriv]

210. A case of repeated inheritance with renaming of the single
     inherited feature seems to be valid (according to ETL), but the
     compiler reports violation of the Feature Name rule (VMFN).
     [valid-repeated-inheritance2]

211. A class with a multi_branch instruction which appears to be
     syntactically legal and valid (according to ETL page 239) is
     rejected as violating validity constraint VOMB.
     [multi-branch-empty-intervals]

212. The free operator infix "@@@" can be declared, but when I try to
     use it, the compiler complains that there is no feature
     `_infix_@' in class TEST.  [op-feat-cant-be-used]

213. The type `TEST1 [INTEGER, ARRAY [INTEGER]' where TEST1 is
     declared as `TEST1 [G, H -> ARRAY [G]]' causes a compiler
     exception trace.  [valid-actual-generic]

214. In some cases, a validity violation involving a construct
     enclosing an Entity rule violation (validity constraint VEEN) is
     reported, instead of the Entity rule violation, which is the true
     cause of the problem.  This is misleading and confusing.
     [veen-called-other-viol]

215. A call which seems to be export-valid (obeys VUEX) and violates
     argument-validity (constraint VUAR) is reported as violating VUEX
     instead.  [vuar-called-vuex]

216. A BIT type whose length is specified by a constant attribute
     which is not an integer correctly elicits a VTBT violation
     report, but the compiler also reports a VTAT violation though no
     anchored types are used.  [spurious-vtat-on-bit]

217. A creation instruction has an explicit creation type which
     violates VGCC3.  The compiler reports this violation, but also
     erroneously reports a VGCC2 violation if the target entity of the
     creation is of a type based on a deferred class. [spurious-vgcc2]

219. An `old' expression which would be valid in a postcondition
     elicits an incorrect VAOL(2) error report if it appears in a
     precondition.  [old-in-precond-bogus-vaol2]

220. The expression `old Result' is accepted in a postcondition, as it
     should be according to ETL.  This was never really a bug.  [old-result]

221. An expanded class which has more than one creation procedure in
     separate Creation_clause's violates the Creation_clause rule
     VGCP(4) but the compiler does not complain.  Actually, the
     example class does not technically violate VGCP(4), but it
     violates the spirit of this constraint since the class will never
     be able to be used as an expanded type.
     [expanded-multi-creation-procs]
    
223. Compiling a valid class with a multi-branch and then changing the
     type of one of the choices (which is a constant attribute) from
     INTEGER to DOUBLE and recompiling causes the VOMB violation to go
     undetected.  [chg-inspect-const-type]

224. After initial compilation, a class header is changed to make the
     class expanded.  This introduces an Assignment Attempt rule
     violation, but the compiler does not detect it.  [vjrv-sneak]

225. After initial compilation, the value of a constant integer
     attribute is changed, thereby introducing a VTBT violation.  When
     the system is recompiled, the compiler does not detect the VTBT
     violation.  [vtbt-sneak]

226. After initial compilation, a class which is not reachable from
     the root is modified so that it has the same name as the root
     class.  The Ace file does not specify what cluster the root class
     is in.  When the system is recompiled, the compiler does not
     detect the VD29 violation.  [vd29-sneak]

227. A system with a VTCT violation is compiled and the compiler
     detects it.  But when the name of a class is changed so that the
     missing class is present and the compilation is resumed, the
     compiler still reports the same VTCT violation.  [chg-class-name]

228. After initial compilation, the names of two classes are switched.
     When the system is recompiled, the compiler reports a VSCN
     violation although none is present.  [switch-class-names]

229. After initial compilation, the class header of a class which is
     part of the signature of a redefined feature is changed so that
     the class is expanded.  When the system is recompiled, the
     compiler reports a VDRD violation although there is no violation.
     [vdrd-compiler-wrong]

230. After initial compilation, an Ace file with an include has its
     last modification date changed but its contents are unchanged.
     When the system is recompiled, the compiler reports a bogus VD09
     error.  [vscn-compiler-wrong]

231. A generic derivation of a class with a constrained formal generic
     parameter (using `like Current' as actual generic parameter) is
     rejected as violating validity constraint VHPR when used as a
     type in an inheritance clause.  Hitting return to retry
     compilation with no change causes an exception trace.
     [valid-like-generic-deriv]

232. Changing an argumentless function in a class which is repeatedly
     inherited to an attribute and recompiling causes an exception
     trace.  [repeated-func-to-attr]

233. A known sequence of changes causes an exception trace in the
     compiler during freezing.  Based on the trace, it seems to be
     related to external functions.  [external-info-exception]

234. A known sequence of changes causes an exception trace in the
     compiler during pass 3 type checking.  [mystery-bug]

235. A known sequence of changes causes an exception trace in the
     compiler during pass 4.  [dispatch-unit-exception]

236. After initial compilation, deleting the feature to which another
     feature is anchored and recompiling results in a compiler
     exception trace.  [unsolved-type]

237. After initial compilation, changing the name of the root class in
     class text and recompiling causes a compiler exception trace.
     Sometimes it seems to notice the VD20 violation (can't find root
     class).  [chg-root-class-name]

238. A system without a needed cluster is compiled without
     precompilation info.  When the compiler correctly detects the
     VTCT error, the kernel cluster is removed and compilation is
     resumed.  The VD23 error is detected.  But when the kernel
     cluster is added back to the Ace, along with the missing needed
     cluster and compilation is resumed again, the compiler dies with
     an exception trace.  [del-add-kernel-cluster]

239. After initial compilation, a constraint is added to an
     unconstrained formal generic parameter of a generic class,
     thereby introducing a VTCG violation.  When the system is
     recompiled, the compiler dies with an exception trace.
     [add-generic-constraint]

240. A class with a VEEN violation in the invariant is compiled and
     the compiler detects the violation.  Then the invariant assertion
     is deleted and the compilation completes fine.  But when the same
     invalid assertion is added back into the invariant and the system
     is recompiled, an exception trace results.
     [delete-add-invariant]

241. Unique attributes added to an existing unique declaration can
     sometimes get the same value as an existing unique attribute when
     melting is involved.  [unique-not-unique]

242. Attributes declared as unique and introduced in the same feature
     declaration are supposed to have consecutive values according to
     page 266.  But deleting a unique attribute and rerunning es3 can
     sometimes result in unique attributes which should have
     consecutive values, but do not.  [unique-not-consecutive]

244. After initial compilation, a class header is modified so that the
     class is expanded.  The system is recompiled without incident,
     but when it is executed, an attribute which is now of an expanded
     type does not get initalized properly (creation procedure of
     expanded class is not called).  [expanded-class-bad-behavior]
   
245. A class which inherits from itself is correctly reported to
     violate VHPR.  But when the inheritance clause is removed, the
     compiler still reports a VHPR violation although none is present.
     [remove-inheritance-cycle]

246. When a secret attribute inherited from another class has its name
     changed after initial compilation, the compiler does not detect
     the VEEN violation when the system is recompiled.
     [rename-secret-attribute]

247. When a VSCN violation is introduced after initial compilation,
     the compiler does not detect it.  The violation is introduced by
     changing the name of an existing class to match the name of a
     class in the kernel cluster.  [add-vscn-violation]

248. After initial compilation, the type of an attribute is changed
     from `TEST1' to `expanded TEST1'.  The system recompiles fine,
     but when it is executed it dies with a segmentation fault instead
     of printing "Weasel". [expand-attribute]
   
249. Compiling a valid class with a multi-branch which has unique
     inspect constants and then changing the value of one of the
     choices (which is a constant attribute) from 0 to a positive value
     results in an undetected VOMB violation.  [chg-inspect-const-value]

250. An `old' expression in a class invariant is correctly reported to
     violate VAOL.  But when the `old' is removed, the compiler still
     reports a VAOL violation.  [bogus-vaol]

251. An explicit creation type which is an expanded type violates
     VGCC(3), but the compiler does not detect the violation when it
     is introduced after initial compilation by changing a class
     header to `expanded class'.  [vgcc-sneak]

252. A known sequence of changes involving changes to actual generic
     parameters of the genericly derived return type of an external
     function causes a compiler exception trace.
     [change-generic-derived-external]

253. A generic class which violates the Expanded Client rule
     (constraint VLEC) causes an infinite loop in the compiler.
     [generic-expanded-client2]

254. The division `40 / 5' executes correctly after compiling and
     freezing.  When the enclosing feature is modified and the compiler
     is rerun (presumably causing melting), the system prints the wrong
     value (it used to die with a run-time PANIC).  [divide-melt-panic]

255. Passing an actual argument which is a reference type to a routine
     whose corresponding formal argument is the expanded version of
     that reference type compiles fine, but when the resulting system
     is executed an exception trace occurs.  The exception trace only
     occurs when the classes are melted, not when they are frozen.
     [ref-actual-expanded-formal]

257. A system does arithmetic with two REAL operands, at least one of
     which is a constant and assigns the result to a variable of type
     DOUBLE.  Executing the system causes a run-time panic with
     "illegal cast operation", but only if the routine which does the
     arithmetic is melted.  [real-const-arith-to-double]

258. An expression which consists of the application of three
     different unary operators (free operators in this case) compiles
     OK, but after melting the innermost one is called three times
     instead of each one being called once.  [multiple-unary-free-ops]

259. A procedure which prints out some double constants prints correct
     values, but `print' does not print many of the significant digits
     (io.putdouble does).  [print-double]

260. The call `io.putreal' often does not print the correct value of a
     real number when the calling routine is melted.  [melted-putreal-wrong]

261. The expression `old Current' is not equal to Current (using `=')
     in a routine postcondition, where the routine call is an
     unqualified call.  [old-current-ne-current]

262. The power operator (infix "^") gives incorrect results for
     INTEGERs, REALs and DOUBLEs.  [power-operator]

263. A routine with no precondition (i.e., an implicit precondition of
     `true') is redefined in a descendant with alternative
     precondition `false'.  The full precondition of the redefined
     routine is therefore `true or else false'.  But when the system
     is compiled with `assertion (require)' and executed, the
     redefined routine's precondition is violated. [redecl-implicit-precond]

265. The routine `readline' in class UNIX_FILE does not work properly
     on long lines.  The first 256 characters are returned as one
     complete line.  [readline-long-line-wrong]

266. A class with a `strip' expression compiles fine, but doesn't
     execute correctly when frozen - gets a "create on deferred"
     exception.  (It executes fine when melted).  [strip-wont-c-compile]

267. A Strip expression with Void in its Attribute_list is accepted
     (and seems to be valid, since Void is a variable attribute of the
     class, at least technically).  But the generated C code appears
     to be incorrect and dies with a run-time panic when executed.
     [strip-with-void]

268. A system which seems to be correct concatenates and prints the
     BIT constants of a manifest array many times, but eventually dies
     with a run-time panic. [manifest-array-of-bits]

269. The argument to the root class creation procedure is not
     initialized.  [uninit-root-class-arg]

270. Equal dies with a bus error when used with integers or characters
     (and possibly other expanded types), as in `equal (1, 3)'.
     [int-equal-int]

271. A manifest array used as the target of a feature call causes an
     exception trace during compilation (violation of assertion
     `has_generics').  [manifest-array-call-target]

272. A manifest array used as the target of a feature call causes an
     exception trace during compilation (violation of assertion
     `last_type_exists').  [manifest-array-call-target2]

273. An external feature with an alias which is the empty string ("")
     causes a compiler exception trace while freezing.
     [empty-external-feat-alias]

274. A system has a class which declares a local that is of a
     non-basic expanded type and calls a routine on that local.  When
     the system is finalized, the compiler reports that it cannot
     generate C code.  [expanded-local-panic]

275. An invalid type (ARRAY, which is invalid because ARRAY is a
     generic class but no generic parameter is supplied) is accepted by
     the compiler, but only when it is used as explicit creation type
     in a creation instruction.  [bad-generic-deriv-creation-type2]

276. An Ace which references a precompiled cluster causes an exception
     trace if it does not list all the clusters which were
     precompiled.  [precompiled-missing-cluster]

277. A class with a constant attribute which is of a Bit_type is
     reported to violate VQMC if the length of the Bit_constant is not
     identical to the length specified in the Bit_type.
     [bit-constant-diff-length]

278. A VREG violation involving a formal argument is reported once for
     each occurrence of a duplicate argument, but if it involves a
     local entity it is reported (number of occurrences - 1 times).
     It should be reported once for each duplicate identifier.
     [vreg-formal-multiple]

279. Incorrect `what to do' explanation for a VRLE(1) violation.
     [incorrect-vrle1-explain]

280. After initial compilation, an actual generic parameter is changed
     from `expanded A' to `A'.  The system recompiles fine, but
     executing it results in a run-time panic instead of the expected
     "feature applied to void reference" exception.
     [expanded-generic-exec-panic]

281. After initial compilation, an include in the Ace file is
     commented out.  This change effectively removes the root class
     from the universe.  But when the system is recompiled, the
     compiler dies with an exception trace.  [vd20-sneak]

282. A class with header `class TEST1 [G -> TEST1 [REAL]]' which has
     no assignments in it causes the compiler to incorrectly report a
     VJAR violation and then die with an exception trace in the middle
     of reporting the (non-existent) violation.
     [generic-constrained-by-its-class]

283. A system with a generic class whose single generic parameter is
     constrained by the type `ARRAY [STRING]' causes an exception
     trace.  [generic-constr-by-generic-deriv]
    
285. An Ace which includes a file twice (once in an include in a "use"
     file and once in an include which appears directly in the Ace)
     causes the compiler to incorrectly report a VD09 violation.
     [double-include-vscn-wrong]

286. An Ace with no creation procedure specified is accepted, even if
     the root class has a creation clause with zero or multiple creation
     procedures listed.  [lace-no-creation-proc]

287. A Cluster_mark in the Ace indicating which cluster the root class
     is in is case-sensitive, but should not be since it does not
     refer to an outside element.  [root-cluster-case-sensitive]

288. A syntax error in an Ace file sometimes has the wrong position
     reported if there are Manifest strings preceding the position of
     the error.  This bug has been fixed for syntax errors on classes.
     [ace-wrong-positions]

289. Non-existent options specified in a cluster-level `default'
     clause or in an `option' clause cause the compiler to incorrectly
     report a VD36 violation (cluster-level option clause uses
     system-level option).  [lace-nonexistent-cluster-options]

290. An Ace file with a Use clause in a Cluster_properties causes es3
     to die with an exception trace if the Use file has a syntax
     error.  [lace-use-file-error]

291. An Options_clause in the Options section of a Cluster_properties
     which does not have a Target_list causes a run-time panic.
     [lace-option-no-target]

292. An Ace with a Cluster_properties containing an Include or Exclude
     with a completely empty File_list causes an exception trace.
     [lace-empty-include-exclude]

293. An Ace with a `use <filename>' causes an exception trace if the
     <filename> is one of the following directories: ".", "..", or
     "/".  [lace-use-file-is-dir]

294. A cluster_adaptation part with an include or exclude which has a
     trailing semicolon causes a compiler exception trace.  Leading
     semicolons and extra semicolons between files to be included or
     excluded do not seem to cause this problem.
     [lace-include-trailing-semicolon]

296. Removing an unneeded cluster from the Ace and recompiling causes
     an exception trace.  [remove-unneeded-cluster]

297. When both arguments of the boolean operator `implies' are either
     boolean constants (true or false) or local variables, the
     generated C code won't compile.  [implies-wont-c-compile]

298. According to page 418 of ETL, all characters are significant in
     identifiers.  This is now true. [not-all-chars-significant]

299. After initial compilation, the Ace is changed to indicate a
     different root class, which happens to be a generic class.  The
     compiler does not detect the VSRC violation.  Actually, this was
     never really a bug - I just had an error in my test control file.
     [validity-vsrc1-new-root]

301. A system with an Ace which specifies NONE as the root class and
     also specifies a cluster name (which is supposed to be the
     cluster where the root class is found) is accepted without
     complaint, even though class NONE does not actually exist and so
     is not in any cluster.  This was never really a bug: the only
     cluster name which is accepted is the one which refers to the
     kernel cluster.  [root-none-cluster-name]

302. When a VTAT violation is introduced after initial compilation, it
     causes the compiler to terminate with an internal error message.
     [vtat-sneak]

303. When a violation of VDRD(7) is introduced after initial compilation
     by changing an inherited routine with an internal body to have an
     external body, the compiler does not detect it.  [vdrd7-sneak]

304. A system with a VDRD violation is compiled and the compiler
     detects the violation.  Then the offending external routine is
     deleted and a routine with the same name but a `do' body is added
     to the inheriting class.  When compilation is resumed, the
     compiler dies with an exception trace while freezing the system.
     [move-external-make-do]

305. An entity of type `HASH_TABLE [STRING, DOUBLE]' is correctly
     reported to violate VTCG.  But when the error is fixed by
     changing DOUBLE to STRING (which does conform to HASHABLE) and
     compilation is resumed, the compiler dies with an exception
     trace.  [fix-constrained-actual-generic]

306. When a violation of VTEC(2) is introduced after initial
     compilation by adding a creation clause with two creation
     procedures to the class being used as an expanded type, the
     compiler does not detect it.  [vtec-sneak]

307. After the compiler detects a VJAW violation, the feature which is
     the target of the assignment is changed from an argumentless function
     to an attribute.  When compilation is resumed, the compiler later
     reports that it cannot write the .UPDT file.  [cannot-write-updt]

308. An `old' expression in a postcondition references an unknown
     identifier.  But when the reference to this identifier is
     removed, the compiler still reports a VAOL violation. [bogus-vaol2]

309. After initial compilation, a rename subclause of an inheritance
     clause is deleted, which introduces a VRFA violation.  The
     compiler detects the violation, but when the rename subclause is
     added back and compilation is resumed, the compiler reports a
     bogus VD27 error.  [bogus-vd27]

310. After initial compilation, a VCCH(2) error is introduced.  When
     it is detected, it is removed, which produces a VMFN error.  But
     when the offending feature is deleted in the inherited class the
     compiler reports a bogus VD27 error, instead of the VWOE error.
     [bogus-vd27-2]

311. After initial compilation, several infix features of the same
     name (differing only by case) are introduced.  When the system is
     recompiled, the compiler detects the VMFN violations but also
     reports a nonexistent VMRC violation.  [nonexistent-vmrc]

312. After initial compilation, the name of the single creation
     procedure is removed from the creation clause, leaving it empty.
     When the system is recompiled, the compiler detects the VD27
     violation.  Then the creation procedure name is added back but
     twice, resulting in `creation make, make'.  The compiler detects
     the VGCP(3) error but dies with an internal error trying to
     report it.  [del-creation-proc-add-two]

313. After initial compilation, a class invariant is removed and a
     VLEC error is also introduced.  The compiler detects the VLEC
     error, but when it is removed by making the involved class no
     longer generic the compiler dies after pass 3.  Note that having
     and removing the class invariant is necessary for the failure to
     occur.  [invariant-expanded-generic]

314. After initial compilation, the type of an inherited attribute
     referenced in the invariant of the heir class is changed from
     BOOLEAN to INTEGER.  When the system is recompiled, the compiler
     dies with an exception trace.  [chg-invariant-expr-type]

315. After initial compilation, the file with class FINITE (in a local
     directory) is deleted.  When the system is recompiled, the
     compiler detects the VTCT violation.  Then FINITE is added back
     to the cluster and compilation is resumed.  The compiler later
     dies with an exception trace.  [delete-finite-add-back]

316. After initial compilation, the type of an attribute is changed
     from one expanded type to another.  System execution should call
     the creation procedure of the new expanded class but it does not.
     [change-attr-expanded-type]
   
317. After initial compilation, an inherited variable attribute
     referenced in a `strip' expression is changed to a function with
     no arguments.  When the system is recompiled, the compiler does
     not detect the VWST violation.  [vwst-sneak]

318. When an inherited constant integer attribute used as the number
     of bits in a BIT type which is a formal argument type is given a
     smaller value, the compiler does not detect the newly introduced
     VUAR error.  [vuar-weasel]
   
319. After initial compilation where the system is frozen, the value
     of an inherited constant INTEGER attribute is changed and the
     system is refrozen.  System execution should print a longer bit
     string, but it does not.  [chg-bit-length-refreeze]
   
320. A system is frozen and then executed, producing the correct
     output.  Then a class which was expanded is modified so that it
     is no longer expanded and changes are melted.  When the resulting
     system is executed, it dies with an exception trace while trying
     to create an instance of the now non-expanded class.
     [create-chg-to-nonexpanded]

321. After initial compilation, an inherited feature which is
     redefined is marked as frozen in the ancestor class.  The
     compiler detects the violation VDRS violation, but when the
     `frozen' keyword is deleted and compilation is resumed, the
     compiler reports a bogus VD27 error.  [frozen-feat-bogus-vd27]

322. When a small valid class is compiled with `assertion (all)' and
     executed, assertion `empty_property' of the invariant of class
     UNIX_FILE is violated.  [invariant-empty-property]

323. A system has a class TEST1 with 10 attributes of an expanded
     type, where the base class of the expanded type does not contain
     any attributes (doesn't matter if it has attributes or not).
     Repeated creation of instances of TEST1 causes a run-time panic
     when executed.  [expanded-creation-panic]
   
324. According to page 130 of ETL, the Expression in a Variant is
     valid if and only if it is of type INTEGER.  But the compiler
     accepts an expression (Void) of type NONE and later reports an
     internal error.  [void-as-variant]

325. A violation of the Expanded Client rule (VLEC) is not detected
     when more than 2 classes are involved in the cycle, at least if
     the expansion is done in the attribute declarations rather than
     in the class headers.  Compilation ends with "illegal
     instruction".  [expanded-client-3-cycle]

326. A class has a creation instruction whose target is a double
     constant with a negative value.  The compiler starts reporting a
     VGCC(7) error and dies while trying to report it.
     [create-negative-double-const]

327. A Cluster_mark in the Ace in an Adaptation clause indicating
     which cluster should be adapted is case-sensitive if the name is
     enclosed in double quotes, but should not be since it does not
     refer to an outside element.  The compiler reports a VD03
     violation though there is none.  [adapt-cluster-case-sensitive]

328. When a system is being finalized and the Ace specifies that the
     class STRING should be visible, the `finish_freezing' step fails
     due to undefined symbols.  [visible-finalize-wont-link]

329. Finalizing a particular system with `assertion (no)' but allowing
     dead code removal to be done produces C code which will not
     compile.  The C compiler reports a parse error near void.
     [finalize-void-parse-error]

330. For a class with invariant `0 = 0', the compiler generates C code
     which will not compile.  [invariant-zero-equals-zero]

331. The C code generated for some bit operations will not compile.  I
     believe these operations are `not', infix "^" and infix "#".
     [frozen-bit-operations]

332. According to page 518 (VDCN) the Cluster_name must be different
     for each cluster in an Ace.  But an Ace which violates this rule
     causes the compiler to report a VD28 error, instead of a VDCN
     error.  This was never really a bug; since a precompiled cluster
     was used, the kernel path name is looked up in the precompiled
     cluster to determine the cluster tag, which is `kernel'.  Then
     two different clusters (kernel and support) have the same path
     name.  [lace-unique-cluster-names]
   
334. Void, which is of type NONE (not BOOLEAN or INTEGER) is accepted
     as a boolean expression and as an integer expression in some
     contexts.  According to ETL, it should not be. [void-as-bool-or-int]

335. Validity constraint VHRC(4) is not enforced: a feature with invalid
     signature can be renamed to a prefix feature.  [validity-vhrc4-basic]

336. Validity constraint VHRC(5) is not enforced: a feature with invalid
     signature can be renamed to an infix feature.  [validity-vhrc5-basic]

337. Incorrect `invalid assertion clause' listed (precondition instead
     of postcondition) for a VDRD(3) violation on a redeclared routine
     which uses just `ensure' to introduce its postcondition, instead
     of `ensure then'.  [wrong-vdrd-assertion-clause]

338. When an inherited constant integer attribute used as the number
     of bits in a BIT type is changed to a non-constant (even one of
     another type) or a constant of another type the compiler does not
     detect the newly introduced VTBT error.  [vtbt-weasel]
   
339. A inherited function of type `like Current' is called from the
     inheriting class.  The violation of the class invariant at
     execution time is reported.  However a run-time panic also occurs
     when the classes are melted, but not when they are frozen.
     [invariant-melt-panic]

340. After initial compilation and freezing, the type of a formal
     argument to routine is changed from `TEST1' to `expanded TEST1'
     and changes are melted.  Since the actual argument is Void, a
     "void assigned to expanded" exception should occur when the
     system is executed.  Instead, execution terminates with "illegal
     instruction" and no exception trace. [melted-void-expanded-arg]
   
341. An anchored type which appears to be valid according to ETL (page
     214) causes the compiler to report an internal error and
     terminate.  The example involves the type `x: ARRAY [like x]'.
     [actual-generic-anchor-feat]
    
342. A class with a declaration `x: REAL is -13' causes the compiler
     to report an internal error and terminate. [real-decl-integer-constant]

343. A system has one cluster, initially with only the root class in
     it.  Each class the compiler says is missing (via a VD23 error or
     a VTCT error) is copied into the cluster's directory.  The result
     is a set of classes which, when compiled from scratch, cause a
     compiler exception trace.  [minimal-set-of-classes]

344. A system with an attribute whose type is a BIT type with a large
     number of bits (2 million) generates C code which won't compile.
     Actually, the number of bits can be quite small (5) and the
     generated C code still won't compile. [big-bit-attribute]

345. A class which inherits from a generic class and provides a
     generically derived type as actual generic parameter has the
     wrong flat and flatshort forms.  [generic-wrong-flat]

----------------------------------------------------------------------

346. A routine with a precondition which references an entity not
     available to all classes to which the routine is available is
     accepted (i.e. constraint VAPE is not enforced).  ETL page 122.
     [invalid-precondition]

347. A routine which is not a redeclaration of another routine has
     `require else' and `ensure then' in its precondition and
     postcondition.  The compiler does not complain.  ETL page 152.
     Test changed to match clarified language definition, which allows
     `require else' and `ensure then' even if routine is not a
     redeclaration.  [require-else-ensure-then]

348. A reverse assignment attempt `x ?= proc' is accepted, where
     `proc' is a procedure.  The compiler should report a validity
     violation, such as VKCN.  If system is frozen, compiler
     terminates silently while freezing the system.  ETL page 341.
     [vkcn-sneak]

349. After initial compilation where the system is frozen, an
     attribute is changed from a BIT_REF to a BOOL_STRING and the
     instruction which creates it is modified accordingly and changes
     are melted.  System execution then ends with a run-time panic
     which states "invalid assertion level". [invalid-assertion-level]
   
350. After initial compilation, a Cluster_name in the Ace is changed.
     The Ace does not say explicitly which cluster the root class is
     in.  Nothing has changed, but both classes are recompiled.
     [chg-cluster-name-make-work]
   
351. Finalizing a system whose root creation procedure is an external
     routine produces C code which won't link.
     [finalize-ext-root-creation-proc]

352. Repeatedly clicking on the system button of the Project Tool
     (probably have to do it fast too, but I'm not sure) causes
     Eiffelbench to report that it has lost its license.
     [click-sys-lose-license]

353. When es3 starts, it reports `version 3.2 level 0'.  But the
     release I have is supposedly version 3.2.2 so it should report
     level 2.  [es3-wrong-level-number]

354. A system with a root creation procedure which is an external
     routine is finalized.  It doesn't link properly, which is a
     separate problem that has already been reported.  Then the
     external procedure is changed to an internal procedure.  When the
     system is re-finalized ebench dies with an exception trace just
     before starting dead code removal.  (This problem does not occur
     if `es3' is used instead).  [ebench-finalize-extern-intern]

355. A system with many calls to a conversion function that interfaces
     to sprintf is frozen and then executed, producing the correct
     output.  Then a single number is changed, causing melting of the
     root creation procedure.  When the resulting system is executed,
     it dies with a run-time panic after several thousand iterations.
     Changes to the initial classes which seem quite irrelevant, such
     as deleting unused routines (or even deleting the instructions in
     the body of an unused routine), prevent the panic from occurring.
     [weird-sprintf-melt-panic]

356. An inheritance clause which exports features to a class which is
     not in the universe is accepted without complaint (i.e. validity
     constraint VLCP is not enforced).  ETL page 101.
     [class-not-in-universe]

357. A call to deep_clone on a deep object structure (>= 43664 on my
     machine) causes system execution to end with "illegal
     instruction".  This problem is actually caused by stack overflow
     in the garbage collector.  It can be fixed by using csh command
     "limit stacksize unlimited".  [very-deep-clone]

358. A system which builds a fairly long linked list compiles fine,
     but ends with "illegal instruction" when executed.  This problem
     is actually caused by stack overflow in the garbage collector.
     It can be fixed by using csh command "limit stacksize unlimited".
     [long-linked-list-fails]

----------------------------------------------------------------------

359. A valid multi-branch containing another valid multi-branch in one
     of its `when' clauses is rejected by the compiler as violating
     VOMB(2).  The problem only seems to occur when one of the inspect
     expressions is of type INTEGER and the other is of type
     CHARACTER.  First reported by Timur Tabi on comp.lang.eiffel.
     [inspect-char-inside-inspect-int]

360. A multi-branch instruction lists an inspect "constant" which is
     actually a local variable.  The compiler should report a VOMB(2)
     error but it instead reports VEEN (unknown identifier) on the
     local entity which is non-constant and/or of the wrong type.
     [vomb2-called-veen]

361. After initial compilation, a VJAW error is introduced.  When the
     compiler detects it, the creation clause is removed from the root
     class and the cluster mark and creation procedure name are
     removed from the Ace.  When compilation is resumed, the compiler
     detects the VJAW error but terminates silently while trying to
     report it.  [vjaw-delete-creation-clause]

362. After initial compilation, an attribute listed in a strip
     expression is changed to a constant attribute, which elicits a
     VWST(1) error report.  Then an inheritance clause is added and
     the constant attribute is moved to an heir class.  The compiler
     still reports VWST(1), but terminates trying to display the
     feature name.  [vwst-cant-find-feature]
 
363. A system with a root class which has an external routine with an
     alias compiles fine and is correctly frozen even if only melting
     is requested.  Then the Ace is changed to indicate a new root
     class, which does not have any external routines.  When the
     system is recompiled, the compiler terminates silently after pass
     5 on the new root class.  [external-with-alias-new-root]

364. A system with a class which has an external routine with an alias
     compiles fine and is correctly frozen even if only melting is
     requested.  Then the Ace is changed so that the class containing
     the external routine is found in a different (newly added)
     cluster with a new cluster tag, but the class text is identical.
     When the system is recompiled, the compiler terminates silently
     after pass 6 on the new cluster.  [ext-with-alias-new-cluster]

365. After initial compilation, an attribute which is the target of a
     creation instruction is moved to a parent class and changed to an
     external function.  The compiler detects the VGCC(7) error.  But
     when the inheritance clause for the parent is deleted from the
     heir and compilation is resumed, the compiler reports a VEEN
     error but dies in the middle of reporting it. [veen-cant-find-feature]
 
366. After initial compilation with a root class of NONE, one of the
     clusters is removed from the Ace file.  When the system is
     recompiled, the compiler terminates silently right after
     announcing the compiler version number. [root-none-remove-cluster]
 
367. After initial compilation, a BOOL_STRING is changed to a BIT_REF.
     The compiler correctly detects and reports a VEEN error.  But
     when the offending line is deleted and compilation is resumed,
     the compiler dies during pass 3 on the class with the message
     "object allocation: No more memory" or "segmentation fault".
     [bool-string-to-bit-ref]
 
368. After initial melting of a root class whose creation procedure
     has an empty body, a local of type LINKED_LIST [STRING] is added
     and the routine body is modified to create the linked list and
     extend it with one string.  The assertion level is `ensure'.
     When the system is recompiled and executed, system execution ends
     with a segmentation fault in `go_to' of LINKED_LIST.
     [ensure-extend-linked-list]
   
369. The expression `True xor Current /= Void' incorrectly evaluates
     to True when code is frozen, but correctly evaluates to False
     when code is melted.  Compiling the generated C code elicits
     compiler warnings such as "illegal combination of pointer and
     integer, op !=".  This appears to be a precedence problem since
     fully parenthesized expressions involving xor produce the correct
     result when frozen.  [frozen-xor-precedence-error]

370. A pattern of object allocation, resizing and reclamation which
     was derived from a simple merge-sort program compiles fine when
     it is frozen, but dies with a run-time panic when executed with
     certain large values (e.g. 99999).  Many other large values do
     not cause a run-time panic.  [merge-sort-panic]
    
371. A class with an inheritance clause which renames some inherited
     features violates either VHRC(2) or VHRC(3) and also violates
     VHRC(1) is not reported as violating VHRC(1).  It seems to me
     that it should.  If `old_name' is not the final name of a feature
     of the named parent, then `old_name' is not even valid.  This
     seems like a more fundamental error than renaming a valid feature
     name more than once or renaming a valid feature name to itself.
     This was not fixed; I just decided it wasn't really a bug.
     [misleading-vhrc2-and-vhrc3]

372. After initial compilation (without using a precompiled library),
     the text of the root class is modified to give the class a
     different name.  When the system is recompiled, the compiler
     should report a VD30 error (cannot find root class), but it
     instead terminates silently after pass 6 on the root cluster.
     The error does not occur if a precompiled base library is used.
     [no-precomp-chg-class-name]
 
373. An expanded class with header `expanded class TEST1 [G -> TEST1
     [STRING]]' causes silent termination of the compiler after pass
     5.  [expanded-generic-constr-by-self]

374. A particular pair of classes which each have two formal generic
     parameters and which each have a constraint on one of the
     parameters which is a generic derivation of the other class
     causes silent termination of the compiler after pass 5.
     [generic-constraint-cycle]

375. An effective explicit creation type which inherits from a generic
     deferred class causes termination of the compiler during pass 2.
     Actually, the parent class does not have to be generic; the
     creation procedure invoked in the creation instruction just needs
     to be absent in the parent class. [explicit-create-def-gen-parent]

376. A class with header `class WEASEL [G, H -> WEASEL [G, G]]' causes
     silent termination of the compiler during pass 5.
     [formal-generic-in-constraint]

377. A generic class has a constraint `-> TEST2 [STRING]' on its
     formal generic parameter, which is invalid since TEST2 is indeed
     a generic class but its formal generic parameter is constrained
     by `LIST [STRING]'.  The compiler correctly reports a VTCG
     violation, but dies while trying to report the name of the class
     on which the error occurred.  [vtcg-expanded-generic]

378. Finalizing a system whose root creation procedure is an inherited
     (rather than immediate) feature produces C code which won't link.
     It does not matter whether the Ace includes any `visible' clauses
     for the involved classes.  Even turning off dead_code_removal
     does not help.  [finalize-inh-root-creation-proc]

379. A system has an Ace which specifies a nonexistent cluster path.
     The compiler correctly reports a VD01 error.  But when `q' is
     typed to terminate `es3', it says "System recompiled" (which is
     definitely not the case). [ace-error-quit-sys-recompiled]

380. Running `es3 -loop' and melting (`I' then `C') works fine.  If
     there is a compilation error, `Q' correctly returns you to the
     `Command =>' prompt of `es3 -loop'.  However, a subsequent
     attempt to compile via `C' causes termination of es3 with the
     message "You have lost your licence". [es3-loop-compile-quit-compile]

381. Under certain (unreproducible) circumstances after a number of
     changes, a system has a VOMB(5) error on one of its classes.  The
     compiler correctly detects and reports the error, but says "No
     help available for this error".  This bug has been retired because
     it is unreproducible.  [no-help-for-vomb5]

382. Incorrect C code is generated for a routine which passes the
     address of a procedure to an external routine.  When the system
     is executed, it dies with an illegal instruction.  This was never
     really a bug; my C routine should have declared the argument
     which accepted the procedure address as being of type POINTER
     rather than ANY.  Of course, the compiler should have caught my
     error but did not.  [wrong-procedure-address-passed]

----------------------------------------------------------------------

383. An external routine with a non-existent Language_name is accepted
     by the compiler without complaint.  No constraint prohibiting
     this but compiler shouldn't accept it.  ETL page 402.
     [bad-external-language]

384. An argument of the Address form is of type POINTER.  But when the
     corresponding formal argument is declared to be of type POINTER,
     the compiler rejects the class as violating constraint VUAR(2).
     ETL page 405.  [addr-args-not-pointer]

385. After initial compilation where the system is finalized, the
     types of two local variables are changed so that they no longer
     involve expanded types and the system is finalized again.  The
     resulting C code compiles, but will not link due to an undefined
     symbol.  [finalize-remove-expanded-type]

386. A generic class with formal generic parameter `G' has a routine
     `foo' with a local entity of type `G'.  The body of the routine
     calls `generator' on this local.  Another class inherits from the
     generic class and provides an expanded type as actual generic
     parameter.  When the system is executed, it correctly prints the
     local's generating class, but then dies with a panic if the system
     was melted.  Frozen code works fine. [generic-local-expanded-actual]

387. A class has two functions which each have the same expanded type
     as return type.  One of the functions just lets Result get set by
     the default initializations applied to locals, while the other
     one does an explicit creation with Result as target.  The two
     functions return results which should be equal but are not, but
     only if the system is finalized.  [finalize-expanded-not-equal]

388. A system has class with a manifest array of STRINGs, one of whose
     elements is an expression which is a function call with an
     argument that involves another feature call.  When the system is
     finalized, the generated C code will not compile.
     [finalize-manifest-array-call]

389. Finalizing a particular system with a function call whose
     argument is a manifest array produces C code which compiles fine.
     But when the system is executed, a segmentation fault occurs.  If
     the system is instead melted or frozen, system execution works as
     expected.  This appears to be a code generator problem.
     [finalize-pass-wrong-argument]

390. A system has one cluster, initially with only the root class in
     it.  Each class the compiler says is missing (via a VD23 error or
     a VTCT error) is copied into the cluster's directory.  The result
     is a set of classes which, when compiled from scratch, cause the
     compiler to report a VEEN error on `default' in feature
     `is_hashable' in class HASHABLE.  [veen-on-hashable-default]

391. A root class has a single formal generic parameter constrained by
     `-> TEST1 [STRING]' where TEST1 is a generic class which is also
     expanded.  The compiler correctly reports a VSRC(1) error, but
     prints "Exception occurred while displaying error message" when
     trying to display the name and formal generics of the root class.
     [root-expanded-generic-constraint]

392. A system has two classes of the same name, in different clusters.
     The compiler correctly detects the VSCN error, but the name
     reported for the second file with the same class is incorrect.
     It appears to be the name of the class which occurs twice rather
     than the name of the second file containing the repeated class.
     [vscn-second-file-wrong]

393. A system with a syntax error is compiled.  When the error is
     reported, the Ace file is deleted or renamed.  When compilation
     is resumed, the compiler dies with exception tag "No such file or
     directory".  [delete-ace-resume-compile]
   
394. A system with a 1000 class deep client dependency chain compiles
     fine.  But when the root class attribute declaration which links
     it to the client dependency chain is cut (thereby removing all
     client dependencies) and the system is recompiled, the compiler
     dies with a run-time panic.  [cut-long-client-chain]

395. A class has an external procedure with no formal arguments and a
     call to this procedure, but the C code expects a single argument.
     After initial compilation where the system is frozen, a formal
     argument of the correct type is added to the procedure and an
     actual argument is added to the call.  When changes are melted,
     system execution produces the wrong output.
     [external-procedure-add-argument]
   
396. After initial compilation, the order of two attributes (which are
     each of an expanded type) is switched.  After recompilation,
     system execution should initialize the expanded attributes in a
     different order but it does not.  The initial compilation and
     recompilation can each be either a melt or a freeze - the problem
     occurs regardless.  This one was retired, since the order of
     evaluation of expanded attributes (if a class has more than one)
     is not specified in the language definition.
     [switch-expanded-attributes]

397. After initial compilation, a new attribute is added to a parent
     of a class containing a `strip' expression.  After recompilation,
     system execution produces the wrong output (different than the
     output of a system compiled from scratch).  The initial
     compilation and recompilation can each be either a melt or a
     freeze - the problem occurs regardless.  This one was retired,
     since the order of evaluation of expanded attributes (if a class
     has more than one) is not specified in the language definition.
     [add-attribute-wrong-strip]

398. After initial compilation, the order of two parent classes in an
     inheritance clause is switched.  After recompilation, alternate
     postconditions of an inherited routine should be evaluated in a
     different order, but they are not.  Same problem for
     preconditions.  This one was retired, since the order of
     evaluation of expanded attributes (if a class has more than one)
     is not specified in the language definition.
     [switch-parents-assertion-order]

399. A class with a function which takes 3000 arguments of type
     INTEGER and one call to that function causes the compiler to die
     with a PANIC.  [function-with-many-args]

400. A long chain of anchored feature declarations (200 long on my
     machine) causes the compiler to die with a run-time panic on pass
     4 of the class with the declarations.  [long-anchored-decl-chain]

401. A boolean expression which has 200 occurrences of an `and' or
     `or' operator causes the compiler to die with a panic during pass
     3 on the enclosing class.  [heavy-anded-bool-panic]

403. A class with an assignment of a 20000 element manifest array of
     strings to an attribute of type ARRAY [STRING] causes termination
     of the compiler during pass 4 on the class, but only under very
     particular circumstances.  Innocuous changes cause the system to
     be compiled correctly.  [no-precomp-big-manifest-array]

404. A class calls a function whose return type is an expanded type.
     The expanded class on which the expanded type is based has a
     creation procedure.  If the system is finalized with dead code
     removal on, the generated C code will compile but won't link.
     This appears to be a dead code removal problem.
     [expanded-dead-code-removal]

405. Finalizing a system with an expanded class which has an inherited
     (rather than immediate) creation procedure produces C code which
     won't link.  Turning off dead_code_removal does not help.
     [finalize-inh-exp-creation-proc]

406. A class which inherits from INTEGER and evaluates the expression
    `Current \\ 29' compiles fine but generates C code which won't
    compile.  If the code is instead melted, the result is a panic
    with the message "operational stack botched".  Compiler now
    reports a VWOE error.  [inherit-integer-call-remainder]

407. A generic class has a routine with a local whose type is the
     formal generic parameter.  Another class inherits from the
     generic class and provides an expanded type as actual generic
     parameter, where the expanded type's base class has a creation
     procedure.  If the system is finalized with dead code removal on,
     the generated C code will compile but won't link.
     [expanded-generic-dead-code]

408. The instructions `c := '1'; print (c.is_digit)' where `c' is of
     type CHARACTER print the wrong result.  If `io.putbool' is used
     instead of `print' the output is correct. [print-char-dot-is-digit]

409. When a class has two or more parents, the invariant of the heir
     class is supposed to start with the invariants of all parents in
     the order of appearance of the parent clauses in the heir.  But
     when the system is executed, the invariants are monitored in
     reverse order of the parent clauses.
     [parent-invariants-reverse-order]

410. A class repeatedly creates a LINKED_LIST [STRING] whose number of
     elements is guided by a random number generator and then deep
     clones this list several times.  The system compiles fine, but
     dies with a run-time panic when executed.  [deep-clone-panic]

411. A class calls a recursive routine which creates 255 strings, all
     fairly short.  If the depth of recursion is 22 or greater, a
     run-time panic occurs when the system is executed.  If the
     routine only creates 200 strings, then the system executes
     correctly up to a recursion depth of at least 1000.
     [many-locals-deep-recursion]

412. A class has a routine which repeatedly applies the `strip'
     operator to the current object and puts the resulting array in a
     local variable.  The class has 4 INTEGER attributes.  Executing
     the system results in a run-time panic.  Reducing the number of
     attributes to 3 or turning off garbage collection allows the
     system to execute correctly for a huge number of iterations.
     [keep-on-stripping]

413. A class calls a recursive routine which takes a substring of a
     string.  If the recursion is fairly deep (approximately 350) and
     garbage collection is enabled, a run-time panic occurs when the
     system is executed.  [few-locals-deep-recursion]

415. A class with an attribute of type BIT 1000 has a routine which
     calls `out'.  The system compiles fine, but system execution
     terminates with an "out of memory" exception.
     [out-of-memory-on-out]

416. The descriptive text in the Title bar in a Feature Tool is
     shortened too much for the Implementers, Ancestor Versions and
     Descendant Versions formats (and possibly others).  Drag `equal'
     from GENERAL into a Feature Tool.  Select one of these formats
     and look at Title bar.  Even if there is more room very little of
     the title is shown. [ebench-feature-short-titles]

417. A system is frozen with no assertions monitored.  Then a stop
     point is placed on `count' in class SPECIAL.  Clicking the Step
     button causes a stop on the first instruction of `count'.  But
     subsequent clicks never cause a stop after the single instruction
     in `count'.  [debugger-step-skip-stop-point]
   
418. A system is frozen with no assertions monitored.  Then execution
     is single-stepped past the first instruction, which creates a
     string.  If the created string is long (greater than roughly 1950
     characters on my machine), nothing is displayed when the string
     is dragged into an Execution Object Tool.
     [debugger-long-string-blank]
   
419. The `es3 -help' option output is missing a few vertical bars
     indicating alternatives (end of lines 4 and 5).  [es3-help-option]

420. The output of `es3 -help' is a lot more readable if each "|" is
     replaced by " | ".  [es3-help-more-spaces]

421. The option `-file File' is accepted and even seems to be validity
     checked, but the output of compilation or browsing operations
     does not go into the file.  Instead, an empty file is created.
     [es3-file-option]

422. Executing a trivial system from ebench with the Run button and
     then clicking on the End Run button immediately after clicking on
     the Run button works fine.  But repeating this sequence over and
     over eventually causes ebench to be killed, usually within 10-15
     repetitions of the sequence.  [repeatedly-run-end-run]
    
423. The descriptive text in the Title bar in a Class or Feature Tool
     is not updated when the class or feature occupying the tool is
     modified, system is recompiled and then the tool is synchronized
     by clicking on its upper left button.  [ebench-titles-not-synced]

424. Dragging a use of a formal generic parameter as a type into the
     class hole of a Feature Tool terminates ebench with a
     segmentation fault.  [ebench-generic-in-feat-tool]

425. The flat form of a class with an entity `x: expanded TEST1',
     where TEST1 is not an expanded class, has the feature `x: TEST1'.
     The fact that `x' is of an expanded type is omitted.  This seems
     like important information since the semantics of copying,
     argument passing etc are different for expanded types.
     [expanded-type-bad-flat]

426. Routine `forth' in UNIX_FILE skips every other character.
     [unix-file-forth-skip-chars]

427. Calling routine `start' of UNIX_FILE (from class FILE) on an open
     file which has zero characters causes violation of precondition
     `is_readable' of `readchar'.  [unix-file-start-precond-error]

428. When using the debugger in ebench, if I create an Execution
     Object tool on the root object it works fine.  But if I step
     repeatedly until an object referenced by this root object (an
     ARRAY [STRING]) is no longer referenced and gets garbage
     collected and then try to examine that referenced object from the
     old Execution Object tool, ebench dies with an exception trace.
     [examine-collected-object]
    
----------------------------------------------------------------------

429. A declaration of an external routine which uses "c" for the
     language name instead of "C" should be accepted, but is not.
     [external-lower-case-c-lang]

430. A class with an external feature which is a procedure and which
     includes a signature that specifies a return type should be
     called a syntax error (or validity error), but the compiler
     accepts it.  When the system is frozen, the generated C code
     won't compile since a void function cannot return a value.
     [external-proc-sig-return-type]

431. An external routine which does not take any arguments is declared
     as a macro and includes the signature `(EIF_INTEGER)'.  The
     compiler detects an error during degree 3, but prints "exception
     occurred while displaying error message".  Repeatedly resuming
     the compilation causes compiler termination after about 40
     attempts.  [external-arg-signature-mismatch]
    
432. After initial compilation where the system is frozen, an external
     routine which has a Special_external_declaration, Signature and
     Include_files has its External part simplified to just `external
     "C"'.  When the system is refrozen, the C code incorrectly uses
     the old information about the external routine (prior to the
     change).  Same problem with finalizing and re-finalizing code.
     [remove-part-of-external-decl]

433. A class assigns a manifest array with elements which are integer
     constants to a local of type ARRAY [DOUBLE] and prints one of
     these elements.  Executing the system yields the wrong results
     when the class is melted, but not when it is frozen.
     [manifest-array-int-double]

434. A class repeatedly allocates a string whose length is determined
     by a random number generator and fills the string with blanks.
     When the system is frozen, system execution quickly ends with a
     panic.  [random-string-blank-panic]

435. A class repeatedly allocates an array whose length is determined
     by a random number generator.  When the system is frozen and then
     executed, it goes into an infinite loop.
     [random-array-alloc-loop]

437. A very long comment causes the compiler to terminate
     during pass 5 on the class with the comment. [long-comment]

438. A long stretch of consecutive white space (6000 characters)
     causes the compiler to terminate during pass 5 on the class with
     the white space. [long-white-space]

439. An external routine which refers to a DLL16 or DLL32 and appears
     to be valid causes the compiler to terminate during degree 5
     (presumably only on a non-Windows platform).
     [non-windows-dll-external]

440. An external function which takes one argument is declared as a
     macro, but the signature omits the argument and supplies only the
     return type `:EIF_INTEGER'.  The compiler accepts the class, but
     terminates during degree -2.  [external-omit-signature-args]

441. An external routine which takes two arguments includes the
     signature `(long, long, long)' causes the compiler to die on
     degree 3 on the class.  [too-many-signature-arguments]

442. Start ebench and melt a system.  Start a Feature Tool on a feature.
     Drag a class into this Feature Tool which has no version of the
     feature.  Get message such as:
		No version of feature make
   		for class CHILD
     Click on class name CHILD.  Highlights all of class name, but also
     highlights to end of line after class name.  [ebench-highlight-too-much]

443. Under certain unreproducible circumstances, get warning messages:
	Warning: 
	    Name: vbar
	    Class: XmScrollBar
	    The specified scrollbar value is less than the minimum
	    scrollbar value.
     Retired because not reproducible.  [ebench-vbar-scrollbar-warning]

444. Start ebench.  Click on Melt.  Select file `Ace' in current
     directory.  Click on System.  Click on Open in System Tool.
     Select file `fake' in current directory, where `fake' contains a
     single line with "weasel".  Click on Melt.  When syntax error in
     Ace is reported, click on Open in System Tool and select file
     `Ace' again.  Click on Melt.  Ebench dies with segmentation
     fault.  [ebench-switch-to-bad-ace]

445. Start ebench.  Click on System.  Select file `Ace' in current
     directory.  Click on Save As in System Tool.  Click in Selection
     box near bottom of "Select a file" popup and add "/fake" to end
     of existing selection (which ends with `Ace').  Click on OK.
     Ebench dies with "No such file or directory" exception.
     [ebench-save-to-ace-subdir]

446. Setting the tabulation step in the System Tool has no effect on
     the Clusters format.  Since it does affect the Text, Modified
     Classes and Indexing Clauses formats this may be a bug rather
     than a feature.  [ebench-cluster-format-no-tabs]

447. Setting the tabulation step in the Class Tool only affects the
     Text, Clickable, Flat, Short and Flatshort formats.  It does not
     have any effect on any of the other formats, which is most
     annoying.  Similarly, the tabulation step has no effect on the
     Callers format in a Feature Tool (in this case, it seems to
     affect all the other formats).  [ebench-tab-step-no-effect]

448. After switching Ace files by using Open button in the System
     tool, one cannot edit the new Ace file by clicking on the Shell
     button.  The Shell button has no effect.  To reproduce: Start
     ebench.  Click on System button.  Select file Ace in current
     directory.  Click on Open button in System tool.  Select a
     different file in current directory.  Click on Shell button.  No
     editor comes up.  [ebench-switch-ace-no-shell]

449. Under some circumstances, the slice bounds in an object tool
     cease to be effective.  [ebench-slice-bounds-stuck]

450. When ebench pauses after displaying a syntax or validity error,
     dragging an explanation, system or class stone into the Stop
     Points hole brings up a message that says one cannot use the
     debugging facilities since the current version of the system has
     not been successfully compiled.  [ebench-pause-stop-on-class]

451. When ebench pauses after displaying a syntax or validity error,
     control left-clicking on any of the four debugger mode buttons in
     the lower left corner of the Project tool causes a small window
     to flash on top of the Project tool and then disappear.
     [ebench-flashing-window]

452. Making an existing tool (System, Feature, Class, Explanation,
     Object) minimum width causes warning messages about `hbar' for
     class XmScrollBar about slider sizing being less than one and
     scrollbar value being too big.  These messages are displayed in
     the window from which ebench was started.  [ebench-resize-tool-narrow]

453. Under certain unreproducible circumstances, ebench dies with a
     segmentation fault.  The problem may be caused by moving the mouse
     while a Feature tool is being created.  Retired because not
     reproducible.  [ebench-create-tool-move]

454. Repeatedly creating 5 Class tools targeted to the root class and
     then clicking on the Exit button of each such tool causes ebench
     to rapidly use more and more memory.  [ebench-gets-bigger]

455. Start ebench.  Click on OK.  Click on Melt.  Put mouse over
     Choose button in Warning popup.  Hold down Return key for about
     5-10 seconds.  The Project window is still visible, but will not
     respond.  Both the Warning popup and Select A File popup are gone
     and are nowhere to be found.  [ebench-hold-down-return]

456. Start ebench.  Click on OK.  Click on Melt.  Select Ace file and
     compile system.  Replace contents of class TEST with contents of
     Ace file.  Click on Melt.  Start class tool on class TEST.
     Select Clickable, Flat, Short or Flatshort format.  Class tool
     displays error message "Syntax error at line 2 in
     Cluster_properties "Use" file". [clickable-format-wrong-contents]

457. Start ebench.  Click on OK.  Click on Melt.  Select Ace file and
     compile system.  Bring up class tool on class ACTIVE.  Click on
     Explanation to bring up an Explanation tool.  Drag the occurrence
     of formal generic parameter G in `BAG [G]' in inheritance clause
     of class ACTIVE into middle of Explanation tool.  Ebench dies.
     [drop-generic-stone-in-explain]

458. Dragging a stop point into an Explanation tool causes the text
     window of the tool to display "No help available for this
     element", which is reasonable.  But the title bar of the
     Explanation window is blanked instead of displaying the identity
     of the entity for which the user requested an explanation.
     [stop-point-no-explain-title]

459. Start ebench and bring up a tool of each type (Explanation,
     System, Class, Feature, Object).  Iconize Project tool.  All
     other tools are iconized as well inside it (nice).  De-iconize
     Project tool.  Now iconize individual tools one by one, iconizing
     the Project tool last.  De-iconize the Project tool.  All other
     tools are also de-iconized *except* the System tool.
     [ebench-deiconize-project-tool]

460. Start ebench and bring up a Feature tool.  Click in first text
     field and type `make'.  Hit tab to move to second text field (for
     class name) and just hit <return>.  The warning popup comes up
     and says "Please specify a feature".  It should say "Please
     specify a class".  [ebench-empty-class-name]

461. Start ebench and melt a system.  Start two Feature tools on a
     routine which has some instructions in its body.  In one of these
     tools, select Stop Points format and put a stop point on one of
     the instructions.  Switch back to Text format in this same tool.
     The tool used to set the stop point has "(stop)" in its title
     bar.  The other tool should also have "(stop)" in its title bar
     but does not.  Clicking on the Feature button in the upper left
     corner of the tool causes the title bar to be updated to include
     "(stop)".  [ebench-title-bar-no-stop]

462. Start ebench and melt a system.  Bring up System tool.  Click in
     the text area and add some blank lines at the beginning of the
     Ace file, then click on Save.  Right click on the name of the
     root class.  The wrong area is highlighted.  If I perform a
     similar sequence in a Class tool, right clicking is disabled
     because the text has been modified.  The System tool should
     behave the same way.  [ebench-ace-bad-highlight]

463. Running `es3 -loop' and entering `S' then `A' causes es3 to
     terminate with an error.  [es3-loop-show-ace]

464. The PostScript filter (file
     $EIFFEL3/bench/filters/PostScript.fil) produces output which does
     not work on an HP Laserjet 4si Postscript printer.  The
     Postscript commands are printed instead of the class text
     suitably formatted.  Removing the third character (which is a
     space character) of the file that is produced results in a file
     which prints properly.  [ebench-bad-postscript-filter]

465. Clicking on Save As in a Class tool or System tool and saving the
     contents to another file affects the tool so that nothing is
     clickable.  Switching to another format or resynchronizing by
     clicking on the upper left button fixes the problem.
     [ebench-save-as-no-click]

466. Start ebench and melt system with a class having a long line (250
     characters).  Start class tool on the class.  Place mouse in the
     slider part of the horizontal scroll bar area a little to the
     left of the right arrow.  Click repeatedly with left mouse button
     and watch text as slider indicating position moves to the right.
     Window shows far right extent of text when slider is
     approximately in the middle of the scroll bar area.
     [ebench-bad-scroll-bar-position]

467. Dragging a class which is not in the system from the Clusters
     format of the System tool into a Class tool which is in Clickable
     format does not retarget the Class tool.  If the Class tool is in
     any format other than Clickable, then it is retargeted to the new
     class and is put in Text format.  [retarget-clickable-class-tool]

468. Start ebench.  Melt a system.  Bring up empty Class tool.  Enter
     class name FOO in its text field.  Get New Class popup with
     cluster `<cluster name>'.  Click on Create.  Get "Invalid cluster
     name" warning popup.  Click in warning popup window.  It should
     go away but does not.  Click on Cancel.  Now clicking in warning
     popup makes it disappear.  [click-wont-dismiss-warning]

469. Start ebench.  Melt a system.  Bring up empty Class tool.  Enter
     class name A in its text field.  Get New Class popup.  Change
     cluster to `root_cluster' (match a cluster name in Ace).  Click
     on Create.  Now enter class name WEASEL in Class tool text field.
     New Class popup shows `ss name: WEAS' instead of `Class name:
     WEASEL'.  The size of the New Class popup seems to be fixed the
     first time it is needed.  [ebench-trunc-new-class-name]

470. Start ebench.  Select a particular long and syntactically illegal
     Ace file.  Melt.  Bring up System tool and open new Ace file
     which is a short and valid Ace file.  Melt.  Ebench dies.
     [ebench-long-ace-then-short]

471. Start ebench.  Melt a system.  Control-left-click on the Run
     button.  System is melted, but is then run twice instead of once.
     [ebench-melt-run-twice]

472. Doing a control-click on the Run button while system execution is
     in progress but is stopped at a stop point causes a melt and run
     but in the wrong order.  First, system execution is resumed as
     though one had just clicked on Run.  Then the popup which asks
     whether to stop current system execution appears.  If one says
     "yes", the system is melted but is not executed after the melt.
     [ebench-executing-melt-run]

473. If execution of a system is stopped at a stop point, adding a new
     external to a class and clicking on Melt or Freeze freezes the
     system.  Ebench claims that it is launching C compilations in the
     background, but it does not seem to do so.  Soon, a file named
     `core' appears in the project directory.
     [ebench-omit-c-compilations]

474. After initial compilation, the Ace file is deleted and the system
     is melted again.  Ebench reports a VD22 error (unable to open
     file) on the Ace file, which is quite reasonable.  But it also
     displays "System recompiled" after the error.
     [ebench-delete-Ace]

475. Start ebench and freeze a particular system.  Then single-step
     execution single-stepped past the first instruction, which
     creates a string.  Drag the string object into an Object Tool.
     Right-click on Slice button.  Ebench dies if string is long
     (approximately 2000 characters).  [debugger-long-string-slice]
   
476. Putting a stop point on `make_area' in TO_SPECIAL results
     modifies the behavior of a simple system, causing it to end with
     a segmentation fault.  Trying to examine the object in which the
     system stopped terminates EiffelBench with a segmentation fault.
     [debugger-stop-on-make-area]
   
477. Miscellaneous comments about filters:
	A. The symbol `..' does not appear in `template.fil' in
	   the Symbols section, but it should
	B. A feature declaration seems to trigger substitution
	   of the surrounding text twice instead of once.
	   (Cannot check this one right now since EIF_FILTER_PATH
	   doesn't work).
     [ebench-filter-comments]

478. The first time a Filter Selection window is brought up by
     right-clicking on the Filter button in a Class tool, the command
     to be executed cannot be changed.  Clicking on the text window
     and typing into it simply has no effect.  After clicking on
     Execute or Cancel (both of which cause the Filter Selection
     window to disappear) and bringing up the window again, the
     command to be executed can be modified.
     [ebench-filter-command-stuck]

479. A system allocates and fills an array of strings and then checks
     to see that they have the expected value.  System execution ends
     with a run-time panic, but only if the system is finalized and
     array_optimization is on.  [finalize-array-optimization]

480. A pattern of object allocation and resizing guided by a pair of
     random number generators and a pair of size limits compiles fine
     when it is frozen, but dies with a run-time panic when executed
     with certain large values.  Many other values do not cause a
     run-time panic.  (I corrected the class involved to use
     `make_filled' instead of `make' on the ARRAYED_LIST.  It now
     passes).  [random-memory-alloc-panic]
    
481. There is a type in the error message for a VD41 error.  It reads
     "What to do: make sure that the directory specified in the Ace
     file does indeed contains a precompiled system."  Word `contains'
     should be `contain'.

482. A class with an external routine which is declared as a macro and
     which has either a signature or an include specified causes
     refreezing of the system whenever it is modified.  The refreezing
     occurs even if the the change involves only white space or even
     if the file is just "touched".  [ext-touch-file-refreeze]

483. Using `es3 -precompile' with an Ace which specifies a precompiled
     library should elicit a validity error, but does not.  When
     compilation completes, running finish_freezing results in an
     error due to the fact that file `Makefile.SH' does not exist.
     [precompile-with-precompiled-lib]

484. A system has a root class whose creation procedure takes an
     argument (of type ARRAY [STRING].  When the system is executed
     (melted or frozen) with a command line with 100 arguments, each
     of which is 1000 characters long, a segmentation fault occurs
     during the root object's creation.  If the system is frozen and
     the C code is modified to turn off garbage collection, then
     executing the system with 800 arguments works fine.  Increasing
     the number of argument to about 400 (1000 chars long each) causes
     a panic now.  (Now it works even with 800 arguments).
     [many-long-cmd-line-args]

485. A simple system which uses CECIL and appears to be correct
     compiles and links fine.  But when the system is executed, a
     run-time panic occurs.  [cecil-panic]

486. A system which calls malloc, free and str_blank and also calls
     routines allocate_tiny, full_collect and full_coalesce in class
     MEMORY compiles fine.  Executing the system results in an exception
     trace while garbage collecting.  [malloc-free-collect-coalesce]

487. A system whose root class has a very long creation procedure
     compiles and executes correctly, but `es3' does not do the soft
     link to the precompiled driver.  [long-feature-skip-soft-link]

488. Precompiling a library via `es3 -precompile -ace
     $EIFFEL3/precomp/spec/$PLATFORM/base/Ace' generates a file
     `Makefile.SH' which references the obsolete file name `.UPDT'
     instead of the new name `melted.eif'. [precompile-makefile-refs-updt]

489. A class tries to create a very large string (50 MB).  Under
     certain very particular circumstances (system finalized,
     exception stack managed, garbage collection on during string
     creation attempt) system execution ends with a run-time panic
     while trying to print the "out of memory" exception trace.
     [out-of-memory-panic]

490. An assignment whose source is an address expression `$x' (which
     is of type pointer) and whose target is a reference type other
     than ANY should be rejected, since POINTER does not conform to
     any reference type besides ANY.  But the compiler accepts the
     assignment.  ETL page 405.  [pointer-ref-conformance]

491. One cannot put a stop point on any of the routines defined
     directly in HASH_TABLE (e.g., `add_space' or `internal_search')
     when using a precompiled cluster and melting a trivial system.
     (Actually, one can put a stop on these routines if
     there is a generic derivation of HASH_TABLE in the system).
     [debugger-no-hash-stop]
   
----------------------------------------------------------------------

492. The class name in the comment at the end of the class (e.g., `--
     class TEST') should be clickable in the Clickable Flat, Short and
     Flatshort formats, but it is not.  [ebench-class-end-noclick]

493. Start ebench.  Click on OK.  Click on Melt.  Select Ace file and
     compile system.  Bring up class tool on class GENERAL.  Drag the
     occurrence of `other' in the single instruction in the body of
     routine `conforms_to' in GENERAL into the Stop Points hole in
     project window.  Ebench dies.  Note that dragging this same
     entity into an Explanation tool also kills ebench.  Can't check
     this one out now because Text format of GENERAL kills ebench.
     [put-stop-on-argument]

494. Right-clicking on the type of feature `void' in class GENERAL
     (this type is NONE) and dragging it into an Explanation tool
     causes ebench to die with an exception trace.  Cannot check this
     one since class tool on GENERAL kills ebench.
     [ebench-explain-class-none]

495. Taking the flat form of a particular class in a simple system
     kills ebench.  The problem does not occur if `es3 -flat' is used
     instead.  Originally encountered while browsing and taking the
     flat form of the EiffelVision class DASH in ebench.
     [ebench-flat-form-of-dash]

496. Starting ebench and melting a particular class with two routines
     which each contain 3500 routine calls works fine.  But starting a
     Class tool on the class and selecting the Clickable, Flat, Short
     or Flat/Short format kills ebench.  If I first choose some other
     formats, such as ancestors etc., then Clickable and friends work
     just fine.  I suspect this may be a GC problem.  (Now ebench
     seems to go into an infinite loop). [ebench-many-calls-flat-form]

497. Starting a Class tool and trying to look at the Text format of a
     simple class kills ebench.  Originally encountered while trying
     to look at the Text format of class STRING.
     [ebench-text-form-of-string]

498. Start ebench.  Add to the text in the Selection box one parent
     directory component `..' for every element in the path name
     separated by slashes and then one more `..' component.  For
     example, if Selection box has `/dragon/test4/subdir', then add
     `../../../..' to end of Selection box text.  Click on OK.  Ebench
     incorrectly accepts the selection.  Click on Melt and select an
     Ace file.  Ebench dies with "no such file or directory".
     [ebench-too-many-parent-dirs]

499. Start ebench.  Clear text from Selection box and type `/'.
     Ebench responds with a popup which says "Directory: does not
     exist".  But directory `/' does exist.  Also, the message has no
     directory name in it (the same response as if I clear the
     selection box completely and click on OK).  If I instead type
     `/..' into the Selection box, ebench says that the project in /..
     cannot be retrieved.  This seems wrong because there is no
     project in this directory (which is the same directory as just
     `/').  [ebench-weird-project-dirs]

500. Start ebench.  Clear text from Selection box and type
     `/etc/spool/Comp_Color'.  Click on OK.  Ebench says "Project in
     /etc/spool/Comp_Color Cannot be retrieved.  Check permissions and
     please try again."  But there is no project in this directory
     (i.e., no EIFGENs/test subdirectory in it).  Even worse, is that if I
     try to select this directory as the project directory twice more
     via the above procedure, ebench accepts it on the third try.  A
     subsequent Melt kills ebench since the directory is not writable.
     [ebench-unwritable-dir-third-try]

501. Start ebench.  Melt trivial system.  Repeatedly do the following:
     left-click on Run and then immediately control-left click 5 times
     very fast on End Run.  Ebench soon dies (actually, it is killed).
     [ebench-run-quick-end-run]

502. Start ebench.  Melt trivial system.  Start Feature tool on `make'
     from STRING.  Click on Text format, then on Callers format.
     Output fine.  Click on Flat or Stop Points format, then on
     Callers format.  First line of output is indented one tab stop,
     but should not be.  [ebench-feature-callers-after-flat]

503. Setting the tabulation step in an Object Tool which is in
     Attributes format has no effect (the attribute names should be
     indented one tab step).  In "Once functions" format, the once
     function names are also not indented one tab step, but the "Not
     yet called" is indented one tab step if present.
     [ebench-object-tool-tab-step]

504. A particular sequence of melting, setting stop points and running
     a system causes a "byte code botched" run-time panic which
     terminates ebench.  [debugger-byte-code-botched]
   
505. A simple system is melted and stop points are put on the first
     instruction of `copy' and `remake' from class STRING.  The melt
     operation and placement of stop points is repeated twice more.
     When the system is then executed, the result is a segmentation
     fault.  [debugger-melt-stop-three-times]
   
506. A simple system is repeatedly melted and then a stop point is put
     on `copy' from class STRING.  When the system is executed, a
     segmentation fault results (previously reported).  If the system
     is melted immediately at that point and the stop point is added
     back in, executing the system results in a stop but no call stack
     is displayed.  Another melt at this point and replacement of the
     stock and re-execution results in an "unknown entity type" panic.
     [debugger-melt-stop-repeat]
   
507. A particular sequence of compilations and class browsing in
     ebench usually causes a "free-list inconsistency" panic.
     [ebench-free-list-inconsistency]

508. A simpler sequence of compilations and class browsing in ebench
     which causes a panic.  (Now, this one doesn't cause ebench to
     die, but it insists on checking the old root class WEASEL and
     finding a syntax error even after the root class is changed to
     TEST which does not depend on WEASEL).  [ebench-simpler-panic]

509. A system compiles correctly.  Then most of the class header of
     one of the (generic) classes is deleted, except for the word
     class.  When the system is recompiled, the compiler detects the
     VTCT error but terminates silently in the middle of reporting it.
     [delete-generic-class-header]

510. After initial compilation, a feature which is the target of an
     assignment is changed from a variable attribute of type TEST1 to
     a constant attribute of type STRING.  The compiler does not
     detect the VJAW error.  [vjaw-sneak]

511. A class has an assignment where the target entity is of an
     expanded type and the source entity is of an expanded type which
     inherits (indirectly) from the target type base class, but adds
     some attributes.  After initial compilation where the system is
     melted, the type of the source entity is changed to another
     expanded type which is a parent of the original source entity
     type and the system is frozen.  System execution then ends with a
     segmentation fault.  [chg-expanded-source-freeze]
   
512. A class has a routine with an assignment whose source entity is
     an an attribute of the class.  After initial compilation where
     the system is melted, the type of the source entity is changed to
     another type which is a parent of the original source entity type
     and the system is frozen.  System execution then ends with a
     segmentation fault.  [melt-chg-attr-type-freeze]
   
513. A routine with the instruction `io.put_double (5 / 2)' gives
     incorrect output, but only when melted.  The instruction
     `io.put_real (5 / 2)' gives correct output whether melted or
     frozen.  [put-double-five-over-two]

514. A system allocates an ARRAYED_LIST each of whose elements is an
     ARRAYED_LIST [STRING].  It then randomly assigns into the main
     list a random-length list of strings, each of whose STRING
     elements is a random length.  System execution ends with a
     run-time panic, but only if the system is finalized and
     array_optimization is on.  [finalize-random-arrayed-list]

515. A class has a routine which repeatedly creates a manifest array
     of 80 strings, each of whose elements is "w".  The system
     compiles fine when frozen, but execution soon ends with a
     run-time panic.  [manifest-array-of-tiny-strings]

516. An Ace which includes the option `inlining_size ("47_weasels")'
     should provoke a VD15 error, but the compiler accepts it.
     [inlining-size-non-integer]

517. A known sequence of changes which involves changing the name of a
     class to elicit a VTCT error and changing the actual generic
     parameter in a type in a generic constraint to elicit a VTCG
     error causes the compiler to terminate with a segmentation fault
     during degree 5.  [vtct-vtcg-die-degree-5]
   
518. A system has a class which creates a manifest array of strings
     with 25000 elements.  The system compiles fine when frozen, but
     when executed it dies with a run-time panic while creating the
     manifest array.  Turning off garbage collection allows the system
     to execute correctly.  [big-manifest-array-of-strings]

519. A class repeatedly creates an instance of type TEST1, where TEST1
     inherits from MEMORY and redefines `dispose' to print (via C
     code) which object is being disposed.  All objects which are dead
     but uncollected at the end of system execution or which are still
     live do not have their `dispose' routine called.
     [uncollected-objects-not-disposed]

----------------------------------------------------------------------

520. A system which prints the character constants `%/1/' through
     `%/255/' compiles fine when frozen, but prints incorrect values
     for characters `%/128/' and above.  Melted code works correctly.
     [frozen-high-bit-characters]
   
521. A class has a debug instruction with Debug_key "weasel".  The Ace
     specifies `debug ("weasel")' in the defaults section.  The
     Compound in the debug instruction is not executed, but only if
     the system is finalized.  It is executed if the Ace specifies
     `debug (yes)'.  [finalize-debug-inst-not-kept]

522. Finalizing the "Hello weasel" program with `assertion (ensure)'
     produces C code which won't compile, but only if a precompiled
     base library is used and `dead_code_removal (no)' is specified in
     the Ace.  [finalize-ensure-keep-dead]

523. A particular function `f' with a rescue clause calls another
     function.  When this called function raises an exception, the
     rescue clause of `f' is not executed and there is no retry.  The
     rescue clause of the caller of `f' is executed instead.  This
     incorrect behavior only occurs if the system is finalized.
     [finalize-skip-rescue-clause]

524. A class has pattern of creation of small STRINGs guided by a
     random number generator.  It also has an attribute which is a
     BIT_REF and it calls deep_clone on the current object after each
     STRING creation.  The system compiles fine with `assertion
     (all)', but violates postcondition `deep_equal' of routine
     `deep_clone' when it is executed.  [deep-clone-not-deep-equal]

526. Finalizing a trivial system with an Ace which specifies both
     `inlining (yes)' and `dead_code_removal (no)' causes the compiler
     to die during degree -5 on class GENERAL.
     [finalize-inline-remove-dead]

527. Finalizing a system with a class which has a call to a deferred
     routine with no descendants causes the compiler to die during
     degree -5 on the class, but only if the Ace specifies `inlining
     (yes).  [finalize-deferred-feature-call]

528. Finalizing a system with an Ace which specifies both
     `dead_code_removal (no)' and `array_optimization (yes)' causes
     the compiler to die while generating `eplug.c'.  Finalizing with
     the -keep option to retain assertions suppresses dead code
     removal so it also causes the compiler to die if array
     optimization is on.  [finalize-array-opt-remove-dead]

529. An option clause in an Ace file specifies that one debug key is
     to be enabled for classes A and B and a second debug key is to be
     enabled only for class A.  When the system is executed, the
     second debug key is monitored for both classes A and B.
     Reversing the order of the debug clauses corrects the problem.
     [lace-debug-key-subset]

530. Finalizing a system with `assertion (all)' specified in the Ace
     produces C code which will not compile.  [finalize-assertion-all]

531. A manifest string which contains the illegal "character" '% '
     (percent followed by space) and which is continued onto the next
     line immediately following the invalid character causes the
     compiler to report the wrong error message ("incomplete string:
     missing final quote" instead of "invalid character code after
     percent").  Note: this was never really a bug, since the string
     is not continued onto the next line (it doesn't end with a % as
     last character on the line).  [percent-space-extended-string]

532. A class which prints the address of a variable attribute compiles
     fine.  But when the system is executed, the value of the
     attribute is printed instead of its address.
     [variable-attr-wrong-address]

533. Start ebench.  Click on System.  Select file `Ace' in current
     directory.  Click on Save As in System Tool.  Click in Selection
     box near bottom of "Select a file" popup.  Get rid of trailing
     `Ace' on existing file name in Selection box and add
     "/www/www/www/www".  Click on OK.  Ebench dies with "No such file
     or directory" exception.  [ebench-save-to-sub-subdir]

534. After an explicit exception is raised via `raise', the call stack
     shown in the project window when stopped at a stop point is
     wrong.  It seems to omit some routines (possibly all but the root
     creation procedure).  In addition, the `@' button in a Feature
     tool does not show the current instruction when it is part of a
     Rescue clause, though single stepping and break points in a
     Rescue clause appear to work correctly.
     [exception-wrong-call-stack]
   
535. Start ebench and melt a system with a particular class.  Change the
     class so that there is a VTAT violation (anchor cycle).  When VTAT
     error is reported, drag the class name into the Project Tool window
     to start a Class Tool.  Select Clickable format or Flat format.
     Ebench dies with segmentation fault.  [ebench-clickable-anchor-cycle]

536. Start ebench and melt a system with a particular class.  Change the
     class so that it inherits from itself, thereby introducing an
     inheritance cycle.  When VHPR error is reported, drag the class
     name into the Project Tool window to start a Class Tool.  Then
     start a Feature Tool on the creation procedure of the class.  Click
     on Implementers button.  Ebench goes into an infinite loop (used to
     die with run-time panic).  [ebench-inherit-cycle-implementers]

537. Start ebench.  Click on OK.  Click on Melt.  Select Ace file and
     compile a trivial system.  Put mouse Class button in upper left
     corner of resulting class tool and click a large and odd number of
     times quickly (e.g., 21).  Immediately move the mouse to some
     random spot.  When ebench gets done processing all of the clicks, a
     draggable class stone appears and is anchored to the chosen random
     spot.  I cannot reproduce this any more.  [ebench-odd-button-clicks]

538. Start ebench and melt a system with a particular class.  Change the
     class so that it has a syntax error and re-melt.  When syntax error
     is reported, drag the class name into the Project Tool window to
     start a Class Tool.  Select Flat format in the new class tool,
     which just displays the syntax error message.  Remove the syntax
     error in the file with an editor (*not* via the class tool) and
     click on Melt.  Ebench dies.  [ebench-remove-syntax-error]

539. Start ebench and melt system.  Start Feature tool on feature
     `internal_search' from HASH_TABLE.  Select Homonyms format.  Right
     click on occurrence of `internal_search' in the resulting window
     contents and drop it in the same window.  The homonyms are computed
     all over again, even though the feature to which the tool was
     retargeted is the same as the original feature.
     [ebench-recompute-homonyms]

540. Start ebench.  Melt a system.  Bring up empty Class tool.  Type
     something into its main text area (middle of window).  Enter class
     name AAA in its text field.  Get New Class popup.  Change cluster
     to `root_cluster' (match a cluster name in Ace) and hit return.
     Get "File has changed" warning.  Click on OK.  New class created
     correctly, but get warning in window from which ebench was started
     ("Warning: XtRemoveGrab asked to remove a widget not on the list").
     [ebench-remove-missing-widget]

541. New windows created in ebench are sometimes off the edge of the
     screen.  New windows which are up against the right side of the
     screen are off screen a little bit.  New windows which are against
     the bottom side of the screen are off enough to hide the Format
     buttons at the bottom of a tool.  To reproduce, click on Class
     button and then quickly move mouse to each corner of screen in turn
     and compare window positions.  Now they are way off the screen,
     but it acts consistently (upper left corner of created tool is
     where mouse is when window gets created).  [ebench-windows-past-edge]

542. Running `es3 -loop', selecting Compile, Melt, Copy template and
     entering a blank when prompted for the file name causes es3 to
     terminate (this has been previously reported).  But it also
     prints the line "Usage: cp [-ip] f1 f2; or: cp [-ipr] f1 ... fn
     d2", which seems undesirable.  [es3-loop-blank-template-filename]

543. Running `es3 -flat xxx' in a directory where there is no EIFGENs/test
     subdirectory (or one with incomplete information because no
     compile has completed yet) causes the compiler to silently
     terminate with no output at all.  This might lead users to think
     that there is no such class or that the output went somewhere
     else.  Es3 really should display some sort of message.
     [es3-flat-no-eifgen-dir]

544. Selecting the flat format in a class tool for a particular
     non-generic class causes ebench to terminate with a segmentation
     fault.  The class inherits from a generic class which has a
     procedure which assigns one local of type G to another, where G
     is the formal generic parameter of the parent class.
     [ebench-flat-inherited-generic]

545. A class creates an object of type ARRAY [BIT 32].  Starting an
     Object Tool on the object after it is created causes ebench to
     hang.  The mouse pointer remains a clock and ebench must be killed
     from the command line.  [debugger-examine-bit-array]
   
======================================================================

546. An External_declaration has a list of include files with more than
     one file in the list.  If the final include file name is missing
     the final `>' or `%"' delimiter and there is no white space around
     the comma separating the last two file names then the class is
     accepted, but should not be.  [include-missing-last-delimiter]

547. After initial compilation, the value of a constant integer
     attribute is changed and the system is recompiled.  System
     execution should print a longer bit string, but it does not.
     (Now, after the first melt system execution does not produce the
     correct output so this is no longer an incrementality problem).
     [chg-integer-const-value]

548. After initial compilation, an inherited feature which is a named
     as a creation procedure in the heir is changed to an attribute or
     a function.  The compiler should report a VGCP(2) error, but it
     is too lazy to do so.  [vgcp-sneak]

549. A class with a generic parameter `G -> ARRAY [like weasel]' is
     correctly reported as a VCFG(3) error.  But when an empty line is
     inserted and then deleted in the file containing the class,
     thereby updating its date of last modification, and compilation
     is resumed the compiler terminates silently after pass 5 on the
     class.  [anchored-constraint-touch-file]

550. A system is compiled with an Ace which references a precompiled
     cluster that is invalid, so it cannot be retrieved.  After the
     VD41 error is reported, the Ace is changed to indicate a valid
     precompiled cluster.  But the compiler reports a VD41 on the new
     (valid) precompiled cluster.  [new-precomp-cluster-bogus-vd41]

551. Operations on BIT types work correctly after the system is
     frozen.  These same operations cause a run-time panic after
     melting.  (Now, the printed bit value is wrong when system is
     melted, although there is no panic).  [bit-melt-metamorphose]

552. A class calls a procedure and passes as actual argument a named
     constant which is of type BIT 2.  If the system is melted, a
     segmentation fault occurs during system execution.  Frozen code
     works fine.  [named-bit-constant-argument]

553. A class prints `x.out' where `x' is a constant of various types
     (INTEGER, DOUBLE, BOOLEAN, etc).  The system compiles fine, but
     if it was melted system execution ends with an exception trace.
     Frozen code works fine.  [named-constant-call-out]

554. A class declares a named constant via `b: BIT 8 is 11B' and
     prints `b'.  When the system is frozen and executed, the value
     displayed has not been extended with trailing zeroes and so is
     only 2 bits long instead of 8 bits.  [extend-short-bit-constant]
   
555. A class has pattern of creation of small STRINGs guided by a
     random number generator.  It also has an attribute which is a
     BIT_REF and it calls deep_clone on the current object after each
     STRING creation.  The system compiles fine when frozen with
     `assertion (all)', but violates postcondition `deep_equal' of
     routine `deep_clone' when it is executed.  Melted code seems to
     work fine.  [deep-clone-frozen-not-equal]

556. A routine has an assignment attempt whose source is of type
     expanded FOO and whose target is of type FOO.  When executed, the
     assignment attempt correctly succeeds.  However, after wasting
     some memory and presumably causing garbage collection, system
     execution ends with a segmentation fault.  The generated C code
     appears to be incorrect.  [assign-attempt-exp-to-ref]

557. A procedure sets an attribute of type REAL to the value passed in
     as an argument.  Then the procedure checks whether the attribute
     is equal to the value just assigned to it.  If the system is
     frozen then the attribute is not equal to the value assigned to
     it.  Melted code works correctly.  [compare-frozen-real-arg]

558. A function which takes one argument of an expanded type and has
     body `Result := arg' does not work correctly, but only if the
     system is finalized.  This appears to be a code generation
     problem.  [finalize-expanded-arg-result]

559. Equal does not give the correct results for bit strings of
     different lengths.  The shorter bit string is supposed to be
     extended with either leading or trailing zeros (not sure which
     one) before the comparison, but it is not.  [bit-equal-wrong]

560. A class creates an ARRAY [expanded FOO] and then fills it up with
     elements of type `expanded FOO'.  When the system is frozen with
     `assertion (ensure)' and then executed it dies with a
     segmentation fault while evaluating the postcondition
     `insertion_done' of `put' in ARRAY.
     [array-of-expanded-insert-fails]

561. A system has a class TEST1 with 150 attributes of an expanded
     type, where the base class of the expanded type has 110 STRING
     attributes.  Repeated creation of instances of TEST1 causes a
     run-time panic when executed, even if garbage collection is
     turned off.  [big-expanded-attributes]

562. A procedure takes the negation (`not') of a local of type BIT
     2_000_000 and prints the first and last bits of the result.
     System execution ends with a run-time panic, but only if garbage
     collection is on.  [negate-big-bit-local]

563. A system repeatedly allocates a string of size `k', where `k'
     starts at 1 and is incremented by one after each iteration.  When
     the system is executed, the amount of "used" Eiffel memory as
     indicated by the memory statistics facilities of class MEM_INFO
     soon becomes negative.  [negative-eiffel-memory-used]

564. A class repeatedly creates a manifest array with a single element
     of type BIT 32.  Executing the system results in a segmentation
     fault or run-time panic after a large number of iterations.  If
     garbage collection is off or the BIT 32 array element is not a
     local entity, the system executes correctly.
     [repeated-manifest-bit-array]

565. The instruction "print ('%U')" does not output a single null
     character.  It does not output anything.  [print-null-get-nothing]

566. A class A repeatedly calls a procedure on an instance of another
     class B.  Class B has a class invariant with a call to a function
     of class B, which in turn calls a function on an attribute of
     type C.  The system compiles fine, but when executed it quickly
     runs out of memory if the system was melted and if `assertion
     (invariant)' is specified in the Ace.
     [melted-invariant-memory-leak]

567. A generic class with a single formal generic parameter G has two
     attributes of type G.  When the actual generic generic parameter
     is a basic type and the two attributes have the same (default)
     value, they are equal according to `=' but not according to
     `equal'.  [generic-attributes-not-equal]

568. A generic class which has a constraint `ARRAY -> [BIT Weasel_bits]' 
     on its formal generic parameter causes the compiler to correctly
     report a VTCG violation, but the compiler dies while trying to
     report the type to which the actual generic parameter should
     conform.  [generic-constraint-bit-type]

569. A system with a generic class with a formal generic parameter
     constrained by `ARRAY [TEST]' causes the compiler to die while
     freezing the system, but only if class TEST is expanded.
     [generic-constraint-with-expand]
   
570. A class which tries to get and print the address of an external
     feature (which is not a constant) compiles fine, but dies with an
     exception trace when executed.  Fixed because compiler now says
     taking address of an external feature is not supported in release
     4.1.  [external-feature-address]

571. A routine has a local of an expanded type and the creation
     procedure of the expanded type's base class raises an exception.
     When the routine is called repeatedly, a run-time panic occurs if
     garbage collection is on.  [expanded-local-raise-exception]

572. An Ace with an Externals section which has more than one
     Language_contribution causes es3 to report a syntax error.  ETL
     page 528.  [lace-mult-ext-lang]

573. An expression with a division by constant 0 or 0.0 compiles fine,
     but the generated C code won't compile using `cc'.  However,
     it will compile using `gcc', and `cc' is no longer supported on
     SunOS since it isn't an ANSI C compiler.  [divide-by-zero]

574. A routine with an assignment attempt whose source is of a basic
     type (INTEGER, REAL, etc.)  compiles fine when frozen, but
     generates C code which won't compile.
     [assign-attempt-basic-type]

575. A routine with an assignment attempt whose source is a `$x',
     where `x' is a local which is of a basic type (INTEGER, REAL,
     etc.)  compiles fine when frozen, but generates C code which
     won't compile.  Compiler now reports a syntax error, so it won't
     accept this code just like it won't accept "x := $y".
     [assign-attempt-basic-local-addr]

576. Freezing a system with a feature which is an argumentless
     external function that includes a signature in the
     External_declaration produces C code which won't compile.
     [external-func-with-signature]

577. A declaration of an external routine declares the external to be
     a macro and specifies two include files whose names are delimited
     only by white space (no %" or <> bracketing).  If the white space
     is a tab instead of a space, only one C include is generated with
     the two file names run together, causing the C code not to
     compile.  [external-tab-between-includes]

579. A routine fills an ARRAY [POINTER] with its own address.  If the
     system is finalized with `array_optimization (yes)', the generated
     C code won't compile.  [finalize-array-opt-pointers]

580. A system's Ace has a visible clause which makes one routine of a
     class visible.  The class inherits the routine to be made visible
     from another class along with another routine called by the first
     and renames both routines.  When the system is finalized with
     `dead_code_removal (yes)', the generated C code won't compile.
     [finalize-wont-trace-visible]

581. A system calls a routine which tries to create an instance of a
     deferred type, where this invalid creation is not detected at
     compile time because the target of the creation is anchored.
     When the system is finalized the generated C code won't link,
     even if dead code removal is off.
     [finalize-create-deferred-type]

582. A feature with 100 nested calls to `clone' and a missing
     parenthesis causes the compiler to terminate silently after pass
     5.  [deep-function-nest]

583. If a class renames inherited infix feature to an identifier
     feature, the flat and flatshort forms of the class are incorrect
     (in at least some cases).  Feature name is `"time_less_than"'
     instead of `time_less_than'.  [rename-inherited-wrong-flat]

584. Changing a class after initial compilation and then taking the
     flat form before recompiling causes the flat form to be incorrect
     (basically an empty class in my example).  [flat-after-change]

585. The flat form for a particular class which inherits both directly
     and indirectly from a class with a deferred feature incorrectly
     lists the same feature twice, with two different bodies.  Only
     one of the routine bodies is correct.  [flat-feature-two-defs]

586. A class A inherits from class B and renames a deferred feature in
     B so that it has the same final name as another (non-renamed)
     effective feature from B.  Class A is not deferred.  But the flat
     form for class A shows two declarations for the renamed feature,
     one of which is deferred.  [eff-class-flat-deferred-feature]

587. If a class renames an inherited identifier feature to a prefix or
     infix feature, the flat and flatshort forms of the class are
     incorrect.  Feature name is `_prefix_@weasel' instead of `prefix
     "@weasel"' and similarly for infix features.
     [rename-inherited-bad-flat]

588. A class inherits from a parent class, renaming a feature `right'
     which is called in another inherited feature.  Feature `right' is
     called on an entity of type `like first', but feature `first' is
     redefined to change its return type.  The flat form of the heir
     class refers to `right' instead of using the new name assigned by
     renaming.  [redefine-anchor-rename-called-feat]

589. A class has a routine with no comment and the routine is the last
     in a `feature' section.  If the feature section has a comment (as
     in `feature -- Properties'), the feature section comment is
     incorrectly used as the comment for the routine in the Flat and
     Stop Points formats in a routine tool.
     [ebench-flat-use-next-comment]

590. In the Clickable, Flat, Short or Flatshort formats of a Class
     tool (or in the Flat or Stop Points formats for a Routine tool),
     the backquotes and quotes around entity names in a routine
     comment are not preserved.  [ebench-comment-entities-unquoted]

591. While stepping through routine `sequential_search' of
     ARRAYED_LIST, the arrow in a Feature tool indicating the point
     where execution is stopped disappears.  Even the "@" button can't
     bring it back.  [debugger-hidden-stop]
   
592. After initial compilation, a non-generic class is changed to a
     generic class by adding a single formal generic parameter FOO,
     with the constraint `-> ARRAY [FOO]'.  The system also happens to
     have a class named FOO.  The compiler correctly reports the
     VCFG(1) violation but says "Exception occurred while displaying
     error message" while trying to display the name of the class
     involved.  [make-generic-add-vcfg]

593. A system with a generic class also has a VLEC error.  The
     compiler detects the error, but says "Exception occurred while
     displaying error message" while trying to display the name of the
     class involved.  [expanded-generic-vlec-exception]

594. After initial compilation, a VEEN error is added to a class.
     When the compiler detects the error, it is corrected by
     inheriting from a different class.  This introduces a VRFA error
     which the compiler catches, but it also says "Exception occurred
     while displaying error message" while trying to display the name
     of the feature involved.  [fix-veen-add-vrfa]

595. A system has an Ace which makes a class visible under another
     name FOO and an external routine which tries to get the type id
     of class BAR.  After initial compilation where the system is
     frozen, system execution works as expected: no type id can be
     obtained for BAR since the class was made visible as FOO instead
     of BAR.  The Ace is changed to make the class visible as BAR and
     changes are melted.  When the system is executed, no type id can
     be obtained for BAR.  [visible-class-change-name]
   
596. After initial compilation, the name of a formal routine argument
     is changed, along with the single reference to it in the routine
     body.  After the system is recompiled, the flat form of a
     descendant class shows the wrong body for the inherited routine.
     The formal argument is renamed but the reference to it in the
     routine body is not.  [flat-change-argument-name]

597. A system sets a variable to the character constants `%/128/' and
     `%/255/' and then checks to see if the variable is equal to the
     value just assigned to it.  The system compiles fine when frozen,
     but thinks the variable is not equal to the character just
     assigned to it for characters `%/128/' and above.  Melted code
     works correctly.  [compare-frozen-high-bit-chars]

598. The collect option does not seem to be implemented.  Invalid
     values for the collect option are accepted without any complaint.
     Retired because VD37 errors are issued every time the collect
     option is specified, even though the values are ignored.
     [lace-invalid-collect-values]

599. The trace option used in a system-level Defaults part in an Ace
     does not seem to be implemented.  An Ace which includes a valid
     `trace(yes)' or `trace(no)' option does not elicit any warnings
     from the compiler.  [lace-system-opts-fail]

600. A class with no attributes and a strip expression `strip ()'
     compiles fine, but the generated C code won't compile with `cc'.
     It will compile with `gcc'.  Retired because `cc' is not an ANSI
     C compiler and only ANSI C is supported now.
     [strip-empty-list-freeze-cc]

601. Freezing a system with a call `equal ($make, $make)' produces C
     code which compiles, but the C compiler issues warnings about
     "illegal pointer combination".  [feature-addr-illegal-pointer]

602. A class inherits three deferred features and joins and effects
     them.  The flatshort form of the heir class looks as expected,
     with all alternative preconditions present in the expected order.
     But when the system is executed, only one of the preconditions of
     the deferred features is executed.  In this case, postconditions
     seem to work correctly.  [join-effect-precond-skipped]

603. Finalizing a system with a call `wimp ($make)' produces C code
     which compiles, but the C compiler issues a warning about
     "illegal pointer combination".  The warning only occurs if the
     system was finalized with `inlining (yes)'.
     [inline-addr-illegal-pointer]

604. A system is compiled via ebench when there is not enough disk
     space.  The compiler runs out of disk space while writing the
     `project.eif' file.  A subsequent attempt to melt causes the
     compiler to go into an infinite "no more disk space" loop.
     [no-disk-space-loop]

605. A system is compiled via ebench when there is not enough disk
     space.  During degree 5, a "file system full" message is
     displayed.  Thereafter, attempts to melt the system result in a
     warning panel which says "Read-only project: cannot compile".
     This happens even if more disk space is made available.
     [no-disk-space-read-only]

606. A routine whose body just allocates a lot of strings has a rescue
     clause which just retries.  The system is melted or frozen with
     an Ace which specifies `assertion (invariant)'.  When the program
     is executed, repeatedly typing control-C characters usually
     causes the program to terminate with a run-time panic.  The
     exception trace shows an invalid object.
     [control-c-invalid-object]

607. An external routine has a signature specified (e.g., "C
     (double)") to cause casting of an argument before it is passed to
     the C routine.  The external routine is redefined in a
     descendant.  In a call to the routine which cannot be statically
     bound, the cast should not be applied to the argument in the
     generated C code, but it is if the system is finalized.  This
     results in wrong results when the system is executed.  A frozen
     system works correctly.  [finalize-redef-external-with-sig]

608. The position of a syntax error in an external declaration is shown
     incorrectly (even by es3) when the declaration has any escaped
     characters such as '%"'.  Every such character seems to be
     counted as one character instead of the number of characters used
     to represent it in the class text.
     [external-wrong-syntax-position]

609. Start ebench.  Keep double clicking on parent directories until you
     reach the root and then on directories `/bin' and
     `/bin/sunview1'.  Click on OK.  Ebench correctly says that
     `/bin/sunview1' does not have appropriate permissions.  But two
     warning messages appear in the window from which ebench was
     started which say "The scrollbar page increment is less than 1".
     Retired because no longer reproducible. [ebench-page-increment-lt-one]

610. If the general resource file in the $EIF_DEFAULTS directory does
     not specify "progress_bar_color" explicitly then the Compilation
     Progress bar is blue and the background for the labels for each
     button/hole which pop up if one leaves the mouse there is light
     yellow.  However, if the resource file specifies
     "progress_bar_color: green" then both the Compilation Progress
     bar and the background for popup help labels over buttons are
     green.  [ebench-help-label-wrong-color]

611. The Once/Constant format for a constant of type STRING uses single
     quotes around the value intstead of double quotes.  The
     Once/Constant format for a constant of type CHARACTER uses double
     quotes around the value intstead of single quotes.  These two seem
     to have been switched.  [ebench-once-constant-quote-mixup]

612. There is a number of wrong or strange behaviors associated with
     compiling a system where the Ace is built by ebench.  
	A. Start ebench.  Select OK.  Click on Melt then on Build.
	   Click on Cancel to get rid of window, which is titled "Ace
	   builder_popup" (why is the "_popup" part needed?).
        B. Click on Melt again, then Build.  When the Ace builder
	   window comes up, it is wider than it was before (why?).
	   Click Cancel again.
	C. Do the Melt, Build, Cancel sequence several more times.
	   Notice that each time you do this it takes 1-2 seconds
	   longer for the Ace builder window to appear.
    	D. In Ace builder window, change system name to "test", root
	   class name to "weasel" and creation procedure name to
	   "wimp".  Click on Create Project.  Compilation finishes,
	   but the name of the class displayed in the Compilation
	   Progress window is ROOT_CLASS rather than WEASEL, although
	   the Ace.ace file and the file weasel.e were both generated
	   correctly.
    	E. Notice also that the system is compiled multiple times
	   instead of just once (I believe there is one compilation
	   for each time the Ace builder window showed up).
    [ebench-ace-builder-weirdness]

613. The underscores in lines of a routine which are "stepped" through
     are erased and not redrawn, leading to a very confusing display in
     the debugger feature window.  For that matter, the text in white
     again the red background that shows the current location in a
     routine or in the call stack do not include white underscores
     either (also very confusing).  [ebench-debugger-erase-underscores]

614. Drag a class or feature into a Class tool which has a class in it
     whose text has been modified.  Ebench asks for confirmation (File
     has changed since last save!  Lose changes?).  If one responds
     affirmatively, the class or feature goes into the Class tool, but
     the text input field with the class name (to right of Next
     button) still shows the name of the previous class.  Furthermore,
     if you drag a feature into a Class tool with modified text, the
     title bar of the Class tool shows "Feature: make Class: TEST"
     (for example) and only the text of the new feature is shown
     rather than the text of the entire class with the feature
     highlighted.  In other words, the title bar and text window of a
     Class tool look like it is a Feature tool.
     [ebench-target-changed-class]

615. If a user loses his license (e.g., due to a crash and reboot of the
     machine on which the license daemon runs), trying to get
     information twice by clicking on Info in the popup announcing the
     loss of license causes ebench to terminate with a segmentation
     fault.  Retired because no longer reproducible.
     [ebench-license-loss-info-twice]

616. Problems with Graphical preferences format of the Preference tool:
	A. Switching to the Graphical preferences format of the
    	   Preference tool is *very* slow (over 90 seconds on a SPARC
    	   10).  During this time, CPU utilization is near 100%.
	   [Seems to be OK on an UltraSPARC 2]
	B. Right clicking on on of the font values (e.g., value for
	   Class font) brings up a Font selection box.  The title of
	   the window is "Font Box_popup" (why is "_popup" needed?).
	   Also, the background color (and probably the foreground color)
	   is not the color I specified in my resource file, but
	   a fairly dark blue.
    	C. There are *two* boxes labeled "Progress bar color".  One
	   has the value "LightYellow" and the other has the value
	   "blue".  I suspect that one of them is misnamed and may be
	   affecting the background color of popup help labels.
	   Actually, changing either one or both of the boxes to have
	   the value "green" and clicking Apply does not change the
	   color of the progress bar or of the background for popup
	   help labels.
    [ebench-graphical-preferences]

617. Files generated with PostScript filter do not print correctly on
     HP LaserJet 4Si.  The text of the Postscript commands prints.
     Changing the first line from "%!PS-Adobe-1.0" to "%!PS-Adobe-2.0"
     corrects the problem.  [ebench-postscript-prints-wrong]

618. The "tab_step" resource does not seem to have any effect
     when the preference file is read on startup.  Changing tab step
     in the preferences tool and applying the change does have the
     appropriate effect.
     
619. Clicking twelve times quickly in a Feature tool in Stop Points
     format seems to work correctly.  But after ebench stops processing
     the mouse clicks, selecting Flat format causes ebench to die.
     Retired because no longer reproducible.
     [ebench-twelve-feature-clicks]

620. Selecting Special/Reverse engineer before compiling a project
     results in an appropriate error message.  However, the message
     says (note the missing word "has"):
    	Project not been compiled.
	The project must be compiled before it can be reversed engineered 
     [ebench-reverse-engineer-early]

621. Holding down the left mouse button and moving the mouse to select
     text in a class tool works fine.  However, a subsequent click on
     the middle mouse button to paste the selected text into an Emacs
     window causes ebench to die with a segmentation fault.
     [ebench-select-then-paste]

622. Holding down the Back Space key or the Delete key in a System tool
     or Class tool (and presumably others, though I haven't tried them)
     causes ebench to die with a bus error.  [ebench-hold-down-delete]

623. The creation procedure `make' of BOOL_STRING has a precondition
     `positive_size: n > 0'.  This should be `nonnegative_size: n >= 0'.
     [create-zero-len-bool-string]

624. The clickable form, flat form and flat short form of a class show
     prefix features as, for example, `prefix "@weasel "' instead of
     `prefix "@weasel"'.  That is, there is an extra space following
     the name inside double quotes.  See code in
     [rename-inherited-bad-flat] to reproduce. [prefix-feature-extra-space]

625. Start ebench.  Select OK, Melt, Browse and choose file Ace.
     Immediately click on the File menu in upper left corner of Project
     tool, while compilation is going on.  As soon as the File menu is
     displayed, click in the middle of the Project tool main window in
     an area not over any menu item.  Ebench finishes compiling and
     then dies with a segmentation fault.
     [ebench-compile-file-menu]

626. Clicking more than once in rapid succession on the Cancel button
     in the Compilation Progress window during a compilation sometimes
     causes ebench to go into an infinite loop or die with a panic.
     [ebench-cancel-compile-twice]

627. An iconified Project tool is labeled ISE Eiffel 3 instead of ISE
     Eiffel 4.  Can't tell if this is fixed since cannot see the number
     in icon on Solaris version.  [ebench-iconified-project-wrong-version]

628. The "Case sensitive" push button in the Search window which comes
     up when the Find button is clicked (in any tool that has a Find
     button) does not work properly.  Searches are always
     case-insensitive regardless of whether this button is pushed in or
     not.  In release 4.2, searches don't seem to work at all - nothing
     is highlighted.  [ebench-case-button-ignored]

629. If the Debugger Feature window contains a feature and is in a
     format other than Stop Points and the window is hidden via
     Formats/Hide Feature then shown again via Formats/Show Feature,
     then the Stop Points button in the debugger feature window is
     inoperative until another format is selected first.
     [ebench-debugger-stop-points-inoperative]

630. Melting a system from ebench and then trying to precompile it via
     Compile/Precompile menu causes ebench to die with a segmentation
     fault.  [ebench-melt-then-precompile]

631. Changing the symbol color in the Graphical Preferences window
     causes ebench to die with a segmentation fault under particular
     circumstances.  [ebench-change-symbol-color]

632. Changing a color or font in the Graphical Preferences window
     causes ebench to popup a warning that states "System is not
     running" when the change is applied, but only if there is an empty
     Object tool present.  [ebench-system-not-running]

633. Interrupting compilation by clicking on the Cancel button in the
     Compilation Progress window usually works fine.  However, if the
     compilation is a precompilation started via Compile/Precompile,
     the error message says "Reverse engineering interrupted" instead
     of "Compilation interrupted".  [ebench-interrupt-precompile]

634. Dragging the class name NONE from the declaration for feature
     `Void' in class GENERAL into a Shell Hole, the Stop Points hole or
     the Clear Stop Points hole causes ebench to die with a
     segmentation fault.  [ebench-drop-class-none]

635. If the Debugger Feature window is in a format other than Stop
     Points *and* if the feature in the window is the first one to be
     stopped in then when the debugger stops the Feature Tool is not
     switched to Stop Points format.  When a different feature is
     brought into the Debugger Feature window, the format always seems
     to be changed to Stop Points format.
     [ebench-debugger-no-format-switch]

636. Finalizing a particular simple program without inlining reduces
     system execution time by more than half, as compared with a version
     where inlining is on.  [faster-without-inlining]

637. A type `STRING [STRING]' should be a VTUG(1) error since STRING is
     not a generic class.  The compiler reports a VTUG(2) error for this
     type, but only when it is used in a constraint on a formal generic
     parameter.  Other uses are correctly reported as VTUG(1).
     [vtug1-called-vtug2]

638. A type `ARRAY' should be a VTUG(2) error since ARRAY is a generic
     class with one generic parameter.  The compiler reports a VTUG(1)
     error for this type, but only when it is used in a constraint on a
     formal generic parameter.  Other uses are correctly reported as
     VTUG(2).  [vtug2-called-vtug1]

639. An attribute `weasel' of a generic class is anchored to another
     attribute whose type is the formal generic parameter.  A second
     generic class has a constraint involving the first.  This second
     class has a multi-dot call involving a nonexistent feature, but it
     is not detected.  [attribute-anchored-to-generic]

640. A system with an invalid generic derivation of a generic class
     with two formal generic parameters A and B, where B is constrained
     by `LIST [A]' is accepted by the compiler, but should not be.
     This results in an undetected type error and a segmentation fault
     when the system is executed.  [tricky-constraint-with-generic]

641. Class A calls a feature in class B which is exported only to B and
     its descendants.  This is valid since class A is a descendant of B.
     But when the inheritance clause is removed, so that A is no longer
     a descendant of B, and the system is recompiled, the VUEX violation
     is not detected.  [vuex-sneak]

642. Depending on the order of formal generic parameters in a class (one
     constrained and one unconstrained), the compiler interprets G as
     either a formal generic or as a class.  It seems that if there is a
     class G, then G should be interpreted as a class (and a VCFG error
     signaled).  If there is no class G, then G should always be treated
     as a formal generic parameter, regardless of order so a VTCG error
     should always be reported (instead of reporting VTCT for formals `H
     -> G, G'). [generic-constrained-by-generic]

644. A class has an external function which specifies a cast of the
     return type (i.e., `external "C :EIF_INTEGER"').  After initial
     compilation where the system is frozen, system execution works but
     produces the wrong result.  Then some white space is added inside
     the Language_name portion of the external, leaving its semantics
     unchanged and the system is melted.  System execution then ends
     with a segmentation fault.  [cast-external-add-white-space]
   
645. A class calls a routine and the routine calls its precursor.
     After initial compilation, system execution works correctly.  Then
     a rename is removed, which causes the routine with the precursor
     call to have a different precursor.  Recompilation works but
     execution output is wrong.  [rename-get-new-precursor]
   
646. A generic class has a reference to `<< x >>' where the type of
     attribute `x' is the single formal generic parameter of the
     enclosing class.  Another class has a generic derivation of the
     first class, using a non-basic expanded type as the actual generic
     parameter.  The system compiles fine, but when executed it dies
     with an exception trace if it was melted.  Frozen code works fine.
     [manifest-array-expanded-generic]

647. A class repeatedly does `clone (clone (c))' where `c' is of an
     expanded type.  If the system is melted and garbage collection is
     enabled, a segmentation fault occurs when the system is executed.
     Frozen code works fine.  [expanded-clone-of-clone]

648. A class repeatedly creates an instance of another class which has
     one attribute of an expanded type.  The base class of the expanded
     type has a creation procedure which allocates a small amount of
     memory to initialize the value of a string attribute.  If the
     system is melted, a segmentation fault occurs when the system is
     executed.  Frozen code works fine.  [expanded-creation-alloc-memory]

649. A routine with a local of type ARRAY [EXPANDED_TYPE] dies with a
     segmentation fault if finalized with `array_optimization (yes)'.
     If array optimization is off, the generated C code works fine.
     [finalize-array-opt-expanded]

650. A system with classes that use the `precursor' construct produces
     incorrect output when the system is finalized with inlining.
     [finalize-inline-precursor]

651. A class creates an ARRAYED_LIST [STRING] and then clones it.  The
     class compiles fine, but when the system is executed the
     postcondition of `clone' is violated.  Using the debugger to look
     at the objects reveals that the clone is not working properly.
     [arrayed-list-clone-not-equal]

652. A class inherits a feature `weasel: TEST3 [like Current]' where
     TEST3 is an expanded class.  In an instance of the parent class
     `weasel' is non-Void (it better be since it is of an expanded
     type).  But in the inheriting class `weasel' is Void, which should
     be impossible.  If some Class_type is used as the actual generic
     parameter, instead of `like Current', then the attribute is
     non-Void in both parent and child.  [expanded-generic-like-current]

653. An object of type `TEST1 [STRING]' conforms to an object of type
     `TEST1 [SEQ_STRING]' according to `conforms_to'.  This is
     obviously not the case and system execution later pays the
     ultimate price.  [conforms-to-with-generics]

654. A root class has two attributes of an expanded type.  The base
     class of this expanded type has a creation procedure which creates
     a single large string in an attribute.  System execution ends with
     a run time panic, but only if garbage collection is on.
     [expanded-create-big-string]

656. A function with return type of NONE causes silent termination of
     compilation (during pass -1 generation if freezing system or
     during pass 1 if not freezing system).  [function-returning-none]

657. A class which inherits a deferred feature `feat' once from one
     class and an effective feature `feat' with the same signature
     twice from a second class (as both `feat' and `renamed_feat') and
     also redefines `feat' so that its return type is anchored to
     `renamed_feat' causes silent termination of the compiler after
     pass 1.  [redef-anchored-to-self-version]

658. An external routine which takes an expanded argument and also
     specifies a cast in the Special_external_decl compiles fine when
     frozen, but the generated C code won't compile.
     [expanded-arg-with-cast]

659. After initial compilation, a constant integer attribute referenced
     in a BIT type is given a larger value.  This introduces a VNCB
     violation (assigning `BIT n' to `BIT p' where n > p), but upon
     recompile the error is not detected.  [vncb-sneak]

660. A class has a routine with 2000 copies of an instruction that
     prints a BIT constant which is 370 bits long.  When the class is
     compiled, the compiler dies with a run-time panic during degree 2.
     [many-long-bit-constants]

661. Finalizing a system with a simple root class causes the compiler to
     die during degree -5 on the root class, but only if the Ace
     specifies `inlining (yes)' and a very large value of `inlining_size'
     (1000000).  Now the compiler signals a VD15 error, so I don't know
     if the bug is still there.  [finalize-big-inline-size]

662. Putting a stop on a once routine in a very small and simple system
     and then executing the system causes system execution to terminate
     with a segmentation fault.  The system executes correctly without
     the stop on the routine.  [ebench-debugger-once-routine-stop]

663. The Clickable, Flat, Short and Flat-Short formats in a Class tool
     repeat the keyword expanded twice (e.g., "x: expanded TEST1" is
     shown as "x: expanded expanded TEST1" in these formats).
     [ebench-too-much-expansion]

664. Setting a 0 or negative or very large width or height for the
     Project tool in the Preferences tool causes ebench to terminate
     with an X error.  This also happens for width/height for some
     other types of tools, but not all.  [ebench-zero-project-width]

665. When precompiling a system where one of the classes has an error
     (in this case a VEEN error - unknown identifier) the error is
     detected.  If the error is corrected and then one forgets one is
     doing a precompilation and instead clicks on the Melt button then
     the compilation restarts but suddenly hangs before completion.  No
     CPU is used but the mouse pointer is the familiar clock indicating
     the program is busy.  Now ebench dies with a seg fault.
     [ebench-precompile-then-melt]

666. Holding down the left mouse button and moving the mouse to select
     text in a class tool does select the text.  But the text is not
     highlighted so you cannot see what is selected.  Perhaps I have
     something set wrong in my preferences file.  
     [ebench-select-text-no-highlight]

667. An attribute `weasel' of a class has the type of the formal
     generic parameter, which is constrained by `LINKED_LIST [STRING]'.
     The expression `weasel.i_th (1)' should therefore be of type
     STRING.  But an assignment to a local of type STRING is rejected
     as a VJAR error.  The compiler seems to think the expression is of
     type `Generic #1'.  Note: the 4.3 compiler accepts this code,
     but melted system dies.  Frozen system works fine.
     [generic-attr-call-bad-type]

668. After initial compilation, a constrained generic parameter [G -> STRING]
     is added to the root class.  When the compiler detects the VSRC(1)
     error, the generic parameter is removed.  The compiler then dies.
     [add-remove-root-generic]

669. A class has an attribute of type `expanded TUPLE'. After initial 
     compilation where the system is frozen, the type is changed to
     `TUPLE [BIT 32]'. When changes are melted, system execution
     dies with a panic. [change-expanded-tuple-bit]
	   
670. A routine has 400 locals of an expanded type, where the base class
     of the expanded type has 400 attributes of type DOUBLE.  The
     system compiles fine, but dies with a segmentation fault when
     melted if garbage collection is on.  [many-big-expanded-locals]

671. A class has an attribute `x' of type `LINKED_LIST [like weasel]',
     where weasel is of type `LINKED_LIST [STRING]'.  A reference to
     the first item of the first list in `x', which is of the form
     `x.i_th (1).i_th (1)' causes termination of the compiler after
     pass 3 on the class.  [anchored-generic-multi-dot-call]

672. Finalizing a system with two small classes causes compiler to die 
     while inlining. [finalize-inline-small-classes]

673. A class with a generic class whose constrained generic parameter
     names a nonexistent feature in the constraining class causes
     compiler to die.  [generic-nonexistent-creator]

674. After initial compilation, the name of a cluster (the tag) is
     changed in the Ace file.  When the system is recompiled, the
     compiler accepts the class instead of issuing a VD19 validity error.
     [chg-cluster-name]

675. Freezing a class with a creation expression whose type is a generic
     (create {TEST1 [STRING]}) produces C code that won't compile. 
     [freeze-generic-creation-expr]

676. A class A declares an entity of type `expanded B [like Current]'.
     Since B inherits from A, there should be an expanded client cycle
     involving only B.  But the compiler does not detect the VLEC
     error.  If the entity type is instead `expanded B [A]' the VLEC
     error is detected.  [like-current-generic-vlec]

677. A class has a feature of type `HASH_TABLE [STRING, NONE]'.  After
     the compiler correctly detects a VUAR error, NONE is changed to
     STRING, thereby making the class correct.  When compilation is
     resumed, the compiler dies with a segmentation fault during degree
     -1 on HASH_TABLE.  [none-then-string-generic]
   
678. A class has a feature of type `PROCEDURE [TEST, NONE]'.  After
     the compiler correctly detects a VJAR error, NONE is changed to
     TUPLE, thereby making the class correct.  When compilation is
     resumed, the compiler dies.  [none-then-tuple-generic]
   
679. After initial compilation where the system is melted, the root
     class is changed so that it is expanded and the system is
     frozen.  The resulting C code will not compile in eparents.c.
     [make-root-expanded-freeze]
   
680. A class declares a local entity of an expanded type and then calls
     a feature on the entity, passing the local itself as an actual
     argument in the call.  The called feature evaluates `arg =
     Current'.  When the system is executed, it dies with a run-time
     panic and the message "operational stack botched", but only if the
     system is melted.  Frozen code works fine.
     [expanded-melted-equal-current]

681. A class repeated creates a manifest array whose elements are an
     expanded type.  If the routine which does this creation the array
     and the elements are all melted and there are four or more elements
     in the manifest array, a segmentation fault occurs when the system
     is executed.  Frozen code works fine.  [manifest-array-of-expanded]

682. Freezing a system with a class with a routine which takes one
     argument of type NONE, clones it and assigns the result of the
     clone to a local of type NONE causes silent termination of
     compilation while freezing.  [unusual-none-use]

683. A class which provides NONE as actual generic parameter in a
     generic derivation of LINKED_LIST causes silent termination of the
     compiler during pass 3. [none-as-actual-generic2]

684. A system with a reference to `Current.Void' causes silent
     termination of the compiler while freezing.  [current-dot-void]

685. Finalizing a class with a BIT attribute produces C code that
     won't compile in esize.c. [finalize-bit-attribute]

686. A generic class CHILD has an inheritance clause `TEST1 [CHILD]',
     which should elicit a VTUG(2) error.  Instead, the compiler
     reports a VTCG error in the generic constraint of a different
     class.  But in order to discover the VTCG violation, the compiler
     should have had to analyse CHILD enough to detect the VTUG error,
     which is the real problem.  I decided compiler's behavior is
     reasonable. [vtcg-instead-of-vtug2]

687. An Ace with a cluster which references a nonexistent "use" file
     causes the compiler to terminate with a "No such file or directory
     error" during degree 6 on the cluster.  [nonexistent-use-file]

688. A routine with the instruction `s := create {NONE} s.make' where
     s is a STRING causes compiler to die. [assign-creation-expression]

689. A generic class with a formal generic parameter constrained by
     a TUPLE type causes compiler to die. [generic-constrained-by-tuple]

690. A class with a generic class whose constrained generic parameter
     names a nonexistent infix feature in the constraining class causes
     compiler to die.  [generic-nonexistent-infix]

691. A internal routine which just retries exceptions a specified
     number of times and then returns successfully calls an external
     routine which raises an exception.  When the internal routine is
     called repeatedly, more and more C memory is used, which seems to
     indicate a memory leak.  [external-exception-memory-leak]

692. A system which calls a once function whose result type is an
     expanded type should execute correctly, but dies with an exception
     trace or with illegal instruction if it is partially melted.
     [once-expanded-result]
   
693. A routine creates does a creation on an attribute of type `TEST1
     [BIT 8]' where TEST1 [G] has a creation procedure with a single
     formal argument of type G.  This creation procedure calls `out' on
     the formal argument to display it.  The system compiles fine, but
     dies with a precondition violation in `put' of BIT_REF.
     [generic-formal-bit-actual-arg]

694. Null characters (%U) are completely ignored in a standard operator
     name such as infix "and%U", but only when they are trailing nulls.
     ETL page 68. [std-operator-trailing-null]

695. A syntax error with the invalid character Ctrl-@ or Ctrl-A causes
     the compiler to terminate with a segmentation fault.
     [null-or-ctrl-a-syntax]

696. There is no limit to the length of identifiers.  But the compiler
     reports a syntax error for identifiers longer than 511 characters.
     ETL page 418.  [fairly-long-identifier]

697. A declaration of a routine with zero arguments which includes the
     parentheses around an empty argument list, such as `try () is do end'
     should be accepted but is not.  ETL page 109.  [routine-empty-arg-list]

698. A Real constant `.e1' has both the integral and fractional parts
     absent, making it invalid, but the compiler accepts it.  The
     generated C code will not compile (melted code gives wrong
     results).  [point-e-one-real-constant]

699. A qualified call to a feature whose name is `e' followed by an
     unsigned integer (e.g., `e47') should be legal, but the compiler
     reports a syntax error.  The `.e47' in the call `my_feature.e47' is
     misinterpreted as a Real constant.  First reported by Bertrand
     Meyer on NICE Eiffel Language mailing list.
     [qualified-call-e-forty-seven]

700. The name NONE is accepted as formal generic parameter in a generic
     class.  ETL page 52.  [none-as-formal-generic]

701. When a class with a postcondition containing the assertion `(old
     (old Result)' is compiled, the compiler correctly reports a syntax
     error.  But when the extra parenthesis is removed, the compiler
     issues a VEEN(22) error (local entity may not be used in this
     context) naming the entity `y'.  It should instead report a VEEN(2)
     error (illegal use of Result).  If the class is compiled from
     scratch, a VEEN(2) error is correctly reported. [veen2-called-veen22]

702. When a class having an invariant with a syntax error is compiled,
     the compiler correctly reports a syntax error.  But when the
     missing parenthesis is added and compilation is resumed, the
     compiler reports a bogus VEEN error instead of the expected VUAR(1)
     error.  [vuar1-called-veen]

703. A sequence of changes where a VSRC(2) error is added and then
     removed causes the compiler to die. [add-remove-vsrc]
   
705. A system with a class which does a creation instruction on a local
     of type INTEGER and then tries to add 1 to that local compiles
     fine, but when it is executed it dies with a panic and the message
     "operational stack botched".  [create-integer-then-incr]
   
706. A function which returns a BIT type includes an explicit creation
     instruction `!!Result'.  The class compiles fine, but when the
     BIT type is printed it is wrong.  Removing the explicit creation
     instruction causes system execution to produce correct output.
     [bit-function-explicit-creation]

708. A set of fairly deeply nested multi-branch instructions (49 deep)
     causes the compiler to silently terminate after pass 5 on the
     enclosing class.  Same thing for deeply nested conditionals.
     [deeply-nested-when]

709. A class with an invariant which has any reference to a feature
     address `$x' causes the compiler to terminate with a segmentation
     fault during degree 3.  [feature-address-in-invariant]

710. Finalizing a class with a routine with an argument of type 
     ARRAY [EXPANDED_TYPE] causes compiler to die while inlining.
     Actually, I'm not sure that is the cause of the problem but
     the compiler does die.
     [finalize-inline-array-expanded]

711. Finalizing a system with a function whose body is
     `Result := create {SEQ_STRING} .make (47)' causes compiler to die.
     [finalize-creation-expression]

712. A class with a reference to `s~make' in the invariant causes
     compiler to die. [invariant-delayed-closed-target]

713. In a generic class, an attempt to use 8 or more formal generic
     parameters causes the compiler to report a syntax error.  ETL page
     52.  [vtct-on-generic-5]

715. An Ace which specifies a precompiled cluster with a very long path
     name (a little longer than 512 characters) causes the compiler to
     die with a run-time panic and not return the license.  Similarly,
     specifying a long string for an assertion level kills the compiler.
     In fact any long string in the Ace file kills the compiler.
     [long-precompiled-path-name]
    
716. A class with two creation clauses (`creation make' and `creation')
     where `make' is a procedure of the enclosing class causes silent
     termination of the compiler after pass 4 on the class.
     [two-creation-clauses-one-empty]

717. Selecting Special menu and Version menu item in an empty Class tool
     causes ebench to die with a segmentation fault.
     [ebench-empty-class-version]

718. Selecting File/Feature/Print or File/Object/Print causes ebench to
     die with a segmentation fault, regardless of whether or not there
     is a feature or object in the window whose contents are to be
     printed.  [ebench-print-debugger-feature]

719. A class with a call `f ("#",a,"%N")' should be valid but
     the compiler reports a syntax error.  Adding white space
     before the `a' eliminates the error.
     [bogus-string-syntax-error]

720. A valid class with an indexing clause with either an Index_tag or
     an identifier Index_term which includes `class', even as a proper
     substring, causes the compiler to report VTCT on the enclosing
     class.  [vtct-on-valid-class]

721. An external routine has a signature specified (e.g., "C (double):
     long") to cause casting of a result before it is passed back to the
     Eiffel side.  The external routine is redefined in a descendant.
     In a call to the routine which is statically bound, the cast is not
     applied to the result of the function call in the generated C code
     if the system is finalized.  This results in wrong results when the
     system is executed.  A frozen system works correctly.
     [finalize-cast-func-result]

722. A manifest string constant with 400000 characters should be
     allowed, but the compiler dies while trying to compile class.
     [long-string-constant]

723. A bit constant which is 300000 bits long causes the compiler to
     die while trying to compile the class.
     [long-bit-constant]

724. A class calls `print (i = i.default)' on an INTEGER i.
     T N and just returns its argument.  The system compiles fine when
     melted, but when executed it dies with "operational stack botched".
     Frozen code works correctly.  [compare-var-to-default]

725. An expanded class FOO has a function `weasel' whose return type is
     `like Current'.  A routine declares a local entity of type FOO and
     calls `weasel' on it, passing this result to another routine.
     [pass-expanded-like-current]

726. A class which inherits from an unconstrained generic class and
     provides a BIT type as actual generic parameter, where the number
     of bits is specified by an integer constant attribute, causes
     silent termination of the compiler.  If the class is instead a
     client of the generic class with the same actual generic parameter,
     termination does not occur.  [valid-weasel-bits]

727. A class with a very long token (300K) causes the compiler to die.  
     [very-long-token]

728. Running es4 on a new project whose Ace specifies a precompiled library 
     and typing a control-C as soon as es4 announces that it is
     retrieving the precompiled information causes it to repeatedly
     print a PANIC CASCADE message.  Es4 uses up more and more memory
     until you kill the process via "kill -9".  Presumably, it would
     eventually run out of memory.

729. Finalizing a system with `assertion (all)' specified in the Ace
     when precompiled EiffelBase is used produces C code which won't link.  
     NOTE: Test cannot be automated because can't tell EiffelWeasel
     to keep assertions in final mode.
     SECOND NOTE: EiffelWeasel has been enhanced with compile_final_keep
     instruction and test has now been automated.
     [finalize-precomp-assertion-all]

730. A routine has a call to `equal' where both operands are bit
     constants which are all zeroes and the second operand is `0B'.
     The call incorrectly returns false if the length of the first
     operand is 63 bits or greater.  [long-short-bits-not-equal]

731. A class with an attribute of type `expanded TUPLE' compiles when
     frozen but system execution ends with a panic.
     [freeze-expanded-tuple-attr]

732. A system has a deferred class with one attribute `weasel' and one
     deferred feature.  There is one effective descendant class which
     effects the deferred feature.  If the system is finalized, a
     reference to the attribute via `x: PARENT; !CHILD!x; i := x.weasel'
     is not statically bound, though it should be.
     [finalize-attr-dynamic-binding]

733. A routine with an integer divide-by-zero terminates the program
     with "Arithmetic Exception" and no exception trace.  The rescue
     clause is not executed.  Melted code executes rescue clause once
     and then prints "Floating exception" and
     terminates. [rescue-floating-exception]

734. A class has a routine which repeatedly creates a manifest array,
     each of whose elements is `strip ()'.  The class has one
     attribute, of type ARRAY [ANY].  Executing the system results in a
     run-time panic.  Reducing the number of "strip ()" elements below
     49 or turning off garbage collection allows the system to execute
     correctly for a huge number of iterations.  [manifest-array-of-strip]
     
735. When an inheritance clause is deleted, a former CHILD class no
     longer conforms to PARENT.  This introduces a violation of the
     Redeclaration rule (VDRD), but the compiler does not detect it.
     [vdrd-sneak]

736. A class inherits an external routine and tries to redefine it, but
     includes some locals in the redefined external routine.  The
     compiler catches the VRRR(2) error.  Then the parent version is
     changed to a deferred feature and the child version is changed to a
     non-external routine.  When compilation is resumed, the compiler
     terminates silently after pass 2 on the parent class.
     [redef-external-chg-to-effect]

737. A class has routines which take an argument of type INTEGER, REAL,
     DOUBLE or ANY and calls to these routines passing an INTEGER. REAL
     or DOUBLE constant or variable.  After initial compilation where
     the system is frozen, formal argument types are change to a more
     general type (e.g., INTEGER is changed to REAL or DOUBLE or ANY,
     etc).  When changes are melted, system execution produces the
     wrong output and then a segmentation fault.
     [change-numeric-formal-argument]
   
738. After initial compilation, a VEEN error is introduced by changing
     an identifier in a class invariant.  When the compiler detects it,
     the error is removed and compilation resumes and finishes normally.
     But a subsequent attempt to freeze the system with no further changes
     causes the compiler to die.  [add-remove-veen-freeze]
   
739. After initial compilation, the inheritance clause in a class used
     in a formal generic constraint is changed, introducing a VTCG
     error.  When the system is recompiled, the compiler does not
     detect the error.  [vtcg-weasel]

740. After initial compilation where the system is frozen, an inherited
     external BOOLEAN function is changed to an internal BOOLEAN
     function and changes are melted.  System execution then ends with a
     run-time panic which states "invalid assertion level".  The problem
     does not occur if the routine which gets modified is introduced
     directly in the class which calls it, instead of appearing in an
     heir.  [chg-external-to-internal]
   
741. After initial compilation where the system is frozen, an entity
     name in a postcondition is changed to the name of a nonexistent
     entity.  When the compiler reports the VEEN error, the entity name
     is changed back to its original value and compilation completes.
     But execution of the resulting system ends with a run-time panic
     which states "invalid assertion level".
     [postcondition-veen-then-restore]
   
742. After initial compilation where the system is melted, an entity
     name in a class invariant is changed to the name of a nonexistent
     entity.  When the compiler reports the VEEN error, the entity name
     is changed back to its original value and compilation completes.
     But execution of the resulting system, which was compiled with
     `assertion (all)', does not monitor class invariants.  It does
     monitor all other assertions.  [invariant-veen-skip-invariant]
   
743. After initial compilation where the system is frozen, an inherited
     internal INTEGER function with no arguments is changed to an INTEGER
     constant and changes are melted.  System execution then ends with a
     run-time panic which states "invalid assertion level".
     [chg-argless-func-to-constant]
   
744. A call to a routine which is implemented as an infix operator
     sometimes gives the wrong results when the formal argument is of a
     heavier type than the actual argument (e.g., formal is DOUBLE and
     actual is REAL).  Also, in some cases passing a REAL to a REAL
     formal argument does not give correct results.  In some cases,
     frozen and melted code give different results.
     [infix-integer-real-double]
   
746. A routine's precondition calls a routine which raises an exception
     and then retries and succeeds.  After freezing, system execution
     works correctly except that after the last instruction of the root
     creation procedure is executed system execution ends with a
     segmentation fault.  Melted code works fine. 
     [frozen-retried-precondition]

747. A system has a routine with a delayed call expression for a
     deferred routine.  When the system is finalized with inlining,
     system execution produces incorrect output (actually, a 
     segmentation fault). [finalize-delayed-deferred-call]

748. Null characters (%U) are dropped from a manifest string.
     (Execution ends with a panic if system is melted).
     [null-char-in-string]

749. An actual argument of type INTEGER is not converted correctly when
     passed to a routine whose corresponding argument is of type DOUBLE,
     but only when the called routine is an infix operator feature.
     [wrong-oper-int-convert]

751. A class does a comparison INTEGER_REF > INTEGER.  This should be
     legal, since INTEGER conforms to INTEGER_REF, and the compiler
     accepts it.  But executing the system results in an exception
     trace (segmentation fault or bus error).  Same thing for REALs,
     DOUBLEs and CHARACTERs.  [integer-ref-gt-integer]

752. A class has two attributes of type `expanded TEST1 [STRING]'.
     TEST1 is a generic class with parent `ARRAY [expanded TEST1 [G]]'.
     The system compiles fine, but dies with an exception trace when
     executed.  Turning off garbage collection allows the program to
     run correctly.  [inherit-array-of-expanded]

753. A class creates an ARRAY [BIT 32] and fills it with elements of
     type BIT 32.  Executing the system results in a run-time panic if
     the size of the array is big enough (approximately 4500), but only
     if garbage collection is on.  If garbage collection is off, a
     500_000 element array works fine.  [big-array-of-bit]

755. A class with one attribute, which is of type LINKED_LIST [STRING],
     repeatedly calls `strip ()' and checks the result.  The system
     compiles fine, but executing it yields some `strip' result arrays
     whose first element does not conform to LINKED_LIST [STRING].
     Trying to print the offending first element terminates system
     execution with an illegal instruction.  [strip-bad-linked-list]

756. A class with a routine that has a single instruction 
     `io.put_character ('%/255/')' compiles fine but dies with
     an exception trace indicating I/O error when executed.
     [put-character-255]

757. Finalizing a system with a delayed call and specifying `inlining (yes)'
     causes compiler to die.  [finalize-inline-delayed-call]

758. A function whose return type is an expanded type has a local of
     this return type and body `Result := x'.  When the system is
     finalized, the code generated for the routine won't compile.
     [finalize-expanded-return-type]

759. A function takes a BIT argument and just returns its argument.
     When the system is finalized, the code generated for the routine
     won't compile.  [finalize-bit-return-type]

760. When a system with a VTCG error (creation procedure named in constraint
     does not exist) is compiled, the compiler detects the error.
     However, when the system is melted again to resume compilation,
     the compiler dies. [vtcg-creator-try-again]

761. After initial compilation where a system is finalized, an attribute
     is moved to a parent class and the parent's name is changed to
     the child's name (child is renamed to something unused).
     When the system is recompiled, the compiler dies.
     [finalize-move-attribute]

762. A Generate or External clause in the Ace which names the valid
     language `C' or `c' causes the compiler to report a VD33 or VD34
     error (respectively), but only if the language name is enclosed in
     double quotes.  [quoted-gen-or-ext-language-name]

763. An Ace with a "use" file containing the single line `system test
     root TEST1 end' causes the compiler to terminate with a
     segmentation fault during degree 6.  [use-file-containing-ace]

764. A function whose return type is NONE and which references the
     predefined entity Result is reported to violate the Entity
     rule (VEEN(2)).  [result-in-none-func]

765. The expression `old Void' should be accepted in a postcondition,
     but the compiler reports a VAOL(2) error.  [old-void]

766. The expression `f = Void', where `f' is a procedure, violates VKCN
     but the compiler accepts it.  If the system is being frozen, the
     compiler terminates during degree -2.  [compare-procedure-to-void]

767. Putting a procedure call (rather than a function call) as an element
     in a tuple causes the compiler to die in degree -1 if system is being
     frozen.  Melting is successful, but executing the resulting system
     gives an "operational stack botched" error.  Seems like there is a
     missing validity constraint. [procedure-in-tuple]

768. A class calls a function which takes an argument of type `ARRAY
     [BIT 500]', passing as actual argument a manifest array of bit
     constants which are each only 1 bit long.  After initial
     compilation where the system is frozen, the return type of the
     function is changed from `BIT 2000' to `BIT 2100' and changes are
     melted.  System execution then ends with a "bit copy panic (void
     source)" run-time panic.  [short-manifest-bit-array-arg]

769. A once function which calls itself before setting Result reveals
     that Result is not properly initialized, but only if system
     is melted.  Frozen and finalized code work as expected.
     [once-result-uninitialized]

770. An external routine implemented as a C macro is redefined in two
     descendants.  For a call to the routine which cannot be statically
     bound, incorrect C code is generated if the system is finalized
     (the `()' after the function call is omitted).
     [finalize-redef-external-macro]

771. A class which repeatedly extends an ARRAYED_LIST [X], where `X' is
     an expanded type, compiles fine.  When it is executed, it quickly
     dies with a segmentation fault in `auto_resize'.
     [auto-resize-exp-arrayed-list]

772. A system creates an ARRAY [BIT 32] and tries to print item 1
     without putting any items in the array.  It compiles fine, but
     dies with a run-time panic when executed (bit copy panic).
     [bit-copy-panic-void-source]
   
773. A class with a generic creation which omits the constraint
     (e.g., TEST1 [G create make end]) causes the compiler to die in
     degree 4. [generic-creation-no-constraint]
    
774. A reference to the delayed call expression "{NONE}~weasel"
     causes the compiler to die in degree 3. [none-delayed-call]
    
775. A deferred class which constructs a delayed call on a deferred
     routine compiles fine when finalized, but the generated C code 
     won't compile when dead code removal is turned off.
     [finalize-deferred-delayed-call]

776. A class with the inheritance clause `inherit GENERAL' should have
     ANY added implicitly as an ancestor, thereby making the features
     of PLATFORM accessible, but it does not. [inherit-any-not-ancestor]
     [Retired because class GENERAL has been eliminated].

777. A class with an explicit creation type in a creation expression
     that appears in the class invariant causes compiler to report
     a VGCC(5) error. [invariant-creation-expr]  [Test was wrong -
     it has been corrected and passes].

778. Dragging the formal generic parameter G from the inheritance
     clause for RESIZABLE in class ARRAY (when class is in Text format)
     into a Shell Hole, the Stop Points hole or the Clear Stop Points
     hole causes ebench to die with a segmentation fault.
     [ebench-drop-formal-generic]

779. Putting a stop on the routines of a class, removing all references
     to the class in the only class that references it and then
     recompiling causes ebench to die with a segmentation fault.
     Now the problem happens when select Clickable format in class tool.
     [ebench-remove-stopped-class]

780. Putting a stop on a routine and then changing it to an attribute
     and recompiling causes ebench to die with a segmentation fault.
     [ebench-stopped-routine-attribute]

781. Putting a stop on an routine and then changing it to a deferred
     routine or to an external routine and recompiling causes ebench to
     die with a segmentation fault.  [ebench-stopped-routine-deferred]

782. Start ebench and freeze a system with a root class whose creation
     procedure body is `try1; try2'.  Drag `try1' into Stop Points hole.
     Click on Step button.  Stops at first instruction of `try1'.  While
     stopped there, set a stop point on the call to `try2' in root
     creation procedure.  Click on either Run or Step button.
     Application terminates instead of stopping on Stop point.
     [debugger-skip-explicit-stop]
   
783. Run EiffelWeasel on `external-feature-address' using -k option.
     Change to project directory used for test and start ebench.  Start
     feature tool on `make' from TEST.  Set stop point on first
     instruction.  Click on Run twice.  Program gets "illegal access to
     Current" run-time panic.  Retired because compiler now reports
     a NOT_SUPPORTED validity error instead of accepting the class.
     [debugger-illegal-access-to-current]
   
784. Under certain unreproducible circumstances involving incremental
     changes (melting and freezing), a system gets into a state where
     the debugger will stop at a stop point but displays `Void' as the
     name of the feature in which it is stopped.  Retired because not
     reproducible (and probably fixed in new debugger).  [debugger-void-stop]
   
785. Putting a stop point on `capacity' from STRING and all the routines
     of a simple class causes the debugger to hang.  It says system is
     running, but no CPU is used and execution does not progress.
     Clicking on Execution Status then terminates ebench with a
     segmentation fault.  For release 4.2 on Solaris, these symptoms
     don't happen but the program being run gets a segmentation fault
     although it appears to be valid.  Appears to be fixed with new
     debugger in 5.0.015. [string-capacity-debugger-hangs]
   
786. A compilation followed by a sequence of setting and clearing break
     points and stepping a program causes ebench to terminate with a
     "byte code botched" panic.  Appears to be fixed with new debugger
     in 5.0.015. [debugger-byte-code-botched]
   
787. A class which undefines `default_rescue' and then
     tries to print $default_rescue generates C code which won't compile
     when system is frozen or finalized.  [address-of-default-rescue]

788. If the Project tool window is on far right side of screen,
     selecting the Windows menu, then choosing a menu item which has a
     submenu by clicking on the right side of it (near the arrow
     indicating that there is a submenu) can cause selection of the
     first item on the submenu, which is not what was intended.  This
     happens if the submenu's first item overlaps the parent menu item.
     This also happens with other menu items that indicate submenus.
     [ebench-menu-overlap-problem]

789. When stopped in the debugger, right clicking twice on the dots at
     the beginning of a call stack entry to move down the call stack
     and then putting a stop on one of the instructions of the routine
     displayed in the debugger feature window causes incorrect display
     of that feature.  [ebench-debugger-down-stack]
     
790. Start ebench.  Compile a class TEST with a syntax error.  When
     error is reported, start Class tool on TEST.  Select Special menu,
     then Stoppable.  Ebench dies with segmentation fault.
     [ebench-error-special-stoppable]

791. After initial compilation where the system is melted, a deferred
     routine effected by an attribute is changed to a constant
     attribute.  When the VMFN error is reported, it is changed back
     to a deferred routine and compilation finishes normally.  Then a
     new class with a deferred version of the routine is inherited and
     called with dynamic type Current.  After changes are melted,
     execution ends with a segmentation fault.
     [vmfn-new-deferred-ancestor]
   
792. After initial compilation where a system with an attribute of
     type `expanded TUPLE' is frozen, the system is finalized with no
     changes.  The compiler dies in degree -2 with a panic in
     `server_item' from FEAT_TBL_SERVER. [freeze-expanded-finalize]
     Test does not fail with EiffelWeasel, but can reproduce manually 
     in /marten/yyyy:
	1. cd /marten/yyyy
	   echo $EIFFEL5 
		/home/eiffel/Eiffel5.0.016
	   echo $PLATFORM 
		solaris-2.5+
	   which ec
		/home/eiffel/Eiffel5.0.016/bench/spec/solaris-2.5+/bin/ec
	2. Using test.e and test.ace (shown below):
		ec -ace test.ace -freeze
	3. cd EIFGENs/test/W_code
	4. finish_freezing
	5. cd /marten/yyyy
	6. ec -project test.epr -finalize   [compiler dies]
     [Appears to be fixed.  Not reproducible in 5.0.020]

793. After initial compilation where the system is melted, a constant
     attribute is changed to a variable attribute and the system is
     frozen.  The resulting C code compiles, but will not link due to
     undefined symbols.  [make-const-variable-freeze]
    
794. After initial compilation where the system is melted, a constant
     attribute is changed to a variable attribute and changes are
     melted.  Then the variable attribute is changed to a function with
     no arguments and changes are melted.  System execution then ends
     with a segmentation fault.  [constant-variable-function]
   
795. A call to an infix operator feature which passes `$x' as its second
     argument (e.g., `Current @ $x') should be legal, but the compiler
     reports a syntax error.  [infix-pass-feature-address]

796. After initial compilation where the system is finalized, a once
     routine is changed to a normal routine (non-once) and the system is
     re-finalized.  The resulting C code will not compile.
     [change-once-to-do]
   
797. The creation procedure of the root class repeatedly calls another
     routine, which has a rescue clause.  This latter routine has a
     qualified call of an exported feature in a class which has a class
     invariant.  If assertion level `ensure' is specified for the class
     with the invariant, system execution appears to continue
     indefinitely, as it should.  If assertion level `invariant' is
     specified *and* the class invariant is violated, system execution
     quickly ends with a panic.  Also, once the class invariant is
     violated, it is never checked again.  [class-invariant-fail-panic]

798. A generic class which inherits from ARRAY [Generic #2] and ANY
     causes the compiler to terminate with the tag "Compiler error".
     If the inheritance is from ARRAY [Generic #1], the compiler
     correctly reports a VMFN error instead of dying.
     In 5.0.020, test passes EiffelWeasel but output includes
     "Exception occurred while displaying error message.
      Please contact ISE to report this bug."
     [inherit-generic-and-any]
    
799. A class with an external routine whose language is "C++"
     causes the compiler to die in `external_name'.
     [external-c-plus-plus]
    
800. A sequence of changes causes the compiler to die with a
     segmentation fault in `byte_node'.  [byte-node-disaster]

801. A sequence of changes tricks the compiler into accepting a class
     with a VXRC error.  If the system is compiled from scratch the
     compiler detects the error.  [vxrc-sneak]

802. A sequence of changes where system is melted several times,
     with various errors but with no external or deferred routines
     involved, causes the compiler to die with a segmentation fault in
     `set_has_loop'.  [set-has-loop-disaster]

805. An Ace file with a recursive sub-cluster specification 
     "all root_cluster (xxx)" where xxx is never defined causes
     compiler to die with a segmentation fault in
     `expand_recursive_clust' instead of reporting a VD51 error. 
     [recursive-cluster-bad-parent]
    
806. A system has a class with an external routine and another class
     which inherits the first class and undefines the external
     routine.  There is also a call to the undefined version of the
     external routine (which cannot work at run-time, of course).
     When the system is finalized, the generated C code won't compile.
     (Note: compiler now prohibits undefining an external routine -
     reports VDUS(2) error). [finalize-call-undef-external]

807. Constraint VDRD(7) prohibits redefining an external routine as an
     internal one or conversely.  But a class which circumvents this
     prohibition by first undefining the external routine is accepted
     by the compiler.  The resulting system dies with a run-time panic
     when executed.  (Note: compiler now prohibits undefining an
     external routine - reports VDUS(2) error). 
     [undefine-external-make-internal]

808. An invalid type used as actual generic parameter in an explicit
     type in a creation instruction should cause the compiler to report
     a VTEC or VTCG error, but it does not.  [creation-bad-actual-generic]

809. A routine has explicit creation instruction with an invalid actual
     generic parameter.  The creation procedure of the generic class
     takes an argument of type `G' where `G' is the name of the formal
     generic parameter.  The compiler should report a VTCG error, but
     it does not.  Compilation ends prematurely with a segmentation
     fault.  [explicit-creation-bad-generic]

810. A generic class TEST1 [G -> TEST2] with an attribute `s: G' has a creation
     instruction `!TEST2!s.make'.  The compiler should report a VGCC(3)
     error but does not.  The generated code acts as if the creation
     instruction was `!!s.make'.  [nonconforming-generic-creation]

811. An invalid type used as actual generic parameters in an explicit type
     in a creation expression or an agent expression should cause the
     compiler to report a VTCG error, but it does not.
     [agent-bad-actual-generic]

812. A sequence of changes where system is melted several times,
     with varying versions of a routine (external, deferred, once)
     moved back and forth between two classes and with several errors
     along the way (VXRC, VDRD(7), VMFN, EXT_SAME_SIGN) causes the
     compiler to die with a segmentation fault in `set_has_loop'.
     [external-routine-madness]

813. After initial compilation where the system is melted, a parent
     class is added to the root class.  This parent has a deferred
     version of a feature effected by the root class and the deferred
     feature has a precondition and postcondition.  When changes are
     melted, executing the system does not execute the precondition or
     postcondition but it should. [add-inherited-assertions]
   
814. Executing a system which assigns an INTEGER_8, INTEGER_16 or INTEGER_64
     variable to itself results in an "unknown entity type" run-time panic,
     if the system is melted.  Frozen code works correctly.
     [melted-short-integers]

815. A class has attributes of a generic type using INTEGER_8
     as actual generic parameter.  The generic class has a routine that
     prints the generating type of its single generic attribute.  When
     code is frozen or finalized, the generating type displayed is
     INTEGER instead of INTEGER_8.  Melted code works
     correctly. [integer-8-generating-type]

816. A prefix operator which is implemented as an variable integer
     attribute compiles fine (whether freezing or not).  But when the
     resulting system is executed and tries to print the value of the
     attribute, an exception trace results.
     [prefix-oper-attribute]

817. A class with a feature of type ARRAY [BIT n] causes the compiler to
     silently terminate while freezing when `n' is very large
     (250_000_000 on my machine).  [array-of-big-bit]

818. Finalizing a system with a class which has a prefix operator
     implemented as a variable attribute causes the compiler to die
     during degree -3 on the class.  [finalize-prefix-attribute]

819. A class that undefines an inherited external routine and then
     effects it with an internal routine that calls precursor causes
     the compiler to die in degree 3.  (Note: compiler now prohibits
     undefining an external routine - reports VDUS(2) error).
     [undef-external-call-precursor]
    
821. A generic class which prints $x and $y, where x and y are attributes
     of a generic type, generates C code which won't compile when system
     is frozen or finalized.  [address-of-generic-attribute]

822. Finalizing a system with a call to a prefix feature which is
     an inherited integer constant generates C code which won't link if
     system is finalized, whether inlining or not.
     [finalize-prefix-constant]

823. Finalizing a particular large system with over 600 classes causes the 
     compiler to die with a "no such file or directory" error in
     SERVER_FILE.  This is a real system, not a torture test.  This is a
     very serious bug that MUST BE FIXED before release.
     [finalize-missing-server-file]

824. A creation instruction with an explicit creation type which is a
     BIT type with (what looks like) a constant attribute expressing the
     number of bits in the BIT type is rejected as a VGCC(3) error,
     even if the type exactly matches the declared type of the target. 
     [bit-creation-type]

825. Start ebench.  Compile a root class TEST which inherits from
     itself.  When VHPR error is reported, start Class Tool on TEST.
     Select Flat format (or any of several other formats).  Ebench dies.
     [ebench-flat-inheritance-cycle]

826. Start ebench.  Click on OK.  Click on Melt.  Select Ace file and
     compile a system with a non-generic class.  Start a Class tool on
     this class.  Change class to a generic class.  Melt.  The text in
     the Class tool is changed so that it is correct but no other
     formats can be selected.  The title bar still shows the class as a
     non-generic class and says "(not in system)".  One has to click on the
     Class synchronization button in the upper left corner to fix it.
     [ebench-make-class-generic]

827. Start ebench.  Melt system with routines "make" and "try".  Bring
     up Feature tool on "try".  Change class to remove "try".  Melt
     again.  While compilation is going on, drag "try" into Stop Points
     hole.  Ebench dies.  [ebench-stop-nonexistent-routine]

828. The flat form of an attribute `a' (obtained via Flat format in
     Feature tool) or via `flat CLASS a ASCII' from es4 -loop) includes
     the associated comment if the containing class is precompiled, but
     does not include this comment if the class is not precompiled.
     Also, it seems that in text format the comment is only shown with
     the attribute (whether class is precompiled or not) if attribute
     declaration does not end with a semicolon.
     [ebench-drop-attribute-comment]

829. A deep call stack (200 routine names or more) is not displayed
     correctly.  If the call stack is exactly 200 routines deep, only
     the top routine on the stack is shown.  It appears that every 200th
     routine deep, the call stack display is truncated to one entry and
     then allowed to grow up to 200 again.  [debugger-deep-call-stack]
   
830. For a class invariant violation, the debugger displays a different
     exception trace than the one produced when the program is run from
     the command line.  The top entry of the exception trace is missing.
     In 5.0.015, ebench dies when I try to execute the system with
     the invariant violation. [debugger-invariant-bad-call-stack]
   
831. Starting an Object tool on an object with an attribute of type BIT
     600 and then ending run causes ebench to die with a segmentation
     fault.  Now it doesn't die, but the object is not displayed properly
     (funny characters near the end).  In 5.0.015, debugger won't
     stop and program produces no output, though it should.
     [debugger-examine-bit-object]
   
832. After initial compilation, the entire contents of the Ace file
     is deleted so that it is a completely empty file, except for some
     comments.  When the system is recompiled, the compiler detects the
     Ace syntax error.  But when compilation is resumed, the compiler
     accepts the invalid Ace file.  [melt-then-empty-ace]

833. After initial compilation, a syntax error is added to the Ace file.
     The compiler detects the syntax error.  But when compilation is
     resumed, the compiler accepts the Ace file even though the syntax
     error is still there.  [resume-ace-syntax-error]

834. A system whose Ace file specifies `dynamic_runtime (yes)'
     generates a Makefile with a wrong library name, so C code won't
     link for frozen or finalized case.  The ".so" suffix is missing on
     Solaris platform.  [dynamic-runtime-bad-library]

836. A system has a deferred class with one feature `weasel' and one
     effective descendant class which effects the feature.  If the
     system is finalized, a call to this feature via `x: PARENT;
     !CHILD!x; x.weasel' is not statically bound, though it should be.
     [finalize-no-static-binding]

837. After initial compilation, the root creation procedure is changed
     from `make is do end' to `make (args: ARRAY [STRING]) is do end'
     and changes are melted.  System execution then ends with a
     segmentation fault.  [add-root-creation-arg]
   
838. A system involving several generic derivations has an
     assignment attempt.  A call `a2.f' works before the assignment
     attempt, but the same call fails after the instruction `a ?= a2'
     where a2 is the source of the assignment attempt.
     [assign-attempt-affects-source]

839. A creation instruction with an explicit creation type `BIT Weasel'
     where Weasel is not defined causes compiler to report VGCC(3)
     instead of VEEN error.  (Note: compiler used to die).
     [explicit-bit-creation]

840. A sequence of changes where a rescue clause is added to 
     external routines, then removed and routines are made
     deferred causes the compiler to die with a segmentation
     fault in `has_rescue'.  [missing-rescue-clause]

841. A manifest array with one element of type INTEGER should conform to
     ANY, but the compiler reports a VJAR violation.  ETL pages 219, 393.
     [manifest-array-conform]

842. A routine with a precondition which has a function call that
     references a secret argument violates VAPE, but the compiler
     accepts it.  [secret-func-arg-in-precondition]

843. An exported routine has a precondition `a.b'.  Feature `b' is not
     available to all classes so the compiler should report a VAPE
     error but it does not.  [precond-call-chain-vape]

844. A system has a generic class CLIENT with constraint `G -> SUPPLIER create
     make end', where the creation procedure of SUPPLIER is exported to
     {CLIENT}.  If another class has an attribute `x: CLIENT
     [SUPPLIER]' the compiler reports a VTCG error, though it should
     accept the classes.  [restricted-creation-wrong-vtcg]

845. A class which calls a feature on the manifest array target 
     `<< << "weasel" >> >>' causes termination of the compiler during
     pass 3 on the class.  [nested-manifest-array-feat-call]

846. After initial compilation with an invalid type `expanded STRING'
     as an actual generic parameter, the type is changed to STRING.
     Finalization completes normally, but the resulting C code will not
     compile.  [invalid-expanded-generic]
   
847. A routine with an insufficiently exported entity in a precondition
     violates VAPE, but the compiler accepts it.  It appears that the
     compiler accepts any case where both the routine with the
     precondition and the entity referenced in the precondition have an
     export restriction and the entity is not completely secret.
     [precondition-too-secret]

848. A routine with an insufficiently exported entity in a precondition
     violates VAPE.  The compiler accepts it, but only if the entity
     Current is explicitly involved and the entity is an operator
     feature (e.g. as `Current + value').  [vape-involving-current]

849. An assignment `b := a.new_b' in a generic class `C [G -> A]',
     where a is of type A, b is of type B [G] and new_b is of type `B
     [like Current]' should be accepted because the type of `a.new_b'
     is effectively B [G], but the compiler reports a VJAR
     error. [generic-like-current-vjar]
    
850. After initial compilation where the system is melted, a generic
     class header is changed so that it is expanded and the system is
     frozen.  The resulting C code compiles, but will not link due to
     multiply defined symbols.  [make-generic-expanded-freeze]
   
851. After initial compilation, a redefined `default_create' with
     an empty body is changed so that the body has an instruction.
     After recompilation, the new version of `default_create' should be
     executed but is not.  [default-create-add-body]

852. A system has a cluster "base", whose path name contains and
     environment variable enclosed in braces, and a subcluster of "base".
     After initial compilation, the date of modification of the Ace file
     is changed without changing the file's contents.  When the system
     is recompiled, the compiler reports a bogus VD01 error.
     [env-in-braces-bogus-vd01]

853. A routine has a precondition.  The body of the routine raises an
     exception which is retried by the rescue clause.  When precondition
     are monitored and the system is melted, the routine precondition is
     incorrectly evaluated again when the retry instruction is executed.
     Frozen code works correctly.  [eval-precondition-when-retry]

854. A class creates an instance of INTERNAL and uses it to print the
     field count of the current object.  The system compiles fine
     when frozen and correctly prints 0 when executed.  Then an
     attribute is added to the class and changes are melted.
     System execution then incorrectly still prints 0, instead of 1.
     [wrong-field-count]
   
855. A system has a routine with a call to a procedure that takes
     an argument of type NONE and clones it.  When the system is
     finalized with inlining, the compiler dies.
     [finalize-inline-none-proc]

856. An exception is raised in a routine which is being called as part
     of the evaluation of an assertion.  The routine handles the
     exception itself and retries it.  Subsequent calls from the
     "retrying" invocation of the routine monitor assertions, but
     should not.  [retry-forget-in-assertion]

857. A class declares a local of type `FOO [expanded DOUBLE]' where FOO
     is a generic class with a single formal generic parameter
     constrained by DOUBLE.  A routine of the generic class assigns
     something of type `Generic #1' to something of type DOUBLE.  The
     system compiles fine, but dies with an "illegal metamorphose type"
     panic when executed.  If the system is frozen, the C code for the
     generic class won't compile.  [generic-constrained-by-double]

858. INTEGER_64 numbers do not work correctly or maybe they just don't
     print correctly. [print-integer64]

859. A routine calls `s.replace_substring (s, 4, 6)' to replace a portion
     of itself with its original value.  The replace_substring call
     does gives the wrong result.  [replace-substring-with-self]

860. A call to `print (0x12345081234567)' does not print the correct
     answer.  It prints -1 on Solaris and -2128394905 on Windows.
     [print-big-constant]

861. A routine in class A does an assignment attempt whose target is an 
     attribute of type B and is the routine's class.  A descendant A1
     of class A redefines the type of the attribute to be a descendant
     of B.  When the routine is executed in A1 with a passed-in
     argument that is used as the source of the assignment attempt, it
     incorrectly allows the assignment attempt to succeed.
     [assign-attempt-redefined-type]

862. A call `b.to_integer' where `b' is of type BOOLEAN compiles
     fine when melted, but executing the system results in an "Illegal
     cast operation" panic.  Frozen code works
     correctly. [melted-boolean-to-integer]
   
863. Negative INTEGER_8 values do not print correctly on some architectures.
     [negative-integer-8]

864. A class which prints `(<< t >>).item (1)', where `t' is of a
     non-basic expanded type compiles fine when melted, but system
     execution ends with a segmentation fault.  Frozen code does not
     die, but the output is wrong (doesn't print anything).
     [expanded-manifest-array-item]

865. A generic class `C [G]' has a function `f: LIST [C [G]]'
     and also has a feature `item: G'.  A descendant class redefines
     the function so that its signature is `f: LIST [C [like item]]'
     and it calls Precursor.  The compiler dies in degree 3 when
     compiling the system.  [generic-anchor-call-precursor]

866. A class with the instruction `j := 32 \\ i' where `j' is of type
     INTEGER causes the compiler to report a VWOE error.
     [vwoe-on-integer-remainder]
     
867. If the Ace specifies a precompiled library that is an incompatible
    version, the compiler correctly reports a VD52 error.  But it also
    prints "Exception occurred while displaying error message" when
    reporting the error message.  [precomp-lib-wrong-version]

868. A system is frozen without a precompiled library.  Then an
     instruction `print ((<<int64, int64>>).item (1));' is added to the
     body of the root creation procedure and changes are melted. System
     execution then dies with a precondition violation
     (index_small_enough), though it should not.
     [freeze-print-int64-array]
    
869. A system which calls POINTER.memory_copy as passes $double_value
     (address of a double) compiles fine when melted, but dies with a
     segmentation fault when executed.  Frozen code works
     correctly. [melted-memory-copy]
   
870. Routine `is_integer' from STRING accepts `(+|-)[a-zA-Z]*[0-9]*'
     which is incorrect (for example, returns True for
     `("-wer123").is_integer'.  [is-integer-accepts-invalid]
    
871. A call to a static feature `feature {FOO}.value' causes the compiler
     to die with a segmentation fault if FOO is a generic class that
     contains a constant integer feature `value'.
     [generic-static-constant]
    
872. A system is finalized and assertions are discarded, using the
     command line compiler.  When the system is re-finalized while
     keeping assertions, no new C code is generated so system execution
     does not monitor assertions.  [refinalize-with-assertions]

873. Freezing a system which calls a feature `r: REAL is 64.0'
     generates C code that won't compile.
     [frozen-real-constant]
    
874. A system has a routine that prints its argument, where the type of
     the argument is `ARRAY [like item]' and item is `item: X [like
     toto]' where `toto' is of type A.  When the system is finalized,
     the compiler dies during degree -3.
     [print-array-anchored-generic]

875. Melting a system which evalutes `item >= feature {CHARACTER}.Max_value' 
     where `item' is of type INTEGER works fine, but when the system is
     executed it dies with a panic.  Frozen code works fine.
     [melted-integer-compare]
   
876. After initial compilation, a constrained generic parameter is added 
     to root class with unknown actual generic in constraint.  When VTCT
     error is corrected, VCFG error is reported since parameter has same
     name as a class.  When it is fixed there is a VSRC(1) error since
     root class cannot be generic.  After this is corrected, compilation
     dies in degree 1.  [vtct-vcfg-vsrc-die]
   
877. After initial compilation, the creation clause in root class is
     removed, introducing a VD27 error.  Then a generic parameter is
     added to root class and later removed.  Finally, the VD27 error is
     removed.  The compiler dies in degree 4 with a run-time panic.
     [alternate-vd27-and-vsrc]
   
878. After initial compilation where the system is finalized,
     the Ace is changed to indicate a new root class and changes are
     melted.  Execution of the melted system then executes the old root
     creation procedure instead of the new one.  Note: this only
     happens in ebench, where changes are melted in the same session as
     the initial finalization.  It does not happen with two separate
     invocations of the command line compiler.  Second note: In 5.0.031,
     the melt does not generate any executable system. [finalize-then-melt]
   
879. Finalizing a system with a class which has a call to an infix operator
     which is an external routine causes the compiler to die
     during degree -3 on the class, but only if inlining (yes) is
     specified.  [finalize-inline-infix-external]

880. Melting a system which evalutes `x < x' where x is of type WIDE_CHARACTER
     works fine, but when the system is executed it dies with an
     operational stack botched panic.  Frozen and finalized code work
     fine.  [wide-char-comparison]
     [Retired because class WIDE_CHARACTER is now obsolete]
   
881. A system with an Ace file that uses a precompiled library compiles
     fine if the path name of the precompiled library uses environment
     variables, but the compiler issues a bogus VD43 warning at the
     end of compilation.  [bogus-vd43]

882. An when clause of an inspect instruction does not work
     correctly if the constant is of type CHARACTER and is > '%/127/.
     [inspect-high-bit-char]

883. An assignment attempt `a ?= << <<"A","1">> , <<"B","2">> >>'
     where `a' is of type ANY causes the compiler to crash.  
     [assign-attempt-manifest-array]

884. A class that copies a string whose count and capacity are 10 into
     a string whose capacity is 9 causes violation of invariant with tag
     `valid_count'.  [string-copy-valid-count]

885. A class with a particular nested if causes the compiler to crash
     when the system is finalized.  [finalize-nested-if]

886. A redefinition of a routine with no postcondition uses just
     "ensure" for its postcondition, rather than "ensure then".
     The compiler accepts it instead of reporting a VDRD(3) error.
     [vdrd3-ensure-then]
    
887. After initial compilation where the system is frozen, a class that
     prints the value of a boolean constant, which is False, works
     correctly.  When the constant value is changed to True and system
     refrozen, the correct value is still printed.  Then the system is
     finalized and execution prints False.  Similar problem for reals
     and doubles.  [freeze-const-freeze-finalize]
    
888. The creation procedure of a class assigns Void to the attribute to
     which the creation procedure is being applied (by the root creation
     procedure).  Executing the system results in a segmentation fault,
     but only if the system is melted.  If non-Void value is assigned
     instead, the result is incorrect system execution output.
     [creation-proc-modify-target]

889. A creation instruction is applied to an entity (local or attribute)
     which is already attached to an object and the current value of the
     entity is passed to the creation procedure (e.g., !!x.make (x)).
     If the code is melted, the newly created object is passed to the
     creation procedure instead of the object to which the entity is
     attached before the creation instruction.  Frozen code works
     correctly.  [melted-creation-pass-target]

890. A class calls a feature that is a once function in another class, where 
     the target of the call is a creation expression.  The once
     function value is stated not be Void in the invariant of the
     second class.  If the system is melted, execution ends with an
     invariant violation.  Frozen code works correctly. 
     [invariant-melted-once-function]
   
891. A tuple composed of an integer and an expanded type works properly
     when melted, but not when frozen or finalized.  This appears to
     be a code generation bug. [tuple-expanded-and-integer]

892. Melted/frozen, finalized and finalized-with-inlining code
     give different results for some numerical operations (floor and
     ceiling), as well as in cases where a real must be converted to a
     double or an integer must be converted to a real.
     [numeric-discrepancies]

893. A class has an agent whose target is an expanded type, is non-Void
     and has no open operands.  The system compiles fine when frozen or
     finalized but dies with a "Feature call on Void target" exception
     when executed.  [agent-expanded-target]

894. A system involving several generic derivations prints out
     the generating type of an attribute as `ARRAY [B2 [STRING]]'
     instead of `ARRAY [B2 [C]]'.  [wrong-generating-type]

895. A class does an `independent_store' of an object that has
     two expanded attributes, then retrieves the previously stored
     object.  The values in the expanded attributes are incorrect after
     retrieval.  [store-expanded-retrieve-wrong]

896. A class does an `independent_store' of an object that has
     two expanded attributes, where each expanded object has an INTEGER
     attribute and another attribute of an expanded type.  Freezing the
     system works fine, but during execution when the stored object is
     retrieved, a floating point exception occurs.  Finalizing the
     system produces C code that won't compile.
     [store-expanded-retrieve-dies]

897. A system creates two objects of type ARRAY [X], where X is
     an expanded class with attributes.  The two objects should be
     deep_equal, but they are not.  [array-expanded-not-deep-equal]

898. A class does an `independent_store' of an object that has
     two expanded attributes, where each expanded object has an INTEGER
     attribute, another attribute of an expanded type and a third
     attribute that is an array of expanded.  Freezing the system works
     fine, but during execution the retrieved object is not deep_equal
     to the original stored object.  [retr-expanded-not-deep-equal]

899. A class creates a linked queue and puts two elements in it, then
     gets its linear representation.  When system is executed, it
     dies with a postcondition violation.
     [linked-queue-linear-rep]

900. A class that calls `is_special_any_type' on the dynamic type of
     the `area' of an ARRAY incorrectly returns False, but only if the
     class also contains an array whose elements are of an expanded
     type.  [is-special-any-type-lies]

901. If a class does an `independent_store' of an ARRAY [STRING] 
     whose count is more than 65536, GC memory is corrupted which later
     causes a crash.  [indep-store-big-array]

902. A once function is supposed to return the value computed thus far
     when called recursively, but doing a recursive call to a once
     function shows that a creation instruction whose target is Result
     incorrectly attaches the newly created object to Result before
     calling the named creation procedure.  [recursive-once-create-result]

903. A class which references `<< "weasel" >> @ 1' causes termination
     of the compiler during degree 3.  [manifest-array-at-sign]

904. A static call `feature {NONE}.value' causes the compiler to die
     with a segmentation fault in degree 3.  [static-call-on-none]

905. A class which inherits from CHAIN causes the compiler to
     die in degree 4.  [inherit-from-chain]

906. Procedure `default_create' is not called on all elements of a
     SPECIAL being created, when the elements are of an expanded type.
     [special-of-expanded]

907. Bug in generic conformance involving class with two constrained
     generic parameters. [generic-conformance-two-params]
    
908. An invalid expanded type used as actual generic parameter in an
     explicit type in a parent part in an inheritance clause should
     cause the compiler to report a VTEC error, but it does not.
     [inheritance-bad-actual-generic]

909. After initial compilation, an attribute of type STRING which is the
     anchor for another feature is changed to a procedure with no
     arguments.  When the system is recompiled, the compiler does not
     notice the newly introduced VTAT error.  [intro-vtat-attr-to-proc]

910. After initial compilation, an attribute used as an anchor in a type
     serving as actual generic parameter is changed to a procedure.
     When the system is recompiled, the compiler incorrectly reports a
     VTCG error (which is impossible since the involved generic class
     has no generic constraints) instead of a VTAT(1) error.
     [vtat1-called-vtcg]
   
911. A system with a class that has a C++ external is frozen.  Then
     the external feature is changed to a C external and the system is
     refrozen.  The resulting C code compiles, but will not link due to
     calling "cpp" to do the link instead of "gcc".  
     [change-cplusplus-to-c]
   
912. A system has a class B that inherits from class A and redefines
     a function into an attribute.  After the system is frozen, class B
     is changed so that it renames the function instead of redefining
     it, but it still includes the attribute that was the redefinition.
     When the system is refrozen, the resulting C code compiles, but
     will not link due to an undefined symbol.  [redefine-to-rename-refreeze]

913. Finalizing a system with `b or else True' and keeping assertions, 
     where b is a boolean in a system with a postcondition `ensure b'
     produces code that violates the postcondition.  [finalize-or-else-true]

914. A routine prints the value of `x * x', where `x' is a DOUBLE constant.
     If the system is finalized, the wrong value is printed.  Melted and
     frozen code work fine.  [finalize-mult-double-constant]

915. A class which redefines a feature of type `REAL' to be of type
     `expanded REAL' is reported to violate VDRD(2).  ETL page 226.
     [expanded-redeclaration]

916. A real number 5_000_000.5 is read as 5 by the lexical analyzer.
     [real-const-with-underscores]

917. A generic class with the header
     "class TEST2 [G -> INTEGER create make end]" 
     causes the compiler to die in degree 4. [generic-constrained-by-integer]
    
918. A class creates an instance of a second class stores it in a file
     using `independent_store' and then opens the file and retrieves
     what was previously stored.  After initial compilation, system
     execution works correctly.  Then a local of type `ARRAY [expanded
     A]' is added and system is recompiled (frozen).  Execution then
     incorrectly ends with a mismatch retrieval error.
     [freeze-retrieval-mismatch]

919. Invalid feature declarations of all kinds are now rejected as a
     syntax error.  However, the wrong line number is reported for
     features like "f2 is 13" if they don't end with a semicolon.
     The syntax error should be detected at the "13" but is only
     detected at the next token.  [bad-feature-decl]
     [Decided this wasn't really a bug]

920. The Index tag is supposed to be optional in an Index_clause, but a
     clause without an index tag is rejected as a syntax error.
     ETL page 49.  [no-index-tag]
     [New ETL3 requires an index tag]

921. An attribute with an anchored type, whose anchor has a
     Formal_generic_name for its type appears to violate VTAT1, but is
     accepted by the compiler.  ETL page 214.  [anchored-formal-generic]
     [New ETL3 allow anchor whose type is a Formal_generic_name]

922. Compiler accepts the following routine:
	weasel is
		external 
			"C!@#$%%^-=+\~`{[];'./?"
		end
     [external-with-punctuation]

923. After initial compilation, a generic parameter is added to root class,
     then a creation clause.  When VSRC error is reported, generics are
     removed and creation procedure formal argument is changed to
     nonexistent class G.  When VTCT is reported, class G is added,
     introducing a VCFG error.  To correct the VCFG error, the name of a
     formal generic parameter is changed.  When compilation is resumed,
     the compiler dies instead of reporting a VSRC(3) error.  
     [vsrc-vtct-vcfg-die]
   
924. Ending class comment constraint VCRN (class name must match) is not
     enforced.  ETL plage 53.  [bad-class-end-comment]
     [New ETL3 no longer includes this constraint - it's just a style
      guideline.]

925. A routine with an entity named `integer' and an assertion tag
     `integer' should be invalid since INTEGER is a reserved word, but
     is accepted.  Violates constraint VIRW.  ETL pages 120 and 418.
     [invalid-entity-assertion-tag]
     [INTEGER is no longer a reserved word in new ETL3]

926. A class which appears to violate both VTAT1 and VTAT2, is accepted
     by the compiler without complaint.  ETL page 214.
     [anchored-type-violation]
    
927. If the compiler dies with an illegal instruction, then the license
     token is not returned.  This is particularly noticeable if one has
     only one license.  I don't know of any way to avoid this problem
     except to avoid executing illegal instructions.
     [illegal-instruction-keep-license]
     [Retired because no license manager any more]

928. A class with an anchored type as explicit creation type in a
     creation instruction appears to be valid, but the compiler reports
     that this construct is not supported.  ETL page 285.
     [anchored-creation-type]

929. After initial compilation, the root class is changed to a generic
    class by adding a single formal generic parameter.  When the system
    is recompiled, the compiler detects the VSRC violation but first
    does pass 5 twice on the root class.  After the problem is
    corrected by removing the formal generic parameter, the compiler
    again does pass 5 twice.  [generic-pass-one-twice]
    [Retired because compiler no longer does pass one twice.  Also,
     even if it did I don't think we should be checking that anyway.]

930. A system sets an environment variable (via EiffelWeb class CGI_INTERFACE)
     and then repeatedly gets the value of that variable and wastes some
     memory.  If garbage collection is on, the value of the environment
     variable is soon overwritten, though it should not be.
     [eiffelweb-overwrite-env-var]
     [Retired because I think this has been fixed for quite awhile.]

931. Compiling the C code generated for the following features generates
     warnings of the form:

/marten/test/EIFGENs/test/W_code/C1/pl13.c:334: warning: assignment makes integer from pointer without a cast

   For example, the code generated for PLATFORM.minimum_integer includes this:

EIF_INTEGER_32 Fah89z3 (EIF_REFERENCE Current)
    	...
	ti32_1 = (tp1 = RTLN(RTUD(71)), *(EIF_INTEGER_32 *)tp1 = Current,
		(FUNCTION_CAST(EIF_INTEGER_32, (EIF_REFERENCE)) RTWPF(24, 3, RTUD(71)))(tp1));
    
   The problem is with 

	*(EIF_INTEGER_32 *)tp1 = Current

   The type of Current is EIF_REFERENCE and it is being assigned to
   an EIF_INTEGER_32 without first casting it to that type.
   
   The following features probably won't work correctly on some platforms:

	INTEGER_8_REF.is_valid_character_code
	INTEGER_16_REF.is_valid_character_code
	INTEGER_16_REF.to_integer_8
	INTEGER_64_REF.is_valid_character_code
	INTEGER_64_REF.to_integer_8
	INTEGER_64_REF.to_integer_16
	INTEGER_64_REF.to_integer_32
	INTEGER_64_REF.to_integer
	INTEGER_64_REF.is_valid_character_code
	INTEGER_REF.to_integer_8
	INTEGER_REF.to_integer_16
	PLATFORM.maximum_character_code
	PLATFORM.maximum_integer
	PLATFORM.minimum_character_code
	PLATFORM.minimum_integer
   
932. Melting a system with a debug instruction with debug key that
     contains a null character ("weasel%U") works fine, but when the
     system is executed debug instructions inside a block with the tag
     "weasel%U" are not executed. [null-in-debug-key]
     [There was a bug in the test - test passes after fixing it.]
    
933. An Ace file which specifies `hide_implementation (yes)' or
     `hide_implementation (no)' causes the compiler to report a VD15
     error (invalid option value) if the system is melted, frozen or
     finalized instead of being precompiled.  [lace-melt-hide-implementation]
     [Retired because compiler no longer recognizes this option at all.]

934. An empty Feature_list in a New_export_item in an inheritance clause
     should be accepted, but the compiler reports a syntax error.
     ETL page 101.  [empty-export-feature-list]
     [Suggested to Manu that compiler is wrong on this one.  
      Manu says he has fixed parser to allow this case.  05-jun-2003]

935. A declaration of an external routine which declares the external to
     be a macro where the word `macro' is followed immediately by a tab
     instead of a space causes the compiler to report a syntax
     error. [external-tab-after-macro]
     [Manu says he has fixed parser to allow this case.  05-jun-2003]

936. A class with a single argument `args: like x' where `x: ARRAY [STRING]'
     should be accepted (since "like" is now just syntactic sugar) but
     the compiler reports a VSRC(3) error.
     [anchored-bogus-vsrc3]

937. A system whose Ace specifies `syntax_warning (yes)' is compiled
     and the compiler issues warning about obsolete syntax.  Then this
     clause is removed from the Ace file and a new use of obsolete
     syntax is added.  The compiler warns about the new use of obsolete
     syntax, but it should not.  [remove-syntax-warning-yes]

938. Specifying the  option `msil_generation (yes)' causes the compiler
     to die, presumably only on an inappropriate platform.
     [msil-generation-yes]

939. A class with a declaration `c: CHARACTER is "abc"' should
     be rejected as a VQMC but the compiler accepts it.  Also
     incorrectly accepts other basic types (INTEGER, REAL, DOUBLE,
     POINTER, BOOLEAN) when the constant is a manifest string.
     [manifest-string-vqmc-sneak]
    
940. A sequence of changes where system is melted several times,
     with varying versions of an external routine, then made deferred
     which causes a VGCC(2) error, then made external again and then
     melted causes the compiler to die with a segmentation fault in
     `real_body_id'.  [change-external-melt]

941. An expanded class has a call to an agent, which consists of
     a call to an inherited function.  After initial compilation the
     return type of the inherited function is changed and changes are
     melted.  System execution then dies with a segmentation violation.
     [change-agent-return-type]
    
942. A class has a call to an agent, which consists of
     a call to an inherited function.  After initial compilation the
     return type of the inherited function is changed from BOOLEAN to
     DOUBLE and changes are melted.  System execution then dies with a
     segmentation violation.  [change-agent-noexp-return-type]
   
943. A system calls an external routine that takes a REAL and
     returns a DOUBLE.  The signature specifies that the argument
     should be cast to double before being passed to the external
     routine.  After freezing, system produces correct output.  
     Changing the routine with the call and melting yields a system
     that produces incorrect output.
     [melt-call-real-external]
   
944. Preconditions, postconditions and class invariants are not monitored
     for an external routine when the Ace specifies `assertion (invariant)'.
     [external-routine-skip-assertion]

945. A system which is compiled using precompiled EiffelBase and
     which declares an external routine identical to one that is
     already in the precompiled library compiles fine when melted.
     But executing the system results in a segmentation fault.
     Frozen code works correctly. [melt-call-precomp-external]
   
946. A class creates several threads.  Each thread repeatedly creates
     a string whose length is determined by a random number generator
     and fills the string with blanks.  System execution ends with an
     exception, but should not.  [multithreaded-string-blank]
    
947. Floor and ceiling called on a REAL do not work correctly when
     code is frozen. [frozen-floor-ceiling]

949. An external routine which takes an expanded argument and is
     defined as a macro with a signature compiles fine when
     frozen, but when executed the system dies with a segmentation fault.
     [expanded-arg-macro-with-cast]

950. A system with one class is compiled.  Then the root class is
     changed to a different class, the system name is changed as well
     and changes are melted.  Finally, the system name is changed back
     to its original value and system is recompiled again.  The
     compiler then dies with a bus error.  [change-sysname-and-root]
   
951. Finalizing a system with an expanded class which has an external
     (rather than internal) creation procedure produces C code which
     won't link.  [finalize-expanded-ext-creation]

952. Finalizing a system with a trivial root class when using
     precompiled EiffelBase with dead code removal turned off produces C 
     code which won't compile in ececil.c.  [finalize-precomp-no-dead]

953. For an external feature which is declared as an infix feature, the
     compiler passes two arguments to the external C routine if there is
     no signature specified in the External_declaration, but only one
     argument if a signature is specified.  It is not clear from ETL
     which one is correct.  Similar question for prefix features.  ETL
     page 421.  [external-infix-feature]

954. A class creates a number of objects, guided by a random number
     generator.  If the EIF_MEMORY_CHUNK environment variable is set to
     262143 before execution, system execution ends with a panic.
     [odd-gc-chunk-size]

955. Try to compile a system after doing "setenv EIF_MEMORY_SCAVENGE 8193".
     Compiler usually dies.  Looks like the value needs to be a multiple
     of 8, but run-time doesn't round to nearest multiple of 8.
     [odd-memory-scavenge-size]

956. Finalizing a system with an expanded class which has an external
     creation procedure that is inline C code generates C code which
     won't compile.  [finalize-ext-exp-inline-create]

957. An external routine which is used as the root creation procedure is
     declared to take a single argument of type ARRAY [STRING].  When
     the external routine tries to access the array, a segmentation
     fault occurs.  It is also impossible to declare an external root
     creation procedure to take two arguments (one of type
     ROOT_CLASS_NAME, the other of type ARRAY [STRING]) even though this
     is what appears to be passed to the external routine.
     [external-root-proc-with-args]

958. A class FOO has a generic parameter G of type XXX with a generic
     creation clause `create default_create end'.  Another class
     declares an attribute of type FOO [XXX], where `default_create'
     is not listed as a creation procedure of XXX.  The compiler should
     report a VTCG error but does not.  [default-create-vtcg]
    
959. A external routine which is "C inline" without an alias to specify the
     actual text of the C code is accepted by the compiler but should
     not be.  Compiler dies with a segmentation fault in degree -1.
     [c-inline-without-alias]

960. An external "C++"  routine which is a delete for a C++ class
     is required to have a single argument of type POINTER.
     An argument which is anchored to an attribute of type POINTER
     is rejected as an EXT_CPP error, but should be accepted.
     [cpp-delete-anchored-arg]

961. After initial compilation, a procedure is changed to a STRING and a
     call of the procedure is changed to a `print' on this (Void)
     string.  After recompilation, system execution ends with a panic.
     [call-proc-print-attr]
   
962. After initial compilation where the system is frozen, an attribute
     of an expanded class is changed from a constant STRING to BIT 1.
     The changes are melted.  System execution then produces the wrong
     output. [string-to-bit1]
   
963. After initial compilation where the system is frozen, an attribute of an
     expanded class is changed from a constant STRING to BIT 1.  The
     changes are refrozen.  System execution then produces the wrong
     output.  [string-to-bit-refreeze]
   
964. A class prints the generating type of the expression
     `create {TEST1 [BIT n]}' where `n: INTEGER is 8'.
     When the system is frozen, system execution works, except that
     it prints "TEST1 [BIT_REF]" instead of the expected "TEST1 [BIT 8]".
     When a trivial change is made to the routine and changes are melted,
     execution ends with an illegal opcode panic. [bit-n-illegal-opcode]
   
965. A class calls an external routine with a precondition that is false.
     When the system is executed, the precondition is violated and
     an exception is raised, which is correct.  Then the precondition
     is changed so that it is true and changes are melted.  System execution
     still violates the precondition, but should not.
     [external-make-precondition-true]
   
966. After initial compilation, an external routine which is "C inline" 
     has the order of its formal arguments changed.  When changes are
     melted, system execution produces the wrong output (same output as
     before).  Looks like the compiler needs to freeze when any changes
     are made to the list of formal argument names.
     [c-inline-change-arg-order]
   
967. A system has a generic class FOO with an inline C external function that
     just returns its argument.  When another class creates an instance of
     FOO [DOUBLE] and calls the external function on it, the result is
     correct.  Then the type in the creation expression is changed to
     FOO [ARRAY [DOUBLE]] and changes are melted.  Finally the creation
     expression type is changed back to FOO [DOUBLE] and changes are melted
     again.  System execution then produces the wrong output.
     [chg-generic-c-inline-function]
   
968. A system has an external function of type INTEGER_8 which
     is inline C.  After initial compilation where the system is frozen,
     the function return type is changed to INTEGER and changes are
     melted.  System execution then produces the wrong output.
     [chg-external-function-type]
   
969. A system has a call to an agent with an open target of type TEST2.
     After initial compilation where the system is frozen,
     execution gives correct results.  Then the target type of the
     agent is changed to `expanded TEST2' and changes are melted.
     System execution then dies with a segmentation fault.
     [make-agent-target-expanded]
   
970. After initial compilation, a system which does repeated creation of
     instances of an expanded type is modified: a second variable
     attribute of an expanded type is added to an expanded class and
     changes are melted.  System execution then ends with a run-time
     panic.  [nested-expanded-creation]
   
971. Subtracting one from an INTEGER_16 attribute with
     a large positive value gives the attribute a value of 0, but only
     when code is melted.  Frozen code works correctly.  Other sizes
     of integers work correctly whether code is melted or frozen.
     [integer-16-minus-one]
   
972. A class tries to print the generating type of the expression
     `create {TEST1 [BIT n]}' where `n: INTEGER is 8'.
     When the system is melted, system execution ends with an
     "out of memory" error.  Frozen code works correctly, except that
     it prints "TEST1 [BIT_REF]" instead of the expected "TEST1 [BIT 8]".
     [bit-n-out-of-memory]
   
973. A class which prints `- (- d.truncated_to_integer)' where `d'
     has value 1.3 correctly prints 1 when melted but prints 0 when
     code is frozen.  [minus-minus-double]

974. A call to a routine that multiplies two REAL values and returns
     the result violates the routine's postcondition,
     which is `Result = a_real * another_real'.  This only happens
     on some platforms (Windows) and only when code is frozen.
     [real-times-real-postcondition]

975. An inspect with an INTEGER_8 constant that has value 0x8f does not work
     correctly, but only when code is frozen.
     [inspect-high-bit-integer8]

976. A routine does a bitwise "and" of an INTEGER_16 local with 0xFF00.
     The result is wrong if code is frozen, but is correct when melted.
     [frozen-bitwise-and-local]
   
977. A routine in a generic class has an assignment attempt whose right
     hand side is of type Generic #1.  If the actual generic parameter
     is an expanded type and if the call to the routine is inlined,
     system execution ends with a segmentation fault.
     [inline-generic-assign-attempt]

978. A class creates an ARRAY [BIT 4096] and fills it with elements of
     type BIT 4096.  Executing the system results in a segmentation
     fault if the size of the array is big enough (approximately 3000),
     but only if the system is finalized and garbage collection is on.
     [bigger-array-of-bit]

979. An external "C inline" function which sums its DOUBLE arguments gives
     the wrong results if the function takes 10 or more arguments, but
     only when code is finalized.  [c-inline-function-ten-args]

980. A class creates a LINKED_LIST [FOO] where FOO is an expanded class
     and appends two elements to it and then prints the `value'
     attribute of the first item in the list.  The wrong result is
     printed if the system is finalized with inlining (47.250000007042502
     instead of 47.25). [inline-linked-list-expanded]

981. A routine that compares an INTEGER local with 
     `feature {INTEGER}.Min_value' minus another local displays the
     wrong result, but only when code is finalized.
     [vicious-finalize-bug]

982. An external inline C routine used as a root creation procedure
     tries to print the number of arguments passed to the program
     but the wrong number is displayed.  An external routine which
     is not inline seems to work correctly as root creation procedure.
     [inline-external-root-proc]

983. A class creates strings of size 1, 2, 3, etc.  If the EIF_GS_LIMIT
     environment variable is set to 5000 before execution, to set 
     `generation_object_limit', system execution ends with a panic.
     [bigger-generation-object-limit]

984. A class enables GC time accounting, creates some objects and
     then gets GC statistics.  The incremental collector values
     `collected' and `collected_average' are negative.
     [negative-incremental-gc-stats]

985. An external routine which takes a string argument has a precondition
     involving the argument.  The code compiles fine (though the C
     code compilation generates warnings) but the precondition is
     violated when system is executed, though it should not be.
     [external-precond-string-arg]

986. Finalizing a system with an expanded class that has 2000 attributes which
     are of an expanded type causes the compiler to die with a "special
     reallocation" exception.  [finalize-many-expanded-attrs]
    
987. A generic class `TEST1 [G -> ANY create default_create end]'
     declares a local of y: G and then does `create y'.
     A client class declares a local of type `TEST1 [DOUBLE]'.
     The system compiles fine when frozen, but the generated C code
     won't compile.  Melted code works fine.
     [generic-create-double]
   
988. A class which prints `- - 3.5' works fine when melted, but
     when frozen or finalized the generated C code won't compile.
     [minus-minus-real]

989. Finalizing a system with a call to an inline C external routine
     with 10 or more arguments, where the call passes a single local
     for all the actual arguments, generates C code that won't compile.  
     [inline-c-ten-pass-local]

990. Compiling a system with a call to an inline C external routine
     that has formal arguments `a, ab, abc: INTEGER' and alias
     "$a + $ab + $abc" produces C code that won't compile.
     Perhaps there needs to be a validity check that none of the
     formal argument names is a prefix of another formal argument
     name for a "C inline" external routine.
     [inline-c-arg-prefix-other]

991. Routine `put' in EXECUTION_ENVIRONMENT is missing preconditions
     that state that `value' and `key' cannot contain null characters.
     Routine `get' may need a similar precondition.
     [putenv-with-null]

992. A class has an external routine with an argument of an expanded
     type.  In a call to this routine which passes an entity of a
     non-expanded type, the passed argument is not cloned first.  This
     results in incorrect system execution output.
     [external-exp-arg-not-cloned]

</pre>
</body>
