note
	description	: "Main window for this application"
	author		: "Generated by the New Vision2 Application Wizard."
	date		: "$Date$"
	revision	: "1.0.0"

class
	CTR_WINDOW

inherit
	EV_TITLED_WINDOW
		redefine
			initialize,
			is_in_default_state,
			create_interface_objects
		end

	EV_SHARED_APPLICATION
		undefine
			default_create, copy
		end

	INTERFACE_NAMES
		export
			{NONE} all
		undefine
			default_create, copy
		end

	CTR_SHARED_RESOURCES
		export
			{NONE} all
		undefine
			default_create, copy
		end

create
	default_create

feature {NONE} -- Initialization

	docking_manager: detachable like new_docking_manager

	new_docking_manager: SD_DOCKING_MANAGER
		do
			create Result.make (main_container, Current)
		end

	create_interface_objects
		do
			Precursor
			create catalog_grid
			create catalog_content.make_with_widget (catalog_grid, "Catalog")

			create standard_status_bar
			create standard_status_label
			create main_container

			create logs_tool.make ("Logs")
			create info_tool.make ("Info")
		end

	initialize
			-- Build the interface for this window.
		local
			dm: like docking_manager
		do
			Precursor {EV_TITLED_WINDOW}
			logs_tool.set_ctr_window (Current)
			info_tool.set_ctr_window (Current)

				-- Create and add the status bar.
			build_standard_status_bar
			lower_bar.extend (standard_status_bar)

			extend (main_container)

			dm := docking_manager
			if dm = Void then
				dm := new_docking_manager
				docking_manager := dm
			end
			build_tools
			restore_docking_layout

				-- Execute `request_close_window' when the user clicks
				-- on the cross in the title bar.
			close_request_actions.extend (agent request_close_window)

				-- Set the title of the window
			set_title (Window_title)

				-- Set the initial size of the window
			set_size (Window_width, Window_height)

			show_actions.extend_kamikaze (agent on_first_shown)
		end

	is_in_default_state: BOOLEAN
			-- Is the window in its default state
			-- (as stated in `initialize')
		do
			Result := (width = Window_width) and then
				(height = Window_height) and then
				(title.is_equal (Window_title))
		end

feature {NONE} -- Events

	reload_catalog
		do
			load_catalog_from_ini
			update_catalog
		end

	on_first_shown
		do
			load_catalog_from_ini
			if True then
				save_catalog_as_ini (".bak")
			end
			update_catalog
--			check_all_repositories
		end

	on_quit
		local
			r: INTEGER
			g: like catalog_grid
			l_row: EV_GRID_ROW
		do
			if attached catalog as cat then
				from
					g := catalog_grid
					r := 1
				until
					r > g.row_count
				loop
					l_row := g.row (r)

					if attached {REPOSITORY_DATA} l_row.data as rdata then
						rdata.save_unread_logs
					end
					r := r + 1
				end
			end
			save_docking_layout
		end

feature -- Layout

	save_docking_layout
		local
			b: BOOLEAN
		do
			if attached docking_manager as dm then
				b := dm.save_data (docking_layout_filename)
--				b := dm.save_editors_data (docking_layout_editors_filename)
--				b := dm.save_tools_data (docking_layout_tools_filename)

			end
		end

	docking_layout_filename: STRING
		once
			Result := "data" + operating_environment.directory_separator.out + "layout.db"
		end

	docking_layout_tools_filename: STRING
		once
			Result := "data" + operating_environment.directory_separator.out + "layout-tools.db"
		end

	docking_layout_editors_filename: STRING
		once
			Result := "data" + operating_environment.directory_separator.out + "layout-editors.db"
		end

	restore_docking_layout
		local
			b, layout_set: BOOLEAN
			retried: BOOLEAN
		do
			if not retried then
				if attached docking_manager as dm then
					b := True
					layout_set := False
					if dm.is_config_data_valid (docking_layout_filename) then
						b := dm.open_config (docking_layout_filename)
						layout_set := True
					end
					if dm.is_config_data_valid (docking_layout_editors_filename) then
						dm.open_editors_config (docking_layout_editors_filename)
						layout_set := True
					end
					if dm.is_config_data_valid (docking_layout_tools_filename) then
						b := dm.open_tools_config (docking_layout_tools_filename)
						layout_set := True
					end
				end
				if not layout_set or not b then
					apply_default_layout
				end
			else
				apply_default_layout
			end
		rescue
			retried := True
			retry
		end

	apply_default_layout
		do
			if attached docking_manager as dm then
				catalog_content.set_top ({SD_ENUMERATION}.top)
				logs_tool.sd_content.set_top ({SD_ENUMERATION}.bottom)
				info_tool.sd_content.set_relative (catalog_content, {SD_ENUMERATION}.right)
				if not catalog_content.is_visible then
					catalog_content.show
				end
				if not logs_tool.sd_content.is_visible then
					logs_tool.sd_content.show
				end
				if not info_tool.sd_content.is_visible then
					info_tool.sd_content.show
				end
				dm.close_editor_place_holder
			end

			show_actions.extend_kamikaze (agent (ac0,ac1,ac2: SD_CONTENT)
					do
						ac0.set_split_proportion ({REAL_32} 0.3)
						ac1.set_split_proportion ({REAL_32} 0.3)
						ac2.set_split_proportion ({REAL_32} 0.3)
					end (catalog_content, logs_tool.sd_content, info_tool.sd_content)
				)
		ensure
			catalog_visible: catalog_content.is_visible
			logs_visible: logs_tool.sd_content.is_visible
			info_visible: info_tool.sd_content.is_visible
		end

feature -- Storage

	catalog_ini_filename: STRING
		local
			fn: FILE_NAME
		once
			create fn.make_from_string (common_data_folder)
			fn.set_file_name ("catalog")
			fn.add_extension ("ini")
			Result := fn.string
		end

	load_catalog_from_ini
		local
			cat: like catalog
			rf: RAW_FILE
			repo: detachable REPOSITORY
			n,k: detachable STRING
			p,i: INTEGER
			s,s2,s3: STRING
			v: STRING
		do
			create rf.make (catalog_ini_filename)
			if rf.exists then
				rf.open_read
				from
					create cat.make
					rf.start
				until
					rf.exhausted
				loop
					rf.read_line
					s := rf.last_string
					s.left_adjust
					if s.count > 0 then
						if s.item (1) = '#' then
							--| skip
						elseif s.item (1) = '[' then
							if repo /= Void and then attached repo.location as loc then
								if n /= Void then
									cat.add_repository (n, repo)
								else
									cat.add_repository (loc, repo)
								end
							end
							s.right_adjust
							n := s.substring (2, s.last_index_of (']', s.count) - 1)
							i := n.index_of (':', 1)
							if i > 0 then
								k := n.substring (1, i - 1)
								k.left_adjust
								k.right_adjust
								k.to_lower
								n := n.substring (i + 1, n.count)
							end
							n.left_adjust
							n.right_adjust
							if k /= Void and then not k.is_empty then
								if k.same_string ("svn") then
									create {REPOSITORY_SVN} repo.make
								else
									--|, cvs, git, ...
									create {REPOSITORY_SVN} repo.make
								end
							end
						elseif repo /= Void then
							p := s.index_of ('=', 1)
							v := s.substring (p + 1, s.count)
							if s.substring (1, p -1).same_string ("uuid") then
								v.left_adjust; v.right_adjust
								repo.set_uuid (create {UUID}.make_from_string (v))
							elseif s.substring (1, p -1).same_string ("location") then
								v.left_adjust; v.right_adjust
								repo.set_location (v)
							elseif s.substring (1, 6).same_string ("review") then
								s2 := s.substring (7, p - 1)
								s2.to_lower
								if s2.is_empty then
									v.left_adjust; v.right_adjust
									repo.set_review_enabled (v.is_case_insensitive_equal ("on"))
								elseif s2.item (1) = '.' then
									s2.remove_head (1)
									s2.left_adjust; s2.right_adjust
									s2.to_lower
									v.left_adjust; v.right_adjust
									repo.add_review_variable (v, s2)
								end
							elseif s.substring (1, 6).same_string ("tokens") then
								s2 := s.substring (7, p - 1)
								s2.to_lower
								if s2.is_empty then
								elseif s2.item (1) = '.' then
									s2.remove_head (1)
									p := s2.index_of ('.', 1)
									if p > 0 then
										k := s2.substring (1, p - 1).as_lower
										s3 := s2.substring (p + 1, s2.count).as_lower
										if s3.same_string ("key") then
											v.left_adjust; v.right_adjust
											repo.add_token (k, v, Void)
										elseif s3.same_string ("url") then
											v.left_adjust; v.right_adjust
											repo.add_token (k, Void, v)
										end
									end
								end
							elseif s.substring (1, 7).same_string ("filters") then
								s2 := s.substring (8, p - 1)
								s2.to_lower
								if s2.is_empty then
								elseif s2.item (1) = '.' then
									s2.remove_head (1)
									p := s2.last_index_of ('.', s2.count)
									if p = 0 then
										k := s2
										v.left_adjust; v.right_adjust
										s3 := ""
									else
										k := s2.substring (1, p - 1)
										s3 := s2.substring (p + 1, s2.count).as_lower
									end
									if s3.is_empty then
										repo.add_filter (k, v)
									else
										if s3.same_string ("author") then
											if repo.filter (k) = Void then
												repo.add_filter (k, k)
											end
											v.left_adjust; v.right_adjust
											repo.add_filter_to (k, create {REPOSITORY_LOG_AUTHOR_FILTER}.make (v))
										elseif s3.same_string ("path") then
											if repo.filter (k) = Void then
												repo.add_filter (k, k)
											end
											v.left_adjust; v.right_adjust
											repo.add_filter_to (k, create {REPOSITORY_LOG_PATH_FILTER}.make (v))
										elseif s3.same_string ("message") then
											if repo.filter (k) = Void then
												repo.add_filter (k, k)
											end
--											v.left_adjust; v.right_adjust

											repo.add_filter_to (k, create {REPOSITORY_LOG_MESSAGE_FILTER}.make (v))
										else
											k := s2
											if repo.filter (k) = Void then
												repo.add_filter (k, v)
											end
										end
									end
								end
							else
								print ("???: " + s + "%N")
							end
						else
							print ("???: " + s + "%N")
						end
					end
				end
				if repo /= Void and then attached repo.location as loc then
					if n /= Void then
						cat.add_repository (n, repo)
					else
						cat.add_repository (loc, repo)
					end
				end
				rf.close
			end
--			if cat = Void or else cat.repositories.is_empty then
--				create cat.make
--				create svn_repo.make_with_location ("https://svn.eiffel.com/eiffelstudio/trunk")
--				cat.add_repository ("EiffelStudio/trunk", svn_repo)

--				create svn_repo.make_with_location ("https://svn.eiffel.com/eiffelstudio/branches/Eiffel_66")
--				cat.add_repository ("EiffelStudio/66", svn_repo)
--			end

			catalog := cat
		end

	save_catalog_as_ini (a_extra: detachable STRING)
		local
			rf: RAW_FILE
		do
			if attached catalog_to_ini as t then
				if a_extra /= Void then
					create rf.make (catalog_ini_filename + a_extra)
				else
					create rf.make (catalog_ini_filename)
				end
				if not rf.exists or else rf.is_writable then
					rf.create_read_write
					rf.put_string (t)
					rf.close
				end
			end
		end

	catalog_to_ini: detachable STRING
		local
			n: STRING
			t: STRING
		do
			if attached catalog as cat then
				create Result.make (100)
				across
					cat.repositories as c
				loop
					n := c.key.string
					t := c.item.kind
					n.replace_substring_all ("]", " ")
					Result.append_string ("[" + t + ":" + n + "]%N")
					Result.append_string ("uuid=" + c.item.uuid.out + "%N")
					Result.append_string ("location=" + c.item.location + "%N")
					if c.item.review_enabled then
						Result.append_string ("review=on%N")
					end
					if attached c.item.review_variables as l_rev_vars then
						across
							l_rev_vars as rvc
						loop
							Result.append_string ("review." + rvc.key + "=" + rvc.item + "%N")
						end
					end
					if attached c.item.tokens as l_tokens then
						across
							l_tokens as tok
						loop
							Result.append_string ("tokens." + tok.key + ".key=" + tok.item.key + "%N")
							Result.append_string ("tokens." + tok.key + ".url=" + tok.item.url_pattern + "%N")
						end
					end
					if attached c.item.filters as l_filters then
						across
							l_filters as flt
						loop
							if not flt.key.same_string (flt.item.name) then
								Result.append_string ("filters." + flt.key + "=" + flt.item.name + "%N")
							end
							Result.append_string (filter_to_ini_line (flt.key, flt.item.filter))
						end
					end
					Result.append_character ('%N')
				end
			end
		end

	filter_to_ini_line (k: STRING; f: detachable REPOSITORY_LOG_FILTER): STRING
		do
			if f = Void then
				create Result.make_empty
			elseif attached {REPOSITORY_LOG_GROUP_FILTER} f as fg then
				create Result.make_empty
				across
					fg.filters as fi
				loop
					Result.append_string (filter_to_ini_line (k, fi.item))
				end
			else
				Result := "filters." + k
				if attached {REPOSITORY_LOG_AUTHOR_FILTER} f as fauth then
					Result.append_string (".author=")
					Result.append_string (fauth.author)
				elseif attached {REPOSITORY_LOG_PATH_FILTER} f as fpath then
					Result.append_string (".path=")
					Result.append_string (fpath.path)
				elseif attached {REPOSITORY_LOG_MESSAGE_FILTER} f as fmsg then
					Result.append_string (".message=")
					Result.append_string (fmsg.message)
				else
				end
				Result.append_character ('%N')
			end
		end

feature -- Configuration

	edit_configuration
		local
			dlg: EV_TITLED_WINDOW
			but: EV_BUTTON
			m: EV_VERTICAL_BOX
			t: EV_TEXT
			s: detachable STRING
		do
			s := catalog_to_ini

			create dlg
			create m
			create t
			create but.make_with_text_and_action ("Save", agent (a_dlg: EV_WINDOW; a_text: EV_TEXT)
					local
						i_txt: STRING
						i_pf: PLAIN_TEXT_FILE
					do
						i_txt := a_text.text.as_string_8
						create i_pf.make (catalog_ini_filename)
						if not i_pf.exists or else i_pf.is_writable then
							i_pf.create_read_write
							i_pf.put_string (i_txt)
							i_pf.close
						end
						a_dlg.destroy
						reload_catalog
					end (dlg, t)
				)

			dlg.extend (m)
			m.extend (t)
			m.extend (but)
			m.disable_item_expand (but)

--			create but.make_with_text_and_action ("Cancel", agent dlg.destroy)
--			m.extend (but)
--			m.disable_item_expand (but)

			if s = Void then
				s := "[
[svn:EiffelStudio/trunk]
location=https://svn.eiffel.com/eiffelstudio/trunk
review=on
review.user=your_login
review.password=your_password
review.domain=community.ise
review.apikey=d0e8536407db776b80225d7d3c1750a2
review.endpoint=/ctr/services/xmlrpc
tokens.issue.key=bug
tokens.issue.url=https://www2.eiffel.com/support/protected/report.aspx?pr=$$
tokens.test.key=test
tokens.test.url=http://svn.origo.ethz.ch/viewvc/eiffelstudio/trunk/eweasel/tests/$$/tcf?view=markup
					]"
			end
			t.set_text (s)
			dlg.close_request_actions.extend (agent dlg.destroy)
			dlg.set_position (x_position, y_position)
			dlg.set_size (width, height)
			dlg.enable_border
			dlg.enable_user_resize
			dlg.show_relative_to_window (Current)
		end

	not_yet_implemented
		local
			p: EV_POPUP_WINDOW
			lab: EV_LABEL
		do
			create p.make_with_shadow
			create lab.make_with_text ("Not Yet Implemented")
			p.extend (lab)
			p.set_size (200,50)
			p.set_position ((x_position + width) // 2 + (p.width // 2), (y_position + height) // 2 + (p.height // 2))
			lab.pointer_button_press_actions.force_extend (agent p.destroy)
			lab.focus_out_actions.extend (agent p.destroy)
			p.show_relative_to_window (Current)
			lab.set_focus
		end

feature -- Check/Update/Refresh

	check_selected_repositories
		local
			g: like catalog_grid
			l_rows: LIST [EV_GRID_ROW]
			r: EV_GRID_ROW
		do
			g := catalog_grid
			l_rows := g.selected_rows
			if l_rows.count > 0 then
				across
					l_rows as c
				loop
					r := c.item
					if attached r.parent_row_root as pr then
						r := pr
					end
					if attached {REPOSITORY_DATA} r.data as d then
						check_repository (d)
					end
				end
			else
				check_all_repositories
			end
		end

	check_all_repositories
		local
			g: like catalog_grid
			r: INTEGER
		do
			g := catalog_grid
			from
				r := 1
			until
				r > g.row_count
			loop
				if attached {REPOSITORY_DATA} g.row (r).data as d then
					check_repository (d)
				end
				r := r + 1
			end
		end

	check_repository (a_repo: REPOSITORY_DATA)
		do
			if attached {REPOSITORY_SVN_DATA} a_repo as rsvndata then
				if not rsvndata.is_asynchronious_fetching then
					ev_application.do_once_on_idle (agent add_asynchronious_svn_task (rsvndata))
				end
			else
				ev_application.do_once_on_idle (agent a_repo.fetch_logs)
			end
		end

feature {NONE} -- Asynchronious operation

	asynchronious_svn_tasks: detachable ARRAYED_LIST [REPOSITORY_SVN_DATA]

	asynchronious_svn_tasks_scheduler_action: detachable PROCEDURE [ANY, TUPLE]

	check_asynchronious_svn_tasks
		do
			debug
				if attached standard_status_label.text as s then
					if s.same_string ("_") then
						standard_status_label.set_text (" ")
					else
						standard_status_label.set_text ("_")
					end
				end
			end
			if
				attached asynchronious_svn_tasks as l_tasks
			then
				check has_task: not l_tasks.is_empty end
				from
					l_tasks.start
				until
					l_tasks.after
				loop
					if attached l_tasks.item as rsvndata and then rsvndata.has_fetched_data then
						l_tasks.remove
						if l_tasks.is_empty then
							if attached asynchronious_svn_tasks_scheduler as l_scheduler then
								l_scheduler.destroy
								asynchronious_svn_tasks_scheduler := Void
							else
								check scheduler_exists: False end
							end
						end
						standard_status_label.set_text ("Get logs for " + rsvndata.repository_location)
						rsvndata.import_fetched_logs
						if rsvndata = logs_tool.current_repository then
							logs_tool.update
							info_tool.update_current_repository (rsvndata)
						end
						if attached catalog_repository_row (rsvndata) as l_row then
							update_catalog_row (l_row)
							l_row.set_background_color (bgcolor_checked)
						end
						standard_status_label.set_text ("Updated: " + rsvndata.repository_location)
					else
						l_tasks.forth
					end
				end
			end
		end

	asynchronious_svn_tasks_scheduler: detachable EV_TIMEOUT

	add_asynchronious_svn_task (a_rsvndata: REPOSITORY_SVN_DATA)
		local
			l_asynchronious_svn_tasks: like asynchronious_svn_tasks
			l_asynchronious_svn_tasks_scheduler: like asynchronious_svn_tasks_scheduler
			l_asynchronious_svn_tasks_scheduler_action: like asynchronious_svn_tasks_scheduler_action
		do
				--| Execute task
			a_rsvndata.asynchronious_fetch_logs
			standard_status_label.set_text ("Check: " + a_rsvndata.repository_location)

			if attached catalog_repository_row (a_rsvndata) as l_row then
				l_row.set_background_color (bgcolor_checking)
			end

				--| Handle scheduler
			l_asynchronious_svn_tasks := asynchronious_svn_tasks
			if l_asynchronious_svn_tasks = Void then
				create l_asynchronious_svn_tasks.make (10)
				asynchronious_svn_tasks := l_asynchronious_svn_tasks
			end
			l_asynchronious_svn_tasks.extend (a_rsvndata)

			l_asynchronious_svn_tasks_scheduler_action := asynchronious_svn_tasks_scheduler_action
			if l_asynchronious_svn_tasks_scheduler_action = Void then
				l_asynchronious_svn_tasks_scheduler_action := agent check_asynchronious_svn_tasks
				asynchronious_svn_tasks_scheduler_action := l_asynchronious_svn_tasks_scheduler_action
			end
			l_asynchronious_svn_tasks_scheduler := asynchronious_svn_tasks_scheduler
			if l_asynchronious_svn_tasks_scheduler = Void then
				create l_asynchronious_svn_tasks_scheduler
				asynchronious_svn_tasks_scheduler := l_asynchronious_svn_tasks_scheduler
				l_asynchronious_svn_tasks_scheduler.actions.extend (l_asynchronious_svn_tasks_scheduler_action)
				l_asynchronious_svn_tasks_scheduler.set_interval (1_000)
			end

		end

feature {CTR_TOOL} -- Catalog

	catalog_repository_row (a_repo: detachable REPOSITORY_DATA): detachable EV_GRID_ROW
		local
			g: like catalog_grid
			r,l_count: INTEGER
		do
			if a_repo /= Void then
				g := catalog_grid
				l_count := g.row_count
				if l_count > 0 then
					from
						r := 1
					until
						r > l_count or Result /= Void
					loop
						Result := g.row (r)
						if Result.data /= a_repo then
							Result := Void
							r := r + 1
						end
					end
				end
			end
		end

	update_catalog
		local
			g: like catalog_grid
			repo: REPOSITORY
			repo_data: detachable REPOSITORY_DATA

			cat: like catalog
			glab: EV_GRID_LABEL_ITEM
			l_row, l_subrow: detachable EV_GRID_ROW
			tt,k,kp: STRING
			p: INTEGER
			l_filter_rows: HASH_TABLE [EV_GRID_ROW, STRING]
		do
			g := catalog_grid
			g.wipe_out
			cat := catalog
			if cat /= Void then
				g.set_column_count_to (2)
				across
					cat.repositories as c
				loop
					g.insert_new_row (g.row_count + 1)
					l_row := g.row (g.row_count)

					create glab.make_with_text (c.key)
					glab.set_data (c.key.string)
					l_row.set_item (cst_repo_name_column, glab)

					repo := c.item
					create tt.make_empty
					debug ("scm")
						tt.append_string ("%Nstorage: " + repo.uuid.out + "%N")
					end

					if attached {REPOSITORY_SVN} repo as rsvn then
						create {REPOSITORY_SVN_DATA} repo_data.make (repo.uuid, rsvn)
						l_row.set_data (repo_data)
					else
						repo_data := Void
					end

					tt.append_string ("Location: " + repo.Location + "%N")
					if attached repo.review_username as l_username then
						tt.append_string ("%Nusername: " + l_username.out + "%N")
					end
					if repo.review_enabled then
						tt.append_string ("%NReview enabled%N")
					end
					glab.set_tooltip (tt)

					create glab.make_with_text (repo.Location)
					l_row.set_item (cst_repo_uuid_column, glab)

					if attached repo.filters as l_filters and then l_filters.count > 0 then
						create l_filter_rows.make (l_filters.count)
						across
							l_filters as fcursor
						loop
							k := fcursor.key
							l_subrow := Void
							if l_filter_rows.has_key (k) then
								l_subrow := l_filter_rows.found_item
							else
								if k.has ('.') then
									p := k.last_index_of ('.', k.count)
									if p > 0 then
										kp := k.substring (1, p - 1)
										if l_filter_rows.has_key (kp) then
											if attached l_filter_rows.found_item as p_row then
												p_row.insert_subrow (p_row.subrow_count + 1)
												l_subrow := p_row.subrow (p_row.subrow_count)
											end
										end
									else
										check has_dot: False end
									end
								end
							end

							if l_subrow = Void then
								l_row.insert_subrow (l_row.subrow_count + 1)
								l_subrow := l_row.subrow (l_row.subrow_count)
							end

							l_filter_rows.force (l_subrow, k)

							create glab.make_with_text (fcursor.item.name)
							glab.set_tooltip (k)
							glab.set_data (fcursor.item.name)

							l_subrow.set_item (1, glab)
							if attached fcursor.item.filter as f then
								create glab.make_with_text ("Filter: " + f.to_string)
								l_subrow.set_item (2, glab)
							end
							l_subrow.set_data (fcursor.item.filter)
						end
					end
					if repo_data /= Void and then repo_data.unread_log_count > 0 then
						update_catalog_row (l_row)
					end
				end
			end
			if logs_tool.current_repository = Void and g.row_count > 0 then
				g.row (1).enable_select
			end
			update_catalog_layout
		end

	update_catalog_layout
		local
			g: like catalog_grid
		do
			g := catalog_grid
			if attached g.column (cst_repo_name_column) as col then
				col.set_width (col.required_width_of_item_span (1, g.row_count) + 4)
			end
			if attached g.column (cst_repo_uuid_column) as col then
				col.set_width (col.required_width_of_item_span (1, g.row_count) + 4)
			end
		end

	update_catalog_row_by_data (a_rdata: REPOSITORY_DATA)
		do
			if attached catalog_repository_row (a_rdata) as l_row then
				update_catalog_row (l_row)
			end
		end

	update_catalog_row (a_row: EV_GRID_ROW)
		local
			n: INTEGER
		do
			if attached {REPOSITORY_DATA} a_row.data as rdata then
				if a_row.count > cst_repo_name_column then
					if attached {EV_GRID_LABEL_ITEM} a_row.item (cst_repo_name_column) as glab then
						if attached {STRING_GENERAL} glab.data as l_name then
							n := rdata.unread_log_count
							if n > 0 then
								glab.set_text (l_name.to_string_8 + " (" + n.out + ")")
								mark_repository_unread (a_row)
							else
								glab.set_text (l_name)
								mark_repository_read (a_row)
							end
							update_catalog_layout
						end
					end
				end
				update_catalog_filter_row (a_row, rdata)
			end
		end

	update_catalog_filter_row (a_row: EV_GRID_ROW; a_data: REPOSITORY_DATA)
		local
			i, n: INTEGER
		do
			if attached {REPOSITORY_LOG_FILTER} a_row.data as rfilter then
				if a_row.count > 0 then
					if attached {EV_GRID_LABEL_ITEM} a_row.item (1) as glab then
						if attached {STRING_GENERAL} glab.data as l_name then
							n := a_data.unread_log_count_for (rfilter)
							if n > 0 then
								glab.set_text (l_name.to_string_8 + " (" + n.out + ")")
								mark_repository_unread (a_row)
							else
								glab.set_text (l_name)
								mark_repository_read (a_row)
							end
							update_catalog_layout
						end
					end
				end
			end
			if a_row.subrow_count > 0 then
				from
					i := 1
				until
					i > a_row.subrow_count
				loop
					update_catalog_filter_row (a_row.subrow (i), a_data)
					i := i + 1
				end
			end
		end

	on_catalog_row_unselected (r: EV_GRID_ROW)
		do
		end

	on_catalog_row_selected	(r: EV_GRID_ROW)
		do
			if catalog_grid.selected_rows.count <= 1 then
				if attached {REPOSITORY_LOG_FILTER} r.data as rfilter then
					if
						attached r.parent_row_root as l_row and then
						attached {REPOSITORY_DATA} l_row.data as rdata
					then
						select_repository (r, rdata, rfilter)
					end
				elseif attached {REPOSITORY_DATA} r.data as rdata then
					select_repository (r, rdata, Void)
				end
			else

			end
		end

	select_repository (r: EV_GRID_ROW; a_repodata: REPOSITORY_DATA; a_log_filter: detachable REPOSITORY_LOG_FILTER)
		local
			l_repo: detachable REPOSITORY_DATA
		do
			l_repo := logs_tool.current_repository
			if attached catalog_repository_row (l_repo) as l_row then
				mark_repository_unselected (l_row)
			end
			if l_repo /= a_repodata then
				if l_repo /= Void then
					l_repo.save_unread_logs
				end
				logs_tool.reset
				a_repodata.load_logs
				logs_tool.update_current_repository (a_repodata, a_log_filter)
				info_tool.update_current_repository (a_repodata)
			else
				logs_tool.update_current_repository (a_repodata, a_log_filter)
			end
			mark_repository_selected (r)
			check
				catalog_repository_row (a_repodata) = r or
				catalog_repository_row (a_repodata) = r.parent_row_root
			end
			if
				attached {REPOSITORY_SVN_DATA} a_repodata as rsvndata  and then
				not rsvndata.is_asynchronious_fetching
			then
				unset_background_color (r)
			end
		end

feature {CTR_TOOL} -- Diff

	show_log_diff (a_log: REPOSITORY_LOG)
		require
			info_tool.current_log = a_log
		local
			rdata: REPOSITORY_DATA
		do
			rdata := a_log.parent
			if not a_log.has_diff then
				set_busy
				rdata.fetch_diff (a_log)
				rdata.get_diff (a_log)
				unset_busy
			end
			if a_log.has_diff then
				info_tool.update_current_log (a_log)
				popup_diff (a_log)
			end
		end

	popup_diff (a_log: REPOSITORY_LOG)
		local
			dlg: EV_TITLED_WINDOW
			but: EV_BUTTON
			m: EV_VERTICAL_BOX
			t: EV_TEXT
		do
			create dlg
			create m
			create t
			create but.make_with_text_and_action ("Close", agent dlg.destroy)
			dlg.extend (m)
			m.extend (t)
			m.extend (but)
			m.disable_item_expand (but)
			t.set_text (a_log.diff)
			dlg.close_request_actions.extend (agent dlg.destroy)
			dlg.set_position (x_position, y_position)
			dlg.set_size (width, height)
			dlg.enable_border
			dlg.enable_user_resize
			dlg.show_relative_to_window (Current)
		end

feature -- Access

	catalog: detachable REPOSITORY_CATALOG

feature {NONE} -- Implementation, Close event

	request_close_window
			-- The user wants to close the window
		local
			question_dialog: EV_CONFIRMATION_DIALOG
		do
			create question_dialog.make_with_text (Label_confirm_close_window)
			question_dialog.show_modal_to_window (Current)

			if attached question_dialog.selected_button as b and then b.is_equal ((create {EV_DIALOG_CONSTANTS}).ev_ok) then
					-- Destroy the window
				on_quit
				destroy;

					-- End the application
					--| TODO: Remove this line if you don't want the application
					--|       to end when the first window is closed..
				if attached (create {EV_ENVIRONMENT}).application as app then
					app.destroy
				end
			end
		end

feature {NONE} -- Implementation

	main_container: EV_VERTICAL_BOX
			-- Main container (contains all widgets displayed in this window)

	build_tools
			--
		local
			cat_c: SD_CONTENT
			g: EV_GRID
			dm: like docking_manager
			mtb: SD_TOOL_BAR
			tbbut: SD_TOOL_BAR_BUTTON
		do
			dm := docking_manager
			if dm = Void then
				dm := new_docking_manager
			end

				--| Repositories
			g := catalog_grid
			g.enable_tree
			cat_c := catalog_content
			create mtb.make
			create tbbut.make
			tbbut.set_pixmap (icons.new_check_small_toolbar_button_icon)
			tbbut.select_actions.extend (agent check_selected_repositories)
			mtb.extend (tbbut)

			create tbbut.make
			tbbut.set_pixmap (icons.new_custom_text_small_toolbar_button_icon ("Config"))
			tbbut.select_actions.extend (agent edit_configuration)
			mtb.extend (tbbut)

			mtb.compute_minimum_size
			cat_c.set_mini_toolbar (mtb)

--			g.enable_tree
			g.enable_multiple_row_selection
			g.set_column_count_to (1)
			cat_c.set_short_title ("Catalog ...")
			cat_c.set_long_title ("Repositories")
			dm.contents.extend (cat_c)
			catalog_grid := g
			catalog_content := cat_c
			g.hide_header
			g.row_select_actions.extend (agent on_catalog_row_selected)
			g.row_deselect_actions.extend (agent on_catalog_row_unselected)

				--| Logs
			dm.contents.extend (logs_tool.sd_content)

				--| Info
			dm.contents.extend (info_tool.sd_content)
		end

	catalog_content: SD_CONTENT
	catalog_grid: EV_GRID

feature {NONE} -- StatusBar Implementation

	standard_status_bar: EV_STATUS_BAR
			-- Standard status bar for this window

	standard_status_label: EV_LABEL
			-- Label situated in the standard status bar.
			--
			-- Note: Call `standard_status_label.set_text (...)' to change the text
			--       displayed in the status bar.

	build_standard_status_bar
			-- Create and populate the standard toolbar.
		do
				-- Create the status bar.
			create standard_status_bar
			standard_status_bar.set_border_width (2)

				-- Populate the status bar.
			create standard_status_label
			standard_status_label.set_text ("...")
			standard_status_label.align_text_left
			standard_status_bar.extend (standard_status_label)
		ensure
			status_bar_created:
				standard_status_bar /= Void and then
				standard_status_label /= Void
		end


feature {CTR_TOOL} -- Tools

	logs_tool: CTR_LOGS_TOOL
	info_tool: CTR_INFO_TOOL

	before_busy_pointer: detachable EV_POINTER_STYLE

	set_busy
		do
			if before_busy_pointer = Void then
				before_busy_pointer := pointer_style
			end
			set_pointer_style ((create {EV_STOCK_PIXMAPS}).Busy_cursor)
		end

	unset_busy
		do
			if attached before_busy_pointer as p then
				set_pointer_style (p)
			end
		end

feature {NONE} -- Implementation

	unset_background_color (a_row: EV_GRID_ROW)
		do
			if attached a_row.parent as g then
				a_row.set_background_color (g.background_color)
			end
		end

	string_started_by (s: STRING_GENERAL; pre: STRING_GENERAL; b: BOOLEAN): BOOLEAN
			--
		local
			i: INTEGER
		do
			Result := s.count >= pre.count
			from
				i := 1
			until
				i > pre.count or not Result
			loop
				Result := s.code (i) = pre.code (i)
				i := i + 1
			end
		end

	content_of (fn: FILE_NAME): STRING
		local
			f: RAW_FILE
		do
			create f.make (fn)
			if f.exists then
				f.open_read
				create Result.make_empty
				from
					f.start
				until
					f.exhausted
				loop
					f.read_stream (512)
					Result.append_string (f.last_string)
				end
				f.close
			else
				Result := "Unable to open file %"" + fn + "%""
			end
		end

feature {NONE} -- Implementation / Constants

	mark_repository_selected (r: EV_GRID_ROW)
		do
			if r.count > 0 and then attached {EV_GRID_LABEL_ITEM} r.item (cst_repo_name_column) as glab then
				glab.set_pixmap (icons.active_cursor_icon)
				glab.set_font (font_selected_repository)
			end
		end

	mark_repository_unselected (r: EV_GRID_ROW)
		local
			i: INTEGER
		do
			if r.count > 0 and then attached {EV_GRID_LABEL_ITEM} r.item (cst_repo_name_column) as glab then
				glab.remove_pixmap
				glab.set_font (font_default)
				if r.subrow_count > 0 then
					from
						i := 1
					until
						i > r.subrow_count
					loop
						mark_repository_unselected (r.subrow (i))
						i := i + 1
					end
				end
			end
		end

	mark_repository_unread (a_row: EV_GRID_ROW)
		local
			n,c: INTEGER
			ft: EV_FONT
		do
			n := a_row.count
			ft := font_unread_log
			from
				c := 1
			until
				c > n
			loop
				if attached {EV_GRID_LABEL_ITEM} a_row.item (c) as l_lab then
					l_lab.set_font (ft)
				end
				c := c + 1
			end
		end

	mark_repository_read (a_row: EV_GRID_ROW)
		local
			n,c: INTEGER
			ft: EV_FONT
		do
			n := a_row.count
			ft := font_read_log
			from
				c := 1
			until
				c > n
			loop
				if attached {EV_GRID_LABEL_ITEM} a_row.item (c) as l_lab then
					l_lab.set_font (ft)
				end
				c := c + 1
			end
		end

	cst_repo_name_column: INTEGER = 1
	cst_repo_uuid_column: INTEGER = 2

	Window_title: STRING = "Commit Then Review"
			-- Title of the window.

	Window_width: INTEGER = 700
			-- Initial width for this window.

	Window_height: INTEGER = 600
			-- Initial height for this window.

note
	copyright: "Copyright (c) 1984-2010, Eiffel Software"
	license: "GPL version 2 (see http://www.eiffel.com/licensing/gpl.txt)"
	licensing_options: "http://www.eiffel.com/licensing"
	copying: "[
			This file is part of Eiffel Software's Eiffel Development Environment.
			
			Eiffel Software's Eiffel Development Environment is free
			software; you can redistribute it and/or modify it under
			the terms of the GNU General Public License as published
			by the Free Software Foundation, version 2 of the License
			(available at the URL listed under "license" above).
			
			Eiffel Software's Eiffel Development Environment is
			distributed in the hope that it will be useful, but
			WITHOUT ANY WARRANTY; without even the implied warranty
			of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
			See the GNU General Public License for more details.
			
			You should have received a copy of the GNU General Public
			License along with Eiffel Software's Eiffel Development
			Environment; if not, write to the Free Software Foundation,
			Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
		]"
	source: "[
			Eiffel Software
			5949 Hollister Ave., Goleta, CA 93117 USA
			Telephone 805-685-1006, Fax 805-685-6869
			Website http://www.eiffel.com
			Customer support http://support.eiffel.com
		]"
end -- class MAIN_WINDOW
