<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML XMLNS:MSHelp="http://msdn.microsoft.com/mshelp">
	<XML>
		<MSHelp:Keyword Index="K" Term="Eiffel Tutorial, The Static Picture: System Organization" />
		<MSHelp:Attr Name="Product" Value="Eiffel"/>
		<MSHelp:Attr Name="Locale" Value="kbEnglish"/>
	</XML>
	<HEAD>
		<TITLE>An Eiffel Tutorial, The Static Picture: System Organization</TITLE>
		<LINK HREF="../../../default.css" TYPE="text/css" REL="STYLESHEET">
	</HEAD>
	<BODY>
		<TABLE CLASS="HEADER">
			<TR>
				<TD CLASS="HEADER">Eiffel ENViSioN!</TD>
			</TR>
			<TR>
				<TD CLASS="SUBHEADER">An Eiffel Tutorial, The Static Picture: System Organization</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FRAME">
			<TR>
				<TD>
					<A NAME="pgfId-514111"></A>

					<P>We now look at the overall organization of Eiffel software.</P>

					<P CLASS=note>References to ISE-originated libraries appearing in
					subsequent examples include: <SPAN CLASS="bold">EiffelBase</SPAN>, the
					fundamental open-source library covering data structures and algorithms;
					the <SPAN CLASS="bold">kernel library</SPAN>, a subset of EiffelBase covering
					the most basic notions such as arrays and strings; and
					<SPAN CLASS="bold">EiffelVision 2</SPAN>, an advanced graphics and GUI library
					providing full compatibility across platforms (Unix, Windows, VMS) with native
					look-and-feel on each.</P>

					<H2>Systems</H2>

					<P>An Eiffel system is a collection of classes, one of which is designated
					as the root class. One of the features of the root class, which must be one
					of its creation procedures, is designated as the root procedure.</P>

					<P>To execute such a system is to create an instance of the root class (an
					object created according to the class description) and to execute the root
					procedure. In anything more significant than &quot;Hello World&quot; systems,
					this will create new objects and apply features to them, in turn triggering
					further creations and feature calls.</P>

					<P>For the system to make sense, it must contains all the classes on which
					the root <SPAN CLASS="bold">depends</SPAN> directly or indirectly. A class
					<SPAN CLASS="eclass">B</SPAN> depends on a class <SPAN CLASS="eclass">A</SPAN>
					if it is either a <SPAN CLASS="bold">client</SPAN> of
					<SPAN CLASS="eclass">A</SPAN>, that is to say uses objects of type
					<SPAN CLASS="eclass">A</SPAN>, or an <SPAN CLASS="bold">heir</SPAN>
					of <SPAN CLASS="eclass">A</SPAN>, that is to say extends or specializes
					<SPAN CLASS="eclass">A</SPAN>. (These two relations, client and inheritance,
					are covered below.)</P>

					<H2>Classes</H2>

					<P>The notion of class is central to the Eiffel approach. A class is the
					description of a type of run-time data structures (<SPAN CLASS="italics">
					objects</SPAN>), characterized by common operations (<SPAN CLASS="italics">
					features</SPAN>) and properties. Examples of classes include:</P>

					<UL>
						<LI>In a banking system, a class <SPAN CLASS="eclass">ACCOUNT</SPAN> may
						have features such as <SPAN CLASS="efeature">deposit</SPAN>, adding a
						certain amount to an account, <SPAN CLASS="efeature">all_deposits</SPAN>,
						yielding the list of deposits since the account's opening, and
						<SPAN CLASS="efeature">balance</SPAN>, yielding the current balance, with
						properties stating that <SPAN CLASS="efeature">deposit</SPAN> must add an
						element to the <SPAN CLASS=efeture>all_deposits</SPAN> list and update
						<SPAN CLASS="efeature">balance</SPAN> by adding the sum deposited, and
						that the current value of <SPAN CLASS="efeature">balance</SPAN> must be
						consistent with the lists of deposits and withdrawals.</LI>

						<LI>A class <SPAN CLASS="eclass">COMMAND</SPAN> in an interactive system
						of any kind may have features such as <SPAN CLASS="efeature">execute</SPAN>
						and <SPAN CLASS="efeature">undo</SPAN>, as well as a feature
						<SPAN CLASS="efeature">undoable </SPAN> which indicates whether a command
						can be undone, with the property that <SPAN CLASS="efeature">undo</SPAN> is
						only applicable if <SPAN CLASS="efeature">undoable</SPAN> yields the value
						true.</LI>

						<LI>A class <SPAN CLASS="eclass">LINKED_LIST</SPAN> may have features such
						as <SPAN CLASS="efeature">put</SPAN>, which adds an element to a list, and
						<SPAN CLASS="efeature">count</SPAN>, yielding the number of elements in the
						list, with properties stating that <SPAN CLASS="efeature">put</SPAN>
						increases <SPAN CLASS="efeature">count</SPAN> by one and that
						<SPAN CLASS="efeature">count</SPAN> is always non-negative.</LI>
					</UL>

					<P>We may characterize the first of these examples as an analysis class,
					directly modeling objects from the application domain; the second one as a
					design class, describing a high-level solution; and the third as an
					implementation class, reused whenever possible from a library such as
					EiffelBase. In Eiffel, however, there is no strict distinction between these
					categories; it is part of the approach's seamlessness that the same notion of
					class, and the associated concepts, may be used at all levels of the software
					development process.</P>

					<H2>Class relations</H2>

					<P>Two relations may exist between classes:</P>

					<UL>
						<LI>You can define a class <SPAN CLASS="eclass">C</SPAN> as a
						<SPAN CLASS="bold">client</SPAN> of a class <SPAN CLASS="eclass">A</SPAN>
						to enable the features of <SPAN CLASS="eclass">C</SPAN> to rely on objects
						of type <SPAN CLASS="eclass">A</SPAN>.</LI>

						<LI>You may define a class <SPAN CLASS="eclass">B</SPAN> as an
						<SPAN CLASS="bold">heir</SPAN> of a class <SPAN CLASS="eclass">A</SPAN> to
						provide <SPAN CLASS="eclass">B</SPAN> with all the features and properties
						of <SPAN CLASS="eclass">A</SPAN>, letting <SPAN CLASS="eclass">B</SPAN>
						add its own features and properties and modify some of the inherited
						features if appropriate.</LI>
					</UL>

					<A NAME="INHERITANCE AND CLIENT TERMS"></A>
					<P>If <SPAN CLASS="eclass">C</SPAN> is a client of <SPAN CLASS="eclass">A</SPAN>,
					<SPAN CLASS="eclass">A</SPAN> is a <SPAN CLASS="bold">supplier</SPAN> of
					<SPAN CLASS="eclass">C</SPAN>. If <SPAN CLASS="eclass">B</SPAN> is an heir of
					<SPAN CLASS="eclass">A</SPAN>, <SPAN CLASS="eclass">A</SPAN> is a <SPAN CLASS="bold">
					parent</SPAN> of <SPAN CLASS="eclass">B</SPAN>. A <SPAN CLASS="bold">descendant</SPAN>
					of <SPAN CLASS="eclass">A</SPAN> is either <SPAN CLASS="eclass">A</SPAN> itself or,
					recursively, a descendant of an heir of <SPAN CLASS="eclass">A</SPAN>; in more
					informal terms a descendant is a direct or indirect heir, or the class itself.
					To exclude <SPAN CLASS="eclass">A</SPAN> itself we talk of
					<SPAN CLASS="bold">proper descendant</SPAN>. In the reverse direction the terms
					are <SPAN CLASS="bold">ancestor</SPAN> and <SPAN CLASS="bold">proper ancestor</SPAN>.</P>

					<P>The client relation can be cyclic; an example involving a cycle would be classes
					<SPAN CLASS="eclass">PERSON</SPAN> and <SPAN CLASS="eclass">HOUSE</SPAN>, modeling the
					corresponding informal everyday &quot;object&quot; types and expressing the properties
					that every person has a home and every home has an architect. The inheritance (heir)
					relation may not include any cycle.</P>

					<P>In modeling terms, client roughly represents the relation &quot;has&quot; and heir
					roughly represents &quot;is&quot;. For example we may use Eiffel classes to model a
					certain system and express that every child <SPAN CLASS="bold">has</SPAN> a birth date
					(client relation) and <SPAN CLASS="bold">is</SPAN> a person (inheritance).</P>

					<P>Distinctive of Eiffel is the rule that classes can only be connected through
					these two relations. This excludes the behind-the-scenes dependencies often found
					in other approaches, such as the use of global variables, which jeopardize the
					modularity of a system. Only through a strict policy of limited and explicit
					inter-class relations can we achieve the goals of reusability and extendibility.</P>

					<A NAME="GLOBAL"></A><H2>The global inheritance structure</H2>

					<P>An Eiffel class that you write does not come into a vacuum but fits in a
					preordained structure, shown in the figure and involving two library classes:
					<SPAN CLASS="eclass">ANY</SPAN> and <SPAN CLASS="eclass">NONE</SPAN>.</P>

					<A NAME="ANY"></A><IMG SRC="tutorial-4.png">

					<P>Any class that does not explicitly inherit from another is considered to inherit
					from <SPAN CLASS="eclass">ANY</SPAN>, so that every class is a descendant, direct or
					indirect, of <SPAN CLASS="eclass">ANY</SPAN>. <SPAN CLASS="eclass">ANY </SPAN>
					introduces a number of general-purpose features useful everywhere, such as copying,
					cloning and equality testing operations (see
					<A HREF="tutorial-07.html">The Dynamic Structure: Execution Model</A>) and default
					input-output. The procedure <SPAN CLASS="efeature">print</SPAN> used in the first
					version of our <A HREF="tutorial-05.html">&quot;Hello World!&quot;</A> comes from
					<SPAN CLASS="eclass">ANY</SPAN>.</P>

					<P><SPAN CLASS="eclass">NONE</SPAN> inherits from any class that has no explicit
					heir. Since inheritance has no cycles, <SPAN CLASS="eclass">NONE</SPAN> cannot have
					proper descendants. This makes it useful, as we will see, to specify non-exported
					features, and to denote the type of void values.
					Unlike <SPAN CLASS="eclass">ANY</SPAN>, class <SPAN CLASS="eclass">NONE</SPAN> doesn't
					have an actual class text; instead, it's a convenient fiction.</P>

					<A NAME="CLUSTERS"></A><H2>Clusters</H2>

					<P>Classes are the only form of module in Eiffel. As will be explained in more detail,
					they also provide the basis for the only form of type. This module-type
					identification is at the heart of object technology and of the fundamental simplicity
					of the Eiffel method.</P>

					<P>Above classes, you will find the concept of cluster. A cluster is a group of
					related classes. Clusters are a property of the method, enabling managers to
					organize the development into teams. As we have already seen (section
					<A HREF="tutorial-04.html">3</A>) they also play a central role in the lifecycle model.
					Clusters are an organizational concept, not a form of module, and do not require an
					Eiffel language construct.</P>

					<A NAME="91180"></A><H2>External software</H2>

					<P>The subsequent sections will show how to write Eiffel classes with their features.
					In an Eiffel system, however, not everything has to be written in Eiffel: some features
					may be <SPAN CLASS="bold">external</SPAN>, coming from languages such as C, C++, Java,
					C# and others. For example a feature declaration may appear (in lieu of the forms seen
					later) as:</P>

					<CODE>
						<P><SPAN CLASS="efeature">file_status</SPAN>
						<SPAN CLASS="esymbol">(</SPAN>filedesc<SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">):</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN> <SPAN CLASS="ekeyword">is</SPAN></P>

						<P CLASS=ecomment>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--
						Status indicator for <SPAN CLASS="elocal">filedesc</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">external</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="esymbol">&quot;</SPAN>C<SPAN CLASS="esymbol">&quot;</SPAN>
						<SPAN CLASS="ekeyword">alias</SPAN>
						<SPAN CLASS="esymbol">&quot;</SPAN>_fstat<SPAN CLASS="esymbol">&quot;</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN>
					</CODE>

					<P>to indicate that it is actually an encapsulation of a C function whose original
					name is <SPAN CLASS="bold">_fstat</SPAN>. The <SPAN CLASS="ekeyword">alias</SPAN>
					clause is optional, but here it is needed because the C name, starting with an
					underscore, is not valid as an Eiffel identifier.</P>

					<P>Similar syntax exists to interface with C++ classes.</P>

					<P>These mechanisms illustrate one of the roles of Eiffel: as an system
					architecturing and software composition tool, used at the highest level to produce
					systems with robust, flexible structures ready for extendibility, reusability and
					maintainability. In these structures not everything must be written in the Eiffel
					language: existing software elements and library components can play their part,
					with the structuring capabilities of Eiffel (classes, information hiding, inheritance,
					clusters, contracts and other techniques seen in this presentation) serving as the
					overall wrapping mechanism.</P>

					<P CLASS="seealso"><B>See also</B><BR />
						<A HREF="tutorial-07.html">The Dynamic Structure: Execution Model</A>
					</P>
				</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FOOTER">
			<TR>
				<TD>© 2003-2004 Eiffel Software. All rights reserved.</TD>
			</TR>
		</TABLE>
	</BODY>
</HTML>