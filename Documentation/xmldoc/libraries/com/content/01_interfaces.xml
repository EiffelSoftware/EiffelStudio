<document output="studio" title="Interfaces">
	<meta_data/>
	<paragraph>
		<paragraph>
			COM interfaces have several facets. First, an interface is a deferred, or an abstract, class.
			This means that an interface is a specification of a type.
			Second, an interface pointer represents a COM object, which is callable by a client
			application. An object can expose several interfaces, or represent several types.
		</paragraph>
		<heading>
			<size>2</size>ECOM_INTERFACE
		</heading>
		<paragraph>
			For each interface listed in a type library, the EiffelCOM wizard generates a deferred class
			and two effective classes: a proxy of an interface pointer, or a client side class, and a stub
			of an interface pointer, or a server side class. The deferred interface class inherits from
			<class_name>
				<url>../reference/ecom_interface_chart.xml</url>
				<label>ECOM_INTERFACE</label>
			</class_name>
			and has a deferred feature per each interface function. Both effective classes, or implemented
			interfaces, inherit from the deferred class and implement its functions. The functions of the
			interface proxy calls the underlying C layer, which in turn calls the COM component while
			the functions of the interface stub implement the component functionality.
		</paragraph>
		<paragraph>
			<link>
				<url>../reference/ecom_interface_chart.xml</url>
				<label>ECOM_INTERFACE</label>
			</link>
			holds a pointer to the underlying COM interface.
		</paragraph>
		<heading>
			<size>2</size>ECOM_QUERIABLE
		</heading>
		<paragraph>
			Different languages handle type coercion in different ways. C uses type cast; C++ introduces
			several type casting mechanisms; Eiffel uses assignment attempt, etc. Every COM interface exposes
			the <feature_name>QueryInterface</feature_name> function which allows clients to query the COM
			component for a pointer to another interface. Querying a component for an interface pointer is
			similar to using an assignment attempt in Eiffel. The Eiffel implementation of the assignment
			attempt relies on the runtime data. Since changing the Eiffel runtime and the
			implementation of the assignment attempt was not an option, EiffelCOM introduces a library class
			<link>
					<label>ECOM_QUERIABLE</label>
					<url>../reference/ecom_queriable_chart.xml</url>
			</link>
			, which has the creation routine
		</paragraph>
		<code_block>
			<feature_name>make_from_other</feature_name> <symbol>(</symbol>other<symbol>:</symbol> <class_name>ECOM_INTERFACE</class_name><symbol>)</symbol></code_block>
		<paragraph>
			which queries a COM component internally. Every interface proxy class inherits from
			<link>
					<label>ECOM_QUERIABLE</label>
					<url>../reference/ecom_queriable_chart.xml</url>
			</link>.
			The one difference between this mechanism versus using assignment attempt is that upon failure an
			exception will be raised. An assignment attempt that fails simply returns <keyword>Void</keyword>.
		</paragraph>
		<heading>
			<size>2</size>ECOM_STUB
		</heading>
		<paragraph>
			<link>
				<url>../reference/ecom_stub_chart.xml</url>
				<label>ECOM_STUB</label>
			</link>
			inherits from
			<link>
				<url>../reference/ecom_interface_chart.xml</url>
				<label>ECOM_INTERFACE</label>
			</link>
			, and exposes the feature
			<code>
				<link>
					<url>../reference/ecom_stub_chart.xml</url><anchor_name>f_create_item</anchor_name>
					<label>create_item</label>
				</link>
			</code>
			which allows creating the underlying COM object.
		</paragraph>
	</paragraph>
</document>