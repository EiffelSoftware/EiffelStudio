/*
	description: "Generic conformance routines."
	date:		"$Date$"
	revision:	"$Revision$"
	copyright:	"Copyright (c) 1985-2007, Eiffel Software."
	license:	"GPL version 2 see http://www.eiffel.com/licensing/gpl.txt)"
	licensing_options:	"Commercial license is available at http://www.eiffel.com/licensing"
	copying: "[
			This file is part of Eiffel Software's Runtime.
			
			Eiffel Software's Runtime is free software; you can
			redistribute it and/or modify it under the terms of the
			GNU General Public License as published by the Free
			Software Foundation, version 2 of the License
			(available at the URL listed under "license" above).
			
			Eiffel Software's Runtime is distributed in the hope
			that it will be useful,	but WITHOUT ANY WARRANTY;
			without even the implied warranty of MERCHANTABILITY
			or FITNESS FOR A PARTICULAR PURPOSE.
			See the	GNU General Public License for more details.
			
			You should have received a copy of the GNU General Public
			License along with Eiffel Software's Runtime; if not,
			write to the Free Software Foundation, Inc.,
			51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
		]"
	source: "[
			 Eiffel Software
			 356 Storke Road, Goleta, CA 93117 USA
			 Telephone 805-685-1006, Fax 805-685-6869
			 Website http://www.eiffel.com
			 Customer support http://support.eiffel.com
		]"
*/

/*
doc:<file name="gen_conf.c" header="eif_gen_conf.h" version="$Id$" summary="Generic conformance">
*/

#include "eif_portable.h"
#include "rt_macros.h"
#include "eif_globals.h"
#include "rt_struct.h"
#include "rt_gen_conf.h"
#include "rt_gen_types.h"
#include "rt_malloc.h"
#include "rt_threads.h"
#include "rt_garcol.h"
#include "rt_assert.h"
#include <ctype.h>
#include <string.h>

/*------------------------------------------------------------------*/
/* Debugging flag. If set, the names of the generated types will be */
/* output to the file 'logfile'. Simple facility.                   */
/*------------------------------------------------------------------*/

/*
doc:	<attribute name="eif_par_table" return_type="struct eif_par_types **" export="shared">
doc:		<summary>Parent tables. Defined by compiler C generated code in `eparents.c'. Changes to this table after melt are stored in melted file and processed by `updated.c' and stored in `eif_par_table2'.</summary>
doc:		<access>Read only through macro `par_info'.</access>
doc:		<indexing>base id; RTUD(no)</indexing>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None since initialized during runtime initialization.</synchronization>
doc:	</attribute>
doc:	<attribute name="eif_par_table_size" return_type="EIF_TYPE_INDEX" export="shared">
doc:		<summary>Size of `eif_par_table' table.</summary>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None since initialized during runtime initialization.</synchronization>
doc:	</attribute>
doc:	<attribute name="eif_par_table2" return_type="struct eif_par_types **" export="shared">
doc:		<summary>Same as `eif_par_table' except that this one contains both the static definition generated by compiler in `eparents.c' and the melted definition contained in melted file.</summary>
doc:		<access>Read only through macro `par_info'.</access>
doc:		<indexing>base id; RTUD(no)</indexing>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None since initialized during runtime initialization.</synchronization>
doc:	</attribute>
doc:	<attribute name="eif_par_table2_size" return_type="EIF_TYPE_INDEX" export="shared">
doc:		<summary>Size of `eif_par_table2' table.</summary>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None since initialized during runtime initialization.</synchronization>
doc:	</attribute>
*/
rt_shared struct eif_par_types **eif_par_table = NULL;
rt_shared EIF_TYPE_INDEX    eif_par_table_size = 0;
rt_shared struct eif_par_types **eif_par_table2 = NULL;
rt_shared EIF_TYPE_INDEX    eif_par_table2_size = 0;

/*
doc:	<attribute name="rtud_inv" return_type="EIF_TYPE_INDEX *" export="private">
doc:		<summary>Inverse RTUD table. Only used in workbench mode with changing dynamic types.</summary>
doc:		<access>Read only</access>
doc:		<indexing>base id; RTUD(yes)</indexing>
doc:		<result>RTUD(no)</result>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None since initialized during runtime initialization in `eif_gen_conf_init'.</synchronization>
doc:	</attribute>
*/
#ifdef WORKBENCH
rt_private EIF_TYPE_INDEX *rtud_inv = NULL;
#endif

/*
doc:	<attribute name="eif_cid_map" return_type="EIF_TYPE_INDEX *" export="public">
doc:		<summary>Compound id map. Maps compiler generated IDs to themselves and run-time generated IDs to their base IDs. In other word, map full dynamic type to dynamic type. Table is dynamically reallocated except in multithreaded mode where it is by default initialized to a count which represent the greatest type id (MAX_DTYPE).</summary>
doc:		<access>Read/Write (read with macros To_dtype)</access>
doc:		<indexing>full type id; RTUD(yes)</indexing>
doc:		<result>base id; RTUD(yes)</result>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None</synchronization>
doc:	</attribute>
doc:	<attribute name="eif_cid_size" return_type="int" export="private">
doc:		<summary>Number of elements in following structures `eif_cid_map', `eif_derivations', `eif_con_tab', `eif_anc_id_map' and `eif_conf_tab'.</summary>
doc:		<access>Read/Write</access>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>eif_gen_mutex</synchronization>
doc:	</attribute>
*/
rt_public EIF_TYPE_INDEX  *eif_cid_map = NULL;
rt_private int  eif_cid_size = 0;

/*
doc:	<attribute name="egc_any_dtype" return_type="EIF_TYPE_INDEX" export="public">
doc:		<summary>Type of ANY. Used to create ARRAY [ANY] from the runtime (e.g. used for `strip'). Value computed in `eif_gen_conf_init'.</summary>
doc:		<result>RTUD(no)</result>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None since initialized during runtime initialization in `eif_gen_conf_init'.</synchronization>
doc:	</attribute>
doc:	<attribute name="tuple_static_type" return_type="EIF_TYPE_INDEX" export="private">
doc:		<summary>Base id of TUPLE.</summary>
doc:		<result>RTUD(no)</result>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None since initialized during runtime initialization in `eif_gen_conf_init'.</synchronization>
doc:		<fixme>Shouldn't we use `egc_tup_dtype' instead?</fixme>
doc:	</attribute>
*/
rt_public EIF_TYPE_INDEX egc_any_dtype = INVALID_DTYPE; /* Precise value determined in init */
rt_private EIF_TYPE_INDEX tuple_static_type = INVALID_DTYPE;

/*------------------------------------------------------------------*/
/* Structure representing a generic derivation. We also use this    */
/* for BIT types to remember their sizes.                           */
/*------------------------------------------------------------------*/

typedef struct eif_gen_der {
	uint32              size;       /* Size of type array/ nr. of bits in BIT type */
	EIF_TYPE_INDEX      hcode;      /* Hash code to speedup search */
	EIF_TYPE_INDEX      *typearr;   /* Array of types (cid) */
									/* RTUD(no) */
	EIF_TYPE_INDEX      *gen_seq;   /* Id sequence which generates this type */
									/* RTUD(yes) */
	EIF_TYPE_INDEX      *ptypes;    /* Parent types */
									/* RTUD(yes) */
	EIF_TYPE_INDEX      id;         /* Run-time generated id */
									/* RTUD(no) */
	EIF_TYPE_INDEX      base_id;    /* Compiler generated (base) id */
									/* RTUD(no) */
	EIF_TYPE_INDEX      first_id;   /* First matching compiler gen. id */
									/* RTUD(no) */
	char                *name;      /* Full type name */
	char                is_expanded;/* Is it an expanded type? */
	char                is_bit;     /* Is it a BIT type? */
	char                is_tuple;   /* Is it a TUPLE type? */
	char                is_array;   /* Is it an ARRAY type? */
	struct eif_gen_der  *next;      /* Next derivation */
} EIF_GEN_DER;
/*------------------------------------------------------------------*/
/* Structure for conformance information. The `lower' ids are the   */
/* usual compiler generated ids. The others are generated here.     */
/*                                                                  */
/* All ids are full type ids; RTUD(yes)                             */
/* Indexing: full type ids; RTUD(yes)                               */
/*------------------------------------------------------------------*/

typedef struct {
	EIF_TYPE_INDEX  min_low_id;     /* Minimal lower conforming id */
	EIF_TYPE_INDEX  max_low_id;     /* Maximal lower conforming id */
	EIF_TYPE_INDEX  min_high_id;    /* Minimal high conforming id */
	EIF_TYPE_INDEX  max_high_id;    /* Maximal high conforming id */
	unsigned char   *low_tab;       /* Bit table for lower ids */
	unsigned char   *high_tab;      /* Bit table for high ids */
	unsigned char   *low_comp;      /* Bit table for computed lower conf. */
	unsigned char   *high_comp;     /* Bit table for computed high conf. */
} EIF_CONF_TAB;
/*------------------------------------------------------------------*/
/* Structure for ancestor id information.                           */
/*------------------------------------------------------------------*/

typedef struct {
	EIF_TYPE_INDEX  min_id;         /* Minimal ancestor id; RTUD(no) */
	EIF_TYPE_INDEX  max_id;         /* Maximal ancestor id; RTUD(no) */
	EIF_TYPE_INDEX  *map;           /* Ancestor id map.
									   Index : RTUD(no)
									   Result: RTUD(yes)
									*/
} EIF_ANC_ID_MAP;
/*------------------------------------------------------------------*/

/*
doc:	<attribute name="first_gen_id" return_type="EIF_TYPE_INDEX" export="private">
doc:		<summary>base id of first generic type. All values below `first_gen_id' do not represent generic classes.</summary>
doc:		<access>Read</access>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None since initialized during runtime initialization in `eif_gen_conf_init'.</synchronization>
doc:	</attribute>
doc:	<attribute name="next_gen_id" return_type="EIF_TYPE_INDEX" export="private">
doc:		<summary>ID for next new generic derivation encountered during runtime execution.</summary>
doc:		<access>Read/Write</access>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>eif_gen_mutex</synchronization>
doc:	</attribute>
*/
rt_private EIF_TYPE_INDEX  first_gen_id = 0;
rt_private EIF_TYPE_INDEX  next_gen_id  = 0;

/*
doc:	<attribute name="eif_anc_id_map" return_type="EIF_ANC_ID_MAP **" export="private">
doc:		<summary>Ancestor ID maps.</summary>
doc:		<access>Read/Write</access>
doc:		<indexing>full type id; RTUD(yes)</indexing>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>eif_gen_mutex</synchronization>
doc:	</attribute>
doc:	<attribute name="eif_conf_tab" return_type="EIF_CONF_TAB **" export="private">
doc:		<summary>Conformance tables.</summary>
doc:		<access>Read/Write</access>
doc:		<indexing>full type id; RTUD(yes)</indexing>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>eif_gen_mutex</synchronization>
doc:	</attribute>
doc:	<attribute name="eif_derivations" return_type="EIF_GEN_DER **" export="private">
doc:		<summary>Generic derivations.</summary>
doc:		<access>Read/Write</access>
doc:		<indexing>full type id; RTUD(yes)</indexing>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>eif_gen_mutex</synchronization>
doc:	</attribute>
*/
rt_private EIF_ANC_ID_MAP **eif_anc_id_map = NULL;
rt_private EIF_CONF_TAB **eif_conf_tab = NULL;
rt_private EIF_GEN_DER **eif_derivations = NULL;

#ifndef EIF_THREADS
/*
doc:	<attribute name="cid_array" return_type="EIF_TYPE_INDEX [3]" export="private">
doc:		<summary>Static array used by `eif_gen_cid' for `dftype' that are not generics.</summary>
doc:		<access>Read/Write</access>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>Private per thread data</synchronization>
doc:	</attribute>
*/
rt_private EIF_TYPE_INDEX cid_array [3];

/*
doc:	<attribute name="non_generic_type_names" return_type="char **" export="private">
doc:		<summary>Array indexed by non generic type id which contains their associated type name.</summary>
doc:		<access>Read/Write</access>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>Private per thread data</synchronization>
doc:	</attribute>
*/
rt_private char ** non_generic_type_names = NULL;
#endif

/*------------------------------------------------------------------*/
/* THREADS.                                                         */
/* Calls to public routines are indirected and protected by a mutex */
/* The indirection avoids problems with recursive calls.            */
/*------------------------------------------------------------------*/

#ifdef  EIF_THREADS

/*
doc:	<attribute name="eif_gen_mutex" return_type="" export="shared">
doc:		<summary>Calls to public routines are indirected and protected by current mutex. Indirection is needed to avoids problem with recursive calls.</summary>
doc:		<access>Read</access>
doc:		<thread_safety>Safe</thread_safety>
doc:	</attribute>
*/
rt_shared EIF_LW_MUTEX_TYPE *eif_gen_mutex = NULL;

rt_public EIF_TYPE_INDEX eifthd_compound_id (EIF_TYPE_INDEX *, EIF_TYPE_INDEX, EIF_TYPE_INDEX, EIF_TYPE_INDEX *);
rt_public EIF_TYPE_INDEX eifthd_final_id (EIF_TYPE_INDEX *, EIF_TYPE_INDEX **, EIF_TYPE_INDEX, int );
rt_shared uint32 eifthd_gen_count_with_dftype (EIF_TYPE_INDEX );
rt_shared char eifthd_gen_typecode_with_dftype (EIF_TYPE_INDEX , uint32);
rt_public EIF_TYPE_INDEX eifthd_gen_param_id (EIF_TYPE_INDEX , uint32);
rt_public EIF_REFERENCE eifthd_gen_create (EIF_REFERENCE , uint32);
rt_shared EIF_TYPE_INDEX eifthd_register_bit_type (uint16);
rt_shared EIF_TYPE_INDEX eifthd_typeof_array_of (EIF_TYPE_INDEX);
rt_public char *eifthd_gen_typename (EIF_REFERENCE );
rt_shared EIF_TYPE_INDEX *eifthd_gen_cid (EIF_TYPE_INDEX);
rt_shared EIF_TYPE_INDEX eifthd_gen_id_from_cid (EIF_TYPE_INDEX *, EIF_TYPE_INDEX *);
rt_public int eifthd_gen_conf (EIF_TYPE_INDEX, EIF_TYPE_INDEX);

#define EIFMTX_LOCK \
	{\
		RT_GET_CONTEXT \
		EIF_ASYNC_SAFE_LW_MUTEX_LOCK(eif_gen_mutex, "Cannot lock mutex for eif_gen_conf\n");

#define EIFMTX_UNLOCK \
	   	EIF_ASYNC_SAFE_LW_MUTEX_UNLOCK(eif_gen_mutex, "Cannot unlock mutex for eif_gen_conf\n"); \
	}

#else
/* Noop for locks in non-multithreaded mode. */
#define EIFMTX_LOCK
#define EIFMTX_UNLOCK
#endif
/*------------------------------------------------------------------*/

rt_shared size_t eif_typename_len (EIF_TYPE_INDEX dftype);
rt_private EIF_TYPE_INDEX eif_gen_param (EIF_TYPE_INDEX, uint32, char *, uint16 *);
rt_private void eif_create_typename (EIF_TYPE_INDEX, char*);
rt_private EIF_GEN_DER *eif_new_gen_der(uint32, EIF_TYPE_INDEX*, EIF_TYPE_INDEX, char, char, EIF_TYPE_INDEX);
rt_private EIF_ANC_ID_MAP *eif_new_anc_id_map (EIF_TYPE_INDEX, EIF_TYPE_INDEX);
rt_private void eif_compute_anc_id_map (EIF_TYPE_INDEX);
rt_private void eif_expand_tables(int);
rt_private EIF_TYPE_INDEX eif_id_of (EIF_TYPE_INDEX**, EIF_TYPE_INDEX**, EIF_TYPE_INDEX, int);
rt_private void eif_compute_ctab (EIF_TYPE_INDEX);
rt_private EIF_CONF_TAB *eif_new_conf_tab (EIF_TYPE_INDEX, EIF_TYPE_INDEX, EIF_TYPE_INDEX, EIF_TYPE_INDEX);
rt_private void eif_enlarge_conf_tab (EIF_CONF_TAB *, EIF_TYPE_INDEX);
rt_private uint16 eif_gen_seq_len (EIF_TYPE_INDEX);
rt_private void eif_put_gen_seq (EIF_TYPE_INDEX, EIF_TYPE_INDEX*, EIF_TYPE_INDEX*, EIF_TYPE_INDEX);

/*------------------------------------------------------------------*/

#ifdef WORKBENCH
#define RTUD_INV(x)  (((x) >= fcount)?(x):rtud_inv[(x)])

#else
#define RTUD_INV(x) (x)
#endif

/*
doc:	<routine name="eif_id_for_typarr" return_type="EIF_TYPE_INDEX" export="public">
doc:		<summary>Perform call to RTUD_INV from generated code. Needed as RTUD_INV is not exported.</summary>
doc:		<param name="id" type="EIF_TYPE_INDEX">Full dynamic type converted back to its associated RTUD_INV.</param>
doc:		<return>RTUD_INV of `id'</return>
doc:	</routine>
*/
rt_public EIF_TYPE_INDEX eif_id_for_typarr (EIF_TYPE_INDEX id) {
	REQUIRE ("Valid id", (id >= 0) || (id == NONE_TYPE));
	return (id == NONE_TYPE ? NONE_TYPE : RTUD_INV(id));
}


/*------------------------------------------------------------------*/

#ifdef EIF_THREADS

/*------------------------------------------------------------------*/
/* Public features protected with a MUTEX.                          */
/*------------------------------------------------------------------*/

rt_public EIF_TYPE_INDEX eif_compound_id (EIF_TYPE_INDEX *cache, EIF_TYPE_INDEX current_dftype, EIF_TYPE_INDEX base_id, EIF_TYPE_INDEX *types)
{
	EIF_TYPE_INDEX   result;

	EIFMTX_LOCK;
	result = eifthd_compound_id (cache, current_dftype, base_id, types);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_public EIF_TYPE_INDEX eif_final_id (EIF_TYPE_INDEX *ttable, EIF_TYPE_INDEX **gttable, EIF_TYPE_INDEX dftype, int offset)
{
	EIF_TYPE_INDEX   result;

	EIFMTX_LOCK;
	result = eifthd_final_id (ttable, gttable, dftype, offset);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_shared uint32 eif_gen_count_with_dftype (EIF_TYPE_INDEX dftype)
{
	uint32 result;

	EIFMTX_LOCK;
	result = eifthd_gen_count_with_dftype (dftype);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_shared char eif_gen_typecode_with_dftype (EIF_TYPE_INDEX dftype, uint32 pos)
{
	char    result;

	EIFMTX_LOCK;
	result = eifthd_gen_typecode_with_dftype (dftype, pos);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_public EIF_TYPE_INDEX eif_gen_param_id (EIF_TYPE_INDEX dftype, uint32 pos)
{
	EIF_TYPE_INDEX   result;

	EIFMTX_LOCK;
	result = eifthd_gen_param_id (dftype, pos);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_public EIF_REFERENCE eif_gen_create (EIF_REFERENCE obj, uint32 pos)
{
	char    *result;

	EIFMTX_LOCK;
	result = eifthd_gen_create (obj, pos);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_shared EIF_TYPE_INDEX eif_register_bit_type (uint16 size)
{
	EIF_TYPE_INDEX   result;

	EIFMTX_LOCK;
	result = eifthd_register_bit_type (size);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_shared EIF_TYPE_INDEX eif_typeof_array_of (EIF_TYPE_INDEX dtype)
{
	EIF_TYPE_INDEX   result;

	EIFMTX_LOCK;
	result = eifthd_typeof_array_of (dtype);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_shared EIF_TYPE_INDEX *eif_gen_cid (EIF_TYPE_INDEX dftype)
{
	EIF_TYPE_INDEX   *result;

	EIFMTX_LOCK;
	result = eifthd_gen_cid (dftype);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_shared EIF_TYPE_INDEX eif_gen_id_from_cid (EIF_TYPE_INDEX *a_cidarr, EIF_TYPE_INDEX *dtype_map)
{
	EIF_TYPE_INDEX   result;

	EIFMTX_LOCK;
	result = eifthd_gen_id_from_cid (a_cidarr, dtype_map);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_public int eif_gen_conf (EIF_TYPE_INDEX source_type, EIF_TYPE_INDEX target_type)
{
	int result;

	EIFMTX_LOCK;
	result = eifthd_gen_conf (source_type, target_type);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/
/* Rename public features if EIF_THREADS is on.                     */
/*------------------------------------------------------------------*/

#define eif_compound_id           eifthd_compound_id
#define eif_final_id              eifthd_final_id
#define eif_gen_count_with_dftype eifthd_gen_count_with_dftype
#define eif_gen_typecode_with_dftype  eifthd_gen_typecode_with_dftype
#define eif_gen_param_id          eifthd_gen_param_id
#define eif_gen_create            eifthd_gen_create
#define eif_register_bit_type     eifthd_register_bit_type
#define eif_typeof_array_of       eifthd_typeof_array_of
#define eif_gen_cid               eifthd_gen_cid
#define eif_gen_id_from_cid       eifthd_gen_id_from_cid
#define eif_gen_conf              eifthd_gen_conf

#endif

/*------------------------------------------------------------------*/
/* Initialize all structures                                        */
/* Called only once before root object is created.                  */
/*------------------------------------------------------------------*/

rt_shared void eif_gen_conf_init (EIF_TYPE_INDEX max_dtype)
{
	RT_GET_CONTEXT
	EIF_TYPE_INDEX dt;
	char   *cname;
	struct eif_par_types **pt;

#ifdef EIF_THREADS
		/* Since we want to avoid any locks to happen on the access on 
		 * eif_cid_map, we make sure that `eif_cid_map' can't be resized
		 * by giving the maximum size it can have, ie 0x0000FFFF */
	eif_cid_size = 65535;
#else
	eif_cid_size = max_dtype + 32;
#endif
	first_gen_id = next_gen_id = max_dtype + 1;

	/* Set `eif_par_table2' if it is null. */

	if (eif_par_table2 == NULL)
	{
		eif_par_table2 = eif_par_table;
		eif_par_table2_size = eif_par_table_size;
	}

	eif_cid_map = (EIF_TYPE_INDEX *) cmalloc (eif_cid_size * sizeof (EIF_TYPE_INDEX));

	if (eif_cid_map == NULL)
		enomem();

	eif_derivations = (EIF_GEN_DER **) cmalloc(eif_cid_size * sizeof (EIF_GEN_DER*));

	if (eif_derivations == NULL)
		enomem();

	eif_conf_tab = (EIF_CONF_TAB **) cmalloc(eif_cid_size * sizeof (EIF_CONF_TAB*));

	if (eif_conf_tab == NULL)
		enomem();

	eif_anc_id_map = (EIF_ANC_ID_MAP **) cmalloc(eif_cid_size * sizeof (EIF_ANC_ID_MAP*));

	if (eif_anc_id_map == NULL)
		enomem();

	/* Setup a 1-1 mapping and initialize the arrays */

	for (dt = 0; dt < eif_cid_size; ++dt)
	{
		eif_cid_map [dt]     = dt;
		eif_derivations [dt] = NULL;
		eif_conf_tab [dt]    = NULL;
		eif_anc_id_map [dt]  = NULL;
	}

	/* Now initialize egc_xxx_dtypes */

	for (dt = 0, pt = eif_par_table2; dt <= eif_par_table2_size; ++dt, ++pt)
	{
		if (*pt == (struct eif_par_types *)0)
			continue;

		cname = System((*pt)->dtype).cn_generator;

		if ((strcmp("ANY",cname)==0))
		{
			egc_any_dtype = dt;
		}

		if ((strcmp("TUPLE",cname)==0))
		{
			tuple_static_type = dt;
		}
	}

	/* Now setup inverse RTUD table. This is used
	   to undo the effect of RTUD(type) */

#ifdef WORKBENCH

	rtud_inv = (EIF_TYPE_INDEX *) cmalloc (fcount * sizeof (EIF_TYPE_INDEX));

	if (rtud_inv == NULL)
		enomem();
	
	for (dt = 0; dt < fcount; ++dt)
	{
		if (par_info(dt) != NULL)
			rtud_inv [egc_fdtypes [dt]] = dt;
	}

	rtud_inv [0] = 0;	/* For the GENERAL class */

#endif

	/* Initialize `cid_array' */

	cid_array [0] = 1;  /* count */
	cid_array [1] = 0;  /* id */
	cid_array [2] = TERMINATOR; /* Terminator */

		/* Initialize `non_generic_type_names' for root thread now that `first_gen_id' is
		 * properly computed. Indeed the first call to `eif_gen_conf_thread_init' is done
		 * before `first_gen_id' is initialized and therefore does not allocate anything
		 * since `first_gen_id' is zero. The second call will do things properly.
		 */
	eif_gen_conf_thread_init();
}

/*
doc:	<routine name="eif_gen_conf_thread_init" return_type="void" export="shared">
doc:		<summary>Initialize per thread data used for generic conformance. Root thread initialization is done in `eif_gen_conf_init' as when we are called by the `eif_thr_register' routine, the value `first_gen_id' is still zero.</summary>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None</synchronization>
doc:	</routine>
*/
rt_shared void eif_gen_conf_thread_init (void) {
	RT_GET_CONTEXT
	if (first_gen_id > 0) {
		non_generic_type_names = (char **) eif_rt_xcalloc (first_gen_id, sizeof (char *));
	}
}

/*
doc:	<routine name="eif_gen_conf_thread_cleanup" return_type="void" export="shared">
doc:		<summary>Initialize per thread data used for generic conformance.</summary>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None</synchronization>
doc:	</routine>
*/
rt_shared void eif_gen_conf_thread_cleanup (void) {
	RT_GET_CONTEXT
	char *l_name;
	int i = 0;

	for (; i < first_gen_id; i++) {
		l_name = non_generic_type_names [i];
		if (l_name) {
			eif_rt_xfree (l_name);
		}
	}
	eif_rt_xfree (non_generic_type_names);
	non_generic_type_names = NULL;
}

/*------------------------------------------------------------------*/
/* Clean up.                                                        */
/* Called from reclaim, and free all global variables allocated     */
/* for the Generic Conformance.                                     */
/*------------------------------------------------------------------*/
rt_shared void eif_gen_conf_cleanup (void) 
{
	/* Free in reverse order of allocation. */

	int i, j;

#ifdef EIF_THREADS
	REQUIRE ("Called by root thread", eif_thr_is_root ());
#endif	/* EIF_THREADS */
	REQUIRE ("eif_anc_id_map not null", eif_anc_id_map);
	REQUIRE ("eif_conf_tab not null", eif_conf_tab);
	REQUIRE ("eif_derivations not null", eif_derivations);
	REQUIRE ("eif_cid_map not null", eif_cid_map);

#ifdef WORKBENCH
	eif_rt_xfree (rtud_inv);
	rtud_inv = NULL;
#endif	/* WORKBENCH */

	/* Recursively free eif_anc_id_map */
	for (i = 0; i < eif_cid_size; i++) {
		EIF_ANC_ID_MAP *tmp = eif_anc_id_map [i];

		if (tmp == NULL)
			continue;
		if (tmp->map) {
			eif_rt_xfree (tmp->map);
		} else {
#ifdef LMALLOC_CHECK
			CHECK ("", !(is_in_lm (tmp->map)));
#endif	/* LMALLOC_CHECK */
		}
		eif_rt_xfree (tmp);
	}
	eif_rt_xfree (eif_anc_id_map);	

	/* Recursively free eif_conf_tab */
	for (i = 0; i < eif_cid_size; i++) {
		EIF_CONF_TAB *tmp = eif_conf_tab [i];	

		if (tmp == NULL)
			continue;

		if (tmp->low_tab) {
			eif_rt_xfree (tmp->low_tab);	/* unsigned char * */
		} else {
#ifdef LMALLOC_CHECK
			CHECK ("", !(is_in_lm (tmp->low_tab)));
#endif	/* LMALLOC_CHECK */
		}
		if (tmp->high_tab) {
			eif_rt_xfree (tmp->high_tab);	/* unsigned char * */
		} else {
#ifdef LMALLOC_CHECK
			CHECK ("", !(is_in_lm (tmp->high_tab)));
#endif	/* LMALLOC_CHECK */
		}
		if (tmp->low_comp) {
			eif_rt_xfree (tmp->low_comp);	 	/* unsigned char * */
		} else {
#ifdef LMALLOC_CHECK
			CHECK ("", !(is_in_lm (tmp->low_comp)));
#endif	/* LMALLOC_CHECK */
		}
		if (tmp->high_comp)	{
			eif_rt_xfree (tmp->high_comp);	 	/* unsigned char * */
		} else {
#ifdef LMALLOC_CHECK
			CHECK ("", !(is_in_lm (tmp->high_comp)));
#endif	/* LMALLOC_CHECK */
		}
		eif_rt_xfree (tmp);
	}
	eif_rt_xfree (eif_conf_tab);	

	/* Recursively free eif_derivations. */
	for (i = 0; i < eif_cid_size; i++) {
		EIF_GEN_DER *tmp = eif_derivations [i];

		if (tmp == NULL)
			continue;
		if (tmp->typearr) {
			eif_rt_xfree (tmp->typearr);
		} else {
#ifdef LMALLOC_CHECK
			CHECK ("", !(is_in_lm (tmp->typearr)));
#endif	/* LMALLOC_CHECK */
		}
		if (tmp->gen_seq) {
			eif_rt_xfree (tmp->gen_seq);
		} else {
#ifdef LMALLOC_CHECK
			CHECK ("", !(is_in_lm (tmp->gen_seq)));
#endif	/* LMALLOC_CHECK */
		}
		if (tmp->ptypes) {
			eif_rt_xfree (tmp->ptypes);
		} else {
#ifdef LMALLOC_CHECK
			CHECK ("", !(is_in_lm (tmp->ptypes)));
#endif	/* LMALLOC_CHECK */
		}
		if (tmp->name) {
			eif_rt_xfree (tmp->name);			/* char * */
		}
		for (j = i + 1; j < eif_cid_size; j++) {
			if (eif_derivations [j] == tmp)	
				eif_derivations[j] = NULL;
				
		}
		eif_rt_xfree (tmp);
	}
	eif_rt_xfree (eif_derivations);	

	eif_rt_xfree (eif_cid_map);
#ifndef EIF_THREADS
	eif_gen_conf_thread_cleanup();
#endif
} /* eif_gen_conf_cleanup () */

/*------------------------------------------------------------------*/
/* Compute id for `types'. `cache' is used to cache the result in   */
/* the generated C code if possible.                                */
/*                                                                  */
/* cache   : To cache result; RTUD(yes)                             */
/* base_id : Base id of type; RTUD(no)                              */
/* types   : Id array; RTUD(no)                                     */
/* Result  : Resulting id; RTUD(yes)                                */
/*------------------------------------------------------------------*/

rt_public EIF_TYPE_INDEX eif_compound_id (EIF_TYPE_INDEX *cache, EIF_TYPE_INDEX current_dftype, EIF_TYPE_INDEX base_id, EIF_TYPE_INDEX *types)
{
	EIF_TYPE_INDEX   result, gresult;
	EIF_TYPE_INDEX   outtab [256], *outtable, *intable;

	result = base_id;

	if ((types != NULL) && (*(types+1) != TERMINATOR))
	{
		/* Check if it's cached - if yes return immediately */

		if ((cache) && (*cache != TERMINATOR))
		{
			return *cache;
		}

		intable  = types+1;
		outtable = outtab;

		gresult = eif_id_of (&intable, &outtable, current_dftype, 1);
		
		if (cache) {
			*cache = gresult;
		}

		return gresult;
	}

	return RTUD(result);
}

/*------------------------------------------------------------------*/
/* Compute id for `gttable' (generic type list for feature in final */
/* mode).                                                           */
/*                                                                  */
/* Result : RTUD(yes); doesn't matter since in final mode           */
/*------------------------------------------------------------------*/

rt_public EIF_TYPE_INDEX eif_final_id (EIF_TYPE_INDEX *ttable, EIF_TYPE_INDEX **gttable, EIF_TYPE_INDEX dftype, int offset)

{
	EIF_TYPE_INDEX   result, *gtp;
	EIF_TYPE_INDEX	dtype = To_dtype(dftype);
	int	table_index = dtype - offset;

	if (gttable != NULL) {
		gtp = gttable [table_index];

		if ((gtp != NULL) && (*(gtp+1) != TERMINATOR)) {
			*gtp = dtype;
			return eif_compound_id (NULL, dftype, ttable[table_index], gtp);
		}
	}

	result = ttable[table_index];

	return result;
}
/*------------------------------------------------------------------*/
/* Extract actual generic at position `pos' (>=1) from object `obj'.*/
/* `is_exp' is set to a non-zero value if type is expanded else it's*/
/* set to zero. `nr_bits' is > 0 if type is BIT, zero otherwise -   */
/* the value can then be used to call RTLB(nr_bits).                */
/*                                                                  */
/* Result: RTUD(yes)                                                */
/*------------------------------------------------------------------*/

rt_private EIF_TYPE_INDEX eif_gen_param (EIF_TYPE_INDEX dftype, uint32 pos, char *is_exp, uint16 *nr_bits)
{
	EIF_TYPE_INDEX result;
	EIF_GEN_DER *gdp;

	REQUIRE("Valid type", (dftype >= 0) && (dftype < next_gen_id));

	gdp = eif_derivations [dftype];

	CHECK("A generic type", gdp && (!gdp->is_bit));
	CHECK("Valid generic parameter position", (pos > 0) && (pos <= gdp->size));

	*is_exp = (char) 0;
	*nr_bits = 0;

	result = gdp->typearr [pos-1];

	if (result < first_gen_id) {
		*is_exp = (char) EIF_IS_EXPANDED_TYPE(System (RTUD(result)));
		return RTUD(result);
	}

	gdp = eif_derivations [result];

		/* Is it an expanded type? If yes set the `is_exp' flag. */
	if ((gdp != NULL) && (gdp->is_expanded))
		*is_exp = '1';

		/* Is it a BITn type? If yes set the number of bits */
	if ((gdp != NULL) && (gdp->is_bit))
		*nr_bits = (uint16) gdp->size;

	return result;
}
/*------------------------------------------------------------------*/
/* Number of generic parameters of `obj's type. Can ONLY be used for*/
/* TUPLE and its descendants!                                       */
/*------------------------------------------------------------------*/

rt_public uint32 eif_gen_count_with_dftype (EIF_TYPE_INDEX dftype)
{
	EIF_GEN_DER *gdp;

	REQUIRE("Valid type", (dftype >= 0) && (dftype < next_gen_id));

	gdp = eif_derivations [dftype];

	return (gdp ? gdp->size : 0);
}

/*------------------------------------------------------------------*/
/* Number of generic parameters of `obj's type. Can ONLY be used for*/
/* TUPLE                                                            */
/*------------------------------------------------------------------*/

rt_public uint32 eif_tuple_count (EIF_REFERENCE obj)
{
	return (obj ? RT_SPECIAL_COUNT(obj) - 1 : 0);
}

/*------------------------------------------------------------------*/
/* Are all generic parameters of basic types? Can ONLY be used for  */
/* TUPLE                                                            */
/*------------------------------------------------------------------*/

rt_shared int eif_tuple_is_atomic (EIF_REFERENCE obj)
{
	EIF_VALUE *l_item = (EIF_VALUE *) obj;
	unsigned int count;
	
	if (obj == NULL) {
			/* This is atomic */
		return 1;
	}

	CHECK("Tuple object", HEADER(obj)->ov_flags & EO_TUPLE);
	count = RT_SPECIAL_COUNT(obj);

		/* Don't forget that first element of TUPLE is the BOOLEAN
		 * `object_comparison' attribute. */
	l_item++;
	for (; count > 0 ; count--) {
		if (eif_is_reference_tuple_item(l_item)) {
				/* It has a reference. This is therefore not atomic */
			return 0;
		}
	}
		/* No reference found. It is atomic */
	return 1;
}

/*------------------------------------------------------------------*/
/* Typecode of generic type at position `pos' in `obj'. ONLY for    */
/* TUPLE                                                            */
/*------------------------------------------------------------------*/

rt_public char eif_gen_typecode (EIF_REFERENCE obj, uint32 pos)
{
	if (obj == NULL) {
		return (char) 0;
	} else {
		char result;
			/* Critical section as we might compute a new `eif_anc_id_map' entry */
		EIFMTX_LOCK;
		result = eif_gen_typecode_with_dftype (Dftype(obj), pos);
		EIFMTX_UNLOCK;
		return result;
	}
}

rt_shared char eif_gen_typecode_with_dftype (EIF_TYPE_INDEX dftype, uint32 pos)
{
	EIF_TYPE_INDEX gtype;
	EIF_GEN_DER *gdp;

		/* Check type validity */
	REQUIRE ("dftype is non-negative", dftype >= 0);
	REQUIRE ("dftype is less than maximum computed id", dftype < next_gen_id);
	REQUIRE ("We have routines, so we must have tuples.", tuple_static_type >= 0);

	gdp = eif_derivations [dftype];

	CHECK ("gdp not null", gdp != (EIF_GEN_DER *)0);
	CHECK ("Not a bit type", !gdp->is_bit);

	CHECK ("Valid generic position min", pos > 0);
	CHECK ("Valid generic position max", pos <= gdp->size);

	gtype = gdp->typearr [pos-1];

	if (gtype == NONE_TYPE) {
		return EIF_REFERENCE_CODE;
	}

	return EIF_TUPLE_CODE(System(eif_cid_map[RTUD(gtype)]));
}

/*------------------------------------------------------------------*/
/* Typecode string for target/argument types of a ROUTINE object.   */
/* ONLY for ROUTINE!                                                */
/*------------------------------------------------------------------*/

rt_public EIF_REFERENCE eif_gen_typecode_str (EIF_REFERENCE obj)
{
	EIF_GET_CONTEXT

	EIF_REFERENCE ret;	/* Return value. */
	EIF_TYPE_INDEX dftype, gtype;
	int len;
	uint32 pos;
	EIF_GEN_DER *gdp;
	char *strp;

	REQUIRE ("obj not null", obj != (EIF_REFERENCE )0);

	dftype = Dftype(obj);

	REQUIRE ("Non negative dftype", dftype >= 0);
	REQUIRE ("Valid dftype", dftype < next_gen_id);

	gdp = eif_derivations [dftype];

	CHECK ("gdp not null", gdp != (EIF_GEN_DER *)0);
	CHECK ("Not a bit type", !gdp->is_bit);
	CHECK ("Not a routine object", gdp->size > 1);

		/* Type of call target */
	gtype = gdp->typearr [0];

		/* Now treat the arguments.  This is necessarily a TUPLE */
	dftype = gdp->typearr [1];

	CHECK ("Non negative dftype", dftype >= 0);
	CHECK ("Valid dftype", dftype < next_gen_id);
	CHECK ("Routines implies we have tuples", tuple_static_type >= 0);

	/* NOTE: Since dftype is a TUPLE we have RTUD(dftype) = dftype.  */
	gdp = eif_derivations [dftype];

	CHECK ("gdp not null", gdp != (EIF_GEN_DER *)0);
	CHECK ("Not a bit type", !gdp->is_bit);

		/* Create a string for gdp->size + 1 characters */
	len = gdp->size + 1;

	ret = emalloc(egc_str_dtype);
	RT_GC_PROTECT(ret);
		/* Protect address in case it moves */

	nstcall = 0;
	RT_STRING_MAKE(ret, (EIF_INTEGER) len);
	RT_STRING_SET_COUNT(ret, len);

	/* We know the `area' is the very first reference
	 * of the STRING object, hence the simple de-referencing.
	 */

	strp = *(EIF_REFERENCE*)ret;

	*strp = EIF_TUPLE_CODE(System(eif_cid_map[RTUD(gtype)]));
	strp++;

	for (pos = 0; pos < gdp->size; pos++, strp++) {
		gtype = gdp->typearr [pos];
		if (gtype == NONE_TYPE) {
			*strp = EIF_REFERENCE_CODE;
		} else {
			*strp = EIF_TUPLE_CODE(System(eif_cid_map[RTUD(gtype)]));
		}
	}

	RT_GC_WEAN(ret);			/* Remove protection */

	return ret;	
}

/*------------------------------------------------------------------*/
/* Type of generic parameter in `obj' at position `pos'.            */
/*                                                                  */
/* Result: RTUD(yes)                                                */
/*------------------------------------------------------------------*/

rt_public EIF_TYPE_INDEX eif_gen_param_id (EIF_TYPE_INDEX dftype, uint32 pos)

{
	char    is_expanded;
	uint16    nr_bits;

	REQUIRE("Valid type", (dftype >= 0) && (dftype < next_gen_id));

	return eif_gen_param (dftype, pos, &is_expanded, &nr_bits);
}
/*------------------------------------------------------------------*/
/* Create an object with the same type as the type of the generic   */
/* parameter at position `pos' in `obj'.                            */
/*------------------------------------------------------------------*/

rt_public EIF_REFERENCE eif_gen_create (EIF_REFERENCE obj, uint32 pos)
{
	EIF_TYPE_INDEX   result_type;
	char    is_expanded;
	uint16    nr_bits;

	REQUIRE("obj not null", obj);

	result_type = eif_gen_param (Dftype(obj), pos, &is_expanded, &nr_bits);

#ifndef WORKBENCH
	if (is_expanded) {
		eif_panic ("Expanded generic parameter.");
	}
#endif

	/* Is it a BIT type? */

	if (nr_bits > 0)
		return RTLB(nr_bits);

#ifdef WORKBENCH
	/* Is it expanded? */

	if (is_expanded)
		return RTLX(result_type);
#endif

	/* Check for basic types */

	if (result_type < MAX_DTYPE)
		eif_panic ("Cannot create basic type.");

	return RTLN(result_type);
}
/*------------------------------------------------------------------*/
/* Register a bit type. Return its type id.                         */
/*                                                                  */
/* Result : RTUD(yes) (doesn't matter actually)                     */
/*------------------------------------------------------------------*/

rt_shared EIF_TYPE_INDEX eif_register_bit_type (uint16 size)
{
	EIF_TYPE_INDEX dftype;
	EIF_GEN_DER *gdp, *prev;

	/* Search for BIT type of size *intab */

	dftype = egc_bit_dtype;
	gdp    = eif_derivations [dftype];
	prev   = NULL;

	while (gdp != NULL)
	{
		if (size == gdp->size)
		{
			break; /* Found */
		}
		prev = gdp;
		gdp  = gdp->next;
	}

	if (gdp == (EIF_GEN_DER *)0)
	{
		/* Not found: we need a new id */

			gdp = eif_new_gen_der(size, NULL, dftype, '1', (char) 0, 0);

		if (prev == (EIF_GEN_DER *)0) {
			eif_derivations [dftype] = gdp;
		} else {
			prev->next = gdp;
		}
		eif_derivations[gdp->id] = gdp; /* Self-reference */
	}

	return gdp->id;
}
/*------------------------------------------------------------------*/
/* Type id for ARRAY [something], where 'something' is a reference  */
/* type.                                                            */
/* dtype : full type id; RTUD(yes)                                  */
/* Result : RTUD(yes) (doesn't matter actually)                     */
/*------------------------------------------------------------------*/

rt_shared EIF_TYPE_INDEX eif_typeof_array_of (EIF_TYPE_INDEX dtype)
{
	EIF_TYPE_INDEX   *typearr, result;

	typearr = (EIF_TYPE_INDEX *) cmalloc (4 * sizeof(EIF_TYPE_INDEX));
	typearr [0] = INVALID_DTYPE;			/* No static call context */
	typearr [1] = RTUD_INV(egc_arr_dtype);	/* Base type of ARRAY     */
	typearr [2] = RTUD_INV(dtype);			/* Parameter type */
	typearr [3] = TERMINATOR;

	result = eif_compound_id (NULL, 0, typearr[1], typearr);
	eif_rt_xfree (typearr);
	return result;
}
/*------------------------------------------------------------------*/
/* Full type name of `obj' as STRING object.                        */
/*------------------------------------------------------------------*/

rt_public EIF_REFERENCE eif_gen_typename_of_type (EIF_TYPE_INDEX current_dftype)
{
	char    *name;
	EIF_REFERENCE ret;	/* Return value. */

	EIFMTX_LOCK;
	name = eif_typename (current_dftype);
	EIFMTX_UNLOCK;

	ret = makestr(name, strlen(name));
	return ret;
}
/*------------------------------------------------------------------*/
/* CID which generates `dftype'. First entry is the length of the   */
/* compound id.                                                     */
/*                                                                  */
/* dftype : full type id; RTUD(yes)                                 */
/* Result : base ids; RTUD(yes)                                     */
/*------------------------------------------------------------------*/

rt_shared EIF_TYPE_INDEX *eif_gen_cid (EIF_TYPE_INDEX dftype)
{
	RT_GET_CONTEXT
	uint16 len;
	EIF_GEN_DER *gdp;

	if ((dftype == NONE_TYPE) || (dftype < first_gen_id)) {
		cid_array [1] = dftype;
		return cid_array;
	}

	/* It's a run-time generated id */

	gdp = eif_derivations [dftype];

	if (gdp->gen_seq) {
		return gdp->gen_seq;        /* already computed */
	}
	/* Compute size of array */

	len = eif_gen_seq_len (dftype);
	gdp->gen_seq = (EIF_TYPE_INDEX *) cmalloc ((len+2)*sizeof(EIF_TYPE_INDEX));
	if (!gdp->gen_seq) {
		enomem();
	}

	gdp->gen_seq [0] = len;
	gdp->gen_seq [len+1] = TERMINATOR;

	/* Fill array */

	len = 1;

	eif_put_gen_seq (dftype, gdp->gen_seq, &len, 0);

	return gdp->gen_seq;
}
/*------------------------------------------------------------------*/
/* Create an id from a type array 'a_cidarr'. If 'dtype_map' is not   */
/* NULL, use it to map old to new dtypes ('retrieve')               */
/* Format:                                                          */
/* First entry: count                                               */
/* Then 'count' type ids, then TERMINATOR                           */
/*------------------------------------------------------------------*/

rt_shared EIF_TYPE_INDEX eif_gen_id_from_cid (EIF_TYPE_INDEX *a_cidarr, EIF_TYPE_INDEX *dtype_map)
{
	EIF_TYPE_INDEX   dftype;
	EIF_TYPE_INDEX   count, i, dtype;

	REQUIRE ("Valid cid array", a_cidarr);

	count   = *a_cidarr;
	*a_cidarr = 0;	/* Not used anyway. */

	if (dtype_map) {
			/* We need to map old dtypes to new dtypes */
		for (i = 1; i <= count; i++) {
			dtype = a_cidarr [i];

			if (dtype <= MAX_DTYPE) {
				dtype = dtype_map [dtype];
				dtype = RTUD_INV(dtype);
				a_cidarr [i] = dtype;
			} else if (dtype == TUPLE_TYPE) {
					/* We simply skip number of generic
					 * parameters of the tuple as they are not really used
					 * and only update TUPLE dynamic type */
				i = i + TUPLE_OFFSET;
				a_cidarr [i]  = RTUD_INV(dtype_map [a_cidarr [i]]);
			} else if (dtype == FORMAL_TYPE) {
					/* We skip formal position as if we were not doing it
					 * it would be updated using `dtype_map'/`RTUD_INV' at the
					 * next iteration and would not make sense anymore. */
				i++;
			}
		}
	} else {
			/* We only need to undo the effect of RTUD */
		for (i = 1; i <= count; i++) {
			dtype = a_cidarr [i];

			if (dtype <= MAX_DTYPE) {
				dtype = RTUD_INV(dtype);
				a_cidarr [i] = dtype;
			} else if (dtype == TUPLE_TYPE) {
					/* We simply skip number of generic
					 * parameters of the tuple as they are not really used
					 * and only update TUPLE dynamic type */
				i = i + TUPLE_OFFSET;
				a_cidarr [i]  = RTUD_INV(a_cidarr [i]);
			} else if (dtype == FORMAL_TYPE) {
					/* We skip formal position as if we were not doing it
					 * it would be updated using RTUD_INV at the next iteration
					 * and it would not make sense anymore. */
				i++;
			}
		}
	}

	a_cidarr [count+1] = TERMINATOR;
	dftype  = eif_compound_id (NULL, 0, *(a_cidarr+1), a_cidarr);
	*a_cidarr = count;

	return dftype;
}
/*------------------------------------------------------------------*/
/* Conformance test. Does `source_type' conform to `target_type'?   */
/* This only applies to instantiated type.                          */
/*                                                                  */
/* Source_type : full type id; RTUD(yes)                            */
/* Target_type : full type id; RTUD(yes)                            */
/*------------------------------------------------------------------*/

rt_public int eif_gen_conf (EIF_TYPE_INDEX stype, EIF_TYPE_INDEX ttype)
{
	EIF_CONF_TAB *stab;
	EIF_GEN_DER *sgdp, *tgdp;
	EIF_TYPE_INDEX *ptypes;
	uint32 i, idx;
	int result;
	unsigned char mask;

	if (stype == ttype) {
		return 1;
	}

	if (EIF_IS_EXPANDED_TYPE(System(eif_cid_map[ttype]))) {
		/* Expanded target no conformance because types are different */
		return 0;
	} else if (stype > MAX_DTYPE) {
			/* Target is not expanded and source is NONE, then there is conformance. */
		CHECK("NONE type", stype == NONE_TYPE);
		return 1;
	}

	stab = eif_conf_tab[stype];

	if (stab == NULL)
	{
		eif_compute_ctab (stype);
		stab = eif_conf_tab[stype];
	}

	if (ttype < first_gen_id)
	{
		/* Lower id */

		if ((ttype >= stab->min_low_id) && (ttype <= stab->max_low_id))
		{
			idx = ttype-stab->min_low_id;
			mask = (unsigned char) (1 << (idx % 8));

			return (mask == ((stab->low_tab)[idx/8] & mask)) ? 1 : 0;
		}
	}
	else
	{
		/* High id */

		if ((ttype < stab->min_high_id) || (ttype > stab->max_high_id))
		{
			/* We need to enlarge the table */
			eif_enlarge_conf_tab (stab, ttype);
		}

		/* Now ttype is in the table range */

		idx  = (ttype - stab->min_high_id);
		mask = (unsigned char) (1 << (idx % 8));

		/* If we have computed it already, return result 
		 * We check first if the computed value is '1', if so, it means both that we already
		 * computed it and that is True.
		 * If the computed value is '0' we check if we compute a value, if so we return 0
		 * because we already know the computed value, otherwise we compute it
		 */

		if (mask == ((stab->high_tab)[idx/8] & mask))
			return 1;
		if (mask == ((stab->high_comp)[idx/8] & mask))
			return 0;

		/* We have to compute it now (once!) */

		sgdp = eif_derivations [stype];
		tgdp = eif_derivations [ttype];

		if (stype >= first_gen_id)
		{
			/* Both ids generated here */
		
			if (sgdp->first_id == tgdp->first_id)
			{
				/* Both have the same base class */

				/* Check BIT types. BIT n conforms to BIT m
				   iff n <= m. 
				*/

				if (sgdp->is_bit)
				{
					result = ((sgdp->size <= tgdp->size) ? 1 : 0);
					goto done;
				}

				/* Same base class. If nr. of generics
				   differs, both are TUPLEs.
				*/

				if (tgdp->size > sgdp->size)
				{
					/* Source and target are TUPLES but
					   source has fewer parameters */
					result = 0;
					goto done;
				}

				for (i = 0; i < tgdp->size; ++i)
				{
					stype = (sgdp->typearr) [i];
					ttype = (tgdp->typearr) [i];

					if (stype == ttype)
						continue; /* Same types - avoid recursion */

					if (ttype < first_gen_id)
						ttype = RTUD(ttype);

					if (stype < first_gen_id)
						stype = RTUD(stype);
				
					if (!eif_gen_conf (stype, ttype))
					{
						result = 0;
						goto done;
					}
				}

				result = 1;
				goto done;
			}
		}

		/* Target is generic.
		   We need to check every parent of the source
		   against the target */

		ptypes = sgdp->ptypes;

		result = 0;

		while (!result && (*ptypes != TERMINATOR))
		{
			result = eif_gen_conf (*ptypes, ttype);
			++ptypes;
		}

done:
		/* Register that we have computed it */
		(stab->high_comp)[idx/8] |= mask;

		if (result)
			(stab->high_tab)[idx/8] |= mask;

		return result;
	}

	return 0;
}
/*------------------------------------------------------------------*/
/* Private routines.                                                */
/*------------------------------------------------------------------*/

/*------------------------------------------------------------------*/
/* Computation of a new id.                                         */
/*                                                                  */
/* intab      : RTUD(no) except for dtypes of objects               */
/* outtab     : List of computed ids for generics; RTUD(no).        */
/* obj_type   : Full type of object; RTUD(yes). Used to replace a   */
/*              formal generic by an actual generic of the object.  */
/* apply_rtud : Send result through RTUD?                           */
/*------------------------------------------------------------------*/

rt_private EIF_TYPE_INDEX eif_id_of (EIF_TYPE_INDEX **intab, 
							EIF_TYPE_INDEX **outtab, EIF_TYPE_INDEX obj_type, 
							int apply_rtud)

{
	EIF_TYPE_INDEX   dftype, gcount = 0, i, hcode;
	EIF_TYPE_INDEX   *save_otab;
	int     pos, mcmp;
	char    is_expanded, is_tuple;
	EIF_GEN_DER *gdp, *prev;

	/* Get full type */

	dftype = **intab;

	if (dftype <= MAX_DTYPE) {
		is_expanded = (char) EIF_IS_EXPANDED_TYPE(System (eif_cid_map[RTUD(dftype)]));
	} else {
		is_expanded = (char) 0;
	}

	/* Check whether it's a TUPLE Type */

	if (dftype == TUPLE_TYPE) {
		(*intab)++;
		gcount = **intab;       /* Number of generic params */
		(*intab)++;
		dftype = **intab;       /* Base id for TUPLE */

		if (dftype <= MAX_DTYPE) {
			is_expanded = (char) EIF_IS_EXPANDED_TYPE(System (eif_cid_map[RTUD(dftype)]));
		}

		is_tuple = '1';
	} else {
		is_tuple = (char) 0;
	}

	if (dftype == FORMAL_TYPE) {
			/* formal generic */
		(*intab)++;
		pos = **intab;	/* Position of formal generic */

		gdp = eif_derivations [obj_type];
		dftype = gdp->typearr [pos-1];

		(*intab)++;
		**outtab = dftype;
		(*outtab)++;

		return (apply_rtud ? RTUD(dftype) : dftype);
	}

	if (RTUD(dftype) == egc_bit_dtype) {
		(*intab)++;
		dftype = eif_register_bit_type ((uint16) (**intab));
		**outtab = dftype;
		(*intab)++;
		(*outtab)++;
		return dftype;
	}

	if (dftype >= first_gen_id) {
		/* It's an already created gen. type */
		(*intab)++;
		**outtab = dftype;
		(*outtab)++;
		/* RTUD would not have an effect here */
		return dftype;
	}

	/* It's an ordinary id generated by the compiler */

	if (!is_tuple)
		gcount = par_info(dftype)->nb_generics;

	if (!is_tuple && (gcount == 0)) {
		/* Neither a generic type nor a TUPLE type */
		(*intab)++;

		**outtab = dftype;
		(*outtab)++;

		return (apply_rtud ? RTUD(dftype) : dftype);
	}

	save_otab = *outtab;
	(*intab)++;

	for (hcode = 0, i = gcount; i; --i) {
		hcode = hcode + eif_id_of (intab, outtab, obj_type, 0);
	}

	/* Search */

	gdp  = eif_derivations [RTUD(dftype)];
	prev = NULL;

	while (gdp != NULL) {
		if ((hcode == gdp->hcode) && 
			(is_expanded == gdp->is_expanded) &&
			(gcount == gdp->size))
		{
			mcmp = 0;

			if (gcount > 0)
				mcmp = memcmp((char*)save_otab, (char*)(gdp->typearr),gcount*sizeof(EIF_TYPE_INDEX));

			if (mcmp == 0)
			{
				break; /* Found */
			}
		}
		prev = gdp;
		gdp  = gdp->next;
	}

	if (gdp == (EIF_GEN_DER *)0) {
		/* Not found: we need a new id */

		gdp = eif_new_gen_der(gcount, save_otab, dftype, is_expanded, is_tuple, hcode);

		if (prev == (EIF_GEN_DER *)0)
			eif_derivations [RTUD(dftype)] = gdp;
		else
			prev->next = gdp;

		eif_derivations[gdp->id] = gdp; /* Self-reference */
	}

	/* Put full id */
	*outtab = save_otab;
	**outtab = gdp->id;
	(*outtab)++;

	/* RTUD would not have an effect here */
	return gdp->id;
}
/*------------------------------------------------------------------*/
/* Create a new generic derivation. Actually we create one for every*/
/* type, generic or not.                                            */
/*                                                                  */
/* size     : Nr. of bits in a bit type; nr. of generics in a ge-   */
/*            neric type; 0 otherwise.                              */
/* typearr  : Ids of generic paramenters; RTUD(no); null pointer    */
/*            if not a generic type                                 */
/* base_id  : Base id of type; RTUD(no)                             */
/* is_exp   : Is it expanded?                                       */
/* is_tuple : Is it a tuple?                                        */
/* hcode    : Hash code for faster search                           */
/*------------------------------------------------------------------*/

rt_private EIF_GEN_DER *eif_new_gen_der(uint32 size, EIF_TYPE_INDEX *typearr, EIF_TYPE_INDEX base_id, char is_exp, char is_tuple, EIF_TYPE_INDEX hcode)
{
	EIF_GEN_DER *result;
	EIF_TYPE_INDEX *tp, dt;
	char *cname;
	struct eif_par_types **pt;

	result = (EIF_GEN_DER *) cmalloc(sizeof (EIF_GEN_DER));

	if (result == NULL)
		enomem();

	if (typearr == NULL) {
		/* It's not a generic type. If size > 0 then it's a BIT type */

		result->size        = size;
		result->hcode       = hcode;
		result->typearr     = NULL;
		result->gen_seq     = NULL;      /* Generated on request only */
		result->ptypes      = NULL;      /* Generated on request only */
		result->id          = ((size > 0) ? next_gen_id++ : base_id);
		result->base_id     = base_id;
		result->first_id    = INVALID_DTYPE;
		result->is_expanded = is_exp;
		result->is_bit      = ((size > 0) ? '1' : (char) 0);
		result->is_tuple    = is_tuple;
		result->is_array    = (char) 0;
		result->name        = NULL;       /* Generated on request only */
				/* `name' must be allocated dynamically. */
		result->next        = (EIF_GEN_DER *)0;

		if (size > 0)
			goto finish;

		/* Just a simple, compiler generated id */

		goto finish_simple;
	}

		/* Large array */
	tp = (EIF_TYPE_INDEX *) cmalloc((size + 1)*sizeof(EIF_TYPE_INDEX));
	if (tp == NULL)
		enomem();

	tp[size]=TERMINATOR;

	if (size > 0) {
		memcpy (tp, typearr, size*sizeof(EIF_TYPE_INDEX));
	}

	result->size        = size;
	result->hcode       = hcode;
	result->typearr     = tp;
	result->gen_seq     = NULL;      /* Generated on request only */
	result->ptypes      = NULL;      /* Generated on request only */
	result->id          = next_gen_id++;
	result->base_id     = base_id;
	result->first_id    = INVALID_DTYPE;
	result->is_expanded = is_exp;
	result->is_bit      = (char) 0;
	result->is_tuple    = is_tuple;
	result->is_array    = (char) 0;
	result->name        = NULL;       /* Generated on request only */
				/* `name' must be allocated dynamically. */
	result->next        = (EIF_GEN_DER *)0;

finish:

	/* Expand tables if necessary */

	if (next_gen_id >= eif_cid_size)
		eif_expand_tables (next_gen_id + 32);

	/* Map it to RTUDed compiler generated base id.
	   NOTE: at this point `result->id' is a new id
			 so we have: RTUD(result->id) = result->id.
	*/

	eif_cid_map [result->id] = RTUD(base_id);

finish_simple:

	/* Now find first entry in parent table
	   which has the same class name as `base_id'.
	*/

	cname = System((par_info(base_id))->dtype).cn_generator;

	if (strcmp (cname, "ARRAY") == 0)
		result->is_array = '1';

	for (dt = 0, pt = eif_par_table2; dt <= eif_par_table2_size; ++dt, ++pt)
	{
		if (*pt == (struct eif_par_types *)0)
			continue;

		if (strcmp (cname,System((*pt)->dtype).cn_generator) == 0)
		{
			result->first_id = dt;
			break;
		}
	}

	return result;
}
/*------------------------------------------------------------------*/
/* Create new conformance table.                                    */
/*                                                                  */
/* All ids are full type ids; RTUD(yes)                             */
/*------------------------------------------------------------------*/

rt_private EIF_CONF_TAB *eif_new_conf_tab(EIF_TYPE_INDEX min_low, EIF_TYPE_INDEX max_low, EIF_TYPE_INDEX min_high, EIF_TYPE_INDEX max_high) {
	EIF_CONF_TAB *result;
	EIF_TYPE_INDEX size;
	unsigned char *tab;

	result = (EIF_CONF_TAB *) cmalloc(sizeof (EIF_CONF_TAB));

	if (result == NULL)
		enomem();

	result->min_low_id = min_low;
	result->max_low_id = max_low;
	result->min_high_id = min_high;
	result->max_high_id = max_high;

	if (min_low <= max_low) {
		size = (max_low - min_low + 8)/8;
		tab = (unsigned char *) eif_rt_xcalloc (size, sizeof (unsigned char));
		if (!tab)
			enomem ();
		result->low_tab = tab;

		tab = (unsigned char *) eif_rt_xcalloc (size, sizeof (unsigned char));
		if (!tab)
			enomem ();
		result->low_comp = tab;
	} else {
		result->low_tab = NULL;
		result->low_comp = NULL;
	}


	if (min_high <= max_high) {
		size = (max_high - min_high + 8)/8;

		tab = (unsigned char *) eif_rt_xcalloc (size, sizeof (unsigned char));
		if (!tab)
			enomem ();
		result->high_tab = tab;
		tab = (unsigned char *) eif_rt_xcalloc (size, sizeof (unsigned char));
		if (!tab)
			enomem ();
		result->high_comp = tab;
	} else {
		result->high_tab = NULL;
		result->high_comp = NULL;
	}
	
	return result;
}

/*------------------------------------------------------------------*/
/* Enlarge conformance table to include `new_id'                    */
/*                                                                  */
/* New_id: full type id; RTUD(yes)                                  */
/*------------------------------------------------------------------*/

rt_private void eif_enlarge_conf_tab(EIF_CONF_TAB *table, EIF_TYPE_INDEX new_id)
{
	unsigned char *tab, *comp, *old_tab, *old_comp;
	int offset, is_low;
	EIF_TYPE_INDEX min_old, max_old, min_new, max_new, size, old_size;

	is_low = 0;

	if (new_id < first_gen_id) {
		/* It's a lower id */

		is_low  = 1;
		min_old = min_new = table->min_low_id;
		max_old = max_new = table->max_low_id;

		if (new_id < min_new)
			min_new = new_id - (new_id % 8);    /* alignment */

		if (new_id > max_new)
			max_new = new_id;

		old_tab  = table->low_tab;
		old_comp = table->low_comp;
	} else {
		/* It's a high id */

		min_old = min_new = table->min_high_id;
		max_old = max_new = table->max_high_id;

		if (new_id < min_new)
			min_new = new_id - (new_id % 8);    /* alignment */

		if (new_id > max_new)
			max_new = new_id;

		old_tab  = table->high_tab;
		old_comp = table->high_comp;
	}

	if (min_old <= max_old) {
		old_size = (max_old - min_old + 8)/8;
	} else {
		old_size = 0;
	}

	size = (max_new - min_new + 8)/8;
	tab = (unsigned char *) eif_rt_xcalloc (size, sizeof (unsigned char));
	if (!tab)
		enomem ();
	comp = (unsigned char *) eif_rt_xcalloc (size, sizeof (unsigned char));
	if (!comp)
		enomem ();

		/* Initialize new tables from old tables */
	if (min_old <= max_old)
	{
		offset = (min_old - min_new) / 8;

		memcpy ((void *)(tab + offset), (void *)old_tab, old_size);
		memcpy ((void *)(comp + offset), (void *)old_comp, old_size);
	}

	/* Free old tables if they were not small (i.e. static) */

	if (old_tab) {
		eif_rt_xfree (old_tab);
	}
	if (old_comp) {
		eif_rt_xfree (old_comp);
	}

	/* Now update structure values */

	if (is_low) {
		table->min_low_id = min_new;
		table->max_low_id = max_new;
		table->low_tab  = tab;
		table->low_comp = comp;
	} else {
		table->min_high_id = min_new;
		table->max_high_id = max_new;
		table->high_tab  = tab;
		table->high_comp = comp;
	}
}
/*------------------------------------------------------------------*/
/* Create new ancestor id map.                                      */
/*                                                                  */
/* min_id : minimal ancestor id; RTUD (no)                          */
/* max_id : maximal ancestor id; RTUD (no)                          */
/*------------------------------------------------------------------*/

rt_private EIF_ANC_ID_MAP *eif_new_anc_id_map (EIF_TYPE_INDEX min_id, EIF_TYPE_INDEX max_id) {
	EIF_ANC_ID_MAP *result;
	EIF_TYPE_INDEX *map, size;

	result = (EIF_ANC_ID_MAP *) cmalloc(sizeof (EIF_ANC_ID_MAP));

	if (result == NULL)
		enomem();

	result->min_id = min_id;
	result->max_id = max_id;

	if (min_id <= max_id) {
		size = (max_id - min_id + 1);

		map = (EIF_TYPE_INDEX *) eif_rt_xcalloc (size, sizeof(EIF_TYPE_INDEX));
		if (map == NULL)
			enomem ();
		result->map = map;
	} else {
		result->map = NULL;
	}

	return result;
}
/*------------------------------------------------------------------*/
/* Expand `eif_cid_map', `eif_conf_tab' , `eif_derivations' and     */
/* `eif_anc_id_map' to `new_size'                                   */
/*------------------------------------------------------------------*/

rt_private void eif_expand_tables(int new_size)
{
#ifdef EIF_THREADS
	eif_panic ("Cannot resize Generic conformance tables in multithreaded mode.");
#else
	EIF_GEN_DER **new;
	EIF_CONF_TAB **tab;
	EIF_ANC_ID_MAP **amap;
	EIF_TYPE_INDEX *map;
	int         i;

	new = (EIF_GEN_DER **) crealloc((char*)eif_derivations, new_size*sizeof (EIF_GEN_DER*));

	if (new == NULL)
		enomem();

	eif_derivations = new;

	tab = (EIF_CONF_TAB **) crealloc((char*)eif_conf_tab, new_size*sizeof (EIF_CONF_TAB*));

	if (tab == NULL)
		enomem();

	eif_conf_tab = tab;

	amap = (EIF_ANC_ID_MAP **) crealloc((char*)eif_anc_id_map, new_size*sizeof (EIF_ANC_ID_MAP*));

	if (amap == NULL)
		enomem();

	eif_anc_id_map = amap;

	map = (EIF_TYPE_INDEX *) crealloc((char*)eif_cid_map, new_size*sizeof (EIF_TYPE_INDEX));

	if (map == NULL)
		enomem();

	eif_cid_map = map;

	for (i = eif_cid_size; i < new_size; ++i)
	{
		eif_cid_map [i]     = 0;
		eif_derivations [i] = NULL;
		eif_conf_tab [i]    = NULL;
		eif_anc_id_map [i]  = NULL;
	}

	eif_cid_size = new_size;
#endif
}
/*------------------------------------------------------------------*/
/* Full type name for type `dftype' as C string.                    */
/*                                                                  */
/* dftype : full type id; RTUD(yes)                                 */
/* Attention! This routine is not threaded safe (because of the    */
/* static buffer "result"). It must be protected by a lock.         */
/* ATTENTION: kill the previous 'attention' comment.                */
/*------------------------------------------------------------------*/

rt_public char *eif_typename (EIF_TYPE_INDEX dftype)
{
	/* Not MT-safe. */
	EIF_GEN_DER *gdp;
	size_t len;
	char    *result;
			
	REQUIRE("Valid type", (dftype >= 0) && (dftype < next_gen_id));

	if (dftype < first_gen_id) {
		RT_GET_CONTEXT
		char *l_name;

		l_name = non_generic_type_names [dftype];
		if (l_name == NULL) {
			char *l_class_name = System(par_info(RTUD_INV(dftype))->dtype).cn_generator;

			if (EIF_NEEDS_EXPANDED_KEYWORD(System (dftype))) {
				l_name = cmalloc (10 + strlen (l_class_name));
				l_name [0] = '\0';
				strcat (l_name, "expanded ");
			} else if (EIF_NEEDS_REFERENCE_KEYWORD(System (dftype))) {
				l_name = cmalloc (11 + strlen (l_class_name));
				l_name [0] = '\0';
				strcat (l_name, "reference ");
			} else {
				l_name = cmalloc (strlen (l_class_name) + 1);
				l_name [0] = '\0';
			}
			strcat (l_name, l_class_name);
			non_generic_type_names[dftype] = l_name;
		}
		return l_name;
	}

	gdp = eif_derivations [dftype];

	if (gdp->name != NULL)    /* Already computed */
	{
		return gdp->name;	/* Allocated dynamically! */
	}

	len = eif_typename_len (dftype);

	/* Create dynamic buffer for string */

	result = cmalloc (len + 1);

	if (result == NULL)
		enomem();

	*result = '\0';

	eif_create_typename (dftype, result);

	/* It may happen that gdp->name is now not NULL (BIT types).
	   In this case we have to free 'result' and use
	   gdp->name instead. */

	if (gdp->name != NULL)
	{
		eif_rt_xfree (result);
		result = gdp->name;
	}
	else
	{
		/* Remember the string in gdp->name. Otherwise
		   we get a memory leak. */

		gdp->name = result;
	}

	return result;
}
/*------------------------------------------------------------------*/
/* Produce full type name of `dftype' in `result'.                  */
/*                                                                  */
/* dftype : full type id; RTUD(yes)                                 */
/*------------------------------------------------------------------*/

rt_private void eif_create_typename (EIF_TYPE_INDEX dftype, char *result)
{
	EIF_GEN_DER *gdp;
	EIF_TYPE_INDEX       *gp, dtype, i;
	int         size;
	char        *bits;
	int	needs_expanded = 0, needs_reference = 0;

	if (dftype > MAX_DTYPE) {
		CHECK("NONE type", dftype == NONE_TYPE);
		strcat(result, "NONE");
		return;
	}

	needs_expanded = EIF_NEEDS_EXPANDED_KEYWORD(System(eif_cid_map[dftype]));
	needs_reference = EIF_NEEDS_REFERENCE_KEYWORD(System(eif_cid_map[dftype]));

	if (dftype < first_gen_id) {
		if (needs_expanded) {
			strcat (result, "expanded ");
		} else if (needs_reference) {
			strcat (result, "reference ");
		}
		/* Compiler generated id */
		strcat (result, System(par_info(RTUD_INV(dftype))->dtype).cn_generator);
		return;
	}

	/* We have created this id */

	gdp = eif_derivations [dftype];

	if (gdp->name != NULL)    /* Already computed */
	{
		strcat (result, gdp->name);
		return;
	}

	if (gdp->is_bit)
	{
		size = gdp->size;
		i = 4;

		while (size)
		{
			size /= 10;
			++i;
		}

		bits = cmalloc (i+1);

		if (bits == NULL)
			enomem ();

		strcpy (bits, "BIT ");

		size = gdp->size;
		bits [i] = '\0';

		for (--i; size; --i)
		{
			bits [i] = (char) (size % 10) + '0';
			size /= 10;
		}

		strcat (result, bits);

		gdp->name = bits;
				/* `name' must be allocated dynamically. */

		return;
	}
	
	/* Generic case */

	i = (EIF_TYPE_INDEX) gdp->size;

	if (needs_expanded) {
		strcat (result, "expanded ");
	} else if (needs_reference) {
		strcat (result, "reference ");
	}

	strcat (result, System(par_info(gdp->base_id)->dtype).cn_generator);

	if (i > 0)
	{
		strcat (result, " [");

		gp = gdp->typearr;

		while (i--)
		{
			dtype = *gp;

			if (dtype <= MAX_DTYPE) {
				dtype = RTUD(dtype);
			}

			eif_create_typename (dtype, result);
			++gp;

			if (i)
				strcat (result, ", ");
		}

		strcat(result, "]");
	}
}
/*------------------------------------------------------------------*/
/* Compute length of string needed for full type name of `dftype'   */
/*                                                                  */
/* dftype : full type id; RTUD(yes)                                 */
/*------------------------------------------------------------------*/

rt_shared size_t eif_typename_len (EIF_TYPE_INDEX dftype)
{
	EIF_GEN_DER *gdp;
	EIF_TYPE_INDEX *gp, dtype;
	uint32 i;
	size_t len = 0;
	int         size;
	int	needs_expanded = 0, needs_reference = 0;

	if (dftype > MAX_DTYPE) {
		CHECK ("NONE type", dftype == NONE_TYPE);
		return 4;
	}

	needs_expanded = EIF_NEEDS_EXPANDED_KEYWORD(System(eif_cid_map[dftype]));
	needs_reference = EIF_NEEDS_REFERENCE_KEYWORD(System(eif_cid_map[dftype]));

	if (dftype < first_gen_id) {
		if (needs_expanded) {
			len = 9;
		} else if (needs_reference) {
			len = 10;
		}
		/* Compiler generated id */
		return len + strlen (System(par_info(RTUD_INV(dftype))->dtype).cn_generator);
	}

	/* We have created this id */

	gdp = eif_derivations [dftype];

	if (gdp->name != NULL)    /* Already computed */
	{
		return strlen (gdp->name);
	}

	if (gdp->is_bit)
	{
		size = gdp->size;
		len += 4;

		while (size)
		{
			size /= 10;
			++len;
		}
		return len;   /* "BIT n" */
	}

	/* Generic case */

	i = gdp->size;

	len += (uint32) strlen (System(par_info(gdp->base_id)->dtype).cn_generator);

	if (needs_expanded) {
		len += 9;
	} else if (needs_reference) {
		len += 10;
	}

	if (i == 0)         /* TUPLE without generics */
		return len;

	len += 3 + (i-1)*2;

	gp = gdp->typearr;

	while (i--)
	{
		dtype = *gp;

		if (dtype <= MAX_DTYPE)
			dtype = RTUD(dtype);

		len += eif_typename_len (dtype);
		++gp;
	}

	return len;
}
/*------------------------------------------------------------------*/
/* Compute length of generating id sequence for `dftype'            */
/*                                                                  */
/* dftype : full type id; RTUD(doesn't matter)                      */
/*------------------------------------------------------------------*/

rt_private uint16 eif_gen_seq_len (EIF_TYPE_INDEX dftype)
{
	EIF_GEN_DER *gdp;
	uint32 i;
	uint16 len;

	REQUIRE ("dftype is not a formal generic parameter", dftype != FORMAL_TYPE);
	REQUIRE ("dftype is not a tuple", dftype != TUPLE_TYPE);
	REQUIRE ("dftype is not a terminator", dftype != TERMINATOR);

		/* Simple id */
	if ((dftype == NONE_TYPE) || (dftype < first_gen_id)) {
		return 1;
	}

		/* It's a generic type or a BIT type */
	gdp = eif_derivations[dftype];

		/* Is it a BIT type? */
	if (gdp->is_bit) {
		return 2;
	}

	len = 0;

		/* Is it a TUPLE? */
	if (gdp->is_tuple) {
			/* Size is TUPLE_OFFSET because we need to take into account
			 * TUPLE_TYPE constant, number of generic parameters
			 * in seqence for tuple type */
		len += TUPLE_OFFSET;
	}

	i = gdp->size;
	while (i) {
		i--;
		len = len + eif_gen_seq_len (gdp->typearr [i]);
	}

	return len + 1; /* Base id plus generics */
}
/*------------------------------------------------------------------*/
/* Produce generating id sequence for `dftype' in `typearr'.        */
/*                                                                  */
/* dftype    : full type id; RTUD(not apply_rtud)                   */
/* typearr   : Base type ids; RTUD(yes)                             */
/* idx       : index where to put id                                */
/* apply_rtud: must we send entries through RTUD?                   */
/*------------------------------------------------------------------*/

rt_private void eif_put_gen_seq (EIF_TYPE_INDEX dftype, EIF_TYPE_INDEX *typearr, EIF_TYPE_INDEX *idx, EIF_TYPE_INDEX apply_rtud)
{
	EIF_GEN_DER *gdp;
	uint32 i, len;

	REQUIRE ("dftype is not a formal generic parameter", dftype != FORMAL_TYPE);
	REQUIRE ("dftype is not a tuple", dftype != TUPLE_TYPE);
	REQUIRE ("dftype is not a terminator", dftype != TERMINATOR);

	/* Simple id */

	if ((dftype == NONE_TYPE) || (dftype < first_gen_id)) {
		if (dftype > MAX_DTYPE) {
			typearr [*idx] = dftype;
		} else {
			typearr [*idx] = (apply_rtud ? RTUD(dftype) : dftype);
		}
		(*idx)++;
		return;
	}

		/* It's a generic type or a BIT type */
	gdp = eif_derivations[dftype];

		/* Is it a BIT type? */
	if (gdp->is_bit) {
		typearr [*idx] = egc_bit_dtype;    /* Bit type */
		(*idx)++;
		CHECK("Valid number of bits", rt_valid_type_index(gdp->size));
		typearr [*idx] = (EIF_TYPE_INDEX) (gdp->size); /* Nr of bits */
		(*idx)++;
		return;
	}

		/* Is it a TUPLE type? */
	if (gdp->is_tuple) {
		typearr [*idx] = TUPLE_TYPE;                   /* TUPLE type */
		(*idx)++;
		CHECK("Valid number of generics", rt_valid_type_index(gdp->size));
		typearr [*idx] = (EIF_TYPE_INDEX) (gdp->size);   /* Nr of generics */
		(*idx)++;
	}

	typearr [*idx] = RTUD(gdp->base_id);
	(*idx)++;

	len = gdp->size;

	for (i = 0; i < len; ++i) {
		eif_put_gen_seq (gdp->typearr [i], typearr, idx, 1);
	}
}
/*------------------------------------------------------------------*/
/* Compute conformance table for `dftype'                           */
/*                                                                  */
/* dftype : full type id; RTUD(yes)                                 */
/*------------------------------------------------------------------*/

rt_private void eif_compute_ctab (EIF_TYPE_INDEX dftype)

{
	EIF_TYPE_INDEX outtab [256], *outtable, *intable;
	EIF_TYPE_INDEX min_low, max_low, min_high, max_high, pftype, dtype, *ptypes;
	int i, count, offset, pcount;
	unsigned char *src, *dest, *src_comp, *dest_comp, mask;
	char is_expanded;
	struct eif_par_types *pt;
	EIF_CONF_TAB *ctab, *pctab;
	EIF_GEN_DER *gdp;

	/* Get parent table */

	dtype = To_dtype(dftype);

		/* Compiler generated id */
	pt = par_info (RTUD_INV(dtype));

	is_expanded = pt->is_expanded;

	/* Compute the ranges of the bit tables */

	outtable = outtab;
	intable = pt->parents;

	CHECK ("Parents never NULL", intable);

	min_low = next_gen_id;
	max_low = 0;
	min_high = next_gen_id;
	max_high = 0;

	/* Type conforms to itself */

	if (dftype < first_gen_id)
	{
		min_low = max_low = dftype;
	}
	else
	{
		min_high = max_high = dftype;
	}

	pcount = 1; /* Parent count + 1 */

	while (*intable != TERMINATOR)
	{
		pftype = eif_id_of (&intable, &outtable, dftype, 1);
		if (*intable == PARENT_TYPE_SEPARATOR) {
			intable++;
		}
		++pcount;

		ctab = eif_conf_tab [pftype];

		if (ctab == NULL)
		{
			eif_compute_ctab (pftype);
			ctab = eif_conf_tab [pftype];
		}

		if (ctab->min_low_id < min_low)
			min_low = ctab->min_low_id;
		if (ctab->max_low_id > max_low)
			max_low = ctab->max_low_id;
		if (ctab->min_high_id < min_high)
			min_high = ctab->min_high_id;
		if (ctab->max_high_id > max_high)
			max_high = ctab->max_high_id;
	}

	/* Create a new table */
	/* Make sure that the min values are == 0 mod 8 */

	min_low  -= (min_low % 8);
	min_high -= (min_high % 8);

	ctab = eif_new_conf_tab (min_low, max_low, min_high, max_high);

	eif_conf_tab [dftype] = ctab;

	/* Create table of parent types */

	gdp = eif_derivations [dftype];

	if (gdp == NULL)
	{
		gdp = eif_new_gen_der (0, NULL, RTUD_INV(dtype), (char) 0, (char) 0, 0);

		eif_derivations [dftype] = gdp;
	}

	ptypes = (EIF_TYPE_INDEX *) cmalloc (sizeof (EIF_TYPE_INDEX)*pcount);
	if (ptypes == NULL)
		enomem ();

	gdp->ptypes = ptypes;

	/* Fill bit tables */

	outtable = outtab;
	intable = pt->parents;

	CHECK ("Parents never NULL", intable);

	while (*intable != TERMINATOR)
	{
		pftype = eif_id_of (&intable, &outtable, dftype, 1);
		if (*intable == PARENT_TYPE_SEPARATOR) {
			intable++;
		}
		pctab = eif_conf_tab [pftype];

		/* Register parent type */

		*(ptypes++) = pftype;

		if ((min_low <= max_low) && (pctab->min_low_id <= pctab->max_low_id))
		{
			count  = (pctab->max_low_id-pctab->min_low_id+8)/8;
			offset = (pctab->min_low_id - min_low)/8;
			src  = pctab->low_tab;
			dest = ctab->low_tab + offset;
			src_comp = pctab->low_comp;
			dest_comp = ctab->low_comp + offset;

			for (i = count; i; --i)
			{
				/* We conform to everything our parent
				   conforms to */

				*dest |= *src;

				/* Consider only those bits as already
				   computed for which conformance holds
				   because we may conform to something
				   to which the parent does not! */
				   
				*(dest_comp) |= ((*src) & (*src_comp));
				++dest;
				++src;
				++src_comp;
				++dest_comp;
			}
		}

		if ((min_high <= max_high) && (pctab->min_high_id <= pctab->max_high_id))
		{
			count  = (pctab->max_high_id-pctab->min_high_id+8)/8;
			offset = (pctab->min_high_id - min_high)/8;
			src  = pctab->high_tab;
			dest = ctab->high_tab + offset;
			src_comp = pctab->high_comp;
			dest_comp = ctab->high_comp + offset;

			for (i = count; i; --i)
			{
				/* We conform to everything our parent
				   conforms to */
				*dest |= *src;

				/* Consider only those bits as already
				   computed for which conformance holds
				   because we may conform to something
				   to which the parent does not! */
				   
				*(dest_comp) |= ((*src) & (*src_comp));
				++dest;
				++src;
				++src_comp;
				++dest_comp;
			}
		}
	}

	*ptypes = TERMINATOR;

	/* Put own type in table if it's not expanded */

	if (is_expanded)
		return;

	if (dftype < first_gen_id)
	{
		offset = (dftype - min_low);
		mask   = (char) (1 << (offset % 8));
		(ctab->low_tab)[offset/8] |= mask;
		(ctab->low_comp)[offset/8] |= mask;
	}
	else
	{
		offset = (dftype - min_high);
		mask   = (char) (1 << (offset % 8));
		(ctab->high_tab)[offset/8] |= mask;
		(ctab->high_comp)[offset/8] |= mask;
	}
}
/*------------------------------------------------------------------*/
/* Compute ancestor id map for `dftype'.                            */
/*                                                                  */
/* dftype                      : full type; RTUD(yes)               */
/* min_id, max_id, table index : RTUD(no)                           */
/* Table entries               : RTUD(yes)                          */
/*------------------------------------------------------------------*/

rt_private void eif_compute_anc_id_map (EIF_TYPE_INDEX dftype)

{
	EIF_TYPE_INDEX outtab [256], *outtable, *intable;
	EIF_TYPE_INDEX min_id, max_id, pftype, dtype;
	int i, count, offset;
	EIF_TYPE_INDEX *src, *dest;
	struct eif_par_types *pt;
	EIF_ANC_ID_MAP *map, *pamap;

	/* Get parent table */

	dtype = To_dtype(dftype);

		/* Compiler generated id */
	pt = par_info (RTUD_INV(dtype));

	/* Compute the range of the id map */

	outtable = outtab;
	intable = pt->parents;

	CHECK ("Parents never NULL", intable);

	min_id = max_id = RTUD_INV(dtype);

	while (*intable != TERMINATOR)
	{
		pftype = eif_id_of (&intable, &outtable, dftype, 1);
		if (*intable == PARENT_TYPE_SEPARATOR) {
			intable++;
		}

		map = eif_anc_id_map [pftype];

		if (map == NULL)
		{
			eif_compute_anc_id_map (pftype);
			map = eif_anc_id_map [pftype];
		}

		if (map->min_id < min_id)
			min_id = map->min_id;
		if (map->max_id > max_id)
			max_id = map->max_id;
	}

	/* Create a new map */

	map = eif_new_anc_id_map (min_id, max_id);

	eif_anc_id_map [dftype] = map;

	/* Fill map */

	outtable = outtab;
	intable = pt->parents;

	CHECK ("Parents never NULL", intable);

	while (*intable != TERMINATOR)
	{
		pftype = eif_id_of (&intable, &outtable, dftype, 1);
		pamap = eif_anc_id_map [pftype];
		if (*intable == PARENT_TYPE_SEPARATOR) {
			intable++;
		}

		/* Register parent type */

		if ((min_id <= max_id) && (pamap->min_id <= pamap->max_id))
		{
			count  = (pamap->max_id-pamap->min_id+1);
			offset = (pamap->min_id - min_id);
			src    = pamap->map;
			dest   = map->map + offset;

			for (i = count; i; --i)
			{
				if (*src)
				{
					*dest = *src;
				}

				++dest;
				++src;
			}
		}
	}

	/* Put own type in table */

	(map->map)[RTUD_INV(dtype)-(map->min_id)] = dftype;
}

/*
doc:</file>
*/
