<document title="Domains" output="studio">
	<meta_data/>
	<paragraph>
		<paragraph>A domain is a list of code elements, it can contain different kinds of code elements. A domain is used as input to a metric, as output of a metric to review some details, and as an argument passed to some criteria. Domain is used to specify scope.</paragraph>
		<heading>
			<size>2</size>
			<content>Domain Convention</content>
		</heading>
		<paragraph>Before we go to real domain examples, we introduce a simple convention to describe a domain:</paragraph>
		<list ordered="false">
			<item>
				Group element is written in lower case, for example: <cluster_name>base</cluster_name>, <cluster_name>thread</cluster_name>
			</item>
			<item>
				Class element is written in UPPER case, for example: <class_name>ANY</class_name>, <class_name>LINKED_LIST</class_name>
			</item>
			<item>
				Feature element is written in <class_name>CLASS_NAME</class_name>.<feature_name>feature_name</feature_name>, i.e, its associated class will be presented also in upper case and the feature name will be in lower case. For example, <class_name>ANY</class_name>.<feature_name>is_equal</feature_name>, <class_name>STRING_8</class_name>.<feature_name>is_equal</feature_name>
			</item>
			<item>
				All items in a domain will be in curly braces
			</item>
		</list>
		<paragraph>For example, {<class_name>ANY</class_name>, <class_name>STRING_8</class_name>.<feature_name>as_lower</feature_name>, <cluster_name>base</cluster_name>} defines a domain with 3 elements, a class <class_name>ANY</class_name>, a feature <feature_name>as_lower</feature_name> which is in class <class_name>STRING_8</class_name>, and a group <cluster_name>base</cluster_name>.</paragraph>
		<paragraph>Suppose we have a basic metric called <bold>Classes</bold> which counts the number of classes. Before calculating the metric, we need to specify an input domain. This input domain tells metrics system over which scope the metric is calculated. And after calculating a basic metric, for sometimes, we not only want to know the value of that metric, but we are also interested in which are the actual items that adds up to that value. This detailed item list is also accessible for a basic metric if detailed results are specified to be kept before metric calculation, and it is called output domain.</paragraph>
		<heading>
			<size>2</size>
			<content>Domain Examples</content>
		</heading>		
		<paragraph>As a real example, go to Metrics tool in EiffelStudio, select Metric Evaluation panel, select metric <bold>Classes</bold> in the "Select metric" area, and set input domain in the "Setup input domain" area. See the following figure, in which the input domain is set to {<cluster_name>base</cluster_name>, <class_name>APPLICATION</class_name>}.</paragraph>
		<paragraph>
			<image>
				<url>../../../../../images/eiffelstudio/metrics_tool/domain_example1.png</url>
				<alt_text>Defining an input domain</alt_text>
			</image>
		</paragraph>		
		<paragraph>After running the metric, you should see the following result in the Detailed Result panel shown in the following figure:</paragraph>
		<paragraph>
			<image>
				<url>../../../../../images/eiffelstudio/metrics_tool/domain_example2.png</url>
				<alt_text>Metric detailed result</alt_text>
			</image>
		</paragraph>		
		<paragraph><note>Note: an element can appear more than one time in a domain, but the detailed result list show only distinct items, so it is possible that the calculated metric value is not equal to the number of items in the detailed result list.</note></paragraph>
		<paragraph>A domain can be used as an argument of a relation criterion, see the following example:</paragraph>
		<paragraph>
			<image>
				<url>../../../../../images/eiffelstudio/metrics_tool/domain_example3.png</url>
				<alt_text>Domain criterion</alt_text>
			</image>
		</paragraph>
		<paragraph>Here, we define a class basic metric, and in the definition area, we specify a criterion named ancestor_is which is a relation criterion. In that criterion, we set a domain {<class_name>ANY</class_name>} as its criterion domain. This metric reads: Count classes whose ancestor is class <class_name>ANY</class_name>. Put another way, this metric will find descendants of class <class_name>ANY</class_name>. </paragraph>
		<paragraph>Now, let's have a look at some examples using delayed item and input domain item.</paragraph>
		<paragraph>Suppose we have the following feature metric created in the following figure:</paragraph>
		<paragraph>
			<image>
				<url>../../../../../images/eiffelstudio/metrics_tool/domain_example4.png</url>
				<alt_text>Delayed domain item</alt_text>
			</image>
		</paragraph>		
		<paragraph>When this metric is calculated over input domain {<class_name>APPLICCATION</class_name>}, this means that for every feature from class <class_name>APPLICATIOIN</class_name>, we check if it satisfies the defined criterion which is callee_is {Delayed item}. And because of this delayed item, the actual semantic is: For a feature from class <class_name>APPLICATION</class_name>, say <feature_name>foo</feature_name>, check if foo satisfies criterion callee_is {<class_name>APPLICATION</class_name>.<feature_name>foo</feature_name>}. i.e., the delayed item is replaced by the actual candidate feature. </paragraph>
		<paragraph>One may wonder why the concept of delayed item is useful. The answer is that it is powerful when used with other criteria, such as criterion value_of_metric_is. See documentation of value_of_metric_is for details.</paragraph>
		<paragraph>Now, an example of Input domain item. Suppose we created the following class basic metric in the following figure:</paragraph>
		<paragraph>
			<image>
				<url>../../../../../images/eiffelstudio/metrics_tool/domain_example5.png</url>
				<alt_text>Input domain item</alt_text>
			</image>
		</paragraph>
		<paragraph>And when this metric is calculated over input domain {<class_name>APPLICATION</class_name>}, the domain criterion Input domain in ancestor_is criterion will be replaced by the specified input domain, i.e., {<class_name>APPLICATION</class_name>}, and the metric will use the current application target as its input domain instead. Put another way, the metric is semantically equal to the following one shown in the following figure:</paragraph>
		<paragraph>
			<image>
				<url>../../../../../images/eiffelstudio/metrics_tool/domain_example6.png</url>
				<alt_text>Actual semantic for input domain item</alt_text>
			</image>
		</paragraph>
		<paragraph><note>Note: Only code element target, group, folder, class, feature, delayed item, input domain item and application target can be specified through domain selector in Metrics tool. And code element generic, assertion, argument, local, line cannot be specified in domain selector, but they may present in the detailed result domain list.</note></paragraph>	
		<seealso>
			<bold>See Also</bold>
			<line_break/> 
			<link>
				<url>20_units.xml</url>
				<label>Units</label>
			</link>
			<line_break/> 
			<link>
				<url>70_scopes.xml</url>
				<label>Scopes</label>
			</link>
		</seealso>
	</paragraph>
</document>
