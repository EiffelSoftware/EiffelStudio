<document title="Type Organization">
	<meta_data>
		<help>
			<toc>
				<envision_pseudo_name>20</envision_pseudo_name>
				<envision_location>Eiffel\Eiffel for .NET\Conventions</envision_location>
				<envision_title>Class/Type Organization</envision_title>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph>In any comprehensive object-oriented system, the act of programming results in creation of new data types. There must be a way of organizing these types and/or their static representation as classes. This section tells you how classes are organized in Eiffel and in .NET, and how these organization methods are used together.
		</paragraph>
		<heading>
			<size>2</size>Eiffel Clusters
		</heading>
		<paragraph>Eiffel classes are grouped in clusters. These clusters of classes ordinarily share some commonality of functionality or purpose. In other words,the classes in a particular cluster may provide the same sorts of capabilities or relate to a single software model. In the Eiffel Base Library there is a cluster called 
			<cluster_name>list</cluster_name> which contains classes which implement different types of lists, for example, 
			<class_name>ARRAYED_LIST</class_name>, 
			<class_name>LINKED_LIST</class_name>, 
			<class_name>SORTED_TWO_WAY_LIST</class_name>, 
			<class_name>TWO_WAY_CIRCULAR</class_name>. At an abstract level all these classes are related to the software model of the notion of "list".
		</paragraph>
		<paragraph>The cluster 
			<cluster_name>list</cluster_name> is actually a subcluster of the cluster 
			<cluster_name>structures</cluster_name> which contains clusters other than 
			<cluster_name>list</cluster_name> related to data structures other than lists. Eiffel convention dictates that a cluster should either contain classes or subclusters, but not both.
		</paragraph>
		<paragraph>So clusters serve both to categorize and locate classes. So, class 
			<class_name>LINKED_LIST</class_name> can be described as a basic library class implementing a data structure, more particularly a list. As such, it can be found in the Base Library, in cluster 
			<cluster_name>structures</cluster_name> in subcluster 
			<cluster_name>list</cluster_name>.
		</paragraph>
		<heading>
			<size>2</size>.NET Namespaces and Assemblies
		</heading>
		<paragraph>In .NET, types (the language independent, compiled form of classes) are stored in "assemblies". So, we locate a type we want to use by referencing the assembly in which it resides. </paragraph>As .NET programmers, we think of types as being categorized by namespace. For example, we view the type 
		<class_name>System.Windows.Forms.TextBox</class_name> as the 
		<class_name>TextBox</class_name> type in the context of the windows forms namespace ( 
		<class_name>System.Windows.Forms</class_name>). Particularly, this is in contrast to type 
		<class_name>System.Web.UI.TextBox</class_name> which is a 
		<class_name>TextBox</class_name> for web forms. As it relates to making .NET types usable by Eiffel, the important thing to understand is that the real .NET type name is the fully qualified type name, including the namespace. Namespaces are simply a bit of "syntactic sugar" that keeps us from having to repeat the entire type name every time we use it in source code.
		<heading>
			<size>3</size>.NET Assemblies Available to Eiffel
		</heading>When types from .NET assemblies are made available to Eiffel programmers, each assembly is mapped to a cluster. So all the types in an assembly appear as if they were Eiffel classes in a cluster which corresponds to the .NET assembly.
		<paragraph>To summarize, as you learned in Naming Conventions and Name Handling, unambiguous Eiffel-style names are made available for the.NET types in an assembly. The assembly is represented to Eiffel for .NET programmers as a cluster of classes. The process of name derivation is based upon a portion of the .NET type name, possibly augmented with a prefix to ensure uniqueness.
		</paragraph>
		<heading>
			<size>3</size>Assemblies Built with Eiffel
		</heading>
		<paragraph>The object model for which Eiffel was designed differs in some ways from the .NET object model. Importantly, Eiffel supports the facilties of full, controllable multiple inheritance, and genericity, among other things, that the inherent .NET object model does not. That does not mean that these things cannot work in .NET. Indeed they can, and they make Eiffel for .NET very powerful. But, they do make things look a little different.
		</paragraph>
		<paragraph>When you compile Eiffel for .NET, the result is a .NET assembly; either an executable system, or a library of potentially reusable data types. Because the object model for Eiffel is different from that of .NET, the assembly resulting from a compile is different in some ways. </paragraph>
		<paragraph>First an assembly built using Eiffel for .NET will likely contain lots of types and interfaces. This is because as you use a class from the Eiffel libraries, say class 
			<class_name>STRING</class_name>, all the classes upon which 
			<class_name>STRING</class_name> depends ( 
			<class_name>STRING</class_name>'s suppliers and ancestors) must also be included in the assembly. That's because the Eiffel libraries, unlike the Microsoft .NET libraries like 
			<cluster_name>mscorlib</cluster_name> and 
			<cluster_name>System.Data</cluster_name>, are not distributed as shared type libraries.
		</paragraph>
		<paragraph>Another thing you may notice is that each Eiffel class you produce is represented by three entities in the assembly ... two classes and an interface. So, if you produce a class called 
			<class_name>GUARD_DOG</class_name>, then in the assembly you'd see an interface called 
			<class_name>GuardDog</class_name>, a class called 
			<class_name>Impl.GuardDog</class_name>, and a class called 
			<class_name>Create.GuardDog</class_name>. Again, this is done for reasons that concern the differences in the object models between Eiffel and .NET.
		</paragraph>
		<paragraph>The 
			<class_name>GuardDog</class_name> interface is what you use when you declare an entity or variable of that type. The objects attached to that entity at runtime will be of the type 
			<class_name>Impl.GuardDog</class_name>. You create an instance of 
			<class_name>Impl.GuardDog</class_name> and attach it to an entity of type 
			<class_name>GuardDog</class_name> by calling a routine in the factory class 
			<class_name>Create.GuardDog</class_name>. The factory routines will almost always have names that begin with the word " 
			<feature_name>Make</feature_name>", and represent the creation routines of Eiffel the classes. So in the case of using an instance of 
			<class_name>GuardDog</class_name> from a C# class, the code would like this:
		</paragraph>
		<code_block>
{
	<class_name>GuardDog</class_name> <feature_name>aGuardDog</feature_name> = <feature_name>Create.GuardDog.Make</feature_name>();	<comment>//Create an instance</comment>
	<feature_name>aGuardDog.RollOver</feature_name>();	<comment>// Apply a feature</comment>
}
</code_block>
		<paragraph>This object creation model accounts for some of the differences between constructors in .NET and creation procedures in Eiffel. These differences will be discussed in more detail in Constructors and Creation Procedures.
		</paragraph>
		<paragraph>Another advantage is that it provides a syntax that is similar to that used to create objects in Eiffel. An Eiffel for .NET client to the class 
			<class_name>GUARD_DOG</class_name> might use the following code to create and use an instance.
		</paragraph>
		<code_block>
	<keyword>local</keyword>
		<feature_name>a_guard_dog</feature_name><symbol>:</symbol> <class_name>GUARD_DOG</class_name>	<comment>-- Declare an entity of the type</comment>
	<keyword>do</keyword>
		<keyword>create</keyword> <feature_name>a_guard_dog</feature_name>.<feature_name>make</feature_name>	<comment>-- Create an instance and attach to entity</comment>
		<feature_name>a_guard_dog</feature_name>.<feature_name>roll_over</feature_name>	<comment>-- Apply a feature</comment>
	<keyword>end</keyword>
</code_block>
		<paragraph>You may have noticed in these examples that even though the type 
			<class_name>GuardDog</class_name> was compiled from an Eiffel class, when the C# client uses 
			<class_name>GuardDog</class_name>, it uses what would be considered the .NET naming convention for the type 
			<class_name>GuardDog</class_name> (vs. 
			<class_name>GUARD_DOG</class_name>) and the method name 
			<feature_name>RollOver</feature_name> (vs 
			<feature_name>roll_over</feature_name>). What happens here is that when assemblies are produced from Eiffel classes, by default .NET naming standards are used in the assembly.
		</paragraph>
	</paragraph></document>
