note
	description: "Visitor for BYTE_NODE objects which count breakpoint slots in assertions."

class
	ASSERTION_BREAKABLE_SLOT_STRATEGY

inherit
	BYTE_NODE_ITERATOR
		redefine
			process_assign_b,
			process_assert_b,
			process_inv_assert_b,
			process_require_b,
			process_variant_b,
			process_elsif_b,
			process_elsif_expression_b,
			process_if_b,
			process_if_expression_b,
			process_inspect_b,
			process_instr_call_b,
			process_loop_b,
			process_loop_expr_b,
			process_nested_b,
			process_retry_b,
			process_reverse_b,
			process_check_b,
			process_invariant_b,
			process_guard_b
		end

	SHARED_BYTE_CONTEXT

feature -- Status report

	update_breakpoint_slot (a_node: BYTE_NODE; ctx: BYTE_CONTEXT)
		do
			counter := 0
			a_node.process (Current)
			context.set_breakpoint_slot (context.breakpoint_slots_number + counter)
		end

feature {NONE} -- Implementation: access

	counter: INTEGER

	increment_counter (a_node: BYTE_NODE)
		do
			counter := counter + 1
			debug ("dbg_assertion_in_trace")
				if attached {ASSERT_B} a_node as a_assert and then attached a_assert.tag as t then
					print (" - " + a_node.generator + " %"" + t + "%" [" + counter.out + "]%N")
				else
					print (" - " + a_node.generator + " [" + counter.out + "]%N")
				end
			end
		end

	generate_melted_debugger_hook_nested
		do

		end

feature -- Node processing

	process_assert_b (a_node: ASSERT_B)
			-- Process `a_node`.
			-- (from BYTE_NODE_ITERATOR)
			-- (export status {BYTE_NODE})
		do
				-- Assertion mark
			if context.assertion_type = {ASSERT_TYPE}.in_precondition then
				increment_counter (a_node)
				a_node.expr.process (Current)
			else
				if context.assertion_type /= {ASSERT_TYPE}.in_invariant then
						-- No hooks when it is an invariant
					increment_counter (a_node)
				end
					-- Assertion byte code
				a_node.expr.process (Current)
			end
		end

	process_inv_assert_b (a_node: INV_ASSERT_B)
			-- Process `a_node'.
		do
			process_assert_b (a_node)
		end

	process_require_b (a_node: REQUIRE_B)
		do
			process_assert_b (a_node)
		end

	process_variant_b (a_node: VARIANT_B)
			-- Process `a_node'.
		do
			process_assert_b (a_node)
		end

	process_check_b (a_node: CHECK_B)
			-- Process `a_node'.
		do
			if a_node.check_list /= Void then
					-- Set assertion type
				context.set_assertion_type ({ASSERT_TYPE}.In_check)
				a_node.check_list.process (Current)
				context.set_assertion_type (0)
			end
		end


	process_guard_b (a_node: GUARD_B)
			-- <Precursor>
		do
				-- Generate hook for the condition test.
			if attached a_node.check_list as c then
					-- Generated byte code for assertions.
				context.set_assertion_type ({ASSERT_TYPE}.In_guard)
				c.process (Current)
				context.set_assertion_type (0)
			end
			if attached a_node.compound as c then
					-- Generated byte code for compound.
				c.process (Current)
			end
		end

	process_invariant_b (a_node: INVARIANT_B)
			-- Process `a_node'.
		local
			l_context: like context
		do
			l_context := context
			l_context.set_assertion_type ({ASSERT_TYPE}.in_invariant)
			Precursor (a_node)
			l_context.set_assertion_type (0)
		end

	process_assign_b (a_node: ASSIGN_B)
			-- <Precursor>
		do
			increment_counter (a_node)
			Precursor (a_node)
		end

	process_elsif_b (a_node: ELSIF_B)
		do
			increment_counter (a_node)
			Precursor (a_node)
		end

	process_elsif_expression_b (a_node: ELSIF_EXPRESSION_B)
		do
				-- Generate hook for the condition test.
			increment_counter (a_node)

				-- Generate byte code for condition.
			a_node.condition.process (Current)

				-- Generate hook for Then_part.
			increment_counter (a_node)

				-- Generate alternative expression byte code.
			a_node.expression.process (Current)
		end

	process_if_b (a_node: IF_B)
		do
			if attached {HIDDEN_IF_B} a_node then
				Precursor (a_node)
			else
					-- Generate hook for the condition test
				increment_counter (a_node)

				Precursor (a_node)
			end
		end

	process_if_expression_b (a_node: IF_EXPRESSION_B)
			-- <Precursor>

		do
			a_node.condition.process (Current)

				-- Generate hook for Then_part.
			increment_counter (a_node)

				-- Generate expression for Then_part.
			a_node.then_expression.process (Current)

			if attached a_node.elsif_list as l then
					-- Generate byte code for alternatives.
				across
					l as c
				loop
					c.item.process (Current)
				end
			end

				-- Generate hook for Else_part.
			increment_counter (a_node)

				-- Generate expression for Else_part.
			a_node.else_expression.process (Current)
		end

	process_inspect_b (a_node: INSPECT_B)
			-- Process `a_node'.
		do
			increment_counter (a_node)

				-- Generate switch expression byte code
			a_node.switch.process (Current)
			if a_node.case_list /= Void then
				across
					a_node.case_list as c
				loop
					c.item.process (Current)
				end
					-- Generate code for the various inspect matches
				a_node.case_list.process (Current)
			end
			if a_node.else_part /= Void then
					-- We need to pop the value of the expression since we do not need it anymore.
				a_node.else_part.process (Current)
			end
		end

	process_instr_call_b (a_node: INSTR_CALL_B)
			-- Process `a_node'.
		do
			increment_counter (a_node)
			Precursor (a_node)
		end

	process_loop_b (a_node: LOOP_B)
			-- Process `a_node'.
		local
			invariant_breakpoint_slot: INTEGER
			body_breakpoint_slot: INTEGER
			l_context: like context
			l_old_hidden_code_level: INTEGER
		do
			l_context := context
			l_old_hidden_code_level := l_context.hidden_code_level
			l_context.set_hidden_code_level (0)
			if attached a_node.iteration_initialization as i then
					-- Generate byte code for iteration initialization.
				increment_counter (a_node)
				l_context.enter_hidden_code
				i.process (Current)
				l_context.exit_hidden_code
			end
			if a_node.from_part /= Void then
					-- Generate byte code for the from part
				a_node.from_part.process (Current)
			end

			if a_node.variant_part /= Void then
					-- ...
			end

				-- Record context.
			invariant_breakpoint_slot := l_context.get_breakpoint_slot

			if not (a_node.invariant_part = Void and then a_node.variant_part = Void) then
					-- Invariant loop byte code
				if a_node.invariant_part /= Void then
					l_context.set_assertion_type ({ASSERT_TYPE}.in_loop_invariant)
					a_node.invariant_part.process (Current)
				end
					-- Variant loop byte code
				if a_node.variant_part /= Void then
					l_context.set_assertion_type ({ASSERT_TYPE}.in_loop_variant)
					a_node.variant_part.process (Current)
				end
				l_context.set_assertion_type (0)
			end

			if attached a_node.iteration_exit_condition as e then
					-- Generate a test for iteration exit condition.
				e.process (Current)
			end
			if attached a_node.stop as s then
					-- Generate breakpoint slot.
				increment_counter (a_node)
					-- Generate a test for loop exit condition.
				s.process (Current)
			end

			if a_node.compound /= Void then
				a_node.compound.process (Current)
			end
			if attached a_node.advance_code as a then
				a.process (Current)
			end

				-- Save hook context & restore recorded context.
			body_breakpoint_slot := l_context.get_breakpoint_slot
			l_context.set_breakpoint_slot (invariant_breakpoint_slot)

			if not (a_node.invariant_part = Void and then a_node.variant_part = Void) then
					-- Invariant loop byte code
				if a_node.invariant_part /= Void then
					l_context.set_assertion_type ({ASSERT_TYPE}.in_loop_invariant)
					a_node.invariant_part.process (Current)
				end
					-- Variant loop byte code
				if a_node.variant_part /= Void then
					l_context.set_assertion_type ({ASSERT_TYPE}.in_loop_variant)
					a_node.variant_part.process (Current)
				end
				l_context.set_assertion_type (0)
			end

				-- Restore hook context
			l_context.set_breakpoint_slot (body_breakpoint_slot)
			l_context.set_hidden_code_level (l_old_hidden_code_level)
		end

	process_loop_expr_b (a_node: LOOP_EXPR_B)
			-- <Precursor>
		local
			invariant_breakpoint_slot: INTEGER
			body_breakpoint_slot: INTEGER
			l_context: like context
			v: detachable VARIANT_B
			i: detachable BYTE_LIST [BYTE_NODE]
			l_old_hidden_code_level: INTEGER
		do
			l_context := context
			l_old_hidden_code_level := l_context.hidden_code_level
			l_context.set_hidden_code_level (0)

				-- Generate loop iteration part.
--			increment_counter (a_node)`
			l_context.enter_hidden_code
			a_node.iteration_code.process (Current)
			l_context.exit_hidden_code

			v := a_node.variant_code

				-- Record context.
			invariant_breakpoint_slot := l_context.get_breakpoint_slot

			i := a_node.invariant_code
			if i /= Void then
				l_context.set_assertion_type ({ASSERT_TYPE}.in_loop_invariant)
				i.process (Current)
			end
				-- Variant loop byte code
			if v /= Void then
				l_context.set_assertion_type ({ASSERT_TYPE}.in_loop_variant)
				v.process (Current)
			end
			l_context.set_assertion_type (0)

				-- Generate byte code for iteration exit condition.
			a_node.iteration_exit_condition_code.process (Current)

			if attached a_node.exit_condition_code as e then
					-- Generate byte code for optional exit condition.
				increment_counter (a_node)
				e.process (Current)
			end

			increment_counter (a_node)
			a_node.expression_code.process (Current)
				-- Advance the loop cursor.
			a_node.advance_code.process (Current)

				-- Save hook context & restore recorded context.
			body_breakpoint_slot := l_context.get_breakpoint_slot
			l_context.set_breakpoint_slot (invariant_breakpoint_slot)

			if i /= Void then
				l_context.set_assertion_type ({ASSERT_TYPE}.in_loop_invariant)
				i.process (Current)
			end
				-- Variant loop byte code
			if v /= Void then
				l_context.set_assertion_type ({ASSERT_TYPE}.in_loop_variant)
				v.process (Current)
			end
			l_context.set_assertion_type (0)

				-- Restore hook context
			l_context.set_breakpoint_slot (body_breakpoint_slot)
			l_context.set_hidden_code_level (l_old_hidden_code_level)
		end

	process_nested_b (a_node: NESTED_B)
			-- Process `a_node'.
		do
			a_node.target.process (Current)
			if a_node.target.is_feature then
				generate_melted_debugger_hook_nested
			end
			a_node.message.process (Current)
		end

	process_retry_b (a_node: RETRY_B)
			-- Process `a_node'.
		do
			increment_counter (a_node)
		end

	process_reverse_b (a_node: REVERSE_B)
			-- Process `a_node'.
		local
			l_source_type: TYPE_A
			l_target_type: TYPE_A
		do
			increment_counter (a_node)

			a_node.source.process (Current)

			if l_target_type.is_none then

			elseif l_target_type.is_expanded and then l_source_type.is_expanded then
				if
					attached {CL_TYPE_A} l_source_type as l_source_class_type and then
					attached {CL_TYPE_A} l_target_type as l_target_class_type and then
					l_target_class_type.class_id = l_source_class_type.class_id
				then
					a_node.target.process (Current)
				end
			else
				a_node.target.process (Current)
			end
		end


note
	date: "$Date: 2018-10-03 18:19:00 +0200 (Wed, 03 Oct 2018) $"
	revision: "$Revision: 102267 $"
	copyright:	"Copyright (c) 1984-2018, Eiffel Software"
	license:	"GPL version 2 (see http://www.eiffel.com/licensing/gpl.txt)"
	licensing_options:	"http://www.eiffel.com/licensing"
	copying: "[
			This file is part of Eiffel Software's Eiffel Development Environment.
			
			Eiffel Software's Eiffel Development Environment is free
			software; you can redistribute it and/or modify it under
			the terms of the GNU General Public License as published
			by the Free Software Foundation, version 2 of the License
			(available at the URL listed under "license" above).
			
			Eiffel Software's Eiffel Development Environment is
			distributed in the hope that it will be useful, but
			WITHOUT ANY WARRANTY; without even the implied warranty
			of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
			See the GNU General Public License for more details.
			
			You should have received a copy of the GNU General Public
			License along with Eiffel Software's Eiffel Development
			Environment; if not, write to the Free Software Foundation,
			Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
		]"
	source: "[
			Eiffel Software
			5949 Hollister Ave., Goleta, CA 93117 USA
			Telephone 805-685-1006, Fax 805-685-6869
			Website http://www.eiffel.com
			Customer support http://support.eiffel.com
		]"

end
