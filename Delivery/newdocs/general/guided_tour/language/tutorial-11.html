<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML XMLNS:MSHelp="http://msdn.microsoft.com/mshelp">
	<XML>
		<MSHelp:Keyword Index="K" Term="Eiffel Tutorial, Other mechanisms" />
		<MSHelp:Attr Name="Product" Value="Eiffel"/>
		<MSHelp:Attr Name="Locale" Value="kbEnglish"/>
	</XML>
	<HEAD>
		<TITLE>An Eiffel Tutorial, Other mechanisms</TITLE>
		<LINK HREF="../../../default.css" TYPE="text/css" REL="STYLESHEET">
	</HEAD>
	<BODY>
		<TABLE CLASS="HEADER">
			<TR>
				<TD CLASS="HEADER">Eiffel ENViSioN!</TD>
			</TR>
			<TR>
				<TD CLASS="SUBHEADER">An Eiffel Tutorial, Other mechanisms</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FRAME">
			<TR>
				<TD>
					<P>We now examine a few important mechanisms that complement the
					preceding picture: shared objects; constants; instructions;
					and lexical conventions.</P>

					<H2><A NAME="71816"></A>Once routines and shared objects</H2>

					<P>The Eiffel's method obsession with extendibility,
					reusability and maintainability yields, as has been seen,
					modular and decentralized architectures, where inter-module
					coupling is limited to the strictly necessary, interfaces are
					clearly delimited, and all the temptations to introduce
					obscure dependencies, in particular global variables, have
					been removed. There is a need, however, to let various
					components of a system access common objects, without
					requiring their routines to pass these objects around as
					arguments (which would only be slightly better than global
					variables). For example various classes may need to perform
					output to a common &quot;console window&quot;, represented by
					a shared object.</P>

					<P>Eiffel addresses this need through an original mechanism
					that also takes care of another important issue, poorly
					addressed by many design and programming approaches:
					initialization. The idea is simple: if instead of
					<SPAN CLASS="ekeyword">do</SPAN> the implementation of an
					effective routine starts with the keyword
					<SPAN CLASS="ekeyword">once</SPAN>, it will only be executed
					the first time the routine is called during a system
					execution (or, in a multithreaded environment, the first time
					in each thread), regardless of what the caller was.
					Subsequent calls from the same caller or others will have no
					effect; if the routine is a function, it will always return
					the result computed by the first call -- object if an
					expanded type, reference otherwise.</P>

					<P>In the case of procedures, this provides a convenient
					initialization mechanism. A delicate problem in the absence
					of a <SPAN CLASS="ekeyword">once</SPAN> mechanism is how to
					provide the users of a library with a set of routines which
					they can call in any order, but which all need, to function
					properly, the guarantee that some context had been properly
					set up. Asking the library clients to precede the first call
					with a call to an initialization procedure
					<SPAN CLASS="efeature">setup</SPAN> is not only
					user-unfriendly but silly: in a well-engineered system we
					will want to check proper set-up in every of the routines,
					and report an error if necessary; but then if we were able to
					detect improper set-up we might as well shut up and set up
					ourselves (by calling <SPAN CLASS="efeature">setup</SPAN>).
					This is not easy, however, since the object on which we call
					<SPAN CLASS="efeature">setup</SPAN> must itself be properly
					initialized, so we are only pushing the problem further.
					Making <SPAN CLASS="efeature">setup</SPAN> a
					<SPAN CLASS="ekeyword">once</SPAN> procedure solves it: we
					can simply include a call <SPAN CLASS="efeature">setup</SPAN>
					at the beginning of each affected routine; the first one to
					come in will perform the needed initializations; subsequent
					calls will have, as desired, no effect.</P>

					<P>Once functions will give us shared objects. A common
					scheme is</P>

					<CODE>
						<P><SPAN CLASS="efeature">console</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">WINDOW</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Shared console window</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">once</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">create</SPAN>
						<SPAN CLASS="ekeyword">Result</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">make</SPAN>
						<SPAN CLASS="esymbol">(</SPAN>&#8230;<SPAN CLASS="esymbol">)</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>Whatever client first calls this function will create the
					appropriate window and return a reference to it. Subsequent
					calls, from anywhere in the system, will return that same
					reference. The simplest way to make this function available
					to a set of classes is to include it in a class
					<SPAN CLASS="eclass">SHARED_STRUCTURES</SPAN> which the
					classes needing a set of related shared objects will simply
					inherit.</P>

					<P>For the classes using it,
					<SPAN CLASS="efeature">console</SPAN>, although a function,
					looks very much as if it were an attribute -- only one
					referring to a shared object.</P>

					<P>The &quot;Hello World&quot; system at the beginning of
					this discussion (section
					<A HREF="tutorial-05.html">4</A>) used an output instruction
					of the form
					<SPAN CLASS="efeature">io</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">put_string</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="estring">&quot;Some string&quot;</SPAN><SPAN CLASS="esymbol">)</SPAN>.
					This is another example of the general scheme illustrated by
					<SPAN CLASS="efeature">console</SPAN>. Feature
					<SPAN CLASS="efeature">io</SPAN>, declared in
					<SPAN CLASS="eclass">ANY</SPAN> and hence usable by all
					classes, is a once function that returns an object of
					type <SPAN CLASS="eclass">STANDARD_FILES</SPAN> (another
					Kernel Library class) providing access to basic input and
					output features, one of which is procedure
					<SPAN CLASS="efeature">put_string</SPAN>. Because basic input
					and output must all work on the same files,
					<SPAN CLASS="efeature">io</SPAN> should clearly be a once
					function, shared by all classes that need these mechanisms.</P>

					<H2><A NAME="94304"></A>Constant and unique attributes</H2>

					<P>The attributes studied earlier were variable: each
					represents a field present in each instance of the class and
					changeable by its routines.</P>

					<P>It is also possible to declare constant attributes, as in</P>

					<CODE>
						<P><SPAN CLASS="efeature">Solar_system_planet_count</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN>
						<SPAN CLASS="enumber">9</SPAN></P>
					</CODE>

					<P>These will have the same value for every instance and
					hence do not need to occupy any space in objects at
					execution time. (In other approaches similar needs would be
					addressed by symbolic constants, as in Pascal or Ada, or
					macros, as in C.)</P>

					<P>What comes after the <SPAN CLASS="ekeyword">is</SPAN> is a
					manifest constant: a self-denoting value of the appropriate
					type. Manifest constants are available for integers, reals
					(also used for doubles), booleans
					(<SPAN CLASS="efeature">True</SPAN> and
					<SPAN CLASS="efeature">False</SPAN>), characters (in single
					quotes, as
					<SPAN CLASS="esymbol">'</SPAN><SPAN CLASS="echar">A</SPAN><SPAN CLASS="esymbol">'</SPAN>,
					with special characters expressed using a percent sign as in
					<SPAN CLASS="esymbol">'%</SPAN><SPAN CLASS="echar">N</SPAN><SPAN CLASS="esymbol">'</SPAN>
					for new line,
					<SPAN CLASS="esymbol">'%</SPAN><SPAN CLASS="echar">B</SPAN><SPAN CLASS="esymbol">'</SPAN>
					for backspace and
					<SPAN CLASS="esymbol">'%</SPAN><SPAN CLASS="ee-text">U</SPAN><SPAN CLASS="esymbol">'</SPAN>
					for null).</P>

					<P>For integer constants, it is also possible to avoid
					specifying the values. A declaration of the form</P>

					<CODE>
						<P><SPAN CLASS="efeature">a</SPAN>,
						<SPAN CLASS="efeature">b</SPAN>,
						<SPAN CLASS="efeature">c</SPAN>, &#8230;
						<SPAN CLASS="efeature">n</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN>
						<SPAN CLASS="ekeyword">is unique</SPAN></P>
					</CODE>

					<P>introduces <SPAN CLASS="efeature">a</SPAN>,
					<SPAN CLASS="efeature">b</SPAN>,
					<SPAN CLASS="efeature">c</SPAN>, &#8230;
					<SPAN CLASS="efeature">n </SPAN> as constant integer
					attributes, whose value are assigned by the Eiffel compiler
					rather than explicitly by the programmer. The values are
					different for all <SPAN CLASS="ekeyword">unique</SPAN>
					attributes in a system; they are all positive, and, in a
					single declaration such as the above, guaranteed to be
					consecutive (so that you may use an invariant property of
					the form
					<SPAN CLASS="elocal">code</SPAN>
					<SPAN CLASS="efeature">&gt;=</SPAN>
					<SPAN CLASS="efeature">a</SPAN>
					<SPAN CLASS="ekeyword">and</SPAN>
					<SPAN CLASS="elocal">code</SPAN>
					<SPAN CLASS="efeature">&lt;=</SPAN>
					<SPAN CLASS="efeature">n</SPAN> to express that
					<SPAN CLASS="efeature">code</SPAN> should be one of the
					values). This mechanism replaces the
					&quot;enumerated types&quot; found in many anguages, without
					suffering from the same problems. (Enumerated types have an
					ill-defined place in the type system; and it is not clear
					what operations are permitted.)</P>

					<P>You may use Unique values in conjunction with the
					<SPAN CLASS="ekeyword">inspect</SPAN> multi-branch
					instruction studied in the next section. They are only
					appropriate for codes that can take on a fixed number of
					well-defined values -- not as a way to program operations
					with many variants, a need better addressed by the
					object-oriented technique studied earlier and relying on
					inheritance, polymorphism, redeclaration and dynamic binding.</P>

					<P>Manifest constants are also available for strings, using
					double quotes as in</P>

					<CODE>
						<P><SPAN CLASS="efeature">User_friendly_error_message</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">STRING</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN>
						<SPAN CLASS="estring">&quot;Go get a life!&quot;</SPAN></P>
					</CODE>

					<P>with special characters again using the
					<SPAN CLASS="esymbol">%</SPAN> codes. It is also possible to
					declare manifest arrays using double angle brackets:</P>

					<CODE>
						<P><SPAN CLASS="esymbol">&lt;&lt;</SPAN><SPAN CLASS="enumber">1</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="enumber">2</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="enumber">3</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="enumber">5</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="enumber">7</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="enumber">11</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="enumber">13</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="enumber">17</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="enumber">19</SPAN><SPAN CLASS="esymbol">&gt;&gt;</SPAN>
					</P></CODE>

					<P>which is an expression of type <SPAN CLASS="eclass">ARRAY</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">]</SPAN>.
					Manifest arrays and strings are not atomic, but denote
					instances of the Kernel Library classes
					<SPAN CLASS="eclass">STRING</SPAN> and
					<SPAN CLASS="eclass">ARRAY</SPAN>, as can be produced by once
					functions.</P>

					<H2><A NAME="38021"></A>Instructions</H2>

					<P>Eiffel has a remarkably small set of instructions. The
					basic computational instructions have been seen: creation,
					assignment, assignment attempt, procedure call,
					<SPAN CLASS="ekeyword">retry</SPAN>. They are complemented
					by control structures: conditional, multi-branch, loop, as
					well as <SPAN CLASS="ekeyword">debug</SPAN> and
					<SPAN CLASS="ekeyword">check</SPAN>.</P>

					<P>A conditional instruction has the form
					<SPAN CLASS="ekeyword">if</SPAN> &#8230;
					<SPAN CLASS="ekeyword">then</SPAN> &#8230;
					<SPAN CLASS="ekeyword">elseif </SPAN> &#8230;
					<SPAN CLASS="ekeyword">then</SPAN> &#8230;
					<SPAN CLASS="ekeyword">else</SPAN> &#8230;
					<SPAN CLASS="ekeyword">end</SPAN>. The
					<SPAN CLASS="ekeyword">elseif</SPAN> &#8230;
					<SPAN CLASS="ekeyword">then</SPAN> &#8230; part (of which
					there may be more than one) and the
					<SPAN CLASS="ekeyword">else</SPAN> &#8230;
					part are optional. After <SPAN CLASS="ekeyword">if</SPAN>
					and <SPAN CLASS="ekeyword">elseif</SPAN> comes a boolean
					expression; after <SPAN CLASS="ekeyword">then</SPAN>,
					<SPAN CLASS="ekeyword">elseif</SPAN> and
					<SPAN CLASS="ekeyword">else</SPAN> come zero or more
					instructions.</P>

					<P>A multi-branch instruction has the form</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">inspect</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="elocal">exp</SPAN></P>

						<P><SPAN CLASS="ekeyword">when</SPAN>
						<SPAN CLASS="enumber">v1</SPAN>
						<SPAN CLASS="ekeyword">then</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">inst1</SPAN></P>

						<P><SPAN CLASS="ekeyword">when</SPAN>
						<SPAN CLASS="enumber">v2</SPAN>
						<SPAN CLASS="ekeyword">then</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">inst2</SPAN></P>

						<P>&#8230;</P>

						<P><SPAN CLASS="ekeyword">else</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">inst0</SPAN></P>

						<P><SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>where the <SPAN CLASS="ekeyword">else</SPAN>
					<SPAN CLASS="efeature">inst0</SPAN> part is optional,
					<SPAN CLASS="elocal">exp</SPAN> is a character or integer
					expression, <SPAN CLASS="enumber">v1</SPAN>,
					<SPAN CLASS="enumber">v2</SPAN>, &#8230; are constant
					values of the same type as <SPAN CLASS="elocal">exp</SPAN>,
					all different, and <SPAN CLASS="efeature">inst0</SPAN>,
					<SPAN CLASS="efeature">inst1</SPAN>,
					<SPAN CLASS="efeature">inst2</SPAN>, &#8230; are sequences of
					zero or more instructions. In the integer case, it is often
					convenient to use <SPAN CLASS="ekeyword">unique</SPAN> values
					(<A HREF="tutorial-11.html#94304">&quot;Constant and unique attributes&quot;</A>)
					for the <SPAN CLASS="enumber">vi</SPAN>.</P>

					<P>The effect of such a multi-branch instruction, if the value
					of <SPAN CLASS="elocal">exp</SPAN> is one of the
					<SPAN CLASS="enumber">vi</SPAN>, is to execute the
					corresponding <SPAN CLASS="efeature">insti</SPAN>. If none of
					the <SPAN CLASS="enumber">vi</SPAN> matches, the instruction
					executes <SPAN CLASS="efeature">inst0</SPAN>, unless there is
					no <SPAN CLASS="ekeyword">else</SPAN> part, in which case it
					triggers an exception.</P>

					<P CLASS=note>Raising an exception is the proper behavior,
					since the absence of an <SPAN CLASS="ekeyword">else</SPAN>
					indicates that the author asserts that one of the values will
					match. If you want an instruction that does nothing in this
					case, rather than cause an exception, use an
					<SPAN CLASS="ekeyword">else</SPAN> part with an empty
					<SPAN CLASS="efeature">inst0</SPAN>. In contrast,
					<SPAN CLASS="ekeyword">if</SPAN> <SPAN CLASS="efeature">c</SPAN>
					<SPAN CLASS="ekeyword">then</SPAN> <SPAN CLASS="efeature">inst</SPAN>
					<SPAN CLASS="ekeyword">end</SPAN> with no
					<SPAN CLASS="ekeyword">else</SPAN> part does nothing in the
					absence of an <SPAN CLASS="ekeyword">else</SPAN> part, since
					in this case there is no implied claim that
					<SPAN CLASS="efeature">c</SPAN> must hold.)</P>

					<P>The loop construct has the form</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">from</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">initialization</SPAN></P>

						<P><SPAN CLASS="ekeyword">until</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">exit</SPAN></P>

						<P><SPAN CLASS="ekeyword">invariant</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">inv</SPAN></P>

						<P><SPAN CLASS="ekeyword">variant</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">var</SPAN></P>

						<P></A><SPAN CLASS="ekeyword">loop</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">body</SPAN></P>

						<P><SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>where the <SPAN CLASS="ekeyword">invariant</SPAN>
					<SPAN CLASS="efeature">inv</SPAN> and
					<SPAN CLASS="ekeyword">variant</SPAN>
					<SPAN CLASS="efeature">var</SPAN> parts are optional, the
					others required. <SPAN CLASS="efeature">initialization</SPAN>
					and <SPAN CLASS="efeature">body</SPAN> are sequences of zero
					or more instructions; <SPAN CLASS="efeature">exit</SPAN> and
					<SPAN CLASS="efeature">inv</SPAN> are boolean expressions
					(more precisely, <SPAN CLASS="efeature">inv</SPAN> is an
					assertion); <SPAN CLASS="efeature">var</SPAN> is an integer
					expression.</P>

					<P>The effect is to execute
					<SPAN CLASS="efeature">initialization</SPAN>, then, zero or
					more times until <SPAN CLASS="efeature">exit</SPAN> is
					satisfied, to execute <SPAN CLASS="efeature">body</SPAN>.
					(If after <SPAN CLASS="efeature">initialization</SPAN> the
					value of <SPAN CLASS="efeature">exit</SPAN> is already true,
					<SPAN CLASS="efeature">body</SPAN> will not be executed at
					all.) Note that the syntax of loops always includes an
					initialization, as most loops require some preparation. If
					not, just leave <SPAN CLASS="efeature">initialization</SPAN>
					empty, while including the <SPAN CLASS="ekeyword">from</SPAN>
					since it is a required component.</P>

					<P>The assertion <SPAN CLASS="efeature">inv</SPAN>, if
					present, expresses a <SPAN CLASS="bold">loop invariant</SPAN>
					(not to be confused with class invariants). For the loop to
					be correct, <SPAN CLASS="efeature">initialization</SPAN> must
					ensure <SPAN CLASS="efeature">inv</SPAN>, and then every
					iteration of <SPAN CLASS="efeature">body</SPAN> executed when
					<SPAN CLASS="efeature">exit</SPAN> is false must preserve the
					invariant; so the effect of the loop is to yield a state in
					which both <SPAN CLASS="efeature">inv</SPAN> and
					<SPAN CLASS="efeature">exit</SPAN> are true. The loop must
					terminate after a finite number of iterations, of course; this
					can be guaranteed by using a
					<SPAN CLASS="bold">loop variant</SPAN>
					<SPAN CLASS="efeature">var</SPAN>. It must be an integer
					expression whose value is non-negative after execution of
					<SPAN CLASS="efeature">initialization</SPAN>, and decreased
					by at least one, while remain non-negative, by any execution
					of <SPAN CLASS="efeature">body</SPAN> when
					<SPAN CLASS="efeature">exit</SPAN> is false; since a
					non-negative integer cannot be decreased forever, this
					ensures termination. The assertion monitoring mode, if turned
					on at the highest level, will check these properties of the
					invariant and variant after initialization and after each
					loop iteration, triggering an exception if the invariant does
					not hold or the variant is negative or does not decrease.</P>

					<P>An occasionally useful instruction is
					<SPAN CLASS="ekeyword">debug</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="estring">Debug_key</SPAN>
					<SPAN CLASS="esymbol">,</SPAN>&#8230;<SPAN CLASS="esymbol">)</SPAN>
					<SPAN CLASS="efeature">instructions</SPAN>
					<SPAN CLASS="ekeyword">end</SPAN> where
					<SPAN CLASS="efeature">instructions</SPAN> is a sequence of
					zero or more instructions and the part in parentheses is
					optional, containing if present one or more strings, called
					debug keys. The EiffelStudio compiler lets you specify the
					corresponding <SPAN CLASS="ekeyword">debug</SPAN> compilation
					option: <SPAN CLASS="ekeyword">yes</SPAN>,
					<SPAN CLASS="ekeyword">no</SPAN>, or an explicit debug key.
					The <SPAN CLASS="efeature">instructions</SPAN> will be
					executed if and only if the corresponding option is on. The
					obvious use is for instructions that should be part of the
					system but executed only in some circumstances, for example
					to provide extra debugging information.</P>

					<P>The final instruction is connected with
					Design by Contract&#153. The instruction
					<SPAN CLASS="ekeyword">check</SPAN>
					<SPAN CLASS="efeature">Assertions</SPAN>
					<SPAN CLASS="ekeyword">end</SPAN>, where
					<SPAN CLASS="efeature">Assertions</SPAN> is a sequence of
					zero or more assertions, will have no effect unless
					assertion monitoring is turned on at the
					<SPAN CLASS="ekeyword">Check</SPAN> level or higher. If so it
					will evaluate all the assertions listed, having no further
					effect if they are all satisfied; if any one of them does not
					hold, the instruction will trigger an exception.</P>

					<P>This instruction serves to state properties that are
					expected to be satisfied at some stages of the computation --
					other than the specific stages, such as routine entry and
					exit, already covered by the other assertion mechanisms such
					as preconditions, postconditions and invariants. A
					recommended use of <SPAN CLASS="ekeyword">check</SPAN>
					involves calling a routine with a precondition, where the
					call, for good reason, does not explicitly test for the
					precondition. Consider a routine of the form</P>

					<CODE>
						<P><SPAN CLASS="efeature">r</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">ref</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">SOME_REFERENCE_TYPE</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">require</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">not_void:</SPAN>
						<SPAN CLASS="elocal">ref</SPAN> <SPAN CLASS="esymbol">/=</SPAN>
						<SPAN CLASS="efeature">Void</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="elocal">ref</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">some_feature</SPAN>
						</P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8230;</P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>Because of the call to <SPAN CLASS="efeature">some_feature</SPAN>,
					the routine will only work if its precondition is satisfied on
					entry. To guarantee this precondition, the caller may protect
					it by the corresponding test, as in</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">if</SPAN>
						<SPAN CLASS="elocal">x</SPAN>
						<SPAN CLASS="esymbol">/=</SPAN>
						<SPAN CLASS="efeature">Void </SPAN>
						<SPAN CLASS="ekeyword">then</SPAN>
						<SPAN CLASS="elocal">a</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">r</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>but this is not the only possible scheme; for example if
					an <SPAN CLASS="ekeyword">create</SPAN>
					<SPAN CLASS="elocal">x</SPAN> appears shortly before the call
					we know <SPAN CLASS="elocal">x</SPAN> is not void and do not
					need the protection. It is a good idea in such cases to use a
					<SPAN CLASS="ekeyword">check</SPAN> instruction to document
					this property, if only to make sure that a reader of the code
					will realize that the omission of an explicit test (justified
					or not) was not a mistake. This is particularly appropriate
					if the justification for not testing the precondition is less
					obvious. For example <SPAN CLASS="elocal">x</SPAN> could have
					been obtained, somewhere else in the algorithm, as
					<SPAN CLASS="efeature">clone</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">)</SPAN>
					for some <SPAN CLASS="elocal">y</SPAN> that you know is not
					void. You should document this knowledge by writing the call
					as</P>

					<CODE>
						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">check</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">x_not_void</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="elocal">x</SPAN>
						<SPAN CLASS="esymbol">/=</SPAN>
						<SPAN CLASS="efeature">Void</SPAN>
						<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Because <SPAN CLASS="elocal">x</SPAN>
						was obtained as a clone of <SPAN CLASS="elocal">y</SPAN>,</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- and <SPAN CLASS="elocal">y</SPAN> is
						not void because [etc.]</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>

						<P><SPAN CLASS="elocal">a</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">r</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">)</SPAN>
						</P>
					</CODE>

					<P CLASS=note>Note the recommended convention: extra
					indentation of the <SPAN CLASS="ekeyword">check</SPAN>
					part to separate it from the algorithm proper; and
					inclusion of a comment listing the rationale behind the
					developer's decision not to check explicitly for the
					precondition.</P>

					<P>In production mode with assertion monitoring turned
					off, this instruction will have no effect. But it will be
					precious for a maintainer of the software who is trying
					to figure out what it does, and in the process to
					reconstruct the original developer's reasoning. (The
					maintainer might of course be the same person as the
					developer, six months later.) And if the rationale is
					wrong somewhere, turning assertion checking on will
					immediately uncover the bug.</P>

					<H2>Obsolete features and classes</H2>

					<P>One of the conditions for producing truly great
					reusable software is to recognize that although you
					should try to get everything right the first time around
					you won't always succeed. But if &quot;good enough&quot;
					may be good enough for application software, it's not
					good enough, in the long term, for reusable software.
					The aim is to get ever closer to the asymptote of
					perfection. If you find a better way, you must implement
					it. The activity of
					<SPAN CLASS="italics">generalization</SPAN>, discussed as
					part of the lifecycle, doesn't stop at the first release
					of a reusable library.</P>

					<P>This raises the issue of backward compability: how to
					move forward with a better design, without compromising
					existing applications that used the previous version?</P>

					<P>The notion of obsolete class and feature helps address
					this issue. By declaring a feature as
					<SPAN CLASS="ekeyword">obsolete</SPAN>, using the syntax</P>

					<CODE>
						<P><SPAN CLASS="efeature">enter</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">i</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">;</SPAN>
						<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="egeneric">G</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">obsolete</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="esymbol">&quot;</SPAN><SPAN CLASS="estring">Use
						`put (x, i)' instead</SPAN><SPAN CLASS="esymbol">&quot;</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">require</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8230;</P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">put</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="elocal">i</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>you state that you are now advising against using it,
					and suggest a replacement through the message that
					follows the keyword <SPAN CLASS="ekeyword">obsolete</SPAN>,
					a mere string. The obsolete feature is still there,
					however; using it will cause no other harm than a warning
					message when someone compiles a system that includes a
					call to it. Indeed, you don't want to hold a gun to your
					client authors' forehead (&quot;<SPAN CLASS="italics">Upgrade now or die!</SPAN>&quot;);
					but you do want to let them know that there is a new
					version and that they should upgrade at their leisure.</P>

					<P>Besides routines, you may also mark classes as
					obsolete.</P>

					<P>The example above is a historical one, involving an
					early change of interface for the EiffelBase library
					class <SPAN CLASS="eclass">ARRAY</SPAN>; the change
					affected both the feature's name, with a new name
					ensuring better consistency with other classes, and the
					order of arguments, again for consistency. It shows the
					recommended style for using
					<SPAN CLASS="ekeyword">obsolete</SPAN>:</P>

					<UL>
						<LI>In the message following the keyword, explain the
						recommended replacement. This message will be part of
						the warning produced by the compiler for a system
						that includes the obsolete element.</LI>

						<LI>In the body of the routine, it is usually
						appropriate, as here, to replace the original
						implementation by a call to the new version. This may
						imply a small performance overhead, but simplifies
						maintenance and avoids errors.</LI>
					</UL>

					<P>It is good discipline not to let obsolete elements
					linger around for too long. The next major new release,
					after a suitable grace period, should remove them.</P>

					<P>The design flexibility afforded by the
					<SPAN CLASS="ekeyword">obsolete</SPAN> keyword is
					critical to ensure the harmonious long-term development
					of ambitious reusable software.</P>

					<H2>Creation variants</H2>

					<P>The basic forms of creation instruction, and the one
					most commonly used, are the two illustrated earlier
					(<A HREF="tutorial-07.html#59651">&quot;Creating and initializing objects&quot;</A>):
					</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">create</SPAN>
						<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">make</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="enumber">2000</SPAN><SPAN CLASS="esymbol">)</SPAN>
						</P>

						<P><SPAN CLASS="ekeyword">create</SPAN>
						<SPAN CLASS="elocal">x</SPAN>
					</CODE>

					<P>the first one if the corresponding class has a
					<SPAN CLASS="ekeyword">create</SPAN> clause, the second
					one if not. In either form you may include a type name in
					braces, as in</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">create</SPAN>
						<SPAN CLASS="esymbol">{</SPAN><SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN><SPAN CLASS="esymbol">}</SPAN>
						<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">make</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="enumber">2000</SPAN><SPAN CLASS="esymbol">)</SPAN>
						</P>
					</CODE>

					<P>which is valid only if the type listed, here
					<SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN>, conforms to
					the type of <SPAN CLASS="elocal">x</SPAN>, assumed here
					to be <SPAN CLASS="eclass">ACCOUNT</SPAN>. This avoids
					introducing a local entity, as in</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">local</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="elocal">sx</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN></P>

						<P><SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">create</SPAN>
						<SPAN CLASS="elocal">xs</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">make</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="enumber">2000</SPAN><SPAN CLASS="esymbol">)</SPAN></P>


						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="elocal">x</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="elocal">xs</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8230;</P>
					</CODE>

					<P>and has exactly the same effect. Another variant is
					the <SPAN CLASS="bold">creation expression</SPAN>, which
					always lists the type, but returns a value instead of
					being an instruction. It is useful in the following
					context:</P>

					<CODE>
						<P><SPAN CLASS="efeature">some_routine</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">create</SPAN>
						<SPAN CLASS="esymbol">{</SPAN><SPAN CLASS="eclass">ACCOUNT</SPAN><SPAN CLASS="esymbol">}</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">make</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="enumber">2000</SPAN><SPAN CLASS="esymbol">))</SPAN>
					</CODE>

					<P>which you may again view as an abbreviation for a more
					verbose form that would need a local entity, using a
					creation instruction:</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">local</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">ACCOUNT</SPAN></P>

						<P><SPAN CLASS="ekeyword">do</SPAN></P>

						<P><SPAN CLASS="ekeyword">&nbsp;&nbsp;&nbsp;create</SPAN>
						<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">make</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="enumber">2000</SPAN><SPAN CLASS="esymbol">)</SPAN>
						</P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">some_routine</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8230;</P>
					</CODE>

					<P>Unlike creation instructions, creation expressions
					must always list the type explicitly,
					<SPAN CLASS="esymbol">{</SPAN><SPAN CLASS="eclass">ACCOUNT</SPAN><SPAN CLASS="esymbol">}</SPAN>
					in the example. They are useful in the case shown:
					creating an object that only serves as an argument to be
					passed to a routine. If you need to retain access to the
					object through an entity, the instruction
					<SPAN CLASS="ekeyword">create</SPAN>
					<SPAN CLASS="elocal">x</SPAN>&#8230; is the appropriate
					construct.</P>

					<P>The creation mechanism gets an extra degree of
					flexibility through the notion of
					<SPAN CLASS="efeature">default_create</SPAN>. The
					simplest form of creation instruction,
					<SPAN CLASS="ekeyword">create</SPAN>
					<SPAN CLASS="elocal">x</SPAN> without an explicit
					creation procedure, is actually an abbreviation for
					<SPAN CLASS="ekeyword">create</SPAN>
					<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">default_create</SPAN>,
					where <SPAN CLASS="efeature">default_create</SPAN> is a
					procedure defined in class
					<SPAN CLASS="eclass">ANY</SPAN> to do nothing. By
					redefining <SPAN CLASS="efeature">default_create</SPAN>
					in one of your classes, you can ensure that
					<SPAN CLASS="ekeyword">create</SPAN>
					<SPAN CLASS="elocal">x</SPAN> will take care of
					non-default initialization (and ensure the invariant if
					needed). When a class has no
					<SPAN CLASS="ekeyword">create</SPAN> clause, it's
					considered to have one that lists only
					<SPAN CLASS="efeature">default_create</SPAN>. If you want
					to allow <SPAN CLASS="ekeyword">create</SPAN>
					<SPAN CLASS="elocal">x</SPAN> as well as the use of some
					explicit creation procedures, simply list
					<SPAN CLASS="efeature">default_create</SPAN> along with
					these procedures in the
					<SPAN CLASS="ekeyword">create</SPAN> clause. To disallow
					creation altogether, include an empty
					<SPAN CLASS="ekeyword">create</SPAN> clause, although
					this technique is seldom needed since most non-creatable
					classes are deferred, and one can't instantiate a
					deferred class.</P>

					<P>One final twist is the mechanism for creating instances
					of formal generic parameters. For
					<SPAN CLASS="elocal">x</SPAN> of type
					<SPAN CLASS="egeneric">G</SPAN> in a class C
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="egeneric">G</SPAN><SPAN CLASS="esymbol">]</SPAN>,
					it wouldn't be safe to allow
					<SPAN CLASS="ekeyword">create</SPAN>
					<SPAN CLASS="elocal">x</SPAN>, since
					<SPAN CLASS="egeneric">G</SPAN> stands for many possible
					types, all of which may have their own creation
					procedures. To allow such creation instructions, we rely
					on constrained genericity. You may declare a class as</P>

					<CODE>
						<P><SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="egeneric">G</SPAN>
						<SPAN CLASS="esymbol">-&gt;</SPAN>
						<SPAN CLASS="eclass">T</SPAN>
						<SPAN CLASS="ekeyword">create</SPAN>
						<SPAN CLASS="efeature">cp</SPAN>
						<SPAN CLASS="ekeyword">end</SPAN>
						<SPAN CLASS="esymbol">]</SPAN>
					</CODE>

					<P>to make <SPAN CLASS="egeneric">G</SPAN> constrained by
					<SPAN CLASS="eclass">T</SPAN>, as we learned before, and
					specify that any actual generic parameter must have
					<SPAN CLASS="efeature">cp</SPAN> among its creation
					procedures. Then it's permitted to use
					<SPAN CLASS="ekeyword">create</SPAN>
					<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">cp</SPAN>,
					with arguments if required by
					<SPAN CLASS="efeature">cp</SPAN>, since it is guaranteed
					to be safe. The mechanism is very general since you may
					use <SPAN CLASS="eclass">ANY</SPAN> for
					<SPAN CLASS="eclass">T</SPAN> and
					<SPAN CLASS="efeature">default_create</SPAN> for
					<SPAN CLASS="efeature">cp</SPAN>. The only requirement
					on <SPAN CLASS="efeature">cp</SPAN> is that it must be a
					<SPAN CLASS="italics">procedure</SPAN> of
					<SPAN CLASS="eclass">T</SPAN>, not necessarily a
					<SPAN CLASS="italics">creation</SPAN> procedure; this
					permits using the mechanism even if
					<SPAN CLASS="eclass">T</SPAN> is deferred, a common
					occurrence. It's only descendants of
					<SPAN CLASS="eclass">T</SPAN> that must make
					<SPAN CLASS="efeature">cp</SPAN> a creation procedure,
					by listing it in the <SPAN CLASS="ekeyword">create</SPAN>
					clause, if they want to serve as actual generic
					parameters for <SPAN CLASS="eclass">C</SPAN>.</P>

					<H2><A NAME="36752"></A>Tuple types</H2>

					<P>The study of genericity described arrays. Another
					common kind of container objects bears some resemblance
					to arrays: sequences, or &quot;tuples&quot;, of elements
					of specified types. The difference is that all elements
					of an array were of the same type, or a conforming one,
					whereas for tuples you will specify the types we want for
					each relevant element. A typical tuple type is of the form</P>

					<CODE>
						<P><SPAN CLASS="eclass">TUPLE</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">X</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="eclass">Y</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="eclass">Z</SPAN><SPAN CLASS="esymbol">]</SPAN></P>
					</CODE>

					<P>denoting a tuple of least three elements, such that
					the type of the first conforms to
					<SPAN CLASS="eclass">X</SPAN>, the second to
					<SPAN CLASS="eclass">Y</SPAN>, and the third to
					<SPAN CLASS="eclass">Z</SPAN>.</P>

					<P>You may list any number of types in brackets,
					including none at all:
					<SPAN CLASS="eclass">TUPLE</SPAN>, with no types in
					brackets, denotes tuples of arbitrary length.</P>

					<P CLASS=note>The syntax, with brackets, is intentionally
					reminiscent of generic classes, but
					<SPAN CLASS="eclass">TUPLE</SPAN> is a reserved word, not
					the name of a class; making it a class would not work
					since a generic class has a fixed number of generic
					parameters. You may indeed use
					<SPAN CLASS="eclass">TUPLE</SPAN> to obtain the effect of
					a generic class with a variable number of parameters.</P>

					<P>To write the tuples themselves -- the sequences of
					elements, instances of a tuple type -- you will also use
					square brackets; for example</P>

					<CODE>
						<P><SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="elocal">x1</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="elocal">y1</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="elocal">z1</SPAN><SPAN CLASS="esymbol">]</SPAN>
					</CODE>

					<P>with <SPAN CLASS="elocal">x1</SPAN> of type
					<SPAN CLASS="eclass">X</SPAN> and so on is a tuple of
					type <SPAN CLASS="eclass">TUPLE</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">X</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="eclass">Y</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="eclass">Z</SPAN><SPAN CLASS="esymbol">]</SPAN>.</P>

					<P>The definition of tuple types states that
					<SPAN CLASS="eclass">TUPLE</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">X1</SPAN><SPAN CLASS="esymbol">,</SPAN>
					&#8230;<SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="eclass">Xn</SPAN><SPAN CLASS="esymbol">]</SPAN>
					denotes sequences of <SPAN CLASS="italics">at least</SPAN>
					<SPAN CLASS="enumber">n</SPAN> elements, of which the first
					<SPAN CLASS="enumber">n</SPAN> have types respectively conforming to
					<SPAN CLASS="eclass">X1</SPAN><SPAN CLASS="esymbol">,</SPAN>
					&#8230;<SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="eclass">Xn</SPAN>. Such a sequence may have
					more than <SPAN CLASS="enumber">n</SPAN> elements.</P>

					<P>Features available on tuple types include
					<SPAN CLASS="efeature">count</SPAN><SPAN CLASS="esymbol">:</SPAN>
					<SPAN CLASS="eclass">INTEGER</SPAN>, yielding the number
					of elements in a tuple, <SPAN CLASS="efeature">item</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">i</SPAN><SPAN CLASS="esymbol">:</SPAN>
					<SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">):</SPAN>
					<SPAN CLASS="eclass">ANY</SPAN> which returns the
					<SPAN CLASS="elocal">i</SPAN>-th element, and
					<SPAN CLASS="efeature">put</SPAN> which replaces an element.</P>

					<P>Tuples are appropriate when these are the only
					operations you need, that is to say, you are using
					sequences with no further structure or properties. Tuples
					give you &quot;anonymous classes&quot; with predefined
					features <SPAN CLASS="efeature">count</SPAN>,
					<SPAN CLASS="efeature">item</SPAN> and
					<SPAN CLASS="efeature">put</SPAN>. A typical example is a
					general-purpose output procedure that takes an arbitrary
					sequence of values, of arbitrary types, and prints them.
					It may simply take an argument of type
					<SPAN CLASS="eclass">TUPLE</SPAN>, so that clients can
					call it under the form</P>

					<CODE>
						<P><SPAN CLASS="efeature">write</SPAN>
						<SPAN CLASS="esymbol">([</SPAN><SPAN CLASS="enumber">your_integer</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="enumber">your_real</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="elocal">your_account</SPAN><SPAN CLASS="esymbol">])</SPAN></P>
					</CODE>

					<P>As soon as you need a type with more specific
					features, you should define a class.</P>

					<P CLASS="seealso"><B>See also</B><BR />
						<A HREF="tutorial-12.html">Agents</A>
					</P>
				</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FOOTER">
			<TR>
				<TD>© 2003-2004 Eiffel Software. All rights reserved.</TD>
			</TR>
		</TABLE>
	</BODY>
</HTML>