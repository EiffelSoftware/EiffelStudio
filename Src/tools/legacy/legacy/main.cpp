/*
 * PUBLIC DOMAIN PCCTS-BASED C++ GRAMMAR (cplusplus.g, stat.g, expr.g)
 *
 * Authors: Sumana Srinivasan, NeXT Inc.;            sumana_srinivasan@next.com
 *          Terence Parr, Parr Research Corporation; parrt@parr-research.com
 *          Russell Quong, Purdue University;        quong@ecn.purdue.edu
 *
 * VERSION 1.1
 *
 * SOFTWARE RIGHTS
 *
 * This file is a part of the ANTLR-based C++ grammar and is free
 * software.  We do not reserve any LEGAL rights to its use or
 * distribution, but you may NOT claim ownership or authorship of this
 * grammar or support code.  An individual or company may otherwise do
 * whatever they wish with the grammar distributed herewith including the
 * incorporation of the grammar or the output generated by ANTLR into
 * commerical software.  You may redistribute in source or binary form
 * without payment of royalties to us as long as this header remains
 * in all source distributions.
 *
 * Requires PCCTS 1.32b4 or higher to get past ANTLR. 
 * 
 * DISCLAIMER: we make no guarantees that this grammar works, makes sense,
 *             or can be used to do anything useful.
 */

/*
 * Program to transpile C++ code into Eiffel code.
 *
 * This distribution is public domain (not only the PCCTS-BASED C++ part
 * but also the Eiffel-code-generation-part.) ISE Inc. is not responsible
 * for parts that do not work (properly).
 * You may use this whole package in any tool or parser you write as long
 * as you don't claim ownership or authorship of either part of this (below)
 * written class and classes it relies on other than the ones coming from PCCTS.
 * For copyright on PCCTS used classes see comments above.
 *
 * Generating the three classes written (and included) below, took about
 * two / three days of actual work. Therefore, this transpiler might be
 * incomplete and some parts of C++ might not even be supported. Don't blame
 * us for lacking some abilities. This version already automizes a lot of work
 * for you, so in fact it is a good product ;-)
 *
 * Feel free to make improvements to this package in any form, but make sure
 * you write the original authors about your improvements. ISE Inc. can be
 * reached at support@eiffel.com. Improvements to the C++ grammar should be
 * sent to parrt@parr-research.com and possibly to support@eiffel.com.
 * Improvements to PCCTS should only be sent to parrt@parr-research.com.
 * C++-Eiffel-Transpiler improvements should be sent to support@eiffel.com.
 *
 * If you don't feel like improving (and hacking) the code yourself, you can
 * always contact ISE Inc. about the bugs, lacks, leaks, and whatever you may
 * find and we will at least have a look at the e-mail you sent us. We cannot
 * guarantee that bugs will fixed, improvements will be made etc.etc. for
 * this product is public domain and not the main goal of our company.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef W32MSC
#       include <stream.h>
#endif /* W32MSC */

#include "tokens.h"
#include "CPPParser.h"
typedef ANTLRCommonToken ANTLRToken;
#include "DLGLexer.h"
#include "PBlackBox.h"
#include "global.h" //*** new

// These are bad. Should be an enum. But I don't care right now.
// (Needs to be defined before Constructor.h is included.)
#define PUBLIC_ACCESS		1
#define PROTECTED_ACCESS	2
#define PRIVATE_ACCESS		3



#include "Constructor.h"
#include "Field.h"

typedef Field **Field_list;
typedef Field *ptrField;
typedef Constructor **Constructor_list;
typedef Constructor *ptrConstructor;
typedef char **Char_list;
typedef char * ptrChar;

// Globals. I know this is bad, but, hey, this is merely the first version.
char *file_name;
char *usr_file_name;
char *preprodir;
char *compiler;
char *prog_name;
FILE *input_file;
int gnu_code;
int prepro;

int joce = 0;

// Function declarations...
void clean_up();		// Cleans up used dummy?.cpp files...

class MyParser : public CPPParser {
private:

	char * _cpp_class_name[NB_MAX_LEVEL];
	char * _eiffel_class_name[NB_MAX_LEVEL];
	char * _eiffel_file_name[NB_MAX_LEVEL]; 

	Char_list *_parents_class;//###
	Char_list *_templ_class;//###


	Constructor_list *_ctor_list_class;
	ptrConstructor _last_ctor[NB_MAX_LEVEL];

	Field_list *_field_list_class;
	ptrField _last_field[NB_MAX_LEVEL];

	FILE *out_file;

	int _access[NB_MAX_LEVEL]; // ***
	int _ctor_array_length;
	int _empty_signature[NB_MAX_LEVEL];

	int _in_ctor_decl[NB_MAX_LEVEL];
	int _in_field_decl[NB_MAX_LEVEL];
	int _in_parameter_list[NB_MAX_LEVEL];

	int _number_of_ctor[NB_MAX_LEVEL];
	int _number_of_field[NB_MAX_LEVEL]; // ***
	int _number_of_parent[NB_MAX_LEVEL];
	int _number_of_templ[NB_MAX_LEVEL];

	int *_parent_access[NB_MAX_LEVEL];//[];//###
	int _icc; // *** _index_current_class

	void ErrorAndDie()
	{
		fprintf(stderr,"\nUnable to translate rest of implementation file..");
		fprintf(stderr,"\nTerminating...\n");
		
		clean_up();
 		exit(EXIT_FAILURE);
	}
	
	char* _strtol(char *s1)
	{
		char *arg = s1;

		while(*s1)
		{
			*s1 = tolower(*s1);
			s1++;
		}

		return arg;
	}

	char* _strtou(char *s1)
	{
		char *arg = s1;

		while(*s1)
		{
			*s1 = toupper(*s1);
			s1++;
		}

		return arg;
	}

	char* _strdup(char *s1)
	{
		char *result;
		int i;

		result = new char[strlen(s1) + 1];
		for(i = 0; i < strlen(s1); i++)
			result[i] = s1[i];
		result[i] = '\0';

		return result;
	}

	char* _to_eiffel_name(char * _name)
		{
			char *result;
				result = _strdup(_name);
			if(result[0] == '_')
			{
				char *real_result;
				real_result = new char[11 + strlen(_name)];
				real_result[0] = '\0';
				real_result = strcat(real_result, "underscore");
				real_result = strcat(real_result, result);
				// delete result;
				result = real_result;
			}
			return result;
		}


private:
	void _print_eiffel_code()
	{
		fprintf(stderr,"Storing class %s in '%s'.\n",_to_eiffel_name(_eiffel_class_name[ _icc ]), _to_eiffel_name(_eiffel_file_name[_icc]));

		out_file = fopen( _to_eiffel_name(_eiffel_file_name[_icc]), "w+");
		if(!out_file)
		{
			fprintf(stderr,"Could not open '%s' for output.\n", _to_eiffel_name(_eiffel_file_name[_icc]));
			fprintf(stderr,"Make sure that you have write permissions for the current directory.\n");			
			exit(EXIT_FAILURE);
		}

			// Print indexing clause
		fprintf(out_file, "indexing\n");
		fprintf(out_file, "\n\tdescription:\n");
		fprintf(out_file, "\t\t\"Eiffel encapsulation of C++ class %s\";\n", _cpp_class_name[_icc]);
		fprintf(out_file, "\tdate: \"$Date$\";\n");
		fprintf(out_file, "\trevision: \"$Revision$\"\n");

			// Print class name
		fprintf(out_file, "\nclass %s", _to_eiffel_name( _eiffel_class_name[ _icc ]) );
//		printf("\t[*] _print_generics()\n"); //###
		_print_generics();

			// Print inheritance clause
		fprintf(out_file, "\ninherit\n");
			// Default parent: MEMORY
		fprintf(out_file, "\tMEMORY\n");
		fprintf(out_file, "\t\tredefine\n");
		fprintf(out_file, "\t\t\tdispose\n");
		fprintf(out_file, "\t\tend");

		if(_number_of_parent[_icc] > 0)
		{
			fprintf(out_file, ";\n");
//			printf("\t[*] _print_inheritance()\n"); //###

			_print_inheritance();
		}
		else
		{
			fprintf(out_file, "\n");
		}

			// Print creation clause
		fprintf(out_file, "\ncreation\n");
//		printf("\t[*] _print_default_creation() or _print_creation_routines()\n"); //###
		if(_number_of_ctor[_icc] == 0)
			_print_default_creation();
		else
			_print_creation_routines();

			// Print redefinition of 'dispose' (with own feature clause)
		fprintf(out_file, "\nfeature -- Removal\n");
		fprintf(out_file, "\n\tdispose is\n");
		fprintf(out_file, "\t\t\t-- Delete C++ object.\n");
		fprintf(out_file, "\t\tdo\n");
		fprintf(out_file, "\t\t\tcpp_delete (object_ptr)\n");
		fprintf(out_file, "\t\tend\n");

//		printf("\t[*] _print_features()\n"); //###
		_print_features();

//		printf("\t[*] _print_externals()\n");  //###
		_print_externals();

			// Declare pointer to external object
		fprintf(out_file, "\nfeature {NONE} -- Implementation\n");
		fprintf(out_file, "\n\tobject_ptr: POINTER\n");

			// Print end of class
		fprintf(out_file, "\nend -- class %s\n",  _to_eiffel_name(_eiffel_class_name[_icc]));

			// Close this output file
		fclose(out_file);

//		_number_of_ctor[_icc]= 0;		// Start from scratch...// ***

	}

	void _print_generics()
	{
		if(_number_of_templ[_icc] > 0)
		{
			int i;

			fprintf(out_file, " [");

			for(i = 0; i < _number_of_templ[_icc]; i++)
			{
				fprintf(out_file, "%s", (_templ_class[_icc])[i]);
				if(i + 1 < _number_of_templ[_icc])
					fprintf(out_file, ", ");
			}
				
			fprintf(out_file, "]\n");
		}
		else
		{
			fprintf(out_file, "\n");
		}
	}
	void _print_inheritance()
	{
		int i;

		for(i = 0; i < _number_of_parent[_icc]; i++)
		{
			switch((_parent_access[_icc])[i])
			{
				case 1:
					fprintf(out_file, "\t{%s} ", _eiffel_class_name[_icc]);
					break;
				case 2:
					fprintf(out_file, "\t{NONE} ");
					break;
				default:
					fprintf(out_file, "\t");
					break;
			}
			fprintf(out_file, "%s", (_parents_class[_icc])[i]);

			if(i + 1 < _number_of_parent[_icc])
				fprintf(out_file, ";\n");
			else
				fprintf(out_file, "\n");
		}
	}
				
	void _print_default_creation()
	{
		fprintf(out_file, "\tmake\n");
		fprintf(out_file, "\nfeature -- Initialization\n");
		fprintf(out_file, "\n\tmake is\n");
		fprintf(out_file, "\t\t\t-- Create Eiffel and C++ objects.\n");
		fprintf(out_file, "\t\tdo\n");
		fprintf(out_file, "\t\t\tobject_ptr := cpp_new\n");
		fprintf(out_file, "\t\tend\n");
	}

	void _print_creation_routines()
	{
		if(_number_of_ctor[_icc] == 1)
		{
			fprintf(out_file, "\tmake\n");
			fprintf(out_file, "\nfeature -- Initialization\n");
			fprintf(out_file, "\n\tmake ");
			((_ctor_list_class[_icc])[0])->print_eiffel_arguments(out_file);
			fprintf(out_file, " is\n");
			fprintf(out_file, "\t\t\t-- Create Eiffel and C++ objects.\n");

			( (_ctor_list_class[_icc])[0] )->PrintEiffelCommentAction(out_file);

			if(((_ctor_list_class[_icc])[0])->HasPointerArg())
			{
				fprintf(out_file, "\t\tlocal\n");
				((_ctor_list_class[_icc])[0])->PrintLocalAny(out_file);
			}
			fprintf(out_file, "\t\tdo\n");
			if(((_ctor_list_class[_icc])[0])->HasPointerArg())
			{
				((_ctor_list_class[_icc])[0])->ConvertArguments(out_file);
				fprintf(out_file, ";\n");
			}
			fprintf(out_file, "\t\t\tobject_ptr := cpp_new");
			((_ctor_list_class[_icc])[0])->print_cpp_parameters(out_file);
			fprintf(out_file, "\n");
			fprintf(out_file, "\t\tend\n");
		}
		else
		{
			int index, iindex, oindex, j;
			int lastaccess = PUBLIC_ACCESS;
			int _just_printed = 0;

			for(oindex = 0; oindex < _number_of_ctor[_icc]; oindex += 1)
			{
				for(iindex = oindex; iindex < _number_of_ctor[_icc]; iindex += 1)
				{
					if(((_ctor_list_class[_icc])[iindex])->AccessSpecifier() == lastaccess)
					{
						fprintf(out_file, "\tmake%d", iindex);
						_just_printed = 1;
						for(j = iindex + 1; j < _number_of_ctor[_icc]; j += 1)
							if(((_ctor_list_class[_icc])[j])->AccessSpecifier() == lastaccess)
							{
								fprintf(out_file, ",");
								break;
							}
						fprintf(out_file, "\n");
					}
				}
				if(lastaccess == PRIVATE_ACCESS)
					break;
				lastaccess = (lastaccess == PUBLIC_ACCESS ? PROTECTED_ACCESS : PRIVATE_ACCESS);
				if(_just_printed == 0)
				{
					oindex -= 1;
				}
				_just_printed = 0;
				for(j = oindex + 1; j < _number_of_ctor[_icc]; j += 1)
					if(((_ctor_list_class[_icc])[j])->AccessSpecifier() == lastaccess)
					{
						fprintf(out_file, "\ncreation {%s}\n",(lastaccess == PROTECTED_ACCESS ? _eiffel_class_name[ _icc] : "NONE"));
						break;
					}
			}

			fprintf(out_file, "\nfeature {NONE} -- Initialization\n");

			for(index = 0; index < _number_of_ctor[_icc]; index += 1)
			{
				fprintf(out_file, "\n\tmake%d", index);
				((_ctor_list_class[_icc])[index])->print_eiffel_arguments(out_file);
				fprintf(out_file, " is\n");
				fprintf(out_file, "\t\t\t-- Create Eiffel and C++ objects.\n");
				( (_ctor_list_class[_icc])[index] )->PrintEiffelCommentAction(out_file);

				if(((_ctor_list_class[_icc])[index])->HasPointerArg())
				{
					fprintf(out_file, "\t\tlocal\n");
					((_ctor_list_class[_icc])[index])->PrintLocalAny(out_file);
				}
				fprintf(out_file, "\t\tdo\n");
				if(((_ctor_list_class[_icc])[index])->HasPointerArg())
				{
					((_ctor_list_class[_icc])[index])->ConvertArguments(out_file);
					fprintf(out_file, ";\n");
				}
				fprintf(out_file, "\t\t\tobject_ptr := cpp_new%d", index);
				((_ctor_list_class[_icc])[index])->print_cpp_parameters(out_file);
				fprintf(out_file, "\n");
				fprintf(out_file, "\t\tend\n");
			}
		}
	}

	void _print_features()
	{
//		printf("[print_feature][%s]  number of field [%i] = %i\n",_eiffel_class_name[_icc],_icc, _number_of_field[_icc]);
		if(_number_of_field[_icc] > 0)
		{
			int index;
			int last_access = -1;

			for(index = 0; index < _number_of_field[_icc]; index += 1)
			{
		//printf("[print_feature]  <-IN->	(_icc=%i / index=%i ) --> ACCESS=%i \n",
//				_icc, index,((_field_list_class[_icc])[index])->AccessSpecifier() );

				if (( (_field_list_class[_icc])[index])->AccessSpecifier() == PUBLIC_ACCESS)
				{
				if(( (_field_list_class[_icc])[index])->AccessSpecifier() != last_access)
				{
					last_access = ( (_field_list_class[_icc])[index])->AccessSpecifier();
					( (_field_list_class[_icc])[index])->PrintAccessClause(out_file);
				}
				fprintf(out_file, "\n\t");

				( (_field_list_class[_icc])[index] )->PrintEiffelName(out_file);
				( (_field_list_class[_icc])[index] )->print_eiffel_arguments(out_file);
				( (_field_list_class[_icc])[index] )->PrintEiffelReturnType(out_file);
				fprintf(out_file, " is\n");
				fprintf(out_file, "\t\t\t-- Call C++ counterpart.\n");

				( (_field_list_class[_icc])[index] )->PrintEiffelCommentAction(out_file);

				if((_field_list_class[_icc][index])->IsStringType())
				{
					fprintf(out_file, "\t\tlocal\n");
					fprintf(out_file, "\t\t\tloc_ptr: POINTER");
					if(( (_field_list_class[_icc])[index] )->HasPointerArg())
					{
						fprintf(out_file, ";\n");
						( (_field_list_class[_icc])[index] )->PrintLocalAny(out_file);
					}
					else
						fprintf(out_file, "\n");
				}
				else
				{
					if(( (_field_list_class[_icc])[index] )->HasPointerArg())
					{
						fprintf(out_file, "\t\tlocal\n");
						( (_field_list_class[_icc])[index] )->PrintLocalAny(out_file);
					}
				}
				fprintf(out_file, "\t\tdo\n");
				fprintf(out_file, "\t\t\t");
				( (_field_list_class[_icc])[index] )->PrintEiffelBody(out_file);
				fprintf(out_file, "\n");
				fprintf(out_file, "\t\tend\n");
			}
			}
		}
	}


	void _print_externals()
	{
		fprintf(out_file, "\nfeature {NONE} -- Externals\n");

		if(_number_of_ctor[_icc] == 0)
		{
			fprintf(out_file, "\n\tcpp_new: POINTER is \n");
			fprintf(out_file, "\t\t\t-- Call default ctor of C++ class.\n");
			fprintf(out_file, "\t\texternal\n");
			fprintf(out_file, "\t\t\t\"C++ [new %s %%\"%s%%\"] ()\"\n", _cpp_class_name[_icc], usr_file_name);
			fprintf(out_file, "\t\tend\n");
		}
		else
			_print_cpp_ctors();

		fprintf(out_file, "\n\tcpp_delete (cpp_obj: POINTER) is\n");
		fprintf(out_file, "\t\t\t-- Call C++ destructor on C++ object.\n");
		fprintf(out_file, "\t\texternal\n");
		fprintf(out_file, "\t\t\t\"C++ [delete %s %%\"%s%%\"] ()\"\n", _cpp_class_name[_icc], usr_file_name);
		fprintf(out_file, "\t\tend\n");

		_print_external_features();
	}

	void _print_cpp_ctors()
	{
		if(_number_of_ctor[_icc] == 1)
		{
			fprintf(out_file, "\n\tcpp_new");
			((_ctor_list_class[_icc])[0])->print_external_eiffel_arguments(out_file);
			fprintf(out_file, ": POINTER is \n");
			fprintf(out_file, "\t\t\t-- Call single constructor of C++ class.\n");
			( (_ctor_list_class[_icc])[0] )->PrintEiffelCommentAction(out_file);
			fprintf(out_file, "\t\texternal\n");
			fprintf(out_file, "\t\t\t\"C++ [new %s %%\"%s%%\"]", _cpp_class_name[_icc], usr_file_name);
			((_ctor_list_class[_icc])[0])->print_external_signature(out_file);
			fprintf(out_file, "\"\n");
			fprintf(out_file, "\t\tend\n");
		}
		else
		{
			int index;

			for(index = 0; index < _number_of_ctor[_icc]; index += 1)
			{
				fprintf(out_file, "\n\tcpp_new%d", index);
				((_ctor_list_class[_icc])[index])->print_external_eiffel_arguments(out_file);
				fprintf(out_file, ": POINTER is \n");
				fprintf(out_file, "\t\t\t-- Call a ctor of C++ class.\n");
				( (_ctor_list_class[_icc])[index] )->PrintEiffelCommentAction(out_file);
				fprintf(out_file, "\t\texternal\n");
				fprintf(out_file, "\t\t\t\"C++ [new %s %%\"%s%%\"]", _cpp_class_name[_icc], usr_file_name);
				((_ctor_list_class[_icc])[index])->print_external_signature(out_file);
				fprintf(out_file, "\"\n");
				fprintf(out_file, "\t\tend\n");
			}
		}
	}

	void _print_external_features()
	{
		if (_number_of_field[_icc] > 0)
		{
			int index;

			for (index = 0; index < _number_of_field[_icc]; index += 1)
			{
				if (( (_field_list_class[_icc])[index] )->AccessSpecifier() == PUBLIC_ACCESS)
				{
					fprintf(out_file, "\n\t");
					( (_field_list_class[_icc])[index] )->PrintExternalName(out_file);
					( (_field_list_class[_icc])[index] )->print_external_eiffel_arguments(out_file);
					( (_field_list_class[_icc])[index] )->PrintExternalType(out_file);
					fprintf(out_file, " is\n");
					fprintf(out_file, "\t\t\t-- Value of C++ data member.\n");
					( (_field_list_class[_icc])[index] )->PrintEiffelCommentAction(out_file);
					fprintf(out_file, "\t\texternal\n");
					fprintf(out_file, "\t\t\t\"C++ [");
					( (_field_list_class[_icc])[index] )->PrintMemberType(out_file);
					fprintf(out_file, "%s %%\"%s%%\"]", _cpp_class_name[_icc], usr_file_name);
					( (_field_list_class[_icc])[index] )->print_external_signature(out_file);
					( (_field_list_class[_icc])[index] )->PrintExternalReturnType(out_file);
					fprintf(out_file, "\"\n");
					fprintf(out_file, "\t\talias\n");
					fprintf(out_file, "\t\t\t\"");
					( (_field_list_class[_icc])[index] )->PrintAliasName(out_file);
					fprintf(out_file, "\"\n");
					fprintf(out_file, "\t\tend\n");
				}
			}
		}
	}

public:
	MyParser(ANTLRTokenBuffer *input) : CPPParser(input)
		{
			char *new_cpp_class_name;
			char *new_eiffel_class_name;
			char *new_eiffel_file_name;
			_icc = 0; // *** initialisation

			_ctor_list_class = new Constructor_list[NB_MAX_LEVEL];
			_ctor_list_class[_icc] = new Constructor*[NB_MAX];
			_last_ctor[_icc] = (ptrConstructor)malloc(sizeof(Constructor)); //NULL;
		

			_field_list_class = new Field_list[NB_MAX_LEVEL];
			_field_list_class[_icc] = new Field*[NB_MAX]; 
			_last_field[_icc] = (ptrField)malloc(sizeof(Field)); //NULL;

			_parents_class = new Char_list[NB_MAX_LEVEL];
			_parents_class[_icc] = new ptrChar[NB_MAX];//###

			//_parent_access = (int*)malloc(NB_MAX_LEVEL*(sizeof(*int)));
			_parent_access[_icc] = new int[NB_MAX];

			_templ_class = new Char_list[NB_MAX];
			_templ_class[_icc] = new ptrChar[NB_MAX];//###

//***begin
			char* tag=new char[strlen("LEVEL_ZERO")+1];
			strcpy(tag,"LEVEL_ZERO");



			new_cpp_class_name = new char[strlen(tag)+1];
			new_cpp_class_name = strdup(tag);

			new_eiffel_class_name = new char[strlen(tag)+1];
			new_eiffel_class_name = strdup(tag);
			new_eiffel_class_name = _strtou(new_eiffel_class_name);

			new_eiffel_file_name = new char[strlen(tag) + 3];
			new_eiffel_file_name = strcpy(new_eiffel_file_name, tag);
			new_eiffel_file_name = strcat(new_eiffel_file_name, ".e");
			new_eiffel_file_name = _strtol(new_eiffel_file_name);

			_cpp_class_name[_icc] = new_cpp_class_name;
			_eiffel_class_name[_icc] = new_eiffel_class_name;
			_eiffel_file_name[_icc] = new_eiffel_file_name;


			//(_parents_class[_icc]) = new char*[NB_MAX];
			_number_of_parent[_icc] = 0;

			//(_templ_class[_icc]) = new char*[NB_MAX];
			_number_of_templ[_icc] = 0;

			_access[_icc] = PRIVATE_ACCESS;
			_ctor_array_length = ARRAY_LENGTH;
			_number_of_ctor[_icc] = 0;
			_number_of_field[_icc] = 0;
			_in_ctor_decl[_icc] = 0;
			_in_parameter_list[_icc] = 0;
			_empty_signature[_icc] = 0;
			_in_field_decl[_icc] = 0;  
		
		}

	// Qualified Type stuff
	virtual void StoreQt(char *qt)
	{
		if(_in_ctor_decl[_icc] && _in_parameter_list[_icc])
			_last_ctor[_icc]->add_qualified_type(_strtou(strdup(qt)));
		else if(_in_field_decl[_icc] && !_in_parameter_list[_icc])
			_last_field[_icc]->add_return_qualified_type(_strtou(strdup(qt)));
		else if(_in_field_decl[_icc] && _in_parameter_list[_icc])
			_last_field[_icc]->add_param_qualified_type(_strtou(strdup(qt)));
	}

	// Template stuff
	virtual void templateTypeParameter(char *id)
	{
		(_templ_class[_icc])[_number_of_templ[_icc]] = _strtou(strdup(id));
		_number_of_templ[_icc] += 1;

		CPPParser::templateTypeParameter(id);
	}

	// Declaration stuff

	//*** les 2 fct suivantes .. ajoutees

	virtual void enterExternalScope()
		{
			CPPParser::enterExternalScope();
		}

	virtual void exitExternalScope()
		{
			CPPParser::exitExternalScope();
		}
	
	
	virtual void endDeclaration()
		{
			_in_field_decl[_icc] = 0;

			CPPParser::endDeclaration();

			if( (_cpp_class_name[_icc]) && ( _icc > 0) )
			{
				int index;

				if (_icc>0) _print_eiffel_code();

				free(_cpp_class_name[_icc]); // Allocated by 'strdup'... //***
				free(_eiffel_class_name[_icc]);	// Allocated by 'strdup'...//***
				delete [] _eiffel_file_name[_icc];	// Allocated by 'new'...
				
				for(index = 0; index < _number_of_ctor[_icc]; index += 1)
					delete (_ctor_list_class[_icc])[index];
					;


				for(index = 0; index < _number_of_field[_icc]; index += 1)
					delete (_field_list_class[_icc])[index];
					;

				for(index = 0; index < _number_of_parent[_icc]; index += 1)
					delete (_parents_class[_icc])[index];
					;

				for(index = 0; index < _number_of_templ[_icc]; index += 1)
					delete (_templ_class[_icc])[index];
					;



				 
				 delete [] _ctor_list_class[_icc];
				 delete [] _field_list_class[_icc];
				 delete [] _parents_class[_icc];
				 delete [] _templ_class[_icc];
				 //delete [] _parent_access[_icc];

				char* tag=new char[strlen("LEVEL_EMPTY")+1];
				strcpy(tag,"LEVEL_EMPTY");

				strcpy(_cpp_class_name[_icc],tag);
				strcpy(_eiffel_class_name[_icc],tag);
				strcpy(_eiffel_file_name[_icc],tag);

				//delete _ctor_list_class[_icc];// = new Constructor*[NB_MAX];
				_last_ctor[_icc] = NULL; //###

				//delete _field_list_class[_icc];// = new Field*[NB_MAX];
				_last_field[_icc] = NULL; //###

				//delete _parents_class[_icc]; // = new char*[NB_MAX];
				//_parent_access[_icc] = new int[NB_MAX];
				_number_of_parent[_icc] = 0;

				//delete _templ_class[_icc]; //= new char*[NB_MAX];
				_number_of_templ[_icc] = 0;

				_access[_icc] = PRIVATE_ACCESS;
				_ctor_array_length = ARRAY_LENGTH;

				_number_of_ctor[_icc] = 0;
				_number_of_field[_icc] = 0;

				_in_ctor_decl[_icc] = 0;
				_in_parameter_list[_icc] = 0;
				_in_field_decl[_icc] = 0; 
				_empty_signature[_icc] = 0; //###

				_icc -= 1;
		
			}


/*
//			CPPParser::endDeclaration();
			if( (_cpp_class_name[_icc]) && !( _icc <1) )
			{
				int index;

				_print_eiffel_code();//***2

				free(_cpp_class_name[_icc]);		// Allocated by 'strdup'...
				free(_eiffel_class_name[_icc]);	// Allocated by 'strdup'...

				delete [] _eiffel_file_name[_icc];	// Allocated by 'new'...

				for(index = 0; index < _number_of_ctor[_icc]; index += 1)
					delete (_ctor_list_class[_icc])[index];
					;

				for(index = 0; index < _number_of_field[_icc]; index += 1)
					delete (_field_list_class[_icc])[index];
					;

				for(index = 0; index < _number_of_parent[_icc]; index += 1)
					delete ((_parents_class[_icc])[_icc])[index];
					;

				for(index = 0; index < _number_of_templ[_icc]; index += 1)
					delete (_templ[_icc])[index];
					;

				delete [] _ctor_list_class[_icc];
				delete [] _field_list_class[_icc];
				delete [] (_parents_class[_icc])[_icc];
				delete [] _templ[_icc];

				char* tag=new char[strlen("LEVEL_EMPTY")+1];
				strcpy(tag,"LEVEL_EMPTY");

				strcpy(_cpp_class_name[_icc],tag);
				strcpy(_eiffel_class_name[_icc],tag);
				strcpy(_eiffel_file_name[_icc],tag);

				delete [] _ctor_list_class[_icc];
				// = new Constructor*[NB_MAX];
				_last_ctor[_icc] = NULL;

				delete [] _field_list_class[_icc];
				//_field_list_class[_icc] = new Field*[NB_MAX];
				_last_field[_icc] = NULL; // ###

				(_parents_class[_icc]) = new char*[NB_MAX];
				_parent_access[_icc] = new int[NB_MAX];
				_number_of_parent[_icc] = 0;

				_templ = new char*[NB_MAX];
				_number_of_templ[_icc] = 0;

				_access[_icc] = PRIVATE_ACCESS;
				_ctor_array_length = ARRAY_LENGTH;

				_number_of_ctor[_icc] = 0;
				_number_of_field[_icc] = 0;

				_in_ctor_decl[_icc] = 0;
				_in_parameter_list[_icc] = 0;
				_in_field_decl[_icc] = 0; 

				_icc -= 1;
		
			}
  */
  }

	virtual void beginConstructorDeclaration(char *ctor)
		{
			//*** ATTENTION i modified this part to make Legacy working,
			//*** but this isn't a nice solution, there may still be a pointer error
			//*** or may be an wrong initialisation
			//*** but it is temporary...

			char *cpp=new char[ strlen(_cpp_class_name[_icc])+1];
			strcpy(cpp,_cpp_class_name[_icc] );
			char *eiffel=new char[ strlen(_eiffel_class_name[_icc])+1];
			strcpy(eiffel,_eiffel_class_name[_icc] );
			char *efile=new char[ strlen(_eiffel_file_name[_icc])+1];
			strcpy(efile,_eiffel_file_name[_icc] );

			if(!guessing)
			{
				Constructor *new_ctor;

				new_ctor = new Constructor(ctor, _number_of_ctor[_icc] + 1);
				(_ctor_list_class[_icc])[_number_of_ctor[_icc]] = new_ctor;

				_in_ctor_decl[_icc] = 1;
				_number_of_ctor[_icc] += 1;

				_last_ctor[_icc] = new_ctor;
				_last_ctor[_icc]->SetAccessSpecifier(_access[_icc]);
				

				CPPParser::beginConstructorDeclaration(ctor);
			_cpp_class_name[_icc]= cpp ;
			_eiffel_class_name[_icc]= eiffel ;
			_eiffel_file_name[_icc]= efile ;
			}
		}
	virtual void endConstructorDeclaration()
		{
			_last_ctor[_icc] = NULL;
			_in_ctor_decl[_icc] = 0;
			_in_parameter_list[_icc] = 0;
		}

	virtual void beginConstructorDefinition(char *ctor)
		{

			//*** ATTENTION I modified this part to make Legacy working,
			//*** but this isn't a nice solution, there may still be a pointer error
			//*** or may be an wrong initialisation
			//*** but it is temporary...

			char *cpp=new char[ strlen(_cpp_class_name[_icc])+1];
			strcpy(cpp,_cpp_class_name[_icc] );
			char *eiffel=new char[ strlen(_eiffel_class_name[_icc])+1];
			strcpy(eiffel,_eiffel_class_name[_icc] );
			char *efile=new char[ strlen(_eiffel_file_name[_icc])+1];
			strcpy(efile,_eiffel_file_name[_icc] );
		

			Constructor *new_ctor;

			new_ctor = new Constructor(ctor, _number_of_ctor[_icc] + 1);
			(_ctor_list_class[_icc])[_number_of_ctor[_icc]] = new_ctor;

			_in_ctor_decl[_icc] = 1;
			_number_of_ctor[_icc] += 1;


			_last_ctor[_icc] = new_ctor;
			_last_ctor[_icc]->SetAccessSpecifier(_access[_icc]);

			CPPParser::beginConstructorDefinition(ctor); //***1
			_cpp_class_name[_icc]= cpp ;
			_eiffel_class_name[_icc]= eiffel ;
			_eiffel_file_name[_icc]= efile ;

		}

	virtual void endConstructorDefinition()
		{
			_last_ctor[_icc] = NULL;
			_in_ctor_decl[_icc] = 0;
			_in_parameter_list[_icc] = 0;
//printf("NBRE OF CTOR[%i]=%i\n",_icc,_number_of_ctor[_icc]);//***1
			CPPParser::endConstructorDefinition();
		}

	virtual void beginFunctionDefinition()
		{
		
			//*** ATTENTION i modified this part to make Legacy working,
			//*** but this isn't a nice solution, there may still be a pointer error
			//*** or may be an wrong initialisation
			//*** but it is temporary...
		 
			char *cpp=new char[ strlen(_cpp_class_name[_icc])+1];
			strcpy(cpp,_cpp_class_name[_icc] );
			char *eiffel=new char[ strlen(_eiffel_class_name[_icc])+1];
			strcpy(eiffel,_eiffel_class_name[_icc] );
			char *efile=new char[ strlen(_eiffel_file_name[_icc])+1];
			strcpy(efile,_eiffel_file_name[_icc] );
		  
			if ((!guessing) && (_icc > 0 ))// ***
			{

				Field* new_field;
  				new_field = new Field(_eiffel_class_name[_icc]);

				(_field_list_class[_icc])[_number_of_field[_icc]] = new_field;
				_last_field[_icc] = new_field;
				_last_field[_icc]->SetAccessSpecifier(_access[_icc]);

				_in_field_decl[_icc] = 1;
				_number_of_field[_icc] += 1;
				_in_parameter_list[_icc] = 0;
				_empty_signature[_icc] = 0;

				CPPParser::beginFunctionDefinition();
			}
				_cpp_class_name[_icc]= cpp ;
				_eiffel_class_name[_icc]= eiffel ;
				_eiffel_file_name[_icc]= efile ;
 
	}
	virtual void endFunctionDefinition()
		{

			_in_field_decl[_icc] = 0;//###6
			_in_parameter_list[_icc] = 0;

			CPPParser::endFunctionDefinition();
		}


	virtual void beginParameterDeclaration()
		{
			if(_in_field_decl[_icc] == 1 && _in_parameter_list[_icc] == 1)
				_empty_signature[_icc] = 0;

			CPPParser::beginParameterDeclaration();
		}
	virtual void beginFieldDeclaration()
		{
			//*** ATTENTION i modified this part to make Legacy working,
			//*** but this isn't a nice solution, there may still be a pointer error
			//*** or may be an wrong initialisation
			//*** but it is temporary...

			//printf("\nBEGIN FIELD DECLARATION\n\n");
			char *cpp=new char[ strlen(_cpp_class_name[_icc])+1];
			strcpy(cpp,_cpp_class_name[_icc] );
			char *eiffel=new char[ strlen(_eiffel_class_name[_icc])+1];
			strcpy(eiffel,_eiffel_class_name[_icc] );
			char *efile=new char[ strlen(_eiffel_file_name[_icc])+1];
			strcpy(efile,_eiffel_file_name[_icc] );

			if ((!guessing) && (_icc > 0 ))
			{
				Field* new_field;
				new_field = new Field(_eiffel_class_name[_icc]);
			
/*###*/			(_field_list_class[_icc])[_number_of_field[_icc]] = new_field;	//*** PB de pointer!!!
				_last_field[_icc] = new_field;
				_last_field[_icc]->SetAccessSpecifier(_access[_icc]);
				_in_field_decl[_icc] = 1;
				_number_of_field[_icc] += 1;
				_in_parameter_list[_icc] = 0;
				_empty_signature[_icc] = 0;

				CPPParser::beginFieldDeclaration();

			}
			_cpp_class_name[_icc]= cpp ;
			_eiffel_class_name[_icc]= eiffel ;
			_eiffel_file_name[_icc]= efile ;

		}

	virtual void endFieldDeclaration() //***
		{
			declarationSpecifier(_sc, _tq, _ts);
			_in_field_decl[_icc] = 0;
			_in_parameter_list[_icc] = 0;
			_last_field[_icc] = NULL; //###
			CPPParser::endFieldDeclaration();
		}
		
	virtual void beginTemplateDefinition() //###
		{
			_number_of_templ[_icc]=0;
			CPPParser::beginTemplateDefinition();
		}

	virtual void endTemplateDefinition() //###
		{
			CPPParser::endTemplateDefinition();
		}

	virtual void beginTemplateParameterList() //###
		{
			//_number_of_templ[_icc]=0;
			CPPParser::beginTemplateParameterList();
		}

	virtual void endTemplateParameterList() //###
		{
			CPPParser::endTemplateParameterList();
		}


	
	
	
	virtual void declarationSpecifier(StorageClass sc,
					  TypeQualifier tq,
					  TypeSpecifier ts)
		{

//			printf("\n[declaration specifier] _icc=%i, <<< %s | %s | %s >>> \n",_icc , _eiffel_class_name[_icc],_cpp_class_name[_icc],_eiffel_file_name[_icc] );
//			printf("[--------suite--------] _access[%i]=%i,  _last_field[_icc]=%s \n",_icc, _access[_icc], _last_field[_icc]?"[OK]":"[NULL]" );
//			printf("[---------end---------] _number_of_field[%i]=%i,  _in_field_decl[%i]=%i,  \n\n",_icc,_number_of_field[_icc],_icc, _in_field_decl[_icc]);

			if(_in_ctor_decl[_icc] == 1 && _in_parameter_list[_icc] == 1)
			{
				if(_last_ctor[_icc])
					_last_ctor[_icc]->addParameter(sc, tq, ts);
				else
					ErrorAndDie();
			}
			else if(_in_field_decl[_icc] == 1 && _in_parameter_list[_icc] == 0)
			{
				if(_last_field[_icc]) 
				{
					_last_field[_icc]->SetReturnType(sc, tq, ts);
				}

				else
					ErrorAndDie();
			}
			else if(_in_field_decl[_icc] == 1 && _in_parameter_list[_icc] == 1)
			{
				if(_last_field[_icc])
					_last_field[_icc]->addParameter(sc, tq, ts);
				else
					ErrorAndDie();
			}


			CPPParser::declarationSpecifier(sc,tq,ts);
		}

	// Parent stuff
	virtual void BaseClause(char *par, int acc)
	{
		(_parents_class[_icc])[_number_of_parent[_icc]] = strdup(_strtou(par));
		(_parent_access[_icc])[_number_of_parent[_icc]] = acc;

		_number_of_parent[_icc]++;
		CPPParser::BaseClause(par, acc); // ***
	}

	virtual void declaratorPointerTo()
		{
			if(_in_ctor_decl[_icc] == 1 && _in_parameter_list[_icc] == 1)
				_last_ctor[_icc]->set_pointer_to();
			else if(_in_field_decl[_icc] == 1 && _in_parameter_list[_icc] == 1)
				_last_field[_icc]->set_pointer_to();
			else if(_in_field_decl[_icc] == 1 && _in_parameter_list[_icc] == 0)
				_last_field[_icc]->SetPointerToReturn();

			CPPParser::declaratorPointerTo();
		}

	virtual void declaratorArrayTo()
		{
			if(_in_ctor_decl[_icc] == 1 && _in_parameter_list[_icc] == 1)
				_last_ctor[_icc]->set_pointer_to();
			else if(_in_field_decl[_icc] == 1 && _in_parameter_list[_icc] == 1)
				_last_field[_icc]->set_pointer_to();
			else if(_in_field_decl[_icc] == 1 && _in_parameter_list[_icc] == 0)
				_last_field[_icc]->SetPointerToReturn();

			CPPParser::declaratorPointerTo();
		}

	virtual void declaratorID(char *id)
		{

			if(_in_ctor_decl[_icc] == 1 & _in_parameter_list[_icc] == 1)
				_last_ctor[_icc]->set_argument_name(id);
			else if(_in_field_decl[_icc] == 1 && _in_parameter_list[_icc] == 1)
				_last_field[_icc]->set_argument_name(id);
			else if(_in_field_decl[_icc] == 1 && _in_parameter_list[_icc] == 0)
			{
				int overload_feature=0;
				int index= _number_of_field[_icc]-1 ;
				// I start at the end, because usually when there is an overloading
				// the features are close.

				while ( ( index > 0 ) && !(overload_feature) )
				{
					index-- ;
					if (( (_field_list_class[_icc])[index])->QueryName(id) == 1 ) 
					{ overload_feature=1; }
					//return TRUE if the field is named "id"
				}

				_last_field[_icc]->set_name(id);

				if (overload_feature == 1)
				{
					_last_field[_icc]->set_comment_action(COMMENT_CLASH);
				}
			}

			CPPParser::declaratorID(id);
		}
	virtual void declaratorParameterList(int def)
		{
			if(_in_field_decl[_icc] == 1)
				_empty_signature[_icc] = 1;

			_in_parameter_list[_icc] = 1;

			CPPParser::declaratorParameterList(def);
		}
	virtual void declaratorEndParameterList(int def)
		{
			if(_in_field_decl[_icc] == 1 && _empty_signature[_icc] == 1)
			{
				_last_field[_icc]->set_function_type();
				_empty_signature[_icc] = 0;
			}

			_in_parameter_list[_icc] = 0;

			CPPParser::declaratorEndParameterList(def);
		}
	virtual void functionParameterList()
		{

			if(_in_field_decl[_icc] == 1)
				_empty_signature[_icc] = 1;

			_in_parameter_list[_icc] = 1;

			CPPParser::functionParameterList();
		}
	virtual void functionEndParameterList()
		{
			if(_in_field_decl[_icc] == 1 && _empty_signature[_icc] == 1)
			{
				_last_field[_icc]->set_function_type();
				_empty_signature[_icc] = 0;
			}

			//_empty_signature[_icc] = 0;//###
			_in_parameter_list[_icc] = 0;

			CPPParser::functionEndParameterList();
		}
	virtual void beginClassDefinition(TypeSpecifier ts, char *tag)
		{

			_icc += 1;						   //***###


			_field_list_class[_icc] = new Field*[NB_MAX];
			_ctor_list_class[_icc] = new Constructor*[NB_MAX];
			_parents_class[_icc] = new char*[NB_MAX];
			_parent_access[_icc] = new int[NB_MAX];

			_cpp_class_name[_icc] = new char[strlen(tag)+1];
			_cpp_class_name[_icc] = strdup(tag);

			_eiffel_class_name[_icc] = new char[strlen(tag)+1];
			_eiffel_class_name[_icc] = strdup(tag);
			
			_eiffel_class_name[_icc] = _strtou(_eiffel_class_name[_icc]);
			_eiffel_file_name[_icc] = new char[strlen(tag) + 3];
			_eiffel_file_name[_icc] = strcpy(_eiffel_file_name[_icc], tag);
			_eiffel_file_name[_icc] = strcat(_eiffel_file_name[_icc], ".e");
			_eiffel_file_name[_icc] = _strtol(_eiffel_file_name[_icc]);


			fprintf(stderr,"\nSampling information about %s.\n",_cpp_class_name[_icc]);			

			CPPParser::beginClassDefinition(ts,tag);
		}

	virtual void endClassDefinition(TypeSpecifier ts)
		{
			_in_field_decl[_icc] = 0;

			CPPParser::endClassDefinition(ts);

			if( (_cpp_class_name[_icc]) && !( _icc <1) )
			{
				int index;

				if (ts==tsCLASS) {_print_eiffel_code();}
				if (ts==tsSTRUCT) {_print_eiffel_code();}

				free(_cpp_class_name[_icc]); // Allocated by 'strdup'... //***
				free(_eiffel_class_name[_icc]);	// Allocated by 'strdup'...//***
				delete [] _eiffel_file_name[_icc];	// Allocated by 'new'...
				
				for(index = 0; index < _number_of_ctor[_icc]; index += 1)
					delete (_ctor_list_class[_icc])[index];
					;


				for(index = 0; index < _number_of_field[_icc]; index += 1)
					delete (_field_list_class[_icc])[index];
					;

				for(index = 0; index < _number_of_parent[_icc]; index += 1)
					delete (_parents_class[_icc])[index];
					;

				for(index = 0; index < _number_of_templ[_icc]; index += 1)
					delete (_templ_class[_icc])[index];
					;


				 
				 delete [] _ctor_list_class[_icc];
				 delete [] _field_list_class[_icc];
				 delete [] _parents_class[_icc];
				 delete [] _templ_class[_icc];
				 //delete [] _parent_access[_icc];

				char* tag=new char[strlen("LEVEL_EMPTY")+1];
				strcpy(tag,"LEVEL_EMPTY");

				strcpy(_cpp_class_name[_icc],tag);
				strcpy(_eiffel_class_name[_icc],tag);
				strcpy(_eiffel_file_name[_icc],tag);

				//delete _ctor_list_class[_icc];// = new Constructor*[NB_MAX];
				_last_ctor[_icc] = NULL; //###

				//delete _field_list_class[_icc];// = new Field*[NB_MAX];
				_last_field[_icc] = NULL; //###

				//delete _parents_class[_icc]; // = new ptrChar[NB_MAX];
				//_parent_access[_icc] = new int[NB_MAX];
				_number_of_parent[_icc] = 0;

				//delete _templ_class[_icc]; // = new char*[NB_MAX];
				_number_of_templ[_icc] = 0;

				_access[_icc] = PRIVATE_ACCESS;
				_ctor_array_length = ARRAY_LENGTH;

				_number_of_ctor[_icc] = 0;
				_number_of_field[_icc] = 0;

				_in_ctor_decl[_icc] = 0;
				_in_parameter_list[_icc] = 0;
				_in_field_decl[_icc] = 0; 
				_empty_signature[_icc] = 0; //###

				_icc -= 1;
		
			}

		}

	
	void PublicAccess()
		{
			_in_ctor_decl[_icc] = 0;
			_in_field_decl[_icc] = 0;
			_in_parameter_list[_icc] = 0;
			_empty_signature[_icc] = 0;

			_access[_icc] = PUBLIC_ACCESS;
			CPPParser::PublicAccess();
		}
	void ProtectedAccess()
		{
			_in_ctor_decl[_icc] = 0;
			_in_field_decl[_icc] = 0;
			_in_parameter_list[_icc] = 0;
			_empty_signature[_icc] = 0;

			_access[_icc] = PROTECTED_ACCESS;
			CPPParser::ProtectedAccess();
		}
	void PrivateAccess()
		{
			_in_ctor_decl[_icc] = 0;
			_in_field_decl[_icc] = 0;
			_in_parameter_list[_icc] = 0;
			_empty_signature[_icc] = 0;

			_access[_icc] = PRIVATE_ACCESS;
			CPPParser::PrivateAccess();
		}
	void tracein(char *r)
		{
			CPPParser::tracein(r); //###T
		}

	void traceout(char *r)
		{
			CPPParser::traceout(r);	//###T
		}

};


void print_help()
{

	fprintf(stderr, "\n%s:  Invalid option or no file specified.\n", prog_name);
	fprintf(stderr, "Usage: %s [-g] [-NE] [-p \"command-line parameters\"] [-c <compiler>] <file>\n", prog_name);
	fprintf(stderr,"\tWhere -g means that the source is meant for GNU C++\n");
	fprintf(stderr,"\tWhere -NE means that the input file <file> should\n");
	fprintf(stderr,"\t\tnot be run through the compilers preprocessor\n");
	fprintf(stderr,"\tWhere -p \"command-line parameters\" means the parameter for the C compiler\n");
	fprintf(stderr,"\tWhere -c <compiler> means the compiler to be used as preprocessor.\n");
  	fprintf(stderr,"\tDefault compiler: g++\n");

	exit(EXIT_FAILURE);
}

void execute_arguments()
{
	char *command;

	if(prepro == 0 && preprodir)
	{
		fprintf(stderr,"Ambigious options: -NE and -f\n");
		exit(EXIT_FAILURE);
	}

	if(gnu_code == 1)
	{
		command = new char[256];
		command[0] = '\0';

		command = strcat(command, "echo \"typedef int __wchar_t;\" > dummy1.cpp");
		system(command);
		// delete command;
		command = new char[256];
		command[0] = '\0';

#ifdef W32MSC
		command = strcat(command, "type ");
#else
		command = strcat(command, "cat ");
#endif
		command = strcat(command, usr_file_name);
		command = strcat(command, " >> dummy1.cpp");
		system(command);
		// delete command;

		// delete file_name;
		file_name = strdup("dummy1.cpp");
	}
	else
		file_name = strdup(usr_file_name);
	printf("\n[*] Preprocessing of the file [%s] ...\n", file_name);

	if(prepro == 1)
	{
		
		command = new char[256];
		command[0] = '\0';

#ifdef W32MSC
		command = strcat(command, "echo /* OUTPUT OF PREPROCESSING */ > dummy2.cpp");
#else
		command = strcat(command, "echo \"/* OUTPUT OF PREPROCESSING */\" > dummy2.cpp");
#endif

		system(command);

		command = new char[256];
		command[0] = '\0';

		FILE *DEF_FILE =fopen("legacy.def","r");
		if (DEF_FILE)
		{ 
		fprintf(stderr,"including the file : legacy.def \n");
		fclose(DEF_FILE);
		command = strcat(command, "echo #include \"legacy.def\" >> dummy2.cpp");
		system(command);
		command = new char[256];
		command[0] = '\0';
		}

		command = new char[256];
		command[0] = '\0';
#ifdef W32MSC
		command = strcat(command, "echo #define __cdecl >> dummy2.cpp");
		system(command);
		// delete command;
		command = new char[256];
		command[0] = '\0';
#endif // W32MSC

#ifdef W32MSC
		command = strcat(command, "type ");
#else
		command = strcat(command, "cat ");
#endif // W32MSC

		command = strcat(command, file_name);
		command = strcat(command, " >> dummy2.cpp");
		system(command);
		// delete command;
		command = new char[256];
		command[0] = '\0';

		// delete file_name;
		file_name = strdup("dummy2.cpp");

#ifdef W32MSC
		command = strcat(command, "cl");
		command = strcat(command, " -nologo -EP ");
#else
		command = strcat(command, compiler);
		command = strcat(command, " -E -P ");
#endif // W32MSC

		if(preprodir)
		{
			command = strcat(command, preprodir);
			command = strcat(command, " ");
		}
		command = strcat(command, file_name);
		command = strcat(command, " > dummy3.cpp");

		// delete command;
		// delete file_name;
		file_name = strdup("dummy3.cpp");

		if(system(command) != 0)
			exit(EXIT_FAILURE);
	}
}

void check_arguments(int argc, char *argv[])
{
	gnu_code = 0;
	prepro = 1;
	preprodir = NULL;
	compiler = "g++";


	prog_name = strdup(argv[0]);

	if(argc == 1)
	{
		print_help();
	}
	else
	{
		if(argv[1][0] != '-' && argc > 2)
		{
			print_help();
		}
		else
		{
			if(argv[1][0] != '-' && argc == 2)
			{
				usr_file_name = strdup(argv[1]);
				file_name = strdup(argv[1]); /*#*/
				execute_arguments();
				return;
			}
			else
			{
				if(argv[1][0] == '-' && argc > 8)
				{
					print_help();
				}
				else
				{
					if(argv[1][0] == '-' && argv[1][1] == 'g')
					{
						gnu_code = 1;
						if(argv[2][0] == '-' && argv[2][1] == 'N' && argv[2][2] == 'E')
						{
							prepro = 0;
							if(argv[3][0] == '-' && argv[3][1] == 'p')
							{
								if(argc < 6) print_help();
								preprodir = strdup(argv[4]);
								if(argv[5][0] == '-' && argv[5][1] == 'c')
								{
									if(argc < 8) print_help();
									compiler = strdup(argv[6]);
									usr_file_name = strdup(argv[7]);
									file_name = strdup(argv[7]); /*#*/
									execute_arguments();
									return;
								}
								else
								{
									if(argv[5][0] == '-')
										print_help();
									else
									{
										usr_file_name = strdup(argv[5]);
										file_name = strdup(argv[5]);/*#*/
										execute_arguments(); 
										return;
									}
								}
							}
							else
							{
								if(argv[3][0] == '-' && argv[3][1] == 'c')
								{
									if(argc < 6) print_help();
									compiler = strdup(argv[4]);
									usr_file_name = strdup(argv[5]);
									file_name = strdup(argv[5]);/*#*/
									execute_arguments();
									return;
								}
								else
								{
									if(argv[3][0] == '-')
										print_help();
									else
									{
										usr_file_name = strdup(argv[3]);
										file_name = strdup(argv[3]);/*#*/
										execute_arguments();
										return;
									}
								}
							}
						}
						else
						{
							if(argv[2][0] == '-' && argv[2][1] == 'p')
							{
								if(argc < 5) print_help();
								preprodir = strdup(argv[3]);
								if(argv[4][0] == '-' && argv[4][1] == 'c')
								{
									if(argc < 7) print_help();
									compiler = strdup(argv[5]);
									usr_file_name = strdup(argv[6]);
									file_name = strdup(argv[6]);/*#*/
									execute_arguments();
									return;
								}
								else
								{
									if(argv[4][0] == '-')
										print_help();
									else
									{
										usr_file_name = strdup(argv[4]);
										file_name = strdup(argv[4]);/*#*/
										execute_arguments();
										return;
									}
								}
							}
							else
							{
								if(argv[2][0] == '-' && argv[2][1] == 'c')
								{
									if(argc < 5) print_help();
									compiler = strdup(argv[3]);
									usr_file_name = strdup(argv[4]);
									file_name = strdup(argv[4]);/*#*/
									execute_arguments();
									return;
								}
								else
								{
									usr_file_name = strdup(argv[2]);/*#*/
									execute_arguments();
									return;
								}
							}
						}
					}
					else
					{
						if(argv[1][0] == '-' && argv[1][1] == 'N' && argv[1][2] == 'E' && argv[1][3] == '\0')
						{
							prepro = 0;
							if(argv[2][0] == '-' && argv[2][1] == 'p')
							{
								if(argc < 5) print_help();
								preprodir = strdup(argv[3]);
								if(argv[4][0] == '-' && argv[4][1] == 'c')
								{
									if(argc < 7) print_help();
									compiler = strdup(argv[5]);
									usr_file_name = strdup(argv[6]);
									file_name = strdup(argv[6]);/*#*/
									execute_arguments();
									return;
								}
								else
								{
									if(argv[4][0] == '-')
										print_help();
									else
									{
										usr_file_name = strdup(argv[4]);
										file_name = strdup(argv[4]); /*#*/
										execute_arguments();
										return;
									}
								}
							}
							else
							{
								if(argv[2][0] == '-' && argv[2][1] == 'c')
								{
									if(argc < 5) print_help();
									compiler = strdup(argv[3]);
									usr_file_name = strdup(argv[4]);
									file_name = strdup(argv[4]);/*#*/
									execute_arguments();
									return;
								}
								else
								{
									if(argv[2][0] == '-')
										print_help();
									else
									{
										usr_file_name = strdup(argv[2]);
										file_name = strdup(argv[2]); /*#*/
										execute_arguments();
										return;
									}
								}
							}
						}
						else
						{
							if(argv[1][0] == '-' && argv[1][1] == 'p')
							{
								if(argc < 4) print_help();
								preprodir = strdup(argv[2]);
								if(argv[3][0] == '-' && argv[3][1] == 'c')
								{
									if(argc < 6) print_help();
									compiler = strdup(argv[4]);
									usr_file_name = strdup(argv[5]);
									file_name = strdup(argv[5]);/*#*/
									execute_arguments();
									return;
								}
								else
								{
									if(argv[3][0] == '-')
										print_help();
									else
									{
										usr_file_name = strdup(argv[3]);
										file_name = strdup(argv[3]); /*#*/
										execute_arguments();
										return;
									}
								}
							}
							else
							{
								if(argv[1][0] == '-' && argv[1][1] == 'c')
								{
									if(argc < 4) print_help();
									compiler = strdup(argv[2]);
									usr_file_name = strdup(argv[3]);
									file_name = strdup(argv[3]);/*#*/
									execute_arguments();
									return;
								}
								else
								{
									if(argv[1][0] == '-')
										print_help();
									else
									{
										usr_file_name = strdup(argv[1]);
										file_name = strdup(argv[1]); /*#*/
										execute_arguments();
										return;
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

void open_file()
{
	input_file = fopen(file_name, "r");
	if(!input_file)
	{
		fprintf(stderr, "\nCannot open file <%s>!\n", file_name);
		fprintf(stderr, "Bailing out...\n");
		fprintf(stderr, "(Leaving memory corrupted...)\n");
		exit(EXIT_FAILURE);
	}
}



ParserBlackBox<DLGLexer, MyParser, ANTLRToken> *p;

int main(int argc, char *argv[])
{
	int rep; 

	check_arguments(argc, argv);

	fprintf(stdout,"\n[*] Store the output into the file [legacy.log] ? [Y=1/N=0] ? :");	
	scanf("%i",&rep); 
	if (rep==1) 
	{ 
		fclose(stderr); 
		fopen( "legacy.log","w+" ); 
		fprintf(stderr,"\n### LOG FILE FOR LEGACY ###\n\n");
	}
	
	open_file();
	{
		p = new ParserBlackBox<DLGLexer, MyParser, ANTLRToken> (input_file);
/*
		if (rep==0) 
		fprintf(stdout,"\n[*] Do you want to see the trace [Y=1/N=0] ? :");	
		else fprintf(stdout,"\n[*] Do you also want to store the trace [Y=1/N=0] ? :");	
		scanf("%i",&rep); 

		if (rep==1) p->parser()->traceOn(); printf("\n"); 
*/
		p->parser()->translation_unit();
	}

	free(prog_name);
	free(file_name);

	clean_up();
	fprintf(stdout,"\nWrapping completed...\n");

	return 1;
}

void clean_up()
{
	int rep;

	fclose(input_file);
	fprintf(stdout,"\n[*] Do you want to keep the dummy files ? (Y=1|N=0) :");
	scanf("%i1",&rep); 
	printf("\n"); 
	if (rep == 0)
	{
	fprintf(stdout,"Deleting dummy files...\n");


#ifdef W32MSC
	if (gnu_code==1) system("del dummy1.cpp");
	system("del dummy2.cpp");
	system("del dummy3.cpp");
#else
	if (gnu_code==1) system("rm -f dummy1.cpp");
	system("rm -f dummy2.cpp");
	system("rm -f dummy3.cpp");
#endif // W32MSC
	}
}

