indexing
	description: "[
			Main window of EiffelVision2 rich text example.
			Originally generated by EiffelBuild. 
		]"
	date: "$Date$"
	revision: "$Revision$"

class
	MAIN_WINDOW

inherit
	MAIN_WINDOW_IMP


feature {NONE} -- Initialization

	user_initialization is
			-- called by `initialize'.
			-- Any custom user initialization that
			-- could not be performed in `initialize',
			-- (due to regeneration of implementation class)
			-- can be added here.
		local
			environment: EV_ENVIRONMENT
			font_families: LINEAR [STRING]
			list_item: EV_LIST_ITEM
			counter: INTEGER
			font: EV_FONT
		do
				-- Initialize color display to black.
			update_color ((create {EV_STOCK_COLORS}).black)

			format_toolbar.disable_vertical_button_style
			
			tab_width_entry.set_value (rich_text.tab_width)
			
				-- Connect events.
			rich_text.caret_move_actions.extend (agent caret_moved)
			rich_text.selection_change_actions.extend (agent selection_changed)
			close_request_actions.extend (agent exit)
			
					-- Now load all available fonts into `font_selection' combo box.
			create environment
			font_families := environment.font_families
			from
				font_families.start
			until
				font_families.off
			loop
				create list_item.make_with_text (font_families.item)
				font_selection.extend (list_item)
				font_families.forth
			end
			
				-- Apply a default font to `rich_edit'.
			create font
			font_families.start
			font.preferred_families.extend (font_families.item)
			font.set_height (12)
			rich_text.set_font (font)
			
			
				-- Add permitted font heights to `size_selection' combo box.
			from
				counter := 6
			until
				counter > 150
			loop
				create list_item.make_with_text (counter.out)
				list_item.set_data (counter)
				size_selection.extend (list_item)
				counter := counter + 2 + (counter // 10)
			end
			
			create accelerator.make_with_key_combination (create {EV_KEY}.make_with_code ((create {EV_KEY_CONSTANTS}).key_s), False, True, False)
			accelerators.extend (accelerator)
			accelerator.actions.extend (agent check_line_positions)
			create accelerator.make_with_key_combination (create {EV_KEY}.make_with_code ((create {EV_KEY_CONSTANTS}).key_d), False, True, False)
			accelerators.extend (accelerator)
			accelerator.actions.extend (agent random_test)
			create timer.make_with_interval (2000)
			timer.actions.extend (agent check_line_positions)
			
		end
		
feature {NONE} -- Event handling

	bold_selected is
			-- `bold_button' has been selected.
		local
			format: EV_CHARACTER_FORMAT
			font: EV_FONT
			char_info: EV_CHARACTER_FORMAT_RANGE_INFORMATION
		do
			if rich_text.has_selection then
				format := rich_text.character_format (rich_text.selection_start)
				font := format.font
				if bold_button.is_selected then
					font.set_weight ((create {EV_FONT_CONSTANTS}).weight_bold)
				else
					font.set_weight ((create {EV_FONT_CONSTANTS}).weight_regular)
				end	
				format.set_font (font)
				create char_info.make_with_values (False, True, False, False, False, False, False)
				rich_text.modify_region (rich_text.selection_start, rich_text.selection_end + 1, format, char_info)
			else
				format := rich_text.character_format (rich_text.caret_position)
				font := format.font
				if font.weight.is_equal (feature {EV_FONT_CONSTANTS}.weight_bold) then
					font.set_weight (feature {EV_FONT_CONSTANTS}.weight_regular)
				else	
					font.set_weight (feature {EV_FONT_CONSTANTS}.weight_bold)
				end
				format.set_font (font)
				rich_text.set_current_format (format)
			end
		end
		
	font_selected is
			-- A font has been selected from `font_selection' combo box.
		local
			format: EV_CHARACTER_FORMAT
			font: EV_FONT
			char_info: EV_CHARACTER_FORMAT_RANGE_INFORMATION
		do
			if rich_text.has_selection then
				format := rich_text.character_format (rich_text.selection_start)
				font := format.font
				font.preferred_families.wipe_out
				font.preferred_families.extend (font_selection.selected_item.text)
				format.set_font (font)
				create char_info.make_with_values (True, False, False, False, False, False, False)
				rich_text.modify_region (rich_text.selection_start, rich_text.selection_end + 1, format, char_info)
			else
				format := rich_text.character_format (rich_text.caret_position)
				font := format.font
				font.preferred_families.wipe_out
				font.preferred_families.extend (font_selection.selected_item.text)
				format.set_font (font)
				if rich_text.is_displayed then
					rich_text.set_focus
					rich_text.set_current_format (format)
				end
			end
		end
		
	font_size_selected is
			-- A font has been selected from `size_selection' combo box.
		local
			format: EV_CHARACTER_FORMAT
			size: INTEGER
			font: EV_FONT
			char_info: EV_CHARACTER_FORMAT_RANGE_INFORMATION
		do
			if rich_text.has_selection then
				format := rich_text.character_format (rich_text.selection_start)
				if size_selection.text.is_integer then
					size := size_selection.text.to_integer
					if size >= 1 and size <= 200 then
						font := format.font
						font.set_height (size)
						format.set_font (font)
						create char_info.make_with_values (False, False, False, True, False, False, False)
						rich_text.modify_region (rich_text.selection_start, rich_text.selection_end + 1, format, char_info)
					end
				end
			else
				format := rich_text.character_format (rich_text.caret_position)
				if size_selection.text.is_integer then
					size := size_selection.text.to_integer
					if size >= 1 and size <= 200 then
						font :=format.font
						font.set_height (size)
						format.set_font (font)
						if rich_text.is_displayed then
							rich_text.set_focus
							rich_text.set_current_format (format)
						end
					end
				end			
			end
		end
	
	italic_selected is
			-- `italic_button' has been selected.
		local
			format: EV_CHARACTER_FORMAT
			font: EV_FONT
			char_info: EV_CHARACTER_FORMAT_RANGE_INFORMATION
		do
			if rich_text.has_selection then
				format := rich_text.character_format (rich_text.selection_start)
				font := format.font
				if italic_button.is_selected then
					font.set_shape (feature {EV_FONT_CONSTANTS}.shape_italic)
				else	
					font.set_shape (feature {EV_FONT_CONSTANTS}.shape_regular)
				end
				format.set_font (font)
				create char_info.make_with_values (False, False, True, False, False, False, False)
				rich_text.modify_region (rich_text.selection_start, rich_text.selection_end + 1, format, char_info)
			else
				format := rich_text.character_format (rich_text.caret_position)
				font := format.font
				if font.shape.is_equal (feature {EV_FONT_CONSTANTS}.shape_italic) then
					font.set_shape (feature {EV_FONT_CONSTANTS}.shape_regular)
				else	
					font.set_shape (feature {EV_FONT_CONSTANTS}.shape_italic)
				end
				format.set_font (font)
				rich_text.set_current_format (format)
			end
		end
		
		
	color_selected is
			-- `color_button' has been selected.
		local
			color_dialog: EV_COLOR_DIALOG
			format: EV_CHARACTER_FORMAT
			char_info: EV_CHARACTER_FORMAT_RANGE_INFORMATION
		do
			create color_dialog
			color_dialog.show_modal_to_window (Current)
			if color_dialog.color /= Void then
				update_color (color_dialog.color)
			end
			if rich_text.has_selection then
				format := rich_text.character_format (rich_text.selection_start)
				if color_dialog.selected_button.is_equal ("OK") then
					format.set_color (color_dialog.color)
					create char_info.make_with_values (False, False, False, False, True, False, False)
					rich_text.modify_region (rich_text.selection_start, rich_text.selection_end + 1, format, char_info)
				end
			else
				format := rich_text.character_format (rich_text.caret_position)
				if color_dialog.selected_button.is_equal ("OK") then
					format.set_color (color_dialog.color)
					rich_text.set_current_format (format)
				end
			end
		end
		
	underline_selected is
			-- Called by `select_actions' of `underlined_button'.
		local
			format: EV_CHARACTER_FORMAT
			char_info: EV_CHARACTER_FORMAT_RANGE_INFORMATION
			underlined: BOOLEAN
			effects: EV_CHARACTER_FORMAT_EFFECTS
		do
			if rich_text.has_selection then
				format := rich_text.character_format (rich_text.selection_start)
				effects := format.effects
				underlined := effects.is_underlined
				if underlined_button.is_selected then
					effects.enable_underlined
				else	
					effects.disable_underlined
				end
				format.set_effects (effects)
				create char_info.make_with_values (False, False, False, False, False, False, True)
				rich_text.modify_region (rich_text.selection_start, rich_text.selection_end + 1, format, char_info)
			else
				format := rich_text.character_format (rich_text.caret_position)
				effects := format.effects
				if underlined_button.is_selected then
					effects.enable_underlined
				else
					effects.disable_underlined
				end
				format.set_effects (effects)
				rich_text.set_current_format (format)
			end
		end
	
	strike_through_selected is
			-- Called by `select_actions' of `striked_through_button'.
		local
			format: EV_CHARACTER_FORMAT
			char_info: EV_CHARACTER_FORMAT_RANGE_INFORMATION
			strike_through: BOOLEAN
			effects: EV_CHARACTER_FORMAT_EFFECTS
		do
			if rich_text.has_selection then
				format := rich_text.character_format (rich_text.selection_start)
				effects := format.effects
				strike_through := effects.is_striked_out
				if striked_through_button.is_selected then
					effects.enable_striked_out
				else	
					effects.disable_striked_out
				end
				format.set_effects (effects)
				create char_info.make_with_values (False, False, False, False, False, True, False)
				rich_text.modify_region (rich_text.selection_start, rich_text.selection_end + 1, format, char_info)
			else
				format := rich_text.character_format (rich_text.caret_position)
				effects := format.effects
				if striked_through_button.is_selected then
					effects.enable_striked_out
				else
					effects.disable_striked_out
				end
				format.set_effects (effects)
				rich_text.set_current_format (format)
			end
		end
		
	word_wrapping_toggled is
			-- Called by `select_actions' of `word_wrapping_menu_item'.
		do
			lock_update
			if word_wrapping_menu_item.is_selected then
				rich_text.enable_word_wrapping
			else
				rich_text.disable_word_wrapping
			end
			unlock_update
		end

feature {NONE} -- Implementation

		caret_moved (new_position: INTEGER) is
				-- Caret of `rich_text' has moved to position `new_position'.
			local
				current_line_number: INTEGER
				format: EV_CHARACTER_FORMAT
				x, y: INTEGER
			do
				current_line_number := rich_text.current_line_number
				y := current_line_number
				x := rich_text.first_position_from_line_number (y)
				x := new_position - x + 1
					
					-- Display caret position in status bar.
				caret_position_label.set_text (x.out + " " + y.out)
				
					-- Update display corresponding to character formatting at
					-- new caret position.
				format := rich_text.character_format (new_position)
				display_format (format)
			end
			
		display_format (format: EV_CHARACTER_FORMAT) is
				-- Udpate formatting toolbars to reflect formatting in `format'.
			local
				font: EV_FONT
				name_matched: BOOLEAN
			do
				font := format.font
				
					-- Updated Displayed font weight
				bold_button.select_actions.block
				if font.weight = feature {EV_FONT_CONSTANTS}.weight_bold then					
					bold_button.enable_select
				else
					bold_button.disable_select
				end
				bold_button.select_actions.resume
				
					-- Update displayed font shape.
				italic_button.select_actions.block
				if font.shape = feature {EV_FONT_CONSTANTS}.shape_italic then					
					italic_button.enable_select
				else
					italic_button.disable_select
				end
				italic_button.select_actions.resume
				
					-- Udpate displayed font size.
				size_selection.set_text (font.height.out)
				
					-- Update displayed font name.
				from
					font_selection.start
				until
					font_selection.off or name_matched
				loop
					if font_selection.item.text.is_equal (font.name) then
						font_selection.item.enable_select
						name_matched := True
					end
					font_selection.forth
				end
				
					-- Updated displayed font color.
				if not last_displayed_color.is_equal (format.color) then
					update_color (format.color)
				end
			end
			
			
		selection_changed is
				-- The selection in `rich_text' has changed, so update
				-- formatting displayed in toolbar.
			local
				format: EV_CHARACTER_FORMAT
				formatting: EV_CHARACTER_FORMAT_RANGE_INFORMATION
				current_value: STRING
			do
				if rich_text.has_selection then
					
						-- Retrieve the format at the end of the selection.
					format := rich_text.character_format (rich_text.selection_end)
					
						-- Retrieve information regarding the consistency of formatting within selected range.
					formatting := rich_text.formatting_range_information (rich_text.selection_start, rich_text.selection_end + 1)

					if formatting.font_height then
							-- Font height is consistent throughout complete selection so display this size.
						current_value := format.font.height.out
						if not size_selection.text.is_equal (current_value) then
							from
								size_selection.start
							until
								size_selection.off or current_value = Void
							loop
								if size_selection.item.text.is_equal (current_value) then
									size_selection.select_actions.block
									size_selection.item.enable_select
									size_selection.select_actions.resume
									current_value := Void
								end
								size_selection.forth
							end
							if current_value /= Void then
								size_selection.set_text (current_value)
							end
						end
					else
							-- Font height is not consistent throughout complete selection so hide the size.
						size_selection.remove_text
						size_selection.remove_selection
					end
					
					if formatting.font_family then
							-- Font family is consistent throughout compelte selection so display the family.
						current_value := format.font.name.out
						if not font_selection.text.is_equal (current_value) then
							from
								font_selection.start
							until
								font_selection.off or current_value = Void
							loop
								if font_selection.item.text.is_equal (current_value) then
									font_selection.select_actions.block
									font_selection.item.enable_select
									font_selection.select_actions.resume
									current_value := Void
								end
								font_selection.forth
							end
						end
					else
							-- Font family is not consistent throughout complete selection so hide family.
						font_selection.remove_text
						font_Selection.remove_selection
					end

					if formatting.color then
							-- Color is consistent throughout selection so update color display if not
							-- already equivalent to the color.
						if not format.color.is_equal (last_displayed_color) or color_undefined then
							update_color (format.color)
						end
					elseif not color_undefined then
							-- Color is not consistent throughout complete selection so display color as 
						update_color_as_undefined
					end
					
						-- Update bold display so that it is only displayed as bold if the formatting is
						-- consistently bold.
					bold_button.select_actions.block
					if formatting.font_weight and format.font.weight = (create {EV_FONT_CONSTANTS}).weight_bold then
						bold_button.select_actions.resume
					else
						bold_button.select_actions.block
					end
					bold_button.select_actions.resume
					
						-- Update italic display so that it is only displayed as italic if the formatting is
						-- consistently italic.
					italic_button.select_actions.block
					if formatting.font_shape and format.font.shape = (create {EV_FONT_CONSTANTS}).shape_italic then
						italic_button.enable_select
					else
						italic_button.disable_select						
					end
					italic_button.select_actions.resume
				else
						-- `selection_changed_actions' is fired once when the selection is removed,
						-- so in this case, we treat the update identically to when the caret has moved
						-- by calling `display_format'.
					format := rich_text.character_format (rich_text.caret_position)
					display_format (format)
				end
			end
		
	update_color (a_color: EV_COLOR) is
			-- Update color displayed in color tool bar button based on `a_color'.
		require
			color_not_void: a_color /= Void
		local
			pixmap: EV_PIXMAP
			text_size: TUPLE [INTEGER, INTEGER]
			text_width, text_height: INTEGER
		do
			create pixmap
			text_size := pixmap.font.string_size ("Color")
			text_width := text_size.integer_32_item (1)
			text_height := text_size.integer_32_item (2)
			pixmap.set_size (text_width + text_height + 2, 16)
			pixmap.set_background_color (format_toolbar.background_color)
			pixmap.clear
			pixmap.draw_text_top_left (text_height + 2, ((16 - text_height) // 2), "Color")
			pixmap.set_foreground_color (a_color)
			pixmap.fill_rectangle (1, 1 + ((16 - text_height) // 2), text_height - 2, text_height - 2)
			color_button.set_pixmap (pixmap)
			last_displayed_color := a_color
			color_undefined := False
		end
		
	update_color_as_undefined is
			-- Update color to display in color tool bar button as undefined
		local
			pixmap: EV_PIXMAP
			text_size: TUPLE [INTEGER, INTEGER]
			text_width, text_height: INTEGER
		do
			create pixmap
			text_size := pixmap.font.string_size ("Color")
			text_width := text_size.integer_32_item (1)
			text_height := text_size.integer_32_item (2)
			pixmap.set_size (text_width + text_height + 2, 16)
			pixmap.set_background_color (format_toolbar.background_color)
			pixmap.clear
			pixmap.draw_text_top_left (text_height + 2, ((16 - text_height) // 2), "Color")
			pixmap.set_foreground_color ((create {EV_STOCK_COLORS}).black)
			pixmap.draw_rectangle (1, 1 + ((16 - text_height) // 2), text_height - 2, text_height - 2)
			color_button.set_pixmap (pixmap)
			color_undefined := True
		end
		
	tab_width_changed (a_value: INTEGER) is
			-- Called by `change_actions' of `l_ev_spin_button_1'.
		do
			rich_text.set_tab_width (a_value)
		end
		
feature {NONE} -- Implementation

	exit is
			-- Exit the application
		do
			((create {EV_ENVIRONMENT}).application).destroy
		end

	last_displayed_color: EV_COLOR
			-- Last color displayed, stored to prevent unecessary updating of displayed color.
			
	color_undefined: BOOLEAN
			-- Is the color currently displayed undefined?
			
feature {NONE} -- To be removed

	--| FIXME all of the routines in this feature clause are only for
	--| testing purposes, and should be removed.

	check_line_positions is
			-- Check that querying all lines of text in `Current' appended together are equivalent to
			-- `text'.
		local
			counter: INTEGER
			current_line: STRING
			start_index, end_index: INTEGER
			a_text: STRING
			substring: STRING
			color: EV_COLOR
		do
			print ("Lines : " + rich_text.line_count.out + "%N")
			if rich_text.text.item (rich_text.text_length) = '%N' then
				print ("Last letter is newline%N")
			end
			a_text := rich_text.text
			from
				counter := 1
			until
				counter > rich_text.line_count
			loop
				current_line := rich_text.line (counter)
				start_index := rich_text.first_position_from_line_number (counter)
				end_index := rich_text.last_position_from_line_number (counter)
				substring := a_text.substring (start_index, end_index)
				if not substring.is_equal (current_line) then
					check
						False
					end
						-- A check for anybody that has checking turned off.
					print (color.red.out)
				end
				counter := counter + 1
			end
		end
		
	timer: EV_TIMEOUT

	random_test is
			-- A feature connected to an accelerator for testing purposes.
		local
			char: EV_CHARACTER_FORMAT
		do
			--| FIXME remove this.
			rich_text.select_region (5, 8)
			char := rich_text.character_format (1)
		end
		
	accelerator: EV_ACCELERATOR

end -- class MAIN_WINDOW

