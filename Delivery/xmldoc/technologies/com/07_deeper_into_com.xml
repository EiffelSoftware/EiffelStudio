<document title="Deeper into COM" output="studio">
	<meta_data/>
	<paragraph>
		<paragraph>The next paragraph gives some details on the COM internals. The understanding of these details are not required to use the EiffelCOM wizard but might help making better decisions when designing new EiffelCOM components. </paragraph>
		<heading>
			<size>2</size>Apartments
		</heading>The first interesting subject that requires more in-depth cover is the execution context of a component. Components can be run in the same process as the client but can also run in a separate process even on a different machine.
		<paragraph>This superficial description only take into accounts processes. What happens if a component uses multithreading to achieve it tasks? In a case of a remote server, this scenario does not seem too esoteric. The problem is that a server does not (and should not) know in advance what its clients will be. It cannot assume that the client will be able to take advantage of its multithreading capabilities. Conversely a multithreaded client should not rely on the server ability to handle concurrent access. </paragraph>
		<paragraph>The solution chosen in the COM specification is to define an additional execution context called an apartment. When COM loads a component it creates the apartment in which the component will run. Multiple instances of a multithreaded component will leave together in the same apartment since asynchronous calls will be handled correctly and there is no need to add any synchronization layer. On the other hand, single threaded component will be alone in their apartment and any concurrent calls coming from clients will be first synchronized before entering the apartment. These two behaviors define two different kinds of apartments: Multi Threaded Apartments (MTA) and Single Threaded Apartments (STA). </paragraph>
		<div>
			<image>
				<legend>Apartments</legend>
				<height>190</height>
				<width>512</width>
				<url>images/com-2.gif</url>
			</image>
		</div>Apartments solve the problem of concurrency by removing the necessity of knowing the multithreaded capability of a component and its clients. Multithreaded clients can always make asynchronous calls and depending on whether the component handles concurrent access or not, they will be forwarded or first synchronized. There can be multiple instances of STA running in one process while there will be at most one MTA.
		<heading>
			<size>2</size>Marshaling
		</heading>At this point you might wonder how calls can "cross" the apartments boundaries. Components from a STA can make calls to components running in a MTA and vice versa. These apartments might be running in different processes or even on different machines. The approach chose in the COM specification is using the proxy and stub patterns.
		<paragraph>The idea is to trick the client of an interface by providing an interface proxy in its apartment. The proxy include exactly the same function as the interface itself but their implementation will just forward the call to the actual interface. The client has no idea whether the entity it is dealing with is the actual interface or just a proxy. One of the main interest of that approach is that the client implementation is independent from the location of the component. </paragraph>
		<paragraph>Last explanation is not totally accurate: the call will not be forwarded to the actual interface but to its stub. The stub is the counterpart of the proxy, it represents the client for the interface. The interface doesn't know either whether it is communicating with the actual client or a stub. Although it is not totally true that the component implementation is independent from the location of the client, the stub pattern still helps keeping code identical for the implementation of the interface themselves. The implementation of a component will still be different whether it is an in-process or out-of-process component since it will have to be a DLL in one case and a executable in the other. The design of the interfaces might also differ since out-of-process servers will tend to avoid too many round trips. </paragraph>
		<div>
			<image>
				<legend>Cross Apartment Calls</legend>
				<height>153</height>
				<width>475</width>
				<url>images/com-3.gif</url>
			</image>
		</div>There is one proxy/stub pair per interface. The proxy or the stub is loaded dynamically only when needed. This proxy/stub pair constitute the marshaller. The reason for having a single name for two different things come from how MIDL generates its code. MIDL will produce files for one DLL in which both the proxy and the stub will be included. This DLL is the marshaller.
		<div>
			<heading>
				<size>2</size>Summary
			</heading>This brief introduction to the Component Object Model should be enough to get started with the EiffelCOM wizard. It specifies the main characteristics that define the type of a component and that need to be given to the wizard along with the definition file.
		</div>
		<seealso>
			<bold>See Also</bold>
			<line_break/>
			<link>
				<url>../../tools/wizards/com/index.xml</url>
				<label>EiffelCOM wizard</label>
			</link>
			<line_break/>
			<link>
				<url>../../libraries/com/index.xml</url>
				<label> EiffelCOM library</label>
			</link>
			<line_break/>
			<link>
				<url>02_generalities.xml</url>
				<label> Generalities</label>
			</link>
			<line_break/>
			<link>
				<url>07_deeper_into_com.xml</url>
				<label> Deeper into COM</label>
			</link>
			<line_break/>
			<link>
				<url>03_interfaces.xml</url>
				<label> COM Interfaces</label>
			</link>
			<line_break/>
			<link>
				<url>04_coclass.xml</url>
				<label> Coclasses</label>
			</link>
			<line_break/>
			<link>
				<url>05_component_location.xml</url>
				<label> Component Location</label>
			</link>
			<line_break/>
			<link>
				<url>06_access_type.xml</url>
				<label> Access Type</label>
			</link>
		</seealso>
	</paragraph></document>
