indexing

	description:
			"Run the specified query.";
	default:	"First time: NOTHING; subsequent times: last expression.";
	date:		"$Date$";
	revision:	"$Revision $"

class EWB_RUN_PROF

inherit
	EWB_CMD
		rename
			name as run_cmd_name,
			abbreviation as run_abb,
			help_message as run_prof_help
		redefine
			loop_action
		end;
	SHARED_QUERY_VALUES
			
feature {NONE} -- Execute

	loop_action is
		do
			execute;
		end;

	execute is
			-- don't know exactly how, but that comes.
			-- maybe this is good, maybe not ( ;-) / :-( )
		local
			executer: QUERY_EXECUTER
		do
			fill_arrays;

			if any_active_query then
				print_active_query;
					-- Do the computation.
				!! executer.make (output_window);
				if last_output /= Void then
					executer.set_last_output (last_output);
				end;
				executer.compute_results;
				last_output := executer.last_output;
			else
				output_window.put_string ("No active queries");
				output_window.new_line;
				io.putstring ("You should first manipulate the subqueries%N");
			end;
		end;

feature {NONE} -- Attributes

	last_output: PROFILE_INFORMATION;
		-- Last output generated by the run of the query.
		-- Needed for the query-feature last_output.

	any_active_query: BOOLEAN
		-- Are there active queries (is to say: may we execute the query).

feature {NONE} -- Implementation

	fill_arrays is
		local
			empty_array: ARRAY [STRING]
		do
			from
					-- Empty the arrays.
				!! empty_array.make (1,0);
				column_names.copy (empty_array);
				binary_operators.copy (empty_array);
				values.copy (empty_array);
				boolean_operators.copy (empty_array);

					-- Copy active subquery into the arrays.
				subqueries.start
			until
				subqueries.after
			loop
				if subqueries.item.is_active then
					any_active_query := true;
					column_names.force (subqueries.item.column, column_names.count + 1);
					binary_operators.force (subqueries.item.operator, binary_operators.count + 1);
					values.force (subqueries.item.value, values.count + 1);
				end;
				subqueries.forth;
			end;
			if any_active_query then

				if column_names.count > 1 then
						-- If more than one active subquery, we must
						-- copy the subquery_operators as well.
					from
						subquery_operators.start
					until
						subquery_operators.after
					loop
						if subquery_operators.item.is_active then
							boolean_operators.force (subquery_operators.item.actual_operator, boolean_operators.count + 1);
						end;
						subquery_operators.forth;
					end;
				end;
			end;
		end;

	print_active_query is
		do
			from
				output_window.put_string ("Query:%N======%N%N");
				subqueries.start;
				subquery_operators.start;
			until
				subqueries.after
			loop
				if subqueries.item.is_active then
					output_window.put_string (subqueries.item.column);
					output_window.put_char (' ');
					output_window.put_string (subqueries.item.operator);
					output_window.put_char (' ');
					output_window.put_string (subqueries.item.value);
					if not subquery_operators.after then
						if subquery_operators.item.is_active then
							output_window.put_char (' ');
							output_window.put_string (subquery_operators.item.actual_operator);
						end;
					end;
					output_window.put_char ('%N');
				end;
				subqueries.forth;
				if not subquery_operators.after then
					subquery_operators.forth;
				end;
			end;
		end;

end -- class EWB_RUN_PROF
