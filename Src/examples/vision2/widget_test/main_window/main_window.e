indexing
	description: "Objects that represent an EV_TITLED_WINDOW.%
		%The original version of this class was generated by EiffelBuild."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	MAIN_WINDOW

inherit
	MAIN_WINDOW_IMP
	
	WIDGET_TEST_SHARED
		undefine
			copy, default_create, is_equal
		end

feature {NONE} -- Initialization

	user_initialization is
			-- called by `initialize'.
			-- Any custom user initialization that
			-- could not be performed in `initialize',
			-- (due to regeneration of implementation class)
			-- can be added here.
		local
			type_selector: GB_TYPE_SELECTOR
			editor: GB_OBJECT_EDITOR
			controller: TEST_CONTROLLER
			event_selector: EVENT_SELECTOR
			documentation_display: DOCUMENTATION_DISPLAY
		do
				-- The first type change agent that we register locks the update, so
				-- that the user does not see the changes taking place.
			register_type_change_agent (agent lock_current)
			
				-- Create the editor and parent.
			create editor
			object_editor.extend (editor)

				-- Create the type selector and parent.
			create type_selector
			widget_selector_parent.extend (type_selector)
			
				-- Create the test controller.
			create controller.make_with_text_control (test_class_display, generation_button)
			controller_parent.extend (controller)
			
				-- Create the documentation display
			create documentation_display.make_with_text (flat_short_display)
			register_type_change_agent (agent documentation_display.update_for_type_change)

			
			create event_selector.make_with_list_and_handler (event_selector_list, event_handler)
			register_type_change_agent (agent event_selector.rebuild)
			
				-- Register a change agent which parents the new test widget.
			register_type_change_agent (agent parent_test_widget)
			
				-- Register a change agent which removes the start up screen.
			register_type_change_agent (agent remove_first_screen)
			
				-- The last type change agent we register unlocks the current
				-- window, so that we can see any changes to the interface.
			register_type_change_agent (agent unlock_current)
			
				-- Ensure that the three tool bar buttons behave as radio buttons.
			properties_button.select_actions.extend (agent update_tool_bar_radio_buttons (properties_button))			
			tests_button.select_actions.extend (agent update_tool_bar_radio_buttons (tests_button))			
			documentation_button.select_actions.extend (agent update_tool_bar_radio_buttons (documentation_button))
			main_notebook.selection_actions.extend (agent update_buttons)
			
			setup_initial_screen
		end

feature {NONE} -- Implementation

	set_window_title (a_widget: EV_WIDGET) is
			-- Assign a title to `Current', reflecting type
			-- of widget that is currently being tested.
		do
			set_title ("Testing - " + test_widget_type + ".")
		end
		

	parent_test_widget (a_widget: EV_WIDGET) is
			-- Ensure `a_widget' is parented in
			-- `widget_holder'.
		do
			widget_holder.wipe_out
			
				-- We must now rebuild `widget_holder' to ensure
				-- that no minimum size settings still apply. This
				-- will ensure that each test will be at the default size,
				-- even if the last was large.
			vertical_spacing_box.prune (widget_holder)
			create widget_holder
			vertical_spacing_box.go_i_th (2)
			vertical_spacing_box.put_left (widget_holder)
			scrollable_widget_area.set_item_height (310)
			scrollable_widget_area.set_item_width (310)
			
			widget_holder.extend (a_widget)
				-- Now clear recorded events, as a widget has changed.
			clear_events
		end
		
	select_all_events is
			-- Select all events in `event_selector_list'.
		do
			from
				event_selector_list.start
			until
				event_selector_list.off
			loop
				event_selector_list.check_item (event_selector_list.item)
				event_selector_list.forth
			end
		end
		
	clear_all_events is
			-- Clear all events in `event_selector_list'.
		do
			from
				event_selector_list.start
			until
				event_selector_list.off
			loop
				event_selector_list.uncheck_item (event_selector_list.item)
				event_selector_list.forth
			end
		end
		
	clear_events is
			-- Reset `event_selector_list'.
		do
			event_handler.reset	
		end
		
	event_handler: ORDERED_STRING_HANDLER is
			-- Once access to an ORDERED_STRING_HANDLER.
		once
			create Result.make_with_textable (event_output)
		end
		
	setup_initial_screen is
			-- Display initial start up scren which will be displayed until a
			-- widget type is selected.
		local
			label: EV_LABEL
		do
			main_split_area.prune (main_box)
			create label.make_with_text ("Please select a widget to begin exploration")
			main_split_area.extend (label)
			label.set_background_color ((create {EV_STOCK_COLORS}).white)
		end
		
	remove_first_screen (v: EV_WIDGET) is
			-- Remove initial start up screen.
			-- Note that this is called every time the widget type
			-- changes, but will do nothing after the first time.
		do
			if not main_split_area.has (main_box) then
				main_split_area.go_to_second
				main_split_area.replace (main_box)
			end
			
				-- Now enable the tool bar buttons.
			properties_button.enable_sensitive
			properties_button.enable_select
			tests_button.enable_sensitive
			documentation_button.enable_sensitive
				
		ensure
			main_split_area.has (main_box)
		end
		
	lock_current (v: EV_WIDGET) is
			-- Calls `lock_update' but with a signature that allows
			-- it to be registered as a type change agent.
		do
			lock_update
		end
		
	unlock_current (v: EV_WIDGET) is
			-- Calls `unlock_update' but with a signature that allows
			-- it to be registered as a type change agent.
		do
			unlock_update
		end
		
	update_tool_bar_radio_buttons (selected_button: EV_TOOL_BAR_TOGGLE_BUTTON) is
			--
		do
			if selected_button /= properties_button then
				properties_button.select_actions.block
				properties_button.disable_select
				properties_button.select_actions.resume
			else
				main_notebook.select_item (main_notebook_properties_item)
				generate_button.disable_sensitive
			end
			if selected_button /= tests_button then
				tests_button.select_actions.block
				tests_button.disable_select
				tests_button.select_actions.resume
			else
				main_notebook.select_item (main_notebook_tests)
				generate_button.enable_sensitive
			end
			if selected_button /= documentation_button then
				documentation_button.select_actions.block
				documentation_button.disable_select
				documentation_button.select_actions.resume
			else
				main_notebook.select_item (flat_short_display)
				generate_button.disable_sensitive
			end
		end
		
	update_buttons is
		do
			if main_notebook.selected_item = main_notebook_properties_item then
				properties_button.enable_select
			end
			if main_notebook.selected_item = main_notebook_tests then
				tests_button.enable_select
			end
			if main_notebook.selected_item = flat_short_display then
				documentation_button.enable_select
			end
		end

end -- class MAIN_WINDOW

