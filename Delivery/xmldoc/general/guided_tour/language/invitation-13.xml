<document title="12 Combining Genericity and Inheritance">
	<meta_data>
		<help>
			<toc>
				<envision_location>Eiffel, The Language\Tutorials\Invitation to Eiffel</envision_location>
				<envision_pseudo_name>93</envision_pseudo_name>
				<envision_title>Combining Genericity and Inheritance</envision_title>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph>Genericity and inheritance, the two fundamental mechanisms for generalizing classes, may be combined in two fruitful ways.  </paragraph>
		<paragraph>The first technique yields 
			<bold>polymorphic data structures</bold>.  Assume that in the generic class 
			<code>
				<class_name>LIST</class_name> 
				<symbol>[</symbol>
				<generics>G</generics>
				<symbol>]</symbol>
			</code> the insertion procedure 
			<code>
				<feature_name>put</feature_name>
			</code> has a formal argument of type 
			<code>
				<generics>G</generics>
			</code>, representing the element to be inserted.  Then with a declaration such as
		</paragraph>
		<code_block><local_variable>pl</local_variable><symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>POLYGON</class_name><symbol>]</symbol></code_block>
		<paragraph>the type rules imply that in a call 
			<code>
				<local_variable>pl</local_variable>
			</code>.
			<code>
				<feature_name>put</feature_name>
			</code> 
			<code>
				<symbol>(</symbol>
				<string>"p"</string>
				<symbol>)</symbol>
			</code> the permitted types for the argument 
			<code>
				<local_variable>p</local_variable>
			</code> include not just 
			<code>
				<class_name>POLYGON</class_name>
			</code>, but also 
			<code>
				<class_name>RECTANGLE</class_name>
			</code> (an heir of 
			<code>
				<class_name>POLYGON</class_name>
			</code>) or any other type conforming to 
			<code>
				<class_name>POLYGON</class_name>
			</code> through inheritance.
		</paragraph>
		<paragraph>The basic conformance requirement used here is the inheritance-based type compatibility rule: 
			<code>
				<class_name>V</class_name>
			</code> conforms to 
			<code>
				<class_name>T</class_name>
			</code> if 
			<code>
				<class_name>V</class_name>
			</code> is a descendant of 
			<code>
				<class_name>T</class_name>
			</code>.
		</paragraph>
		<paragraph>Structures such as 
			<code>
				<local_variable>pl</local_variable>
			</code> may contain objects of different types, hence the name "polymorphic data structure".  Such polymorphism is, again, made safe by the type rules: by choosing an actual generic parameter (
			<code>
				<class_name>POLYGON</class_name>
			</code> in the example) based higher or lower in the inheritance graph, you extend or restrict the permissible types of objects in 
			<code>
				<local_variable>pl</local_variable>
			</code>.  A fully general list would be declared as
		</paragraph>
		<code_block><class_name>LIST</class_name> <symbol>[</symbol><class_name>ANY</class_name><symbol>]</symbol></code_block>
		<paragraph>where 
			<code>
				<class_name>ANY</class_name>
			</code>, a Kernel Library class, is automatically an ancestor of any class that you may write.
		</paragraph>
		<paragraph>The other mechanism for combining genericity and inheritance is 
			<bold>constrained genericity</bold>.  By indicating a class name after a formal generic parameter, as in
		</paragraph>
		<code_block><class_name>VECTOR</class_name> <symbol>[</symbol><generics>T</generics> <symbol>-&gt;</symbol> <class_name>NUMERIC</class_name><symbol>]</symbol></code_block>
		<paragraph>you express that only descendants of that class (here 
			<code>
				<class_name>NUMERIC</class_name>
			</code>) may be used as the corresponding actual generic parameters.  This makes it possible to use the corresponding operations.  Here, for example, class 
			<code>
				<class_name>VECTOR</class_name>
			</code> may define a routine 
			<code>
				<keyword>infix</keyword>
			</code>  "+" for adding vectors, based on the corresponding routine from 
			<code>
				<class_name>NUMERIC</class_name>
			</code> for adding vector elements.  Then by making 
			<code>
				<class_name>VECTOR</class_name>
			</code> itself inherit from 
			<code>
				<class_name>NUMERIC</class_name>
			</code>, you ensure that it satisfies its own generic constraint and enable the definition of types such as 
			<code>
				<class_name>VECTOR</class_name>
			</code> 
			<code>
				<symbol>[</symbol>
			</code>
			<code>
				<class_name>VECTOR</class_name>
			</code> 
			<code>
				<symbol>[</symbol>
			</code>
			<code>
				<generics>T</generics>
			</code>
			<code>
				<symbol>]]</symbol>
			</code>.
		</paragraph>
		<paragraph>As you have perhaps guessed, unconstrained genericity, as in 
			<code>
				<string>LIST</string>
			</code> 
			<code>
				<symbol>[</symbol>
				<generics>G</generics>
				<symbol>]</symbol>
			</code>, may be viewed as an abbreviation for genericity constrained by 
			<code>
				<class_name>ANY</class_name>
			</code>, as in
		</paragraph>
		<code_block><class_name>LIST</class_name> <symbol>[</symbol><generics>G</generics> <symbol>-&gt;</symbol> <class_name>ANY</class_name><symbol>]</symbol></code_block>
		<paragraph>Something else you may have guessed: if 
			<code>
				<class_name>ANY</class_name>
			</code>, introduced in this session, is the top of the inheritance structure -- providing all classes with universal features such as 
			<code>
				<feature_name>equal</feature_name>
			</code> to compare arbitrary objects and 
			<code>
				<feature_name>clone</feature_name>
			</code> to duplicate objects -- then 
			<code>
				<class_name>NONE</class_name>
			</code>, seen earlier in the notation 
			<code>
				<keyword>feature</keyword>
			</code> 
			<code>
				<symbol>{</symbol>
			</code>
			<code>
				<class_name>NONE</class_name>
			</code>
			<code>
				<symbol>}</symbol>
			</code>, is its bottom. 
			<code>
				<class_name>NONE</class_name>
			</code> indeed conceptually inherits from all other classes. 
			<code>
				<class_name>NONE</class_name>
			</code> is, among other things, the type of 
			<code>
				<keyword>ensure</keyword>
			</code>, the void reference.
		</paragraph>
	</paragraph></document>
