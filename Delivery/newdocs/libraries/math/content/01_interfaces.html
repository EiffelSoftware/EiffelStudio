<!DOCTYPE HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">

<HTML>
	<HEAD>
		<TITLE>Interfaces</TITLE>
		<LINK REL=StyleSheet HREF="../../../default.css">
	</HEAD>

	<BODY>
		<H1>Interfaces</H1>
        <p >COM interfaces have several facets.&nbsp; First, an interface is a deferred, or an abstract, class.&nbsp;
        This means that an interface is a specification of a type.
        Second, an interface pointer represents a COM object, which is callable
        by a client application. An
        object can expose several interfaces, or represent several types. </p>
        
        <h2 >ECOM_INTERFACE</h2>
        
        <p >For each interface referenced in a type
        library, the EiffelCOM wizard generates a deferred class and two
        effective classes: a proxy of an interface pointer, or a client side
        class, and a stub of an interface pointer, or a server side class. 
        The deferred interface class inherits from <span class="eclass"><a href="../reference/Interfaces/ecom_interface.html">ECOM_INTERFACE</a></span>
        and has a deferred feature per each interface function. 
        Both effective classes, or implemented interfaces, inherit from
        the deferred class and implement its functions. The functions of the
        interface proxy call underlying C layer, which calls a COM component.
        The functions of the interface stub implement the component
        functionality.</p>
        
        <p ><a href="../reference/Interfaces/ecom_interface.html">ECOM_INTERFACE</a>
        holds a pointer to the underlining COM interface.</p>
        
        <h2 >ECOM_QUERIABLE</h2>
        
        <p >Different languages handle the type
        coercion in dissimilar ways. C
        has a type cast; C++ introduces several type casting mechanisms; Eiffel
        has an assignment attempt, etc. Every
        COM interface exposes <span class="efeature">QueryInterface</span>
        function that allows a client to query the COM component for the
        interfaces it exposes and receive a pointer to another interface.
        Querying a component for an interface is similar to using an
        assignment attempt in Eiffel. The
        Eiffel implementation of the assignment attempt relies on the runtime
        data. Since we could not change the Eiffel runtime and the
        implementation of the assignment attempt, we have created a library
        class <span class="eclass"><a href="../reference/Interfaces/ecom_queriable.html">ECOM_QUERIABLE</a></span>, which has a creation routine</p>
        
        <p class="Code"><span class="efeature">make_from_other</span> 
        (other: <span class="eclass"><a href="../reference/Interfaces/ecom_interface.html">ECOM_INTERFACE</a></span>)</p>
        <p>that queries a COM component internally.
        
        Every interface proxy class inherits from <span class="eclass"><a href="../reference/Interfaces/ecom_queriable.html">ECOM_QUERIABLE</a></span>.</p>

        <h2>ECOM_STUB</h2>

        <p><a href="../reference/Interfaces/ecom_stub.html">ECOM_STUB</a>
        inherits from <a href="../reference/Interfaces/ecom_interface.html">ECOM_INTERFACE</a>,
        and has feature <span class=efeature">
        <a href="../reference/Interfaces/ecom_stub.html#f_create_item">create_item</a></span>,
        which allows to create a COM object corresponding to an Eiffel object.</p>

	</BODY>
</HTML>
