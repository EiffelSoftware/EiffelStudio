indexing
	description: "Window allow user to navigate among all zones.%
		%The original version of this class was generated by EiffelBuild."
	legal: "See notice at end of class."
	status: "See notice at end of class."
	date: "$Date$"
	revision: "$Revision$"

class
	SD_ZONE_NAVIGATION_DIALOG

inherit
	SD_ZONE_NAVIGATION_DIALOG_IMP

create
	make

feature {NONE} -- Initialization

	make (a_is_shift_pressed: BOOLEAN; a_docking_manager: SD_DOCKING_MANAGER) is
			-- Creation method.
		require
			a_docking_manager_not_void: a_docking_manager /= Void
		do
			create internal_shared
			is_shift_pressed := a_is_shift_pressed
			default_create
			internal_docking_manager := a_docking_manager
			tools_box.set_max_size (internal_max_width // 2, internal_max_height)
			files_box.set_max_size (internal_max_width // 2, internal_max_height)

			add_all_content_label
			key_release_actions.extend (agent on_key_release)
			key_press_actions.extend (agent on_key_press)
		ensure
			set: is_shift_pressed = a_is_shift_pressed
			set: internal_docking_manager = a_docking_manager
		end

	user_initialization is
			-- Called by `initialize'.
			-- Any custom user initialization that
			-- could not be performed in `initialize',
			-- (due to regeneration of implementation class)
			-- can be added here.
		local
			l_layout: EV_LAYOUT_CONSTANTS
		do
			create l_layout
			internal_vertical_box_top.set_border_width (l_layout.default_border_size)
			internal_vertical_box_top.set_padding (l_layout.default_padding_size)

			internal_info_box.set_border_width (l_layout.default_border_size)
			internal_info_box.set_padding_width (l_layout.default_padding_size)

			internal_info_box_border.set_border_width (l_layout.tiny_padding_size)
			internal_info_box_border.set_background_color (internal_shared.focused_color)

			internal_tools_box.set_border_width (l_layout.default_border_size)
			internal_tools_box.set_padding (l_layout.default_padding_size)

			internal_files_box.set_border_width (l_layout.default_border_size)
			internal_files_box.set_padding (l_layout.default_padding_size)
		end

	init_background (a_color: EV_COLOR) is
			-- Set all widget's background color.
		do
			internal_vertical_box_top.set_background_color (a_color)
			internal_label_box.set_background_color (a_color)
			internal_tools_box.set_background_color (a_color)
			internal_tools_label.set_background_color (a_color)
			tools_box.set_background_color (a_color)
			internal_files_box.set_background_color (a_color)
			internal_files_label.set_background_color (a_color)
			files_box.set_background_color (a_color)
			internal_info_box.set_background_color (a_color)
			full_title.set_background_color (a_color)
			description.set_background_color (a_color)
			detail.set_background_color (a_color)
		end

	add_all_content_label is
			-- Add all content label to Current.
		local
			l_contents: ARRAYED_LIST [SD_CONTENT]
			l_label: SD_CONTENT_LABEL
			l_pass_first_editor, l_pass_second_editor: BOOLEAN
			l_first_label: SD_CONTENT_LABEL
			l_last_label: SD_CONTENT_LABEL
		do
			l_contents := internal_docking_manager.property.contents_by_click_order
			from
				l_contents.start
			until
				l_contents.after
			loop
				create l_label.make (False, Current)
				l_label.set_data (l_contents.item)
				l_label.enable_color_actions.extend (agent on_label_enable_focus_color (l_label))
				l_label.pointer_button_press_actions.force_extend (agent select_label_and_destroy)
				l_label.set_pixmap (l_contents.item.pixmap)
				l_label.set_text (l_contents.item.short_title)
				if l_contents.item.type = {SD_ENUMERATION}.tool and l_contents.item.is_visible then
					tools_box.extend (l_label)
				elseif l_contents.item.type = {SD_ENUMERATION}.editor and l_contents.item.is_visible then
					files_box.extend (l_label)
					if l_pass_first_editor and then not l_pass_second_editor then
						focus_label (l_label)
						l_pass_second_editor := True
					end
					if not l_pass_first_editor then
						l_first_label := l_label
						l_pass_first_editor := True
					end
					l_last_label := l_label
				else
					check only_three_type: l_contents.item.is_visible implies l_contents.item.type = {SD_ENUMERATION}.place_holder end
				end

				l_contents.forth
			end
			if not is_shift_pressed then
				if l_pass_first_editor and then not l_pass_second_editor then
					on_label_enable_focus_color (l_first_label)
				end
			else
				on_label_enable_focus_color (l_last_label)
			end
		end

feature {NONE} -- Agents

	on_label_enable_focus_color (a_label: SD_CONTENT_LABEL) is
			-- Handle a_label focus color enabled.
		require
			a_label_not_void: a_label /= Void
		local
			l_lables: like labels
		do
			l_lables := labels
			from
				l_lables.start
			until
				l_lables.after
			loop
				if l_lables.item /= a_label then
					l_lables.item.disable_focus_color
				else
					focus_label (a_label)
				end
				l_lables.forth
			end
		end

	on_key_release (a_key: EV_KEY) is
			-- Handle key release.
		do
			inspect
				a_key.code
			when {EV_KEY_CONSTANTS}.key_ctrl then
				select_label_and_destroy
			when {EV_KEY_CONSTANTS}.key_shift then
				is_shift_pressed := False
			else

			end
		end

	on_key_press (a_key: EV_KEY) is
			-- Handle key press.
		local
			l_selected_label: SD_CONTENT_LABEL
		do
			inspect
				a_key.code
			when {EV_KEY_CONSTANTS}.key_tab then
				l_selected_label := selected_label
				if is_shift_pressed then
					focus_label (find_next_label_same_type (False))
				else
					focus_label (find_next_label_same_type (True))
				end
				l_selected_label.disable_focus_color
			when {EV_KEY_CONSTANTS}.key_up then
				l_selected_label := selected_label
				focus_label (find_previsou_label)
				l_selected_label.disable_focus_color
			when {EV_KEY_CONSTANTS}.key_down then
				l_selected_label := selected_label
				focus_label (find_next_label)
				l_selected_label.disable_focus_color
			when {EV_KEY_CONSTANTS}.key_left then
				l_selected_label := selected_label
				focus_label (find_label_at_side (False))
				l_selected_label.disable_focus_color
			when {EV_KEY_CONSTANTS}.key_right then
				l_selected_label := selected_label
				focus_label (find_label_at_side (True))
				l_selected_label.disable_focus_color
			when {EV_KEY_CONSTANTS}.key_shift then
				is_shift_pressed := True
			else

			end
		end

feature {NONE} -- Implementation

	focus_label (a_label: SD_CONTENT_LABEL) is
			-- Enable a_label's focus color, and update `full_title''s text.
		local
			l_content: SD_CONTENT
		do
			l_content ?= a_label.data
			check not_void: l_content /= Void end
			a_label.enable_focus_color
			full_title.set_text (l_content.long_title)
		end

	select_label_and_destroy is
			-- Select a_label and destroy Current.
		local
			l_content: SD_CONTENT
		do
			l_content ?= selected_label.data
			check not_void: l_content /= Void end
			l_content.set_focus
			destroy
		end

	find_label_at_side (a_right: BOOLEAN): SD_CONTENT_LABEL is
			-- Find label at right if a_right True or find it at left if a_right False.
		require
			has_label: labels.count > 0
		local
			l_selected_index: INTEGER
			l_current_list, l_side_list: ARRAYED_LIST [SD_CONTENT_LABEL]
		do
			l_current_list := selected_list
			l_selected_index := l_current_list.index_of (selected_label, 1)
			if l_current_list.is_equal (label_editors) then
				l_side_list := label_tools
			else
				l_side_list := label_editors
			end
			if l_side_list.count >= l_selected_index then
				Result := l_side_list.i_th (l_selected_index)
			else
				Result := l_side_list.last
			end
		ensure
			not_void: Result /= Void
		end

	selected_list: ARRAYED_LIST [SD_CONTENT_LABEL] is
			--  List `selected_label' in.
		require
			not_void: selected_label /= Void
		local
			l_list: like label_editors
			l_selected_label: SD_CONTENT_LABEL
		do
			l_list := label_editors
			l_selected_label := selected_label
			if l_list.has (l_selected_label) then
				Result := l_list
			else
				l_list := label_tools
				check must_has: l_list.has (l_selected_label) end
				Result := l_list
			end
		ensure
			not_void: Result /= Void
		end

	find_next_label_same_type (a_forth: BOOLEAN): SD_CONTENT_LABEL is
			-- Find next label which is same type.
		require
			has_label: labels.count > 0
		local
			l_selected: SD_CONTENT_LABEL
			l_label_editors, l_label_tools: ARRAYED_LIST [SD_CONTENT_LABEL]
		do
			l_selected := selected_label
			l_label_editors := label_editors
			if l_label_editors.has (l_selected) then
				Result := find_next_in_list (l_selected, l_label_editors, a_forth)
			else
				l_label_tools := label_tools
				check must_in_tools: l_label_tools.has (l_selected) end
				Result := find_next_in_list (l_selected, l_label_tools, a_forth)
			end
		ensure
			not_void: Result /= Void
		end

	find_next_in_list (a_selected: SD_CONTENT_LABEL; a_list: ARRAYED_LIST [SD_CONTENT_LABEL]; a_forth: BOOLEAN): SD_CONTENT_LABEL is
			-- Find next in a_list.
		require
			has: a_list.has (a_selected)
		do
			if a_forth then
				if a_list.index_of (a_selected, 1) /= a_list.count then
					a_list.start
					a_list.search (a_selected)
					a_list.forth
					Result := a_list.item
				else
					Result := a_list.first
				end
			else
				if a_list.index_of (a_selected, 1) /= 1 then
					a_list.start
					a_list.search (a_selected)
					a_list.back
					Result := a_list.item
				else
					Result := a_list.last
				end
			end
		ensure
			not_void: Result /= Void
		end

	find_previsou_label: SD_CONTENT_LABEL is
			-- Find previsou lable.
		require
			has_label: labels.count > 0
		local
			l_selected_label: SD_CONTENT_LABEL
			l_labels: like labels
			l_stop: BOOLEAN
		do
			l_selected_label := selected_label
			l_labels := labels
			from
				l_labels.finish
			until
				l_labels.before or l_stop
			loop
				if l_labels.item = l_selected_label then
					l_stop := True
				end

				l_labels.back
			end
			if not l_labels.before then
				Result := l_labels.item
			else
				Result := l_labels.last
			end
		ensure
			not_void: Result /= Void
		end

	find_next_label: SD_CONTENT_LABEL is
			-- Find next label.
		require
			has_label: labels.count > 0
		local
			l_selected_label: SD_CONTENT_LABEL
			l_labels: like labels
			l_stop: BOOLEAN
		do
			l_selected_label := selected_label
			l_labels := labels
			from
				l_labels.start
			until
				l_labels.after or l_stop
			loop
				if l_labels.item = l_selected_label then
					l_stop := True
				end

				l_labels.forth
			end
			if not l_labels.after then
				Result := l_labels.item
			else
				Result := l_labels.first
			end
		ensure
			not_void: Result /= Void
		end

	selected_label: SD_CONTENT_LABEL is
			-- Current selected label
		local
			l_labels: like labels
		do
			l_labels := labels
			from
				l_labels.start
			until
				l_labels.after or Result /= Void
			loop
				if l_labels.item.is_focus_color_enabled then
					Result := l_labels.item
				end

				l_labels.forth
			end
		ensure
			not_void: Result /= Void
		end

	label_tools: ARRAYED_LIST [SD_CONTENT_LABEL] is
			-- All tool labels.
		local
--			l_label: SD_CONTENT_LABEL
		do
--			from
--				create Result.make (1)
--				tools_box.start
--			until
--				tools_box.after
--			loop
--				l_label ?= tools_box.item
--				check not_void: l_label /= Void end
--				Result.extend (l_label)
--				tools_box.forth
--			end
			Result := tools_box.labels
		end

	label_editors: ARRAYED_LIST [SD_CONTENT_LABEL] is
			-- All editor labels.
		local
--			l_label: SD_CONTENT_LABEL
		do
			Result := files_box.labels
--			from
--				create Result.make (1)
--				files_box.start
--			until
--				files_box.after
--			loop
--				l_label ?= files_box.item
--				check not_void: l_label /= Void end
--				Result.extend (l_label)
--				files_box.forth
--			end
		end

	labels: ARRAYED_LIST [SD_CONTENT_LABEL] is
			-- All labels.
		do
			Result := label_editors
			Result.append (label_tools)
		end

	is_shift_pressed: BOOLEAN
			-- If shift key pressed?

	internal_docking_manager: SD_DOCKING_MANAGER
			-- Docking manager which Current belong to.

	internal_max_width: INTEGER is 700
			-- Max width.

	internal_max_height: INTEGER is 450
			-- Max height

invariant
	internal_docking_manager_not_void: internal_docking_manager /= Void

indexing
	copyright:	"Copyright (c) 1984-2006, Eiffel Software and others"
	license:	"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)"
	source: "[
			 Eiffel Software
			 356 Storke Road, Goleta, CA 93117 USA
			 Telephone 805-685-1006, Fax 805-685-6869
			 Website http://www.eiffel.com
			 Customer support http://support.eiffel.com
		]"




end -- class SD_ZONE_NAVIGATION_DIALOG

