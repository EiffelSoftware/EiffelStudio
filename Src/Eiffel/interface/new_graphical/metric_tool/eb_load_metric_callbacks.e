indexing
	description: "The callbacks that react on metric xml parsing"
	legal: "See notice at end of class."
	status: "See notice at end of class."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

deferred class
	EB_LOAD_METRIC_CALLBACKS

inherit
	XM_CALLBACKS_NULL
		redefine
			on_error,
			on_start_tag,
			on_attribute
		end

	EB_METRIC_XML_CONSTANTS

	EB_METRIC_SHARED

feature -- Access

	factory: EB_LOAD_METRIC_FACTORY
			-- Factory used to create new nodes when parsing xml definition file

	last_error: EB_METRIC_ERROR
			-- Last error

	current_tag: LINKED_STACK [INTEGER]
			-- The stack of tags we are currently processing

	current_attributes: HASH_TABLE [STRING, INTEGER]
			-- The values of the current attributes	

feature -- Status report

	has_error: BOOLEAN
			-- Does parsing contain error?

feature -- Setting

	clear_last_error is
			-- Clear `last_error'.
		do
			last_error := Void
		ensure
			last_error_is_cleared: last_error = Void and then not has_error
		end

feature -- Callbacks

	on_error (a_message: STRING) is
			-- Event producer detected an error.
		do
			set_parse_error_message (a_message, Void)
		end

	on_start_tag (a_namespace: STRING; a_prefix: STRING; a_local_part: STRING) is
			-- Start of start tag.
		local
			l_trans: HASH_TABLE [INTEGER, STRING]
			l_tag: INTEGER
		do
			if not has_error then
				if current_tag.is_empty then
					current_tag.extend (t_none)
				end
				l_trans := state_transitions_tag.item (current_tag.item)
				if l_trans /= Void then
					l_tag := l_trans.item (a_local_part)
				end
				if l_tag = 0 then
					set_parse_error_message (metric_names.err_invalid_tag_position (a_local_part), Void)
				else
					current_tag.extend (l_tag)
				end
			end
		end

	on_attribute (a_namespace: STRING; a_prefix: STRING; a_local_part: STRING; a_value: STRING) is
			-- Start of attribute.
		local
			l_attr: HASH_TABLE [INTEGER, STRING]
			l_attribute: INTEGER
		do
			if not has_error then
				if
					not a_local_part.is_case_insensitive_equal ("xmlns") and
					not	a_local_part.is_case_insensitive_equal ("xsi") and
					not a_local_part.is_case_insensitive_equal ("schemaLocation")
				then
					a_local_part.to_lower

						-- check if the attribute is valid for the current state
					l_attr := tag_attributes.item (current_tag.item)
					if l_attr /= Void then
						l_attribute := l_attr.item (a_local_part)
					end
					if current_attributes = Void then
						create current_attributes.make (1)
					end
					if l_attribute /= 0 and then not current_attributes.has (l_attribute) then
						current_attributes.force (a_value, l_attribute)
					else
						set_parse_error_message (metric_names.err_invalid_attribute (a_local_part), Void)
					end
				end
			end
		end

feature{NONE} -- Implementation

	set_error (an_error: EB_METRIC_ERROR) is
			-- Set `an_error'.
		require
			an_error_ok: an_error /= Void
		do
			has_error := True
			last_error := an_error
		end

	set_parse_error_message (a_message: STRING_GENERAL; a_location: STRING_GENERAL) is
			-- We have a parse error with a message.
		require
			a_message_attached: a_message /= Void
		local
			l_error: EB_METRIC_ERROR
		do
			create l_error.make (a_message)
			l_error.set_location (a_location)
			has_error := True
			last_error := l_error
		end

feature{NONE} -- Implementation

	state_transitions_tag: HASH_TABLE [HASH_TABLE [INTEGER, STRING], INTEGER] is
			-- Mapping of possible tag state transitions from `current_tag' with the tag name to the new state.
		deferred
		ensure
			Result_not_void: Result /= Void
		end

	tag_attributes: HASH_TABLE [HASH_TABLE [INTEGER, STRING], INTEGER] is
			-- Mapping of possible attributes of tags.
		deferred
		ensure
			Result_not_void: Result /= Void
		end

	domain_item_type_table: HASH_TABLE [FUNCTION [ANY, TUPLE[STRING], EB_METRIC_DOMAIN_ITEM], STRING] is
			-- Domain item type
		once
			create Result.make (6)
			Result.put (agent factory.new_application_target_item, "target")
			Result.put (agent factory.new_group_item, "group")
			Result.put (agent factory.new_folder_item, "folder")
			Result.put (agent factory.new_class_item, "class")
			Result.put (agent factory.new_feature_item, "feature")
			Result.put (agent factory.new_delayed_item, "delayed")
		ensure
			result_attached: Result /= Void
		end

	check_uuid_vadility (a_uuid_str: STRING_GENERAL; a_location: STRING_GENERAL) is
			-- Check vadility of `a_uuid_str'.
			-- `a_location' is where `a_uuid_str' appears.
		require
			a_location_attached: a_location /= Void
		do
			last_valid_uuid := Void
			if a_uuid_str = Void then
				set_parse_error_message (metric_names.err_uuid_missing, a_location)
			else
				if not shared_uuid.is_valid_uuid (a_uuid_str.as_string_8) then
					set_parse_error_message (metric_names.err_uuid_invalid (a_uuid_str), a_location)
				else
					create last_valid_uuid.make_from_string (a_uuid_str.as_string_8)
				end
			end
		end

	last_valid_uuid: UUID
			-- Last valid UUID generated by `check_uuid_vadility'.
			-- If no UUID has been checked or the last checked UUID is invalid,
			-- this will be Void

feature{NONE} -- Status report

	is_valid_boolean_attribute (a_attr: STRING): BOOLEAN is
			-- Is `a_attr' a valid boolean attribute?
		require
			a_attr_attached: a_attr /= Void
			not_a_attr_is_empty: not a_attr.is_empty
		do
			Result := a_attr.is_boolean
		end

	is_domain_item_type_valid (a_scope: STRING): BOOLEAN is
			-- Is `a_scope' a valid domain item type?
		require
			a_scope_attached: a_scope /= Void
		do
			Result := domain_item_type_table.has (a_scope)
		end

invariant
		factory_attached: factory /= Void

indexing
        copyright:	"Copyright (c) 1984-2006, Eiffel Software"
        license:	"GPL version 2 (see http://www.eiffel.com/licensing/gpl.txt)"
        licensing_options:	"http://www.eiffel.com/licensing"
        copying: "[
                        This file is part of Eiffel Software's Eiffel Development Environment.
                        
                        Eiffel Software's Eiffel Development Environment is free
                        software; you can redistribute it and/or modify it under
                        the terms of the GNU General Public License as published
                        by the Free Software Foundation, version 2 of the License
                        (available at the URL listed under "license" above).
                        
                        Eiffel Software's Eiffel Development Environment is
                        distributed in the hope that it will be useful,	but
                        WITHOUT ANY WARRANTY; without even the implied warranty
                        of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
                        See the	GNU General Public License for more details.
                        
                        You should have received a copy of the GNU General Public
                        License along with Eiffel Software's Eiffel Development
                        Environment; if not, write to the Free Software Foundation,
                        Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
                ]"
        source: "[
                         Eiffel Software
                         356 Storke Road, Goleta, CA 93117 USA
                         Telephone 805-685-1006, Fax 805-685-6869
                         Website http://www.eiffel.com
                         Customer support http://support.eiffel.com
                ]"


end
