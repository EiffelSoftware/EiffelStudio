indexing
	description: "Generate Eiffel class from emitter information"
--	attribute: create {CLASS_INTERFACE_ATTRIBUTE}.make_classinterfaceattribute ((create {CLASS_INTERFACE_TYPE}).auto_dual) end
	
class
	EIFFEL_CODE_GENERATOR
	
inherit
	CODE_GENERATOR_SUPPORT
	EIFFEL_CODE_GENERATOR_DICTIONARY
		export
			{NONE} all
		end

create
	make_eiffel_code_generator,
	make_from_info

feature {NONE} -- Initialization

	make_eiffel_code_generator is
		indexing
			description: "Creation routine"
		do
		end
		
	make_from_info (an_eiffel_assembly: like eiffel_assembly) is
		indexing
			description: "Set `eiffel_assembly' with `an_eiffel_assembly'."
		require
			non_void_eiffel_assembly: an_eiffel_assembly /= Void
			non_void_eiffel_assembly_descriptor: an_eiffel_assembly.assembly_descriptor /= Void
			non_void_eiffel_cluster_path: an_eiffel_assembly.Eiffel_Cluster_Path /= Void
			non_void_emitter_version_number: an_eiffel_assembly.Emitter_Version_Number /= Void
			not_empty_emitter_version_number: an_eiffel_assembly.Emitter_Version_Number.count > 0
		local
			code_generation_support: CODE_GENERATION_SUPPORT
			reflection_support: REFLECTION_SUPPORT
			cluster_path: STRING
		do
			eiffel_assembly := an_eiffel_assembly
			--code_generation_support := create {IMPLEMENTATION_CODE_GENERATION_SUPPORT}.make1
			create code_generation_support.make
			
			--reflection_support := create {IMPLEMENTATION_REFLECTION_SUPPORT}.make1
			create reflection_support.make
			
			cluster_path := from_component_string (eiffel_assembly.eiffel_cluster_path)
			if cluster_path.substring_index (from_support_string (reflection_support.eiffel_key), 1) > 0  then
				cluster_path.replace_substring_all (from_support_string (reflection_support.eiffel_key), from_support_string (reflection_support.eiffel_delivery_path))
			end
			--if not code_generation_support.is_valid_directory_path (to_support_string (cluster_path)) then
				--code_generation_support.create_folder (to_support_string (cluster_path))
			---end
		ensure
			eiffel_assembly_set: eiffel_assembly = an_eiffel_assembly
		end

feature -- Access

	eiffel_assembly: EIFFEL_ASSEMBLY
		indexing
			description: "Eiffel assembly generated by the emitter"
		end
			
	eiffel_class: EIFFEL_CLASS
		indexing
			description: "Eiffel class generated by the emitter"
		end
				
	generated_code: STRING 
		indexing
			description: "Generated code"
		end

feature -- Basic Operations

	generate_eiffel_class (an_eiffel_class: like eiffel_class) is
		indexing
			description: "Generate Eiffel class from `eiffel_class'."
		require
			non_void_eiffel_class: an_eiffel_class /= Void
			non_void_eiffel_class_name: an_eiffel_class.eiffel_name /= Void
			not_empty_eiffel_class_name: an_eiffel_class.eiffel_name.count > 0
			non_void_eiffel_class_full_external_name: an_eiffel_class.Full_External_Name /= Void
			not_empty_eiffel_class_full_external_name: an_eiffel_class.Full_External_Name.count > 0
			non_void_eiffel_assembly: eiffel_assembly /= Void
			non_void_eiffel_assembly_descriptor: eiffel_assembly.assembly_descriptor /= Void
			non_void_eiffel_cluster_path: eiffel_assembly.Eiffel_Cluster_Path /= Void
			non_void_emitter_version_number: eiffel_assembly.Emitter_Version_Number /= Void
			not_empty_emitter_version_number: eiffel_assembly.Emitter_Version_Number.count > 0
		local
			eiffel_cluster_path: STRING
			full_external_name: STRING
			filename: STRING
			--formatter: FORMATTER
			reflection_support: REFLECTION_SUPPORT
			
			slash_index: INTEGER
			directory_elements: LIST [STRING]
			excluded_elements: LIST [STRING]
			directory_element: STRING
			i: INTEGER
			code_generation_support: CODE_GENERATION_SUPPORT
			no_namespace_assembly: BOOLEAN
		do
			
			create code_generation_support.make
		
			eiffel_class := an_eiffel_class
			eiffel_cluster_path := from_component_string (eiffel_assembly.eiffel_cluster_path)
			
			create reflection_support.make
			if eiffel_cluster_path.substring_index (reflection_support.eiffel_key, 1) > 0 then
				eiffel_cluster_path.replace_substring_all (from_support_string (reflection_support.eiffel_key), from_support_string (reflection_support.eiffel_delivery_path))
			end
			
			-- append  to cluster path if not already there
			filename := eiffel_cluster_path.clone (eiffel_cluster_path)
			if filename.last_index_of ('\', filename.count) < filename.count then
				filename.append_character ('\')
			end
			
			directory_elements := eiffel_class.namespace.split ('.')
			excluded_elements := eiffel_class.assembly_descriptor.name.split ('.')
			
			-- check to see if the assembly name is contained within then namespace
			from
				no_namespace_assembly := false
				i := 1
			until
				i > directory_elements.count or 
				i > excluded_elements.count or
				no_namespace_assembly = true
			loop
				if not directory_elements.i_th(i).is_equal (excluded_elements.i_th(i)) then
					no_namespace_assembly := true
				end
				i := i + 1
			end
			
			if no_namespace_assembly = false then
				from
					i := 1
				until
					i > directory_elements.count
				loop
					if ( i > excluded_elements.count) then
						if i > excluded_elements.count + 1 then
							filename.append_character ('\')
						end				
						directory_element := directory_elements.i_th (i)
						directory_element.to_lower
						filename.append (directory_element)
					end
				
					i := i + 1
				end
			else
				directory_element := eiffel_class.namespace.clone (eiffel_class.namespace)
				directory_element.replace_substring_all (".", "\") 
				filename.append (directory_element)
			end
			
			if filename.last_index_of ('\', filename.count) < filename.count then
				filename.append_character ('\')
			end
			if not code_generation_support.is_valid_directory_path (filename) then
				code_generation_support.create_folder (filename)
			end
			
			intern_generate_eiffel_class (filename)
		end

	generate_eiffel_class_from_path (an_eiffel_class: like eiffel_class; a_path: STRING) is
		indexing
			description: "Generate Eiffel class from `eiffel_class' in folder corresponding to `a_path'."
		require
			non_void_eiffel_class: an_eiffel_class /= Void
			non_void_eiffel_class_name: an_eiffel_class.eiffel_name /= Void
			not_empty_eiffel_class_name: an_eiffel_class.eiffel_name.count > 0
			non_void_eiffel_class_full_external_name: an_eiffel_class.Full_External_Name /= Void
			not_empty_eiffel_class_full_external_name: an_eiffel_class.Full_External_Name.count > 0
			non_void_eiffel_assembly: eiffel_assembly /= Void
			non_void_eiffel_assembly_descriptor: eiffel_assembly.assembly_descriptor /= Void
			non_void_emitter_version_number: eiffel_assembly.Emitter_Version_Number /= Void
			not_empty_emitter_version_number: eiffel_assembly.Emitter_Version_Number.count > 0
			non_void_path: a_path /= Void
			not_empty_path: a_path.count > 0
		local
			code_generation_support: CODE_GENERATION_SUPPORT
			reflection_support: REFLECTION_SUPPORT
			path: STRING
		do
			eiffel_class := an_eiffel_class
			
			--code_generation_support := create {IMPLEMENTATION_CODE_GENERATION_SUPPORT}.make1
			create code_generation_support.make
			
			--refelction_support := create {REFLECTION_SUPPORT}.make1
			create reflection_support.make
			
			path := a_path
			if path.substring_index (from_support_string (reflection_support.eiffel_key), 1) > 0 then
				path.replace_substring_all (from_support_string (reflection_support.eiffel_key), from_support_string (reflection_support.eiffel_delivery_path))
			end
			if not code_generation_support.is_valid_directory_path (path) then
				code_generation_support.create_folder (path)
			end
			intern_generate_eiffel_class (path)
		end
		
feature {NONE} -- Implementation
	
	intern_generate_eiffel_class (a_filename: STRING) is
		indexing
			description: "Generate Eiffel class from `eiffel_class'."
		require
			non_void_eiffel_class: eiffel_class /= Void
			non_void_eiffel_class_name: eiffel_class.eiffel_name /= Void
			not_empty_eiffel_class_name: eiffel_class.eiffel_name.count > 0
			non_void_eiffel_class_full_external_name: eiffel_class.Full_External_Name /= Void
			not_empty_eiffel_class_full_external_name: eiffel_class.Full_External_Name.count > 0
			non_void_filename: a_filename /= Void
			not_empty_filename: a_filename.count > 0
		local
			file_stream: STREAM_WRITER
			filename: STRING
			full_external_name: STRING
			formatter: FORMATTER
			dir: DIRECTORY
			env: ENVIRONMENT
			cluster_path: STRING
			constraints: ARRAY [STRING]
			a_constraint: STRING
			class_name: STRING
			a_generic_type_name: STRING
			i: INTEGER
			support: CODE_GENERATION_SUPPORT
			generic_type_names: ARRAY [STRING]
			upper_case_name: STRING
			conversation_support: CONVERSION_SUPPORT
			ascii_encoding: ASCIIENCODING
		do
			create formatter.make
			create conversation_support
			full_external_name := from_component_string (eiffel_class.Full_External_Name)
			filename := a_filename.clone (a_filename)
			if filename.last_index_of ('\', filename.count) /= filename.count then
				filename.append_character ('\')
			end
			filename.append (from_system_string (formatter.Format_Type_Name (conversation_support.type_from_eiffel_class (eiffel_class)).To_Lower))
			filename.append (from_component_string (Eiffel_class_extension))
			
			create ascii_encoding.make_asciiencoding
			create file_stream.make_stream_writer_5 (filename.to_cil, False, ascii_encoding)
			generated_code := ""
			
				-- indexing
				--  	generator: "Eiffel Emitter Version number"
				--      assembly: "name", "version", "culture", "publickey"
			generated_code.append (Indexing_keyword)
			generated_code.append (Windows_new_line)
			generated_code.append (Tab)
			generated_code.append (Generator_indexing_clause)
			generated_code.append (Colon)
			generated_code.append (Space) 
			generated_code.append (Inverted_comma)
			generated_code.append (Generator_name)
			generated_code.append (Space)
			generated_code.append (eiffel_assembly.Emitter_Version_Number)
			generated_code.append (Inverted_comma)
			generated_code.append (Windows_new_line)
			generated_code.append (Tab)
			generated_code.append (external_name_keyword)
			generated_code.append (Colon)
			generated_code.append (Space)
			generated_code.append (Inverted_comma)
			generated_code.append (from_system_string (formatter.Format_Strong_Name (eiffel_class.Full_External_Name.to_cil)))
			generated_code.append (Inverted_comma)
			generated_code.append (Windows_new_line)
			generated_code.append (Tab)
			generated_code.append (assembly_keyword)
			generated_code.append (Colon)
			generated_code.append (Space)
			generated_code.append (Inverted_comma)
			generated_code.append (eiffel_assembly.assembly_descriptor.name)
			generated_code.append (Inverted_comma)
			generated_code.append (Comma)
			generated_code.append (Space)
			generated_code.append (Inverted_comma)
			generated_code.append (eiffel_assembly.assembly_descriptor.version)
			generated_code.append (Inverted_comma)
			generated_code.append (Comma)
			generated_code.append (Space)
			generated_code.append (Inverted_comma)
			generated_code.append (eiffel_assembly.assembly_descriptor.culture)
			generated_code.append (Inverted_comma)
			generated_code.append (Comma)
			generated_code.append (Space)
			generated_code.append (Inverted_comma)
			generated_code.append (eiffel_assembly.assembly_descriptor.public_key)
			generated_code.append (Inverted_comma)
			generated_code.append (Windows_new_line)
			
			
				-- enum_type
			if eiffel_class.Enum_Type /= Void and then eiffel_class.Enum_Type.count > 0 then
				generated_code.append (Tab)
				generated_code.append (Enum_type_keyword)
				generated_code.append (Colon)
				generated_code.append (Space)
				generated_code.append (Inverted_comma)
				generated_code.append (from_component_string (eiffel_class.Enum_Type))
				generated_code.append (Inverted_comma)
				generated_code.append (Windows_new_line)
			end
			
				-- generic_types and constraints
			if eiffel_class.is_generic then
				generate_generic_clauses
			end
			
			generated_code.append (Windows_new_line)

				-- frozen
			if eiffel_class.Is_Frozen then
				generated_code.append (Frozen_keyword)
				generated_code.append (Space)
			end
				
				-- expanded
			if eiffel_class.Is_Expanded then
				generated_code.append (Expanded_keyword)
				generated_code.append (Space)
			end

				-- deferred
			if eiffel_class.Is_Deferred then
				generated_code.append (Deferred_keyword)
				generated_code.append (Space)
			end
			
				-- external class
				-- 	CLASS_NAME
			generated_code.append (External_keyword)
			generated_code.append (Space)
			generated_code.append (Class_keyword)
			generated_code.append (Windows_new_line)
			generated_code.append (Tab)
			upper_case_name := from_component_string (eiffel_class.eiffel_name)
			upper_case_name.To_Upper
			generated_code.append (upper_case_name)
			
			if eiffel_class.is_generic then
				class_name := Space
				class_name.append (Opening_square_bracket)
				
				constraints := eiffel_class.constraints
				
				--support := create {IMPLEMENTATION_CODE_GENERATION_SUPPORT}.make1
				create support.make
				
				support.compute_generic_names (constraints.count)
				check
					non_void_generic_type_names: support.generic_type_names /= Void
				end
				generic_type_names := support.generic_type_names
				from
				until
					i = generic_type_names.count
				loop
					a_constraint ?= constraints.item (i)
					if a_constraint /= Void then
						a_generic_type_name ?= generic_type_names.item (i)
						if a_generic_type_name /= Void and then a_generic_type_name.count > 0 then
							class_name.append (a_generic_type_name)
							class_name.append (Space)
							class_name.append ("->")
							class_name.append (Space)
							class_name.append (a_constraint)
							if i < generic_type_names.count - 1 then
								class_name.append (Comma)
								class_name.append (Space)
							end
						end
					end
					i := i + 1
				end
				class_name.append (Space)
				class_name.append (Closing_square_bracket)
				generated_code.append (class_name)
			end
			generated_code.append (Windows_new_line)
			generated_code.append (Windows_new_line)

				-- inherit
				-- 	PARENT_NAME
				-- 		rename ...
				-- 		undefine ...
				-- 		redefine ...
				-- 		end
			generate_inherit_clause

				-- `create {NONE}' or `create make ...'
			generate_create_clause
			
				-- Generate class features (except initialization ones).
			generate_class_features
			
			-- if enum_type, then add the two following methods
			if eiffel_class.Enum_Type /= Void and then eiffel_class.Enum_Type.count > 0 then
				generated_code.append ("feature -- Basic Operations")
				generated_code.append (Windows_new_line)
				generated_code.append (Windows_new_line)
				
				-- from_integer
				generated_code.append (Tab)
				generated_code.append ("from_integer (value: INTEGER) is")
				generated_code.append (Windows_new_line)
				generated_code.append (Tab)
				generated_code.append (Tab)
				generated_code.append ("do")
				generated_code.append (Windows_new_line)
				generated_code.append (Tab)
				generated_code.append (Tab)
				generated_code.append (Tab)
				generated_code.append ("--Built-in")
				generated_code.append (Windows_new_line)
				generated_code.append (Tab)
				generated_code.append (Tab)
				generated_code.append ("end")
				generated_code.append (Windows_new_line)
				generated_code.append (Windows_new_line)
				
				-- to_integer
				generated_code.append (Tab)
				generated_code.append ("to_integer: INTEGER is")
				generated_code.append (Windows_new_line)
				generated_code.append (Tab)
				generated_code.append (Tab)
				generated_code.append ("do")
				generated_code.append (Windows_new_line)
				generated_code.append (Tab)
				generated_code.append (Tab)
				generated_code.append (Tab)
				generated_code.append ("--Built-in")
				generated_code.append (Windows_new_line)
				generated_code.append (Tab)
				generated_code.append (Tab)
				generated_code.append ("end")
				generated_code.append (Windows_new_line)
				generated_code.append (Windows_new_line)
				
				-- infix "|"
				generated_code.append (Tab)
				generated_code.append ("infix %"|%" (infix_arg: like Current): like Current is")
				generated_code.append (Windows_new_line)
				generated_code.append (Tab)
				generated_code.append (Tab)
				generated_code.append ("do")
				generated_code.append (Windows_new_line)
				generated_code.append (Tab)
				generated_code.append (Tab)
				generated_code.append (Tab)
				generated_code.append ("--Built-in")
				generated_code.append (Windows_new_line)
				generated_code.append (Tab)
				generated_code.append (Tab)
				generated_code.append ("end")
				generated_code.append (Windows_new_line)
				generated_code.append (Windows_new_line)
			end

				-- `end -- class CLASS_NAME'
			generated_code.append (End_keyword)
			generated_code.append (Space)
			generated_code.append (Dashes)
			generated_code.append (Space)
			generated_code.append (Class_keyword)
			generated_code.append (Space)
			upper_case_name := from_component_string (eiffel_class.eiffel_name)
			upper_case_name.To_Upper
			generated_code.append (upper_case_name)
			if eiffel_class.is_generic and then class_name /= Void and then class_name.count > 0 then
				generated_code.append (class_name)
			end
			generated_code.append (Windows_new_line)
		
			file_stream.Write_String (generated_code.to_cil)
			file_stream.Close
			eiffel_class := Void
		ensure
			void_eiffel_class: eiffel_class = Void
		end
		
	parents: HASH_TABLE [ ARRAY [LINKED_LIST [INHERITANCE_CLAUSE]], STRING ]
			-- | Key: parent name
			-- | Value: inheritance clauses (ARRAY [ARRAY_LIST [STRING]])
		indexing
			description: "Class parents"
		end
		
	special_classes: HASH_TABLE [STRING, STRING] is
		indexing
			description: "Special classes for which no creation routine should be generated"
		once
			create Result.make (8)
			Result.extend (Integer_class, Integer_class)
			Result.extend (Integer_16_class, Integer_16_class)
			Result.extend (Integer_64_class, Integer_64_class)
			Result.extend (Integer_8_class, Integer_8_class)
			Result.extend (Double_class, Double_class)
			Result.extend (Real_class, Real_class)
			Result.extend (Boolean_class, Boolean_class)
			Result.extend (Character_class, Character_class)
		ensure
			special_classes_created: Result /= Void 
			valid_special_classes: Result.count = 8
		end

	generate_generic_clauses is
		indexing
			description: "Generate `generic_types' and `constraints' clauses."
		require
			non_void_eiffel_class: eiffel_class /= Void
			is_generic: eiffel_class.is_generic
			non_void_generic_derivations: eiffel_class.generic_derivations /= Void	
			non_void_constraints: eiffel_class.constraints /= Void
		do
			generate_generic_types
			generate_constraints
		end
	
	generate_generic_types is
		indexing
			description: "Generate `generic_types' clause."
		require
			non_void_eiffel_class: eiffel_class /= Void
			is_generic: eiffel_class.is_generic
			non_void_generic_derivations: eiffel_class.generic_derivations /= Void		
			not_empty_generic_derivations: eiffel_class.generic_derivations.count > 0
		local
			generic_derivations: ARRAY [GENERIC_DERIVATION]
			a_generic_derivation: GENERIC_DERIVATION
			generic_types_count: INTEGER
			i, j: INTEGER
			generic_types: ARRAY [SIGNATURE_TYPE]
			a_generic_type: SIGNATURE_TYPE
		do
			generated_code.append (Tab)
			generated_code.append (Generic_types_keyword)
			generated_code.append (Colon)
			generated_code.append (Space)
			generated_code.append (Inverted_comma)
			
			generic_derivations := eiffel_class.generic_derivations
			a_generic_derivation ?= generic_derivations.item (0)
			if a_generic_derivation /= Void then
				generic_types_count := a_generic_derivation.generic_types.count
				from
				until
					i = generic_types_count
				loop
					from
						j := 0
					until
						j = generic_derivations.count
					loop
						a_generic_derivation ?= generic_derivations.item (j)
						if a_generic_derivation /= Void then
							generic_types := a_generic_derivation.generic_types
							a_generic_type ?= generic_types.item (i)
							if a_generic_type /= Void then
								generated_code.append (from_component_string (a_generic_type.type_eiffel_name))
								if j < generic_derivations.count - 1 then
									generated_code.append (Comma)
									generated_code.append (Space)
								end
							end
						end
						j := j + 1
					end
					if i < generic_types_count - 1 then
						generated_code.append (Semi_colon)
						generated_code.append (Space)
					end
					i := i + 1
				end
			end
		end

	generate_constraints is
		indexing
			description: "Generate `constraints' clause."
		require
			non_void_eiffel_class: eiffel_class /= Void
			is_generic: eiffel_class.is_generic
			non_void_constraints: eiffel_class.constraints /= Void		
		local
			constraints: ARRAY [STRING]
			a_constraint: STRING
			i: INTEGER
		do		
			generated_code.append (Tab)
			generated_code.append (Constraints_keyword)
			generated_code.append (Colon)
			generated_code.append (Space)
			generated_code.append (Inverted_comma)
			constraints := eiffel_class.constraints
			from
			until 
				i = constraints.count
			loop
				a_constraint ?= constraints.item (i)		
				if a_constraint /= Void then
					generated_code.append (a_constraint)
					if i < constraints.count - 1 then
						generated_code.append (Comma)
						generated_code.append (Space)
					end
				end
				i := i + 1
			end
			generated_code.append (Inverted_comma)
			generated_code.append (Windows_new_line)
		end
		
	generate_inherit_clause is
		indexing
			description: "Generate inherit clause."
		require
			non_void_eiffel_class: eiffel_class /= Void
			non_void_class_name: eiffel_class.eiffel_name /= Void
			not_empty_class_name: eiffel_class.eiffel_name.count > 0
		local			
			parents_names: ARRAY[STRING]
			a_parent: STRING
			inheritance_clauses: ARRAY [LINKED_LIST [INHERITANCE_CLAUSE]]
			rename_clauses: LINKED_LIST [INHERITANCE_CLAUSE]
			undefine_clauses: LINKED_LIST [INHERITANCE_CLAUSE]
			redefine_clauses: LINKED_LIST [INHERITANCE_CLAUSE]
			select_clauses: LINKED_LIST [INHERITANCE_CLAUSE]
			formatted_parents: ARRAY [STRING]
			i: INTEGER
		do
			parents := eiffel_class.Parents
			
			if parents.count > 1 or has_any_rename or has_any_undefine or  has_any_redefine or (parents.count = 1 and (not parents.has (Any_class))) then
				generated_code.append (Inherit_keyword)
				
				parents_names := parents.current_keys
				from
					i := 1
					create formatted_parents.make (1, parents.count)
				until
					 i > formatted_parents.count 
				loop
					a_parent := parents_names.item (i)
					if a_parent /= Void then
						formatted_parents.put (a_parent, i)
					end
					i := i + 1
				end
				
				from
					i := formatted_parents.count
				until
					i = 0
				loop
					a_parent := formatted_parents.item (i)
					if a_parent /= Void then
						if (not a_parent.is_equal (Any_class)) or has_any_rename or has_any_redefine or has_any_undefine then
							generated_code.append (Windows_new_line)
							generated_code.append (Tab)
							generated_code.append (a_parent)
						end
					end
					
					inheritance_clauses ?= parents.Item (a_parent)
					if inheritance_clauses /= Void then
						-- rename clauses
						if inheritance_clauses.item (0).count > 0 then
							generated_code.append (Windows_new_line)
							generated_code.append (Tab)
							generated_code.append (Tab)
							generated_code.append (Rename_keyword)
							rename_clauses := inheritance_clauses.Item (0)					
							if rename_clauses /= Void and then rename_clauses.count > 0 then
								generate_inheritance_clauses (rename_clauses)
							end
						end

							-- undefine clauses
						if inheritance_clauses.Item (1).count > 0 then
							generated_code.append (Windows_new_line)
							generated_code.append (Tab)
							generated_code.append (Tab)
							generated_code.append (Undefine_keyword)						
							undefine_clauses := inheritance_clauses.Item (1)
							if undefine_clauses /= Void and then undefine_clauses.count > 0 then
								generate_inheritance_clauses (undefine_clauses)
							end
						end

							-- redefine clauses
						if inheritance_clauses.Item (2).count > 0 then
							generated_code.append (Windows_new_line)
							generated_code.append (Tab)
							generated_code.append (Tab)
							generated_code.append (Redefine_keyword)
							redefine_clauses := inheritance_clauses.Item (2)
							if redefine_clauses /= Void and then redefine_clauses.count > 0 then
								generate_inheritance_clauses (redefine_clauses)
							end
						end

							-- select clauses
						if inheritance_clauses.Item (3).count > 0 then
							generated_code.append (Windows_new_line)
							generated_code.append (Tab)
							generated_code.append (Tab)
							generated_code.append (Select_keyword)
							select_clauses := inheritance_clauses.Item (3)
							if select_clauses /= Void and then select_clauses.count > 0 then
								generate_inheritance_clauses (select_clauses)
							end
						end
						
						-- Add `end' keyword at the end of inheritance clauses
						if inheritance_clauses.Item (0).count > 0 or inheritance_clauses.Item (1).count > 0 or inheritance_clauses.Item (2).count > 0 or inheritance_clauses.Item (3).count > 0 then
							generated_code.append (Windows_new_line)
							generated_code.append (Tab)
							generated_code.append (Tab)
							generated_code.append (End_keyword)
						end
					end
					i := i - 1
				end
				
				generated_code.append (Windows_new_line)
				generated_code.append (Windows_new_line)
			end
		end
		
	generate_create_clause is
			-- | Do not generate creation clause for deferred classes or expanded classes.
		indexing
			description: "Generate create clause."
		require
			non_void_eiffel_class: eiffel_class /= Void
			non_void_class_name: eiffel_class.eiffel_name /= Void
			not_empty_class_name: eiffel_class.eiffel_name.count > 0
		local	
			i: INTEGER
			a_feature_name: STRING
			a_feature: EIFFEL_FEATURE
			initialization_features: LINKED_LIST [EIFFEL_FEATURE]
			value: STRING
		do
			initialization_features := eiffel_class.Initialization_Features
			
			if initialization_features.count > 0 and not eiffel_class.Is_Deferred and not is_special_class then	
					-- Do not generate creation clause for expanded classes
				if not eiffel_class.is_expanded then
					generated_code.append (Create_keyword) 
					from
						initialization_features.start
					until
						initialization_features.after
					loop
						a_feature ?= initialization_features.Item
						if a_feature /= Void then
							a_feature_name := a_feature.eiffel_name
							if a_feature_name /= Void and then a_feature_name.count > 0 then
								generated_code.append (Windows_new_line)
								generated_code.append (Tab)
								generated_code.append (a_feature_name)
								
								if not (initialization_features.islast) then
									generated_code.append (Comma)
								end
							end
						end
						initialization_features.forth
					end
					generated_code.append (Windows_new_line)
					generated_code.append (Windows_new_line)
					generated_code.append (Initialization_feature_clause_exported_to_none)
				else
					generated_code.append (Windows_new_line)
					generated_code.append (Windows_new_line)
					generated_code.append (Initialization_feature_clause)
				end	
				generated_code.append (Windows_new_line)
				generated_code.append (Windows_new_line)
				from
					initialization_features.start
				until
					initialization_features.after
				loop
					a_feature ?= initialization_features.Item
					if a_feature /= Void then
						if a_feature.Is_Field and a_feature.Is_Static and not a_feature.is_enum_literal and a_feature.is_literal then							
							value := a_feature.literal_value
							if value /= Void and then value.count > 0 then
								generate_eiffel_feature (a_feature)
							end
						else
							generate_eiffel_feature (a_feature)
						end
					end
					initialization_features.forth
				end			
			elseif initialization_features.count = 0 and not eiffel_class.Is_Deferred and not eiffel_class.Is_Expanded then
				generated_code.append (Create_none)
				generated_code.append (Windows_new_line)
				generated_code.append (Windows_new_line)
			end
		end		

	generate_class_features is
		indexing
			description: "Generate class features, except initialization ones."
		require
			non_void_eiffel_class: eiffel_class /= Void
			non_void_class_name: eiffel_class.eiffel_name /= Void
			not_empty_class_name: eiffel_class.eiffel_name.count > 0
		local
			access_features: LINKED_LIST [EIFFEL_FEATURE]
			element_change_features: LINKED_LIST [EIFFEL_FEATURE]
			basic_operations_features: LINKED_LIST [EIFFEL_FEATURE]
			unary_operators_features: LINKED_LIST [EIFFEL_FEATURE]
			binary_operators_features: LINKED_LIST [EIFFEL_FEATURE]
			specials_features: LINKED_LIST [EIFFEL_FEATURE]
			implementation_features: LINKED_LIST [EIFFEL_FEATURE]
		do		
				-- Generate access feature clause.
			access_features := eiffel_class.Access_Features
			if access_features.count > 0 then
				generated_code.append (Access_feature_clause)
				generated_code.append (Windows_new_line)
				generated_code.append (Windows_new_line)
				intern_generate_class_features (access_features)
			end	
				
				-- Generate element change feature clause.
			element_change_features := eiffel_class.Element_Change_Features
			if element_change_features.count > 0 then
				generated_code.append (Element_change_feature_clause)
				generated_code.append (Windows_new_line)
				generated_code.append (Windows_new_line)
				intern_generate_class_features (element_change_features)
			end					

				-- Generate basic operations feature clause.
			basic_operations_features := eiffel_class.Basic_Operations
			if basic_operations_features.count > 0 then
				generated_code.append (Basic_operations_feature_clause)
				generated_code.append (Windows_new_line)
				generated_code.append (Windows_new_line)
				intern_generate_class_features (basic_operations_features)
			end	

				-- Generate unary operators feature clause.
			unary_operators_features := eiffel_class.Unary_Operators_Features
			if unary_operators_features.count > 0 then
				generated_code.append (Unary_operators_feature_clause)
				generated_code.append (Windows_new_line)
				generated_code.append (Windows_new_line)
				intern_generate_class_features (unary_operators_features)
			end	

				-- Generate binary operators feature clause.
			binary_operators_features := eiffel_class.Binary_Operators_Features
			if binary_operators_features.count > 0 then
				generated_code.append (Binary_operators_feature_clause)
				generated_code.append (Windows_new_line)
				generated_code.append (Windows_new_line)
				intern_generate_class_features (binary_operators_features)
			else
				if eiffel_class.bit_or_infix then
					generated_code.append (Bit_or_infix_code)
				end			
			end	

				-- Generate specials feature clause.
			specials_features := eiffel_class.Special_Features
			if specials_features.count > 0 then
				generated_code.append (Windows_new_line)
				generated_code.append (Windows_new_line)
				intern_generate_class_features (specials_features)
			end	

				-- Generate implementation feature clause.
			implementation_features := eiffel_class.Implementation_Features
			if implementation_features.count > 0 then
				generated_code.append (Implementation_feature_clause)
				generated_code.append (Windows_new_line)
				generated_code.append (Windows_new_line)
				intern_generate_class_features (implementation_features)
			end
		end

	generate_inheritance_clauses (clauses: LINKED_LIST [INHERITANCE_CLAUSE]) is
			-- | clauses: ARRAY_LIST [ISE_REFLECTION_INHERITANCECLAUSE]
		indexing
			description: "Generate inheritance clauses from `clauses'."
		require
			non_void_clauses: clauses /= Void
			not_empty_clauses: clauses.count > 0
		local
			a_clause: INHERITANCE_CLAUSE
			added_clauses: LINKED_LIST [STRING]
			string_clause: STRING
		do
			create added_clauses.make
			from
				clauses.start
			until
				clauses.after
			loop
				a_clause ?= clauses.Item
				if a_clause /= Void then
					added_clauses.extend (a_clause.string_representation)
				end
				clauses.forth
			end
			from
				added_clauses.start
			until
				added_clauses.after
			loop
				string_clause := added_clauses.Item
				generated_code.append (Windows_new_line)
				generated_code.append (Tab)
				generated_code.append (Tab)  
				generated_code.append (Tab)
				generated_code.append (string_clause) 
				if not (added_clauses.islast) then
					generated_code.append (Comma)
				end
				added_clauses.forth
			end
		end
		
	is_special_class: BOOLEAN is
		indexing
			description: "Is class to be generated a special class?"
		require
			non_void_special_classes: special_classes /= Void
		local
			eiffel_class_name: STRING
		do
			eiffel_class_name := from_component_string (eiffel_class.eiffel_name.clone (eiffel_class.eiffel_name))
			eiffel_class_name.to_upper
			Result := special_classes.has (eiffel_class_name)
		end

	intern_generate_class_features (a_list: LINKED_LIST [EIFFEL_FEATURE]) is
			-- | Call in loop `generate_eiffel_feature'.
		indexing
			description: "Generate class features from `a_list'."
		local
			a_feature: EIFFEL_FEATURE
			value: STRING
		do
			from
				a_list.start
			until
				a_list.after
			loop
				a_feature ?= a_list.item
				if a_feature /= Void and then (a_feature.eiffel_name /= Void and a_feature.eiffel_name.count > 0) then
					if a_feature.Is_Field and a_feature.Is_Static and not a_feature.is_enum_literal and a_feature.is_literal then							
						value := a_feature.literal_value
						if value /= Void and then value.count > 0 then
							generate_eiffel_feature (a_feature)
						end
					else
						generate_eiffel_feature (a_feature)
					end
				end
				a_list.forth
			end		
		end
	
	generate_eiffel_feature (a_feature: EIFFEL_FEATURE) is
		indexing
			description: "Generate Eiffel feature from `a_feature'."
		require
			non_void_feature: a_feature /= Void
			non_void_feature_name: a_feature.eiffel_name /= Void
			not_empty_feature_name: a_feature.eiffel_name.count > 0
		local
			is_binary_operator: BOOLEAN
			is_unary_operator: BOOLEAN
			unary_operator: STRING
			binary_operator: STRING
			arguments: LINKED_LIST [NAMED_SIGNATURE_TYPE_INTERFACE]
			i: INTEGER
			an_argument: NAMED_SIGNATURE_TYPE_INTERFACE
			formal_argument: FORMAL_NAMED_SIGNATURE_TYPE
			generic_parameter_index: INTEGER
			argument_name: STRING
			argument_type: STRING
			formal_return_type: FORMAL_SIGNATURE_TYPE
			return_type_name: STRING
			comments: LINKED_LIST [STRING]
			a_comment: STRING
			preconditions: LINKED_LIST [ARRAY [STRING]]
			postconditions: LINKED_LIST [ARRAY [STRING]]
			support: CODE_GENERATION_SUPPORT
			generic_type_names: ARRAY [STRING]
			-- temporary
			code: STRING
			do_not_generate: BOOLEAN
		do	
			-- temporary
			do_not_generate := false
			code := ""

			create support.make
			generic_type_names := support.generic_type_names
			
			is_binary_operator := eiffel_class.Binary_Operators_Features.has (a_feature)
			is_unary_operator := eiffel_class.Unary_Operators_Features.has (a_feature)	

			code.append (Tab)

				-- frozen
			if a_feature.Is_Frozen then
				code.append (Frozen_keyword)
				code.append (Space)
			end

				-- feature name
			if is_unary_operator and a_feature.Is_Prefix then
				code.append (Prefix_keyword)
				code.append (from_component_string (a_feature.eiffel_name))
			else
				--if is_binary_operator and a_feature.IsInfix then
				if a_feature.Is_Infix then
					code.append (Infix_keyword)
					code.append (from_component_string(a_feature.eiffel_name))
				else
					code.append (from_component_string(a_feature.eiffel_name))
				end
			end

				-- feature arguments
			arguments := a_feature.Arguments
			if not is_unary_operator and arguments.count > 0 then
				code.append (Space)
				code.append (Opening_round_bracket)
				from
					 arguments.start
				until
					arguments.after
				loop
					an_argument ?= arguments.Item
					if an_argument /= Void then
						argument_name := from_component_string(an_argument.eiffel_name)
						formal_argument ?= arguments.item
						if formal_argument /= Void and then generic_type_names /= Void then
							generic_parameter_index := formal_argument.generic_parameter_index
							if generic_parameter_index < generic_type_names.count then
								argument_type := from_component_string(generic_type_names.item (generic_parameter_index))
							else
								argument_type := from_component_string(an_argument.type_eiffel_name)
							end
						else
							argument_type := from_component_string(an_argument.type_eiffel_name)
						end
					end
					code.append (argument_name)
					code.append (Colon)
					code.append (Space)
					code.append (argument_type)
					-- temporary
					if argument_type.substring_index ("ISE_RUNTIME_", 1) > 0 then
						do_not_generate := true
					end
					if not arguments.islast then
						code.append (Semi_colon)
						code.append (Space)
					end
					arguments.forth
				end
					code.append (Closing_round_bracket)
			end

				-- feature return type			
			if a_feature.is_method and then a_feature.Return_Type /= Void and then a_feature.Return_Type.Type_eiffel_name /= Void then
				-- temporary
				if a_feature.Return_Type.Type_eiffel_name.substring_index ("ISE_RUNTIME_", 1) > 0 then
					do_not_generate := true
				end
				formal_return_type ?= a_feature.return_type
				if formal_return_type /= Void and then generic_type_names /= Void then
					generic_parameter_index := formal_return_type.generic_parameter_index
					if generic_parameter_index < generic_type_names.count then
						return_type_name := from_component_string(generic_type_names.item (generic_parameter_index))
					else
						return_type_name := from_component_string(a_feature.return_type.type_eiffel_name)
					end				
				else
					return_type_name := from_component_string(a_feature.return_type.type_eiffel_name)
				end
				code.append (Colon)
				code.append (Space)
				code.append (return_type_name)
			end
			if a_feature.Is_Field then
				if a_feature.external_name /= Void and then not (a_feature.external_name.substring_index (to_component_string(Property_set_prefix) , 1) = 1) then
					code.append (Colon)
					code.append (Space)
					code.append (from_component_string(a_feature.Return_Type.Type_eiffel_name))
				end
			end

				-- `is' keyword
			code.append (Space)
			code.append (Is_keyword)

				-- feature comments
			comments := a_feature.Comments
			from
				comments.start
			until
				comments.after
			loop
				a_comment ?= comments.item
				if a_comment /= Void and then a_comment.count > 0 then
					code.append (Tab)
					code.append (Dashes)
					code.append (Space)
					code.append (a_comment)
				end
				comments.forth
			end

				-- feature preconditions
			preconditions := a_feature.Preconditions
			if preconditions.count > 0 then
-- temporary
if not do_not_generate then
	generated_code.append (code)
	generate_feature_assertions (preconditions, Require_keyword)
	code := ""
end
			end

				-- `external' keyword
			if a_feature.is_enum_literal or not a_feature.is_literal then
				code.append (Windows_new_line)
				code.append (Tab)
				code.append (Tab)
				code.append (External_keyword)
				code.append (Windows_new_line)
				code.append (Tab)
				code.append (Tab)
				code.append (Tab)
			end
-- temporary
if not do_not_generate then
	generated_code.append (code)
	generate_external_clause (a_feature)
	code := ""
end
				-- feature alias
			if a_feature.is_enum_literal or not a_feature.is_literal then			
				if a_feature.Is_Method or a_feature.Is_Field then
					code.append (Windows_new_line)
					code.append (Tab)
					code.append (Tab)
					code.append (Alias_keyword)

					code.append (Windows_new_line)
					code.append (Tab)
					code.append (Tab)
					code.append (Tab)
					code.append (Inverted_comma)
					code.append (a_feature.External_Name)
					code.append (Inverted_comma)	
				end			

					-- feature postconditions
				postconditions := a_feature.Postconditions
				if postconditions.count > 0 then
-- temporary
if not do_not_generate then
	generated_code.append (code)
	generate_feature_assertions (postconditions, Ensure_keyword)
	code := ""
end
				end

					-- `end' keyword
				code.append (Windows_new_line)
				code.append (Tab)
				code.append (Tab)
				code.append (End_keyword)
				code.append (Windows_new_line)
				code.append (Windows_new_line)
			else
				if code.count > 0 then
					code.append (Windows_new_line)
					code.append (Windows_new_line)
				end
			end
-- temporary
if not do_not_generate then
	generated_code.append (code)
end
		end	

	generate_feature_assertions (assertions: LINKED_LIST [ARRAY [STRING]]; keyword: STRING) is
		indexing
			description: "Generate feature assertions from `assertions' (include `keyword')."
		require
			non_void_assertions: assertions /= Void
			not_empty_assertions: assertions.count > 0
			non_void_keyword: keyword /= Void
			valid_keyword: keyword.is_equal (Require_keyword) or keyword.is_equal (Ensure_keyword)
		local
			an_assertion: ARRAY[STRING]
			an_assertion_tag: STRING
			an_assertion_text: STRING
		do
			from
				assertions.start
			until
				assertions.after
			loop
				an_assertion ?= assertions.item
				if an_assertion /= Void and then an_assertion.count >= 1 then
					if assertions.isfirst then
						generated_code.append (Windows_new_line)
						generated_code.append (Tab)
						generated_code.append (Tab)
						generated_code.append (keyword)
					end
					an_assertion_tag := an_assertion.Item (0)
					an_assertion_text := an_assertion.Item (1)
					generated_code.append (Windows_new_line)
					generated_code.append (Tab)
					generated_code.append (Tab)
					generated_code.append (Tab)
					if an_assertion_tag /= Void and then an_assertion_tag.count > 0 then
						generated_code.append (an_assertion_tag)
						generated_code.append (Colon)
						generated_code.append (Space)
					end
					generated_code.append (an_assertion_text)
					generated_code.append (Windows_new_line)
				end
				assertions.forth
			end			
		end
	
	generate_external_clause (a_feature: EIFFEL_FEATURE) is
		indexing
			description: "Generate `a_feature' external clause."
		require
			non_void_feature: a_feature /= Void
			non_void_feature_name: a_feature.eiffel_name /= Void
			not_empty_feature_name: a_feature.eiffel_name.count > 0
		local
			signature: STRING
			is_binary_operator: BOOLEAN
			is_unary_operator: BOOLEAN
			formatter: FORMATTER
			value: STRING
		do
			create formatter.make
			signature := feature_signature (a_feature)
			is_binary_operator := eiffel_class.Binary_Operators_Features.has (a_feature)
			is_unary_operator := eiffel_class.Unary_Operators_Features.has (a_feature)	
			
			if a_feature.Is_Method then
				if is_unary_operator or is_binary_operator then
						-- "IL operator `signature' use `alias' "
					generated_code.append (Inverted_comma)
					generated_code.append (IL)
					generated_code.append (Space)
					generated_code.append (Operator)
					generated_code.append (Space)
					generated_code.append (signature)
					generated_code.append (Use)
					generated_code.append (Space)
					generated_code.append (from_system_string (formatter.Format_Strong_Name (eiffel_class.Full_External_Name.to_cil)))
					generated_code.append (Inverted_comma)
				else
					if a_feature.Is_Static then
							-- "IL static `signature' use `alias' "
						generated_code.append (Inverted_comma)
						generated_code.append (IL)
						generated_code.append (Space)
						generated_code.append (Static)
						generated_code.append (signature)
						generated_code.append (Use)
						generated_code.append (Space)
						generated_code.append (from_system_string (formatter.Format_Strong_Name (eiffel_class.Full_External_Name.to_cil)))
						generated_code.append (Inverted_comma)
					else
						if a_feature.Is_Abstract then
								-- "IL deferred `signature' use `alias' "
							generated_code.append (Inverted_comma)
							generated_code.append (IL)
							generated_code.append (Space)
							generated_code.append (Deferred_keyword)
							generated_code.append (signature)
							generated_code.append (Use)
							generated_code.append (Space)
							generated_code.append (from_system_string (formatter.Format_Strong_Name (eiffel_class.Full_External_Name.to_cil)))
							generated_code.append (Inverted_comma)
						else
								-- "IL `signature' use `alias' "
							generated_code.append (Inverted_comma)
							generated_code.append (IL)
							generated_code.append (signature)
							generated_code.append (Use)
							generated_code.append (Space)
							generated_code.append (from_system_string (formatter.Format_Strong_Name (eiffel_class.Full_External_Name.to_cil)))
							generated_code.append (Inverted_comma)
						end	
					end
				end
			else
				if a_feature.Is_Field then
					if a_feature.Is_Static then
						if not a_feature.is_enum_literal and a_feature.is_literal then							
							value := from_component_string (a_feature.literal_value)
							generated_code.append (value)
						else					
							if a_feature.Is_Enum_Literal then
									-- "IL enum signature : `type_full_name' use `alias'.
								generated_code.append (Inverted_comma)
								generated_code.append (IL)
								generated_code.append (Space)
								generated_code.append (Enum_keyword)
								generated_code.append (Space)
							else
									-- "IL static_field signature : `type_full_name' use `alias'.
								generated_code.append (Inverted_comma)
								generated_code.append (IL)
								generated_code.append (Space)
								generated_code.append (Static_field)
								generated_code.append (Space)
							end						
							generated_code.append (Signature_keyword)
							generated_code.append (Space)
							generated_code.append (Colon)
							generated_code.append (from_component_string (a_feature.Return_Type.Type_Full_External_Name))
							generated_code.append (Space)
							generated_code.append (Use)
							generated_code.append (Space)
							generated_code.append (from_system_string (formatter.Format_Strong_Name (eiffel_class.Full_External_Name.to_cil)))
							generated_code.append (Inverted_comma)
						end
					else
							-- "IL field signature : `type_full_name' use `alias'.
						generated_code.append (Inverted_comma)
						generated_code.append (IL)
						generated_code.append (Space)
						generated_code.append (Field)
						generated_code.append (Space)
						generated_code.append (Signature_keyword) 
						generated_code.append (Space)
						generated_code.append (Colon)
						generated_code.append (from_component_string (a_feature.Return_Type.Type_Full_External_Name))
						generated_code.append (Space)
						generated_code.append (Use)
						generated_code.append (Space)
						generated_code.append (from_system_string (formatter.Format_Strong_Name (eiffel_class.Full_External_Name.to_cil)))
						generated_code.append (Inverted_comma)
					end
				else
						-- "IL creator `signature' use `alias' "
					generated_code.append (Inverted_comma)
					generated_code.append (IL)
					generated_code.append (Space)
					generated_code.append (Creator)
					generated_code.append (signature)
					generated_code.append (Use)
					generated_code.append (Space)
					generated_code.append (from_system_string (formatter.Format_Strong_Name (eiffel_class.Full_External_Name.to_cil)))
					generated_code.append (Inverted_comma)
				end
			end		
		end

	feature_signature (a_feature: EIFFEL_FEATURE): STRING is
		indexing
			description: ".Net assembly qualified signature of `a_feature'"
		require
			non_void_feature: a_feature /= Void
			non_void_feature_name: a_feature.eiffel_name /= Void
			not_empty_feature_name: a_feature.eiffel_name.count > 0	
		local
			is_unary_operator: BOOLEAN
			is_binary_operator: BOOLEAN
			arguments: LINKED_LIST [NAMED_SIGNATURE_TYPE_INTERFACE]
			i: INTEGER
			an_argument: NAMED_SIGNATURE_TYPE
			temp: STRING			
		do
			Result := ""
			
			is_binary_operator := eiffel_class.Binary_Operators_Features.has (a_feature)
			is_unary_operator := eiffel_class.Unary_Operators_Features.has (a_feature)

			if a_feature.Is_Method then
				arguments := a_feature.Arguments
				if not is_unary_operator or arguments.count > 0 then
					Result := Space
					Result.append (Signature_keyword)
					Result.append (Space)
					Result.append (Opening_round_bracket)
					from
						arguments.start
					until
						arguments.after
					loop
						an_argument ?= arguments.item
						if an_argument /= Void then
							Result.append (from_component_string (an_argument.Type_Full_External_Name))
							if not (arguments.islast) then
								Result.append (Comma)
								Result.append (Space)
							end
						end
						arguments.forth
					end
					Result.append (Closing_round_bracket)
					Result.append (Colon)
					Result.append (Space)
					temp := ""
				else
					temp := Signature_keyword.clone (Signature_keyword)
					temp.append (Space)
					temp.append (Colon)
					temp.append (Space)
				end

				if a_feature.Return_Type /= Void and then a_feature.Return_Type.Type_Full_External_Name /= Void and then a_feature.Return_Type.Type_Full_External_Name.count > 0 then
					Result.append (temp)
					Result.append (from_component_string (a_feature.Return_Type.Type_Full_External_Name))
				end
				Result.append (Space)
			end
			
			if not a_feature.Is_Method and not a_feature.Is_Field then
				arguments := a_feature.Arguments
				if arguments.count > 0 then
					Result := Space
					Result.append (Signature_keyword)
					Result.append (Space)
					Result.append (Opening_round_bracket)
					from
						arguments.start
					until
						arguments.after
					loop
						an_argument ?= arguments.Item
						if an_argument /= Void then
							Result.append (from_component_string (an_argument.Type_Full_External_Name))
						end
						if  not (arguments.islast) then
							Result.append (Comma)
							Result.append (Space)
						end
						arguments.forth
					end
					Result.append (Closing_round_bracket)
				end
				Result.append (Space)
			end
		ensure
			signature_built: Result /= Void
		end
	
	has_any_rename: BOOLEAN is
		indexing
			description: "Does class have rename clauses for parent `ANY'?"
		require
			non_void_parents: parents /= Void
		local
			inheritance_clauses: ARRAY [LINKED_LIST [INHERITANCE_CLAUSE]]
		do
			if parents.has (Any_class) then
				inheritance_clauses ?= parents.Item (Any_class)
				if inheritance_clauses /= Void then
					Result := inheritance_clauses.item (0).count > 0
				end
			else
				Result := False
			end
		end

	has_any_undefine: BOOLEAN is
		indexing
			description: "Does class have undefine clauses for parent `ANY'?"
		require
			non_void_parents: parents /= Void
		local
			inheritance_clauses: ARRAY[LINKED_LIST [INHERITANCE_CLAUSE]]
		do
			if parents.has (Any_class) then
				inheritance_clauses ?= parents.Item (Any_class)
				if inheritance_clauses /= Void then
					Result := inheritance_clauses.item (1).count > 0
				end
			else
				Result := False
			end
		end

	has_any_redefine: BOOLEAN is
		indexing
			description: "Does class have redefine clauses for parent `ANY'?"
		require
			non_void_parents: parents /= Void
		local
			inheritance_clauses: ARRAY[LINKED_LIST [INHERITANCE_CLAUSE]]
		do
			if parents.has (Any_class) then
				inheritance_clauses ?= parents.Item (Any_class)
				if inheritance_clauses /= Void then
					Result := inheritance_clauses.item (2).count > 0
				end
			else
				Result := False
			end
		end
	
	Bit_or_infix_code: STRING is
		indexing	
			description: "Code of `|' infix"
		once
			Result ?= Basic_operations_feature_clause.clone (Basic_operations_feature_clause)
			Result.append (Windows_new_line)
			Result.append (Windows_new_line)				
			Result.append (Tab)
			Result.append (Bit_or_infix_signature)
			Result.append (Windows_new_line)
			Result.append (Tab)
			Result.append (Tab)
			Result.append (Do_keyword)
			Result.append (Windows_new_line)
			Result.append (Tab)
			Result.append (Tab)
			Result.append (Tab)
			Result.append (Built_in_comment)
			Result.append (Windows_new_line)
			Result.append (Tab)
			Result.append (Tab)
			Result.append (End_keyword)
			Result.append (Windows_new_line)
			Result.append (Windows_new_line)
		ensure
			non_void_code: Result /= Void
			not_empty_code: Result.count > 0
		end
	
	Bit_or_infix_signature: STRING is "infix %"|%" (infix_arg: like Current): like Current is"
		indexing	
			description: "Bit or infix signature"
		end
	
	Built_in_comment: STRING is "--Built-in"
		indexing	
			description: "Comment in infix `|' body"
		end
		
end -- class EIFFEL_CODE_GENERATOR
