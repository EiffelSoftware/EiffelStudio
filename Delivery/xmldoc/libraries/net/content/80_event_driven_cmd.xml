<document output="studio" title="Event-driven command execution">
	<meta_data/>
	<paragraph>
		<table><border>1</border>
			<row>
				<cell>The example classes discussed in this section appear in the        subdirectory 
					<italic>polling </italic>of the example directory
				</cell>
			</row>
		</table>
		<heading>
			<size>3</size>9.1 Commands and events
		</heading>
		<paragraph>In the preceding examples each participant in a communication had to    get ready to send or receive at specific stages of its life. Although    this did not preclude asynchronous communication, it is sometimes    desirable to make the scheme even more asynchronous, and control more    decentralized, by letting each system simply specify certain    communication events that it wants to monitor, and certain commands to    be executed on occurrence of the specified events.</paragraph>
		<paragraph>The commands are objects, instances of a general-purpose    class <class_name>COMMAND </class_name>or its proper descendants. Class <class_name>COMMAND </class_name>has, among its    features, a procedure 
			<italic>execute</italic> which executes the current command;    some commands are undoable and have an 
			<italic>undo</italic> procedure.
		</paragraph>
		<paragraph>In EiffelNet the possible events associated with a socket will be of    three kind: a read event; a write event; or a special event (out of    bounds operation). The command classes will be descendants of <link><url>/libraries/net/reference/polling/abstract/poll_command_chart.xml</url><label>POLL_COMMAND</label></link>,    an heir of <class_name>COMMAND</class_name>.</paragraph>
		<heading>
			<size>3</size>9.2 Command classes
		</heading>
		<paragraph>The example uses four command classes: <class_name>CLIENT_DATAGRAM_READER</class_name>,    <class_name>CLIENT_DATAGRAM_WRITER</class_name> and their counterpart for servers, representing    operations that must be triggered in the case of a read event and a    write event.</paragraph>
		<paragraph>Here is the reader command for clients:    
<code_block>
	<keyword>class</keyword>
		<class_name>CLIENT_DATAGRAM_READER</class_name>
	
	<keyword>inherit</keyword>
	
		<class_name>POLL_COMMAND</class_name> 
			<keyword>redefine</keyword>
				<feature_name>active_medium</feature_name>
			<keyword>end</keyword>
	
	<keyword>creation</keyword>
		<feature_name>make</feature_name>
	
	<keyword>feature</keyword>
	
		<feature_name>active_medium</feature_name><symbol>:</symbol> <class_name>NETWORK_DATAGRAM_SOCKET</class_name>
	
		<feature_name>execute</feature_name> <keyword>is</keyword>
				<comment>-- Obtain a packet of ten characters and print them.</comment>
			<keyword>local</keyword>
				<local_variable>rec_pack</local_variable><symbol>:</symbol> <class_name>DATAGRAM_PACKET</class_name> 
				<local_variable>i</local_variable><symbol>:</symbol> <class_name>INTEGER</class_name>
			<keyword>do</keyword>
				<local_variable>rec_pack</local_variable> <symbol>:</symbol><symbol>=</symbol> <feature_name>active_medium</feature_name>.<feature_name>received</feature_name> <symbol>(</symbol>10, 0<symbol>)</symbol>
				<feature_name>io</feature_name>.<feature_name>putint</feature_name> <symbol>(</symbol><local_variable>rec_pack</local_variable>.<feature_name>packet_number</feature_name><symbol>)</symbol>
				<feature_name>io</feature_name>.<feature_name>new_line</feature_name>
				<keyword>from</keyword>
					<local_variable>i</local_variable> <symbol>:</symbol><symbol>=</symbol> 0
				<keyword>until</keyword>
					<local_variable>i</local_variable> <symbol>&gt;</symbol> 9
				<keyword>loop</keyword>
					<feature_name>io</feature_name>.<feature_name>putchar</feature_name> <symbol>(</symbol><local_variable>rec_pack</local_variable>.<feature_name>element</feature_name> <symbol>(</symbol>i<symbol>)</symbol><symbol>)</symbol>; i <symbol>:</symbol><symbol>=</symbol> <local_variable>i</local_variable> <symbol>+</symbol> 1
				<keyword>end</keyword>
				<feature_name>io</feature_name>.<feature_name>new_line</feature_name>
			<keyword>end</keyword>
	
	<keyword>end</keyword>

</code_block>
			<paragraph>The 
				<italic>execute</italic> procedure reads a packet of ten characters and    prints these characters. Its counterpart in the writing command will    produce these ten packets:    
<code_block>
	<keyword>class</keyword>
		<class_name>CLIENT_DATAGRAM_WRITER</class_name>
	
	<keyword>inherit</keyword>
	
		<class_name>POLL_COMMAND</class_name> 
			<keyword>redefine</keyword>
				<feature_name>active_medium</feature_name>
			<keyword>end</keyword>
	
		<class_name>BASIC_ROUTINES</class_name>
	
	<keyword>creation</keyword>
		<feature_name>make</feature_name>
	
	<keyword>feature</keyword>
	
		<feature_name>active_medium</feature_name><symbol>:</symbol> <class_name>NETWORK_DATAGRAM_SOCKET</class_name>
	
		<feature_name>execute</feature_name> <keyword>is</keyword>
				<comment>-- Make a packet with characters 'a' to 'k' in successive positions.</comment>
			<keyword>local</keyword>
				<local_variable>sen_pack</local_variable><symbol>:</symbol> <class_name>DATAGRAM_PACKET</class_name> 
				<local_variable>ccode</local_variable><symbol>:</symbol> <class_name>INTEGER</class_name>
			<keyword>do</keyword>
				<keyword>create</keyword> <feature_name>sen_pack</feature_name>.<feature_name>make</feature_name> <symbol>(</symbol>10<symbol>)</symbol>
				<keyword>from</keyword>
					<local_variable>ccode</local_variable> <symbol>:</symbol><symbol>=</symbol> <feature_name>charcode</feature_name> <symbol>(</symbol><symbol>'</symbol><character>a</character><symbol>'</symbol><symbol>)</symbol>
				<keyword>until</keyword>
					<local_variable>ccode</local_variable> <symbol>&gt;</symbol> <local_variable>charcode</local_variable> <symbol>(</symbol><symbol>'</symbol><character>k</character><symbol>'</symbol><symbol>)</symbol>
				<keyword>loop</keyword>
					<feature_name>sen_pack</feature_name>.<feature_name>put_element</feature_name> <symbol>(</symbol><feature_name>charconv</feature_name> <symbol>(</symbol><local_variable>ccode</local_variable><symbol>)</symbol>, <local_variable>ccode</local_variable> -- <feature_name>charcode</feature_name> <symbol>(</symbol><symbol>'</symbol><character>a</character><symbol>'</symbol><symbol>)</symbol><symbol>)</symbol>
					<local_variable>ccode</local_variable> <symbol>:</symbol><symbol>=</symbol> <local_variable>ccode</local_variable> <symbol>+</symbol> 1
				<keyword>end</keyword>
				<local_variable>sen_pack</local_variable>.<feature_name>set_packet_number</feature_name> <symbol>(</symbol>1<symbol>)</symbol>
				<feature_name>active_medium</feature_name>.<feature_name>send</feature_name> <symbol>(</symbol><local_variable>sen_pack</local_variable>,<keyword> Void</keyword>, 0<symbol>)</symbol>
			<keyword>end</keyword>
	
	<keyword>end</keyword>
</code_block>
				<heading>
					<size>3</size>9.3 The server and the client
				</heading>
				<paragraph>Once the commands have been defined, it suffices for the server and    the client to associate instances of these commands with the    appropriate.</paragraph>
				<paragraph>The abstraction needed for this purpose is provided by class <class_name>MEDIUM_POLLER</class_name>.    An instance of this class knows about a number of commands, each    associated with a certain socket in read, write or special event mode.    By applying procedure 
					<italic>execute</italic> to such a medium poller, you direct    it to monitor these sockets for the corresponding events and to execute    the command associated with each event that will be received. Procedure 
					<italic>execute</italic>    takes two integer arguments: the maximum number of sockets to monitor,    and the timeout in milliseconds.
				</paragraph>
				<paragraph>Here is the server built with this mechanism:    
<code_block>
	<keyword>class</keyword>
	
		<class_name>POLLING_SERVER</class_name>
	
	<keyword>creation</keyword>
		<feature_name>make</feature_name>
	
	<keyword>feature</keyword>
	
		<feature_name>make</feature_name> <keyword>is</keyword>
				<comment>-- Create read and write commands, attach them to a poller,</comment>
				<comment>-- set up the poller for execution.</comment>
			<keyword>local</keyword>
				<local_variable>soc</local_variable><symbol>:</symbol> <class_name>NETWORK_DATAGRAM_SOCKET</class_name> 
				<local_variable>poller</local_variable><symbol>:</symbol> <class_name>MEDIUM_POLLER</class_name> 
				<local_variable>readcomm</local_variable><symbol>:</symbol> <class_name>SERVER_DATAGRAM_READER</class_name>
				<local_variable>writecomm</local_variable><symbol>:</symbol> <class_name>SERVER_DATAGRAM_WRITER</class_name>
			<keyword>do</keyword>
				<keyword>create</keyword> <local_variable>soc</local_variable>.<feature_name>make_server_by_port</feature_name> <symbol>(</symbol>6530<symbol>)</symbol>
				<keyword>create</keyword> <local_variable>poller</local_variable>.<feature_name>make</feature_name>
				<keyword>create</keyword> <local_variable>readcomm</local_variable>.<feature_name>make</feature_name> <symbol>(</symbol>soc<symbol>)</symbol>; <local_variable>poller</local_variable>.<feature_name>put_read_command</feature_name> <symbol>(</symbol><local_variable>readcomm</local_variable><symbol>)</symbol>
				<keyword>create</keyword> <feature_name>writecomm</feature_name>.<feature_name>make</feature_name> <symbol>(</symbol>soc<symbol>)</symbol>; <local_variable>poller</local_variable>.<feature_name>put_write_command</feature_name> <symbol>(</symbol><local_variable>writecomm</local_variable><symbol>)</symbol>
				<local_variable>poller</local_variable>.<feature_name>make_read_only</feature_name>; <local_variable>poller</local_variable>.<feature_name>execute</feature_name> <symbol>(</symbol>15, 20000<symbol>)</symbol>
				<local_variable>poller</local_variable>.<feature_name>make_write_only</feature_name>; <local_variable>poller</local_variable>.<feature_name>execute</feature_name> <symbol>(</symbol>15, 20000<symbol>)</symbol>
				<local_variable>soc</local_variable>.<feature_name>close</feature_name>
			<keyword>end</keyword>
	
	<keyword>end</keyword>
</code_block>
				</paragraph>
				<paragraph>Procedure 
					<italic>make</italic> creates three objects: a socket, which it    associates with a specific port; a poller; and a read command (an    instance of SERVER_DATAGRAM_READER), which it attaches to the socket. It    then enters the read command into the poller, and does the same thing    with a write command. It sets up the poller to accept read commands only    and then executes the poller; this will enable the server to get the    read event triggered by the client's write command (as it appears below    in the text of class <class_name>POLLING_CLIENT</class_name>). Then the server reverses the    poller's set-up to write-only, and calls 
					<italic>execute</italic> again.
				</paragraph>
				<paragraph>The procedures 
					<italic>make_read_only</italic> and 
					<italic>make_write_only</italic> are    creation procedures, so that it is possible in a single instruction to    create a poller and set it up for read-only or write-only, as in 
					<bold>create</bold> 
					<italic>poller</italic>l. 
					<italic>make_read_only</italic>. For clarity, however, the above    class and the next separate calls to these procedures from the creation    of the poller, which uses 
					<italic>make</italic> as creation procedure.
				</paragraph>
				<paragraph>The client follows the same scheme, reversing the order of read and    write operations:    
<code_block>
<keyword>class</keyword>

	<class_name>POLLING_CLIENT</class_name>

<keyword>creation</keyword>
	<feature_name>make</feature_name>

<keyword>feature</keyword>

	<feature_name>make</feature_name> <keyword>is</keyword>
			<comment>-- Create read and write commands, attach them to a poller,</comment>
			<comment>-- set up the poller for execution.</comment>
		<keyword>local</keyword>
			<local_variable>soc</local_variable><symbol>:</symbol> <class_name>NETWORK_DATAGRAM_SOCKET</class_name> 
			<local_variable>poller</local_variable><symbol>:</symbol> <class_name>MEDIUM_POLLER</class_name> 
			<local_variable>readcomm</local_variable><symbol>:</symbol> <class_name>DATAGRAM_READER</class_name>
			<local_variable>writecomm</local_variable><symbol>:</symbol> <class_name>DATAGRAM_WRITER</class_name>
		<keyword>do</keyword>
			<keyword>create</keyword> <local_variable>soc</local_variable>.<feature_name>make_client_by_port</feature_name> <symbol>(</symbol>6530, <string>"serverhost"</string><symbol>)</symbol>
			<keyword>create</keyword> <local_variable>poller</local_variable>.<feature_name>make</feature_name>
			<keyword>create</keyword> <local_variable>readcomm</local_variable>.<feature_name>make</feature_name> <symbol>(</symbol><local_variable>soc</local_variable><symbol>)</symbol>
			<local_variable>poller</local_variable>.<feature_name>put_read_command</feature_name> <symbol>(</symbol><local_variable>readcomm</local_variable><symbol>)</symbol>
			<keyword>create</keyword> <feature_name>writecomm</feature_name>.<feature_name>make</feature_name> <symbol>(</symbol><local_variable>soc</local_variable><symbol>)</symbol>
			<local_variable>poller</local_variable>.<feature_name>put_write_command</feature_name> <symbol>(</symbol><local_variable>writecomm</local_variable><symbol>)</symbol>
			<local_variable>poller</local_variable>.<feature_name>make_write_only</feature_name>
			<local_variable>poller</local_variable>.<feature_name>execute</feature_name> <symbol>(</symbol>15, 20000<symbol>)</symbol>
			<local_variable>poller</local_variable>.<feature_name>make_read_only</feature_name>
			<local_variable>poller</local_variable>.<feature_name>execute</feature_name> <symbol>(</symbol>15, 20000<symbol>)</symbol>
			<local_variable>soc</local_variable>.<feature_name>close</feature_name>
		<keyword>rescue</keyword>
			<keyword>if</keyword> <local_variable>soc</local_variable> /<symbol>=</symbol> <keyword>Void</keyword> <keyword>and</keyword> <keyword>then</keyword> <keyword>not</keyword> <feature_name>soc</feature_name>.<feature_name>is_closed</feature_name> <keyword>then</keyword>
				<feature_name>soc</feature_name>.<feature_name>close</feature_name>
			<keyword>end</keyword>
		<keyword>end</keyword>

<keyword>end</keyword>

</code_block>
					<heading>
						<size>3</size>9.4 A less deterministic scheme
					</heading>
					<paragraph>Although the example uses the event-driven mechanisms of EiffelNet,    it is still relatively deterministic in that it follows a precise    protocol defined by a strict sequence of read and write operations on    both sides. This is why every call to 
						<italic>execute</italic> is preceded by a    call to either 
						<italic>make_read_only</italic> or 
						<italic>make_write_only </italic>to set up    the poller in the appropriate mode.
					</paragraph>
					<paragraph>A less deterministic scheme may often be desirable, where you simply    enter a number of commands (read, write, out of bounds processing) into    a poller and then wait for arbitrary events to occur and trigger    commands. There is no need with this scheme to know in advance the order    in which events may occur: a read event will trigger the command entered    into the poller through 
						<italic>put_read_command</italic>; a write event will    trigger the command entered through 
						<italic>put_write_command</italic>.
					</paragraph>
					<paragraph>To achieve this behavior, simply create the poller using 
						<italic>make</italic>    as creation procedure. This will set up the poller so as to accept all    socket events, and enter into event-driven command execution by calling 
						<italic>execute</italic>    on the poller.
					</paragraph>
				</paragraph>
			</paragraph>
		</paragraph>
	</paragraph></document>
