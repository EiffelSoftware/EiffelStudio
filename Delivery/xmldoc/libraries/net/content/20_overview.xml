<document output="studio" title="An overview of EiffelNet Mechanisms">
	<meta_data/>
	<paragraph>
		<paragraph>To enable clients and servers to exchange objects, you will have to    ensure that they can refer to a common 
			<bold>address</bold>. At the predefined    level this is really the only notion that you need to know, although it    is useful to get the bigger picture, in particular the concept of 
			<bold>socket    </bold>(which enables systems to set up communication channels), the    various forms of communication (single-machine versus multi-machine,    stream versus datagram), the kinds of object structure that may be    exchanged, the notion of packet, and how to associate commands with    communication events. The following paragraphs review these ideas and    the corresponding EiffelNet abstractions.
		</paragraph>
		<heading>
			<size>3</size>Establishing a common address
		</heading>
		<paragraph>When two systems need to communicate through sockets, they must    establish a binding through some common point of reference, called an 
			<bold>address</bold>.    Predictably, the notion of address is one of the important internal    abstractions of EiffelNet, although in most cases developers of    applications using EiffelNet do not need to manipulate address objects    directly.
		</paragraph>
		<paragraph>EiffelNet supports two modes of communication: single-machine and    multi-machine. In the single-machine case, the two communicating systems    are known to be running on the same machine. In the multi-machine case,    also known as the 
			<bold>network</bold> case, they may be running on different    machines, and communication occurs through a network. These two modes    clearly require a different binding mechanism.
		</paragraph>
		<paragraph>When a client and a server reside on the same machine, they both have    access to that machine's file system. This provides a straightforward    binding mechanism: the common address will simply be a "path    name", the Unix terminology for the full name of a file in a    hierarchically organized file system. In the examples below this file    will be 
			<italic>/tmp/here </italic>(file 
			<italic>here</italic> in the 
			<italic>/tmp</italic> directory,    conventionally used for temporary files). This file must not exist prior    to the communication; it will be created by the socket mechanisms and    then removed.
		</paragraph>
		<paragraph>For the network style of communication, this simple device of using a    path name is no longer applicable. To define a common address, we may    use two elements of information: the name of a machine, and the    indication of a 
			<bold>port</bold> on that machine. More precisely:    
			<list ordered="false">
				<item>The port will be identified by an integer. In the examples below      port 
					<italic>2000</italic> will be used.
				</item>
				<item>The machine may be identified in either of two ways: its 
					<bold>host      name</bold> (the name assigned to the machine when the operating system      was first installed on it) or its 
					<bold>Internet address</bold>, a      sequence of numbers separated by periods, such as 
					<italic>127.0.0.1</italic>.      EiffelNet routines that need an argument identifying a machine will      indifferently take a host name or an Internet address, passed in      either case as a string. In the examples below the identification      will be a host name, given as the string 
					<italic>"serverhost"</italic>.
				</item>
			</list>
			<paragraph>In network-style client-server communication, the mechanism will be    dissymmetric, reflecting the possibility (noted earlier) of a single    server catering to many clients. The clients will state both the machine    identification of their intended server and the port on which they will    talk to that server. The server, however, will only specify the port;    this means that it makes itself available to any client that cares to    talk to it on that port. This provides some of the essential flexibility    of client-server communication, where only one of the partners needs to    state beforehand whom it wants to talk to.</paragraph>
			<heading>
				<size>3</size>Sockets and communication modes
			</heading>
			<paragraph>A software system will exchange objects with another by sending them    to a socket. Although if you stay at the predefined level you will not    need to manipulate sockets explicitly, it is useful to understand this    concept and know about the corresponding EiffelNet classes.</paragraph>
			<paragraph>You may think of a socket as a communication port; by attaching    sockets together you enable communication between the corresponding    systems, for example a client and a server:</paragraph>
			<image> 
				<url>fig_2.gif</url>
			</image>
			<paragraph>EiffelNet has been designed so that sockets look very much like    files. You send objects to a socket in the same way that you write    objects onto a file, and receive objects from a socket in the same way    that you read objects from a file. This fundamental commonality is    reflected in the inheritance hierarchy of the corresponding classes:</paragraph>
			<image> 
				<url>fig_3.gif</url> 
			</image>
			<paragraph>Note that the hierarchy as shown is not complete; in particular the    full structure uses classes STREAM
				<italic/>(of which the 
				<code>
					<class_name>STREAM_</class_name>
				</code>
				<italic/>classes are heirs) and 
				<code>
					<class_name>DATAGRAM</class_name>
				</code> for multiple inheritance 
				<italic>. </italic>Only the classes below the dotted line are    part of EiffelNet; the others are part of EiffelBase, the fundamental    data structure and algorithm library of  Eiffel Software  Eiffel [2].
			</paragraph>
			<paragraph>The most important property of this inheritance hierarchy is that it    shows how sockets fit within the overall structure. Thanks to the common    ancestor <code><class_name>IO_MEDIUM</class_name></code>,    socket classes have most of their features in common with files.</paragraph>
			<paragraph>In normal usage, the only socket classes that you will need are four    classes appearing at the bottom of the above figure. They correspond to    two separate distinctions: single-machine versus multi-machine, and    reliable versus unreliable.</paragraph>
			<paragraph>On the first distinction:    
				<list ordered="false">
					<item>If the communicating systems run on the same machine, you may use      one of the 
						<code>
							<class_name>UNIX_</class_name>
						</code> classes.
					</item>
					<item>For systems that run on different machines, you must use one of      the 
						<code>
							<class_name>NETWORK_</class_name>
						</code> classes. This will also work if the systems are      on the same machine, but less efficiently since communication may go      through the network.
					</item>
				</list>
				<paragraph>The use of the word 
					<code>
						<class_name>UNIX_</class_name>
					</code> does not mean that the machine must    be running the Unix operating system; rather, it denotes a certain style    of client-server communication, the Unix style. (This is comparable to    the use of the name 
					<code>
						<class_name>UNIX_FILE</class_name>
					</code> in EiffelBase, for a class describing    files that behave in the Unix style even though they may be implemented    on non-Unix machines.)
				</paragraph>
				<paragraph>The second distinction reflects two modes of socket communication:    stream communication and datagram communication. Both of these modes    support two-way communication between systems, but with different    properties:    
					<list ordered="false">
						<item>A stream socket, as provided by the <code><class_name>STREAM_</class_name></code> classes,      provides sequenced communication without any loss or duplication of      data. Stream communication is normally synchronous: the sending      system waits until it has established a connection to the receiving      system and transmitted the data.</item>
						<item>A datagram socket, as provided by the 
							<code>
								<class_name>DATAGRAM_</class_name>
							</code>
							<italic/> classes, is      asynchronous: the sending system emits its data and does not wait      for an acknowledgment. Because the sender is not blocked, this mode      is more efficient, but it does not guarantee sequencing, reliability      or non-duplication.
						</item>
					</list>
					<heading>
						<size>3</size>Sending and receiving simple values
					</heading>
					<paragraph><code><class_name>IO_MEDIUM</class_name></code>    has all the basic input and output facilities applying to objects of    basic types, as also offered in FILE(see the specification of<code><class_name> FILE</class_name></code>    in reference [2]). So you can use sockets to send and receive    characters, integers, real numbers in simple or double precision and    strings. For example, if the type of</paragraph>
				</paragraph> `my_socket'     is one of the socket classes shown on the preceding figures, any of    the above calls will be valid:      
<code_block>
	<feature_name>my_socket</feature_name>.<feature_name>putstring</feature_name> <symbol>(</symbol><string>"Some text"</string><symbol>)</symbol> <feature_name>my_socket</feature_name>.<feature_name>readint</feature_name>; <feature_name>my_last_integer</feature_name> <symbol>:</symbol><symbol>=</symbol> <feature_name>my_socketllastint</feature_name>
</code_block>
				<paragraph>Since sockets are bidirectional, these instructions may all appear as    part of the same class provided you make sure to guarantee proper    synchronization between senders and receivers. You may also prefer to    specialize certain sockets for sending and others for receiving.</paragraph>
				<heading>
					<size>3</size>Sending and receiving object structures
				</heading>
				<paragraph>In many cases, what you will want to send and receive is not just    simple values but non-basic objects (instances of arbitrary classes,    having as many fields as needed) and, more generally, entire object    structures.</paragraph>
				<paragraph>The basic mechanism enabling a system to send objects through    EiffelNet is also the basic mechanism for storing objects into a file:    class <code><class_name>STORABLE</class_name></code>    from EiffelBase.</paragraph>
				<paragraph>As documented in [2], <code><class_name>STORABLE</class_name></code>    provides features to store and retrieve complete object structures.    There are three storage procedures, called under the respective forms   
<code_block>
	<feature_name>struct1</feature_name>.<feature_name>basic_store</feature_name> <symbol>(</symbol><feature_name>iom1</feature_name><symbol>)</symbol>
	<feature_name>struct1</feature_name>.<feature_name>general_store</feature_name> <symbol>(</symbol><feature_name>iom1</feature_name><symbol>)</symbol>
	<feature_name>struct1</feature_name>.<feature_name>independent_store</feature_name> <symbol>(</symbol><feature_name>iom1</feature_name><symbol>)</symbol>
</code_block>
					<paragraph>Assuming that the type of 
						<italic>iom1 </italic>is <code><class_name>IO_MEDIUM</class_name></code> or    a conforming type such as 
						<link>
							<url>../../base/reference/kernel/classic/file_chart.xml</url>
							<label>FILE</label>
						</link>    or one of the <code><class_name>_SOCKET</class_name></code> classes, and that the type of 
						<italic>struct1</italic>    conforms to <code><class_name>STORABLE</class_name></code> 
						<italic>.</italic>Note that reference [2] in its original version does not include 
						<italic>independent_store</italic>,    and requires 
						<italic>iom</italic> to be of type FILE    rather than the more general <code><class_name>IO_MEDIUM</class_name></code>.    The current version of EiffelBase, however, supports the more general    properties described here.
					</paragraph>
					<paragraph>All three storage procedures have the effect of sending to 
						<italic>iom1 </italic>(whether    a file, a socket or some other IO-medium) a copy of the entire object    structure starting at 
						<italic>struc1</italic>. Together with the retrieval    routines seen below, they apply the principle of reference completeness    stated in [1] and [2]:
					</paragraph>
					<table><border>1</border>
						<row>
							<cell>Whenever a routine of class <code><class_name>STORABLE</class_name></code>        stores an object into an external file, it stores with it the        dependents of that object.</cell>
							<cell>Whenever one of the associated retrieval routines retrieves a        previously stored object, it also retrieves all its dependents.</cell>
						</row>
					</table>
					<paragraph>For EiffelNet, of course, "storing" and    "retrieving" mean sending and receiving. The rest of this    section, which applies to sockets as well as to files, will continue to    use the original terminology of storage and retrieval.</paragraph>
					<paragraph>The three storage procedures differ in their degree of generality:    
						<list ordered="false">
							<item>
								<italic>basic_store</italic> will only work if the sending and retrieving      are performed by instances of the same system (the same executable      module).
							</item>
							<item>
								<italic>general_store</italic> will work if the sender and retriever are      different systems (using the same classes for the objects that they      exchange), but these systems must run on machines of the same      architecture, or at least of architectures that use the same data      representation.
							</item>
							<item>
								<italic>independent_store</italic> will work in the most general case, with      the sender and receiver possibly running on platforms using      different data representations.
							</item>
						</list>
						<paragraph>The penalty for using more general representations is that the data    representation (as stored into the file or sent to the socket) will have    to include more information. So 
							<italic>basic_store </italic>uses the most compact    representation, and 
							<italic>independent_store</italic> the most verbose.
						</paragraph>
						<paragraph>The scheme for accessing an object structure produced by one of these    three procedures is the following, used in a descendant of class <code><class_name>STORABLE</class_name></code>:</paragraph>
<code_block>	<feature_name>struct2</feature_name> <symbol>?=</symbol> <feature_name>retrieved </feature_name><symbol>(</symbol><feature_name>iom2</feature_name><symbol>)</symbol></code_block>

						<paragraph>Here 
							<italic>iom2</italic> must be of a type conforming to <code><class_name>IO_MEDIUM</class_name></code>.    The assignment attempt ?= checks that the root object of the structure    produced by the corresponding call to one of the 
							<italic>_store</italic>    procedures is of a type that conforms to the type of 
							<italic>struct2</italic>; if    not, the assignment will assign to 
							<italic>struct2</italic> a void reference.
						</paragraph>
						<paragraph>Although there are three separate storage procedures, there is only    one retrieval routine, 
							<italic>retrieved</italic>; the algorithm for 
							<italic>retrieved </italic>is    able to figure out, from the format of the retrieved objects, whether    they were produced in the basic, general or independent mode.
						</paragraph>
						<heading>
							<size>3</size>Packets
						</heading>
						<paragraph>The classes <code><class_name>PACKET</class_name></code>    and <code><class_name>DATAGRAM_PACKET</class_name></code>
							<italic/>are used to represent packets of data that can be sent to sockets.
						</paragraph>
						<paragraph>Their main use is for a system that relies on datagram communication.    As noted above, this mode does not guarantee sequencing, making each    system responsible for checking that packets arrive in the proper order.    This is possible through feature 
							<italic>number </italic>of class <code><class_name>DATAGRAM_PACKET</class_name></code>,    which
							<italic/>gives the number of the current packet.
						</paragraph>
						<heading>
							<size>3</size>Associating commands with events
						</heading>
						<paragraph>EiffelNet supports a highly asynchronous (and hence efficient) mode    of operation by offering mechanisms through which you can specify that a    certain action must be executed whenever a certain medium becomes    available for reading, writing or handling of special cases (out of    bounds). This facility is provided by a set of related classes:    
							<list ordered="false">
								<item>The actions are represented by class <code><class_name>POLL_COMMAND</class_name></code>,      an heir of the EiffelBase class 
									<code>
										<class_name>COMMAND</class_name>
									</code> with, in particular, the      procedure 
									<italic>execute</italic>.
								</item>
								<item>Using <code><class_name>MEDIUM_POLLER</class_name></code>,      you can specify that a certain command (an instance of <code><class_name>POLL_COMMAND</class_name></code>)      must be executed whenever a certain medium becomes available for the      appropriate operation (read, write, handling of out-of-bounds      cases).</item>
								<item>Using <code><class_name>POLL_MASK</class_name></code>,      you can set a mask to select the sockets or files on which your      instance of <code><class_name>MEDIUM_POLLER</class_name></code>      is working.</item>
							</list>
						</paragraph>
					</paragraph>
				</paragraph>
			</paragraph>
		</paragraph>
	</paragraph></document>
