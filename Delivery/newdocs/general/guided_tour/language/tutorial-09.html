<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML XMLNS:MSHelp="http://msdn.microsoft.com/mshelp">
	<XML>
		<MSHelp:Keyword Index="K" Term="Eiffel Tutorial, Design by Contract, Assertions, Exceptions" />
		<MSHelp:Attr Name="Product" Value="Eiffel"/>
		<MSHelp:Attr Name="Locale" Value="kbEnglish"/>
	</XML>
	<HEAD>
		<TITLE>An Eiffel Tutorial, Design by Contract&#153, Assertions, Exceptions</TITLE>
		<LINK HREF="../../../default.css" TYPE="text/css" REL="STYLESHEET">
	</HEAD>
	<BODY>
		<TABLE CLASS="HEADER">
			<TR>
				<TD CLASS="HEADER">Eiffel ENViSioN!</TD>
			</TR>
			<TR>
				<TD CLASS="SUBHEADER">An Eiffel Tutorial, Design by Contract&#153, Assertions, Exceptions</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FRAME">
			<TR>
				<TD>
					<P>Eiffel directly implements the ideas of Design by
					Contract&#153, which enhance software reliability and provide
					a sound basis for software specification, documentation and
					testing, as well as exception handling and the proper use of
					inheritance.</P>

					<H2>Design by Contract&#153 basics</H2>

					<P>A system -- a software system in particular, but the ideas
					are more general -- is made of a number of cooperating
					components. Design by Contract&#153 states that their cooperation
					should be based on precise specifications --
					<SPAN CLASS="italics">contracts</SPAN> -- describing each
					party's expectations and guarantees.</P>

					<P>An Eiffel contract is similar to a real-life contract
					between two people or two companies, which it is convenient
					to express in the form of tables listing the expectations and
					guarantees. Here for example is how we could sketch the
					contract between a homeowner and the telephone company:</P>

					<TABLE CLASS="WITHBORDER">
						<TR>
							<TD>
							</TD>
							<TH>
								OBLIGATIONS
							</TH>
							<TH>
								BENEFITS
							</TH>
						</TR>
						<TR>
							<TD>
								<SPAN CLASS="bold">Client</SPAN>
							</TD>
							<TD>
								(Satisfy precondition:)<BR />
								<SPAN CLASS="bold">Pay bill</SPAN>
							</TD>
							<TD>
								(From postcondition:)<BR />
								<SPAN CLASS="bold">Get telephone service</SPAN>
							</TD>
						</TR>
						<TR>
							<TD>
								<SPAN CLASS="bold">Supplier</SPAN>
							</TD>
							<TD>
								(Satisfy postcondition:)<BR />
								<SPAN CLASS="bold">Provide telephone service</SPAN>
							</TD>
							<TD>
								(From precondition:)<BR />
								<SPAN CLASS="bold">No need to provide anything
								if bill not paid</SPAN>
							</TD>
						</TR>
					</TABLE>

					<P>Note how the obligation for each of the parties maps onto
					a benefit for the other. This will be a general pattern.</P>

					<P>The client's obligation, which protects the supplier, is
					called a <SPAN CLASS="bold">precondition</SPAN>. It states
					what the client must satisfy before requesting a certain
					service. The client's benefit, which describes what the
					supplier must do (assuming the precondition was satisfied),
					is called a <SPAN CLASS="bold">postcondition</SPAN>.</P>

					<P>In addition to preconditions and postconditions, contract
					clauses include <SPAN CLASS="bold">class invariants</SPAN>,
					which apply to a class as a whole. More precisely a class
					invariant must be ensured by every creation procedure (or
					by the default initialization if there is no creation
					procedure), and maintained by every exported routine of the
					class.</P>

					<H2>Expressing assertions</H2>

					<P>Eiffel provides syntax for expressing preconditions
					(<SPAN CLASS="ekeyword">require</SPAN>), postconditions
					(<SPAN CLASS="ekeyword">ensure</SPAN>) and class invariants
					(<SPAN CLASS="ekeyword">invariant</SPAN>), as well as other
					assertion constructs studied later (see
					<A HREF="tutorial-11.html#38021">&quot;Instructions&quot;</A>):
					loop invariants and variants, check instructions.</P>

					<P>Here is a partial update of class
					<SPAN CLASS="eclass">ACCOUNT</SPAN> with more assertions:</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">indexing</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eitag">description</SPAN>:
						<SPAN CLASS="estring">&quot;Simple bank accounts&quot;</SPAN></P>

						<P><SPAN CLASS="ekeyword">class</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">ACCOUNT</SPAN>

						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="ecomment">-- Access</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">balance</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Current balance</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">deposit_count</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN> <SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Number of deposits made since opening</SPAN>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8230; As before &#8230;</P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="ecomment">-- Element change</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">deposit</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">sum</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Add <SPAN CLASS="elocal">sum</SPAN> to account.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">require</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">non_negative</SPAN>: <SPAN CLASS="elocal">sum</SPAN>
						<SPAN CLASS="esymbol">&gt;=</SPAN> <SPAN CLASS=enumber>0</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#8230; As before &#8230;</P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">ensure</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">one_more_deposit:</SPAN><BR />
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">deposit_count</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="ekeyword">old</SPAN>
						<SPAN CLASS="efeature">deposit_count</SPAN>
						<SPAN CLASS="esymbol">+</SPAN>
						<SPAN CLASS="enumber">1</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">updated:</SPAN>
						<SPAN CLASS="efeature">balance</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="ekeyword">old</SPAN>
						<SPAN CLASS="efeature">balance</SPAN>
						<SPAN CLASS="esymbol">+</SPAN>
						<SPAN CLASS="elocal">sum</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="esymbol">{</SPAN><SPAN CLASS="eclass">NONE</SPAN><SPAN CLASS="esymbol">}</SPAN>
						<SPAN CLASS="ecomment">-- Implementation</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">all_deposits</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">DEPOSIT_LIST</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- List of deposits since account's opening.</SPAN></P>

						<P><SPAN CLASS="ekeyword">invariant</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eitag">consistent_balance:</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">all_deposits</SPAN>
						<SPAN CLASS="esymbol">/=</SPAN>
						<SPAN CLASS="efeature">Void</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">implies<BR /></SPAN>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">balance</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="efeature">all_deposits</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">total</SPAN><SPAN CLASS="esymbol">)</SPAN></P>


						<P>&nbsp;&nbsp;
						<SPAN CLASS="eitag">zero_if_no_deposits:</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">all_deposits</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="efeature">Void</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">implies<BR /></SPAN>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">balance</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="enumber">0</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P><SPAN CLASS="ekeyword">end</SPAN>
						<SPAN CLASS="ecomment">-- class</SPAN> ACCOUNT</P>
					</CODE>

					<P>Each assertion is made of one or more subclauses, each of
					them a boolean expression (with the additional possibility
					of the <SPAN CLASS="ekeyword">old</SPAN> construct). The
					effect of including more than one subclause, as in the
					postcondition of <SPAN CLASS="efeature">deposit</SPAN> and
					in the invariant, is the same as connecting them through an
					<SPAN CLASS="ekeyword">and</SPAN>. Each clause may be
					preceded by a label, such as
					<SPAN CLASS="eitag">consistent_balance</SPAN> in the
					invariant, and a colon; the label is optional and does not
					affect the assertion's semantics, except for error reporting
					as explained in the next section, but including it
					systematically is part of the recommended style. The value
					of the boolean expression <SPAN CLASS="elocal">a</SPAN>
					<SPAN CLASS="ekeyword">implies</SPAN>
					<SPAN CLASS="elocal">b</SPAN> is true except if
					<SPAN CLASS="elocal">a</SPAN> is true and
					<SPAN CLASS="elocal">b</SPAN> false.</P>

					<P>Because assertions benefit from the full power of boolean
					expressions, they may include function calls. This makes it
					possible to express sophisticated consistency conditions,
					such as
					&quot;<SPAN CLASS="italics">the graph contains no cycle</SPAN>&quot;,
					which would not be otherwise expressible through simple
					expressions, or even through first-order predicate calculus,
					but which are easy to implement as Eiffel functions
					returning boolean results.</P>

					<P>The precondition of a routine expresses conditions that
					the routine is imposing on its clients. Here a call to
					<SPAN CLASS="efeature">deposit</SPAN> is correct if and only
					if the value of the argument is non-negative. The routine
					does not guarantee anything for a call that does not satisfy
					the precondition. It is in fact part of the Eiffel method
					that a routine body should <SPAN CLASS="bold">never</SPAN>
					test for the precondition, since it is the client's
					responsibility to ensure it. (An apparent paradox of
					Design by Contract&#153, which is reflected in the
					bottom-right entries of the preceding and follwing contract
					tables, and should not be a paradox any more at the end of
					this discussion, is that one can get
					<SPAN CLASS="italics">more</SPAN> reliable software by
					having <SPAN CLASS="italics">fewer</SPAN> explicit checks in
					the software text.)</P>

					<P>The postcondition of a routine expresses what the routine
					guaranteed to its clients for calls satisfying the
					precondition. The notation <SPAN CLASS="ekeyword">old</SPAN>
					<SPAN CLASS="efeature">expression</SPAN>, valid in
					postconditions (<SPAN CLASS="ekeyword">ensure</SPAN> clauses)
					only, denotes the value that
					<SPAN CLASS="efeature">expression</SPAN> had on entry to the
					routine.</P>

					<P>The precondition and postcondition state the terms of the
					contract between the routine and its clients, similar to the
					earlier example of a human contract:</P>


					<TABLE CLASS="WITHBORDER">
						<TR>
							<TH>
								deposit
							</TH>
							<TH>
								OBLIGATIONS
							</TH>
							<TH>
								BENEFITS
							</TH>
						</TR>
						<TR>
							<TD>
								<SPAN CLASS="bold">Client</SPAN>
							</TD>
							<TD>
								(Satisfy precondition:)<BR />
								<SPAN CLASS="bold">Use a non-negative argument.</SPAN>
							</TD>
							<TD>
								(From postcondition:)<BR />
								<SPAN CLASS="bold">Get deposits list and balance updated.</SPAN>
							</TD>
						</TR>
						<TR>
							<TD>
								<SPAN CLASS="bold">Supplier</SPAN>
							</TD>
							<TD>
								(Satisfy postcondition:)<BR />
								<SPAN CLASS="bold">Update deposits list and balance.</SPAN>
							</TD>
							<TD>
								(From precondition:)<BR />
								<SPAN CLASS="bold">No need to handle negative arguments.</SPAN>
							</TD>
						</TR>
					</TABLE>

					<P>The class invariant, as noted, applies to all features.
					It must be satisfied on exit by any creation procedure, and
					is implicitly added to both the precondition and
					postcondition of every exported routine. In this respect it
					is both good news and bad news for the routine implementer:
					good news because it guarantees that the object will
					initially be in a stable state, averting the need in the
					example to check that the total of
					<SPAN CLASS="efeature">all_deposits</SPAN> is compatible with
					the <SPAN CLASS="efeature">balance</SPAN>; bad news because,
					in addition to its official contract as expressed by its
					specific postcondition, every routine must take care of
					restoring the invariant on exit.</P>

					<P>A requirement on meaningful contracts is that they should
					be in good faith: satisfiable by an honest partner. This
					implies a consistency rule: if a routine is exported to a
					client (either generally or selectively), any feature
					appearing in its precondition must also be available to that
					client. Otherwise -- for example if the precondition included
					<SPAN CLASS="ekeyword">require</SPAN>
					<SPAN CLASS="efeature">n</SPAN> <SPAN CLASS="esymbol">&gt;</SPAN>
					<SPAN CLASS="enumber">0</SPAN>, where
					<SPAN CLASS="efeature">n</SPAN> is a secret attribute -- the
					supplier would be making demands that a good-faith client
					cannot possibly check for.</P>

					<P>Note in this respect that
					<SPAN CLASS="italics">guaranteeing</SPAN> a precondition does
					not necessarily mean, for the client,
					<SPAN CLASS="italics">testing</SPAN> for it. Assuming
					<SPAN CLASS=efeature>n</SPAN> is exported, a call may test for
					the precondition</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">if</SPAN>
						<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">n</SPAN>
						<SPAN CLASS="esymbol">&gt;</SPAN>
						<SPAN CLASS="enumber">0</SPAN>
						<SPAN CLASS="ekeyword">then</SPAN>
						<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">r</SPAN>
						<SPAN CLASS="ekeyword">end</SPAN>
					</CODE>

					<P>possibly with an <SPAN CLASS="ekeyword">else</SPAN>
					part. But if the context of the call, in the client's code,
					implies that <SPAN CLASS="efeature">n</SPAN> is positive --
					perhaps because some preceding call set it to the sum of two
					squares -- then there is no need for an
					<SPAN CLASS="ekeyword">if</SPAN> or similar construct.</P>

					<P CLASS=note>In such a case, a
					<SPAN CLASS="ekeyword">check</SPAN> instruction as introduced
					later
					(<A HREF="tutorial-11.html#38021">&quot;Instructions&quot;</A>)
					is recommended if the reason for omitting the test is non-trivial.</P>

					<H2>Using contracts for built-in reliability</H2>

					<P>What are contracts good for? Their first use is purely
					methodological. By applying a discipline of expressing, as
					precisely as possible, the logical assumptions behind
					software elements, you can write software whose reliability
					is built-in: software that is developed hand-in-hand with the
					rationale for its correctness.</P>

					<P>This simple observation -- usually not clear to people
					until they have practiced Design by Contract&#153 thoroughly on a
					large-scale project -- brings as much change to software
					practices and quality as the rest of object technology.</P>

					<H2>Run-time assertion monitoring</H2>

					<P>Contracts in Eiffel are not just wishful thinking. They
					can be monitored at run time under the control of compilation
					options.</P>

					<P>It should be clear from the preceding discussion that
					contracts are not a mechanism to test for special conditions,
					for example erroneous user input. For that purpose, the usual
					control structures (<SPAN CLASS="ekeyword">if</SPAN>
					<SPAN CLASS="efeature">deposit_sum</SPAN>
					<SPAN CLASS="esymbol">&gt;=</SPAN>
					<SPAN CLASS="enumber">0</SPAN> <SPAN CLASS="ekeyword">then</SPAN>
					&#8230;) are available, complemented in applicable cases by
					the exception handling mechanism reviewed next. An assertion
					is instead a <SPAN CLASS="bold">correctness condition</SPAN>
					governing the relationship between two software modules (not
					a software module and a human, or a software module and an
					external device). If <SPAN CLASS="elocal">sum</SPAN> is
					negative on entry to <SPAN CLASS="efeature">deposit</SPAN>,
					violating the precondition, the culprit is some other
					software element, whose author was not careful enough to
					observe the terms of the deal. Bluntly:

					<P CLASS="tip"><SPAN CLASS="bold">Assertion Violation
					rule</SPAN><BR />
					A run-time assertion violation is the manifestation of a bug.</P>

					<P>To be more precise:</P>

					<UL>
						<LI>A precondition violation signals a bug in the client,
						which did not observe its part of the deal.</LI>

						<LI>A postcondition (or invariant) violation signals a
						bug in the supplier -- the routine -- which did not do
						its job.</LI>
					</UL>

					<P>That violations indicate bugs explains why it is
					legitimate to enable or disable assertion monitoring
					through mere compilation options: for a correct system
					-- one without bugs -- assertions will always hold, so the
					compilation option makes no difference to the semantics of
					the system.</P>

					<P>But of course for an incorrect system the best way to
					find out where the bug is -- or just that there is a bug
					-- is often to monitor the assertions during development and
					testing. Hence the presence of the compilation options, which
					the tool lets you set separately for each cluster, with
					defaults at the system level.</P>

					<P>An assertion violation, if detected at run time under one
					of these options other than the first, will cause an
					exception
					(<A HREF="#10722">&quot;Exception handling&quot;</A>).
					Unless the software has an explicit &quot;retry&quot; plan as
					explained in the discussion of exceptions, the violation will
					cause produce an exception trace and cause termination (or,
					in the tool, a return to the environment's browsing and
					debugging facilities at the point of failure). If present,
					the label of the violated subclause will be displayed, to help
					identify the problem.</P>

					<P>Only checking preconditions is particularly interesting
					in connection with the Eiffel method's insistence on reuse:
					with libraries such as EiffelBase, richly equipped with
					preconditions expressing terms of use, an error in the
					<SPAN CLASS="bold">client software</SPAN> will often lead,
					for example through an incorrect argument, to violating one
					of these preconditions. A somewhat paradoxical consequence
					is that even an application developer who does not apply the
					method too well (out of carelessness, haste, indifference or
					ignorance) will still benefit from the presence of contracts
					in <SPAN CLASS="italics">someone else</SPAN>'s library code.</P>

					<P>During development and testing, assertion monitoring
					should be turned on at the highest possible level. Combined
					with static typing, this permits the development process
					mentioned in the section
					<A HREF="tutorial-04.html#94733">&quot;Quality and functionality&quot;</A>,
					where errors are exterminated at birth. No one who has not
					practiced the method in a real project can imagine how many
					mistakes are found in this way; surprisingly often, a
					violation will turn out to affect an assertion that was just
					included for goodness' sake, the developer being convinced
					that it could never &quot;possibly&quot; fail to be satisfied.</P>

					<P>By providing a precise reference (the description of what
					the software is supposed to do) against which to assess the
					reality (what the software actually does), Design by Contract&#153
					profoundly transforms the activities of debugging, testing and
					quality assurance.</P>

					<P>When releasing the final version of a system, it is
					usually appropriate to turn off assertion monitoring, or
					bring it down to the <SPAN CLASS="ekeyword">require</SPAN>
					level. The exact policy depends on the circumstances; it is
					a tradeoff between efficiency considerations, the potential
					cost of mistakes, and how much the developers and quality
					assurance team trust the product. When developing the
					software, however, you should always assume -- to avoid
					loosening your guard -- that in the end monitoring will be
					turned off.</P>

					<A NAME="pgfId-514906"><H2></A>The contract form of a class</H2>

					<P>Another application of assertions governs documentation.
					Environment mechanisms, such as clicking the
					<SPAN CLASS="ekeyword">Contract Form</SPAN> icon in
					EifffelStudio or creation a
					<SPAN CLASS="ekeyword">Documentation Project</SPAN> in Eiffel
					ENViSioN!, will produce, from a class text, an abstracted
					version which only includes the information relevant for
					client authors. Here is the contract form of class
					<SPAN CLASS=eclass>ACCOUNT</SPAN> in the latest version given:</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">indexing</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eitag">description:</SPAN>
						<SPAN CLASS="estring">&quot;Simple bank accounts&quot;</SPAN></P>

						<P><SPAN CLASS="ekeyword">class</SPAN>
						<SPAN CLASS="ekeyword">interface</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">ACCOUNT</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN>

						<SPAN CLASS="ecomment">-- Access</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">balance</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Current balance</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">deposit_count</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Number of deposits made since opening</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="ecomment">-- Element change</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">deposit</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">sum</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Add <SPAN CLASS="elocal">sum</SPAN> to account.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">require</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">non_negative</SPAN><SPAN CLASS="eysmbol">:</SPAN>
						<SPAN CLASS="elocal">sum</SPAN> <SPAN CLASS="esymbol">&gt;=</SPAN>
						<SPAN CLASS="enumber">0</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">ensure</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">one_more_deposit:</SPAN>
						<SPAN CLASS="efeature">deposit_count</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="ekeyword">old</SPAN>
						<SPAN CLASS="efeature">deposit_count</SPAN> <SPAN CLASS="esymbol">+</SPAN>
						<SPAN CLASS="enumber">1</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">updated:</SPAN>
						<SPAN CLASS="efeature">balance</SPAN>
						<SPAN CLASS="esymbol">=</SPAN> <SPAN CLASS="ekeyword">old</SPAN>
						<SPAN CLASS="efeature">balance</SPAN> <SPAN CLASS="esymbol">+</SPAN>
						<SPAN CLASS="elocal">sum</SPAN></P>

						<P><SPAN CLASS="ekeyword">invariant</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eitag">consistent_balance:</SPAN>
						<SPAN CLASS="efeature">balance</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="efeature">all_deposits</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">total</SPAN></P>

						<P><SPAN CLASS="ekeyword">end</SPAN>
						<SPAN CLASS="ecomment">-- class interface</SPAN> ACCOUNT</P>
					</CODE>

					<P>The words <SPAN CLASS="ekeyword">class interface</SPAN>
					are used instead of just <SPAN CLASS="ekeyword">class</SPAN>
					to avoid any confusion with actual Eiffel text, since this
					is documentation, not executable software. (It is in fact
					possible to generate a compilable variant of the Contract
					Form in the form of a deferred class, a notion defined later.)</P>

					<P>Compared to the full text, the Contract Form of a class
					(also called its &quot;<SPAN CLASS="italics">short form</SPAN>&quot;)
					retains all its interface properties, relevant to client authors:</P>

					<UL>
						<LI>Names and signatures (argument and result type
						information) for exported features.</LI>

						<LI>Header comments of these features, which carry
						informal descriptions of their purpose. (Hence the
						importance, mentioned in section
						<A HREF="tutorial-05.html#pgfId-514073">4</A>, of always
						including such comments and writing them carefully.)</LI>

						<LI>Preconditions and postconditions of these features
						(at least the subclauses involving only exported
						features).</LI>

						<LI>Class invariant (same observation).</LI>
					</UL>

					<P>The following elements, however, are not in the Contract
					Form: any information about non-exported features; all the
					routine bodies
					(<SPAN CLASS="ekeyword">do</SPAN> clauses, or the
					<SPAN CLASS="ekeyword">external</SPAN> and
					<SPAN CLASS="ekeyword">once</SPAN> variants seen in
					<A HREF="tutorial-06.html#91180">&quot;External software&quot;</A>
					above and
					<A HREF="tutorial-11.html#71816">&quot;Once routines and shared objects&quot;</A>
					below); assertion subclauses involving non-exported features;
					and some keywords not useful in the documentation, such as
					<SPAN CLASS="ekeyword">is</SPAN> for a routine.</P>

					<P>In accordance with the
					<A HREF="tutorial-07.html#UNIFORM ACCESS">Uniform Access principle</A>,
					the Contract Form does not distinguish between attributes and
					argument-less queries. In the above example,
					<SPAN CLASS="efeature">balance</SPAN> could be one or the
					other, as it makes no difference to clients, except
					possibly for performance.</P>

					<P>The Contract Form is the fundamental tool for using
					supplier classes in the Eiffel method. It enables client
					authors to reuse software elements without having to read
					their source code. This is a crucial requirement in
					large-scale industrial developments.</P>

					<P>The Contract Form satisfies two key requirements of good
					software documentation:</P>

					<UL>
						<LI>It is truly abstract, free from the implementation
						details of what it describes and concentrating instead
						on its functionality.</LI>

						<LI>Rather than being developed separately -- an
						unrealistic requirement, hard to impose on developers
						initially and becoming impossible in practice if we
						expect the documentation to remain up to date as the
						software evolves -- the documentation is extracted from
						the software itself. It is not a separate product but a
						different view of the same product. This prolongs the
						<SPAN CLASS="bold">Single Product</SPAN> principle that
						lies at the basis of Eiffel's seamless development model
						(section <A HREF="tutorial-04.html#pgfId-513940">3</A>).</LI>
					</UL>

					<P>The Contract Form is only one of the relevant views.
					EiffelStudio, for example, generates graphical
					representations of system structures, to show classes and
					their relations -- client, inheritance -- according to the
					conventions of BON (the Business Object Notation). In
					accordance with the principles of seamlessness and
					reversibility, EiffelStudio lets you both work on the text,
					producing the graphics on the fly, or work on the graphics,
					updating the text on the fly; you can alternate as you wish
					between these two modes. The resulting process is quite
					different from more traditional approaches based on separate
					tools: an analysis and CASE workbench, often based on UML,
					to deal with an initial &quot;bubble-and-arrow&quot;
					description; and a separate programming environment, to deal
					with implementation aspects only. In Eiffel the environment
					provides consistent, seamless support from beginning to end.</P>

					<P>The Contract Form -- or its variant the Flat-Contract
					Form, which takes account of inheritance
					(<A HREF="tutorial-10.html#11134">&quot;Flat and Flat-Contract Forms&quot;,  page 72</A>)
					are the standard form of library documentation, used
					extensively, for example, in the book
					<A HREF="http://www.eiffel.com/doc/page.html#rs">Reusable Software</A>.
					Assertions play a central role in such documentation by
					expressing the terms of the contract. As demonstrated
					<SPAN CLASS="italics">a contrario</SPAN> by the widely
					publicized $500-million crash of the Ariane-5 rocket launcher
					in June of 1996, due to the incorrect reuse of a software
					module from the Ariane-4 project,
					<SPAN CLASS="bold">reuse without a contract documentation</SPAN>
					is the path to disaster. Non-reuse would, in fact, be preferable.</P>

					<A NAME="pgfId-514963"></A><A NAME="10722"></A><H2>Exception handling</H2>

					<P>Another application of Design by Contract&#153 governs the
					 handling of unexpected cases. The vagueness of many
					 discussions of this topic follows from the lack of a precise
					 definition of terms such as &quot;exception&quot;.
					 With Design by Contract&#153 we are in a position to be
					 specific:</P>

					 <UL>
						<LI>Any routine has a contract to achieve.</LI>

						<LI>Its body defines a strategy to achieve it -- a
						sequence of operations, or some other control
						structure involving operations. Some of these
						operations are calls to routines, with their own
						contracts; but even an atomic operation, such as the
						computation of an arithmetic operation, has an implicit
						contract, stating that the result will be representable.</LI>

						<LI>Any one of these operations may
						<SPAN CLASS="ekeyword">fail</SPAN>, that is to say be
						unable to meet its contract; for example an arithmetic
						operation may produce an overflow (a non-representable result).</LI>

						<LI>The failure of an operation is an
						<SPAN CLASS="bold">exception</SPAN> for the routine that
						needed the operation.</LI>

						<LI>As a result the routine may fail too -- causing an
						exception in its own caller.</LI>
					</UL>

					<P>Note the precise definitions of the two key concepts, failure
					and exception. Although failure is the more basic one -- since
					it is defined for atomic, non-routine operations -- the
					definitions are mutually recursive, since an exception may cause
					a failure of the recipient routine, and a routine's failure
					causes an exception in its own caller.</P>

					<P>Why state that an exception &quot;may&quot; cause a failure?
					It is indeed possible to &quot;rescue&quot; a routine from
					failure in the case of an exception, by equipping it with a
					clause labeled <SPAN CLASS="ekeyword">rescue</SPAN>, as in:</P>

					<CODE>
						<P><SPAN CLASS="efeature">read_next_character</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">f</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">FILE</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Make next character available in
						<SPAN CLASS="efeature">last_character</SPAN>;</SPAN>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- if <SPAN CLASS="elocal">impossible</SPAN>,
						set <SPAN CLASS="efeature">failed</SPAN> to True.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">require</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">readable:</SPAN>
						<SPAN CLASS="efeature">file</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">readable</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">local</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="elocal">impossible</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">BOOLEAN</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">if</SPAN>
						<SPAN CLASS="elocal">impossible</SPAN>
						<SPAN CLASS="ekeyword">then</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">failed</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="efeature">True</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">else</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">last_character</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="efeature">low_level_read_function</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">f</SPAN><SPAN CLASS="esymbol">)</SPAN>
						</P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">rescue</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="elocal">impossible</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="efeature">True</SPAN>
						</P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">retry</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>This example includes the only two constructs needed for
					exception handling: <SPAN CLASS="ekeyword">rescue</SPAN> and
					<SPAN CLASS="ekeyword">retry</SPAN>. A
					<SPAN CLASS="ekeyword">retry</SPAN> instruction is only
					permitted in a rescue clause; its effect is to start again the
					execution of the routine, without repeating the initialization
					of local entities (such as <SPAN CLASS="efeature">impossible</SPAN>
					in the example, which was initialized to
					<SPAN CLASS="efeature">False</SPAN> on first entry). Features
					<SPAN CLASS="efeature">failed</SPAN> and
					<SPAN CLASS="efeature">last_character</SPAN> are assumed to be
					attributes of the enclosing class.</P>

					<P>This example is typical of the use of exceptions: as a last
					resort, for situations that should not occur. The routine has
					a precondition,
					<SPAN CLASS="efeature">file</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">readable</SPAN>,
					which ascertains that the file exists and is accessible for
					reading characters. So clients should check that everything is
					fine before calling the routine. Although this check is almost
					always a guarantee of success, a rare combination of
					circumstances could cause a change of file status (because a
					user or some other system is manipulating the file) between
					the check for <SPAN CLASS="efeature">readable</SPAN> and the
					call to <SPAN CLASS="efeature">low_level_read_function</SPAN>.
					If we assume this latter function will fail if the file is not
					readable, we must catch the exception.</P>

					<P>A variant would be</P>

					<CODE>
						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">local</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="elocal">attempts</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">if</SPAN>
						<SPAN CLASS="elocal">attempts</SPAN>
						<SPAN CLASS="esymbol">&lt;</SPAN>
						<SPAN CLASS="efeature">Max_attempts</SPAN>
						<SPAN CLASS="ekeyword">then</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">last_character</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="efeature">low_level_read_function</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">f</SPAN><SPAN CLASS="esymbol">)</SPAN>
						</P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">else</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">failed</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="efeature">True</SPAN>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">rescue</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="elocal">attempts</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="elocal">attempts</SPAN> <SPAN CLASS="esymbol">+</SPAN>
						<SPAN CLASS="enumber">1</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">retry</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>which would try again up to
					<SPAN CLASS="efeature">Max_attempts</SPAN> times before giving up.</P>

					<P>The above routine, in either variant, never fails: it always
					fulfills its contract, which states that it should either read
					a character or set <SPAN CLASS="efeature">failed</SPAN> to record
					its inability to do so. In contrast, consider the new variant

					<CODE>
						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">local</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="elocal">attempts</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">last_character</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="efeature">low_level_read_function</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">f</SPAN><SPAN CLASS="esymbol">)</SPAN>
						</P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">rescue</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="elocal">attempts</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="elocal">attempts</SPAN> <SPAN CLASS="esymbol">+</SPAN>
						<SPAN CLASS="enumber">1</SPAN>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">if</SPAN>
						<SPAN CLASS="elocal">attempts</SPAN> <SPAN CLASS="esymbol">&lt;</SPAN>
						<SPAN CLASS="efeature">Max_attempts</SPAN>
						<SPAN CLASS="ekeyword">then</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">retry</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>with no more role for <SPAN CLASS="efeature">failed</SPAN>.
					In this case, after <SPAN CLASS="efeature">Max_attempts</SPAN>
					unsuccessful attempts, the routine will execute its
					<SPAN CLASS="ekeyword">rescue</SPAN> clause to the end, with no
					<SPAN CLASS="ekeyword">retry</SPAN> (the
					<SPAN CLASS="ekeyword">if</SPAN> having no
					<SPAN CLASS="ekeyword">else</SPAN> clause). This is how a routine
					<SPAN CLASS="bold">fails</SPAN>. It will, as noted, pass on the
					exception to its caller.</P>

					<P>Such a rescue clause should, before terminating, restore the
					invariant of the class so that the caller and possible
					subsequent <SPAN CLASS="ekeyword">retry </SPAN> attempts from
					higher up find the objects in a consistent state. As a result,
					the rule for an absent <SPAN CLASS="ekeyword">rescue</SPAN>
					clause -- the case for the vast majority of routines in most
					systems -- is that it is equivalent to</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">rescue</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">default_rescue</SPAN></P>
					</CODE>

					<P>where procedure <SPAN CLASS="efeature">default_rescue</SPAN>
					comes from <SPAN CLASS="eclass">ANY</SPAN>, where it is defined
					to do nothing; in a system built for robustness, classes subject
					to non-explicitly-<SPAN CLASS="ekeyword">rescue</SPAN>d
					exceptions should redefine
					<SPAN CLASS="efeature">default_rescue</SPAN> (perhaps using a
					creation procedure, which is bound by the same formal
					requirement) so that it will always restore the invariant.</P>

					<P>Behind Eiffel's exception handling scheme lies the principle
					-- at first an apparent platitude, but violated by many existing
					mechanisms -- that a routine should
					<SPAN CLASS="bold">either succeed or fail</SPAN>. This is in turn
					a consequence of Design by Contract&#153 principles: succeeding
					means being able to fulfill the contract, possibly after one or
					more <SPAN CLASS="ekeyword">retry</SPAN>; failure is the other
					case, which must always trigger an exception in the caller.
					Otherwise it would be possible for a routine to miss its contract
					and yet return to its caller in a seemingly normal state. That is
					the worst possible way to handle an exception.</P>

					<P>Concretely, exceptions may result from the following events:</P>

					<UL>
						<LI>A routine failure (<SPAN CLASS="ekeyword">rescue</SPAN>
						clause executed to the end with no
						<SPAN CLASS="ekeyword">retry</SPAN>), as just seen.</LI>

						<LI>Assertion violation, if for a system that runs with
						assertion monitoring on.</LI>

						<LI>Attempt to call a feature on a void reference:
						<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">f</SPAN>
						<SPAN CLASS="esymbol">(</SPAN>&#8230;<SPAN CLASS="esymbol">)</SPAN>,
						the fundamental computational mechanism, can only work if
						<SPAN CLASS="elocal">x</SPAN> is attached to an object, and
						will cause an exception otherwise.</LI>

						<LI>Developer exception, as seen next.</LI>

						<LI>Operating system signal:arithmetic overfolow; no memory
						available for a requested creation or clone -- even after
						garbage collection has rummaged everything to find some
						space. (But no C/C++-like &quot;wrong pointer address&quot;,
						which cannot occur thanks to the statically typed nature of
						Eiffel.)</LI>
					</UL>

					<P>It is sometimes useful, when handling exceptions in
					<SPAN CLASS="ekeyword">rescue</SPAN> clauses, to ascertain the
					exact nature of the exception that got the execution there. For
					this it is suffices to inherit from the Kernel Library class
					<SPAN CLASS="eclass">EXCEPTIONS</SPAN>, which provides queries
					such as <SPAN CLASS="efeature">exception</SPAN>, giving the code
					for the last exception, and symbolic names
					(<A HREF="tutorial-11.html#94304">&quot;Constant and unique attributes&quot;</A>)
					for all such codes, such as
					<SPAN CLASS="efeature">No_more_memory</SPAN>. You can then
					process different exceptions differently by testing
					<SPAN CLASS="efeature">exception</SPAN> against various
					possibilities. The method strongly suggests, however, that
					exception handling code should remain simple; a complicated
					algorithm in a <SPAN CLASS="ekeyword">rescue</SPAN> clause is
					usually a sign that the mechanism is being misused.</P>

					<P>Class <SPAN CLASS="eclass">EXCEPTIONS</SPAN> also provides various
					facilities for fine-tuning the exception facilities, such as a
					procedure <SPAN CLASS="efeature">raise</SPAN> that will explicitly
					trigger a &quot;developer exception&quot; with a code than can then
					be detected and processed.</P>

					<P>Exception handling helps produce Eiffel software that is not just
					correct but robust, by planning for cases that should
					<SPAN CLASS="italics">not</SPAN> normally arise, but might out of
					Murphy's law, and ensuring they do not affect the software's basic
					safety and simplicity.</P>

					<H2>Other applications of Design by Contract&#153</H2>

					<P>The Design by Contract&#153 ideas pervade the Eiffel method.
					In addition to the applications just mentioned, they have two
					particularly important consequences:</P>

					<UL>
						<LI>They make it possible to use Eiffel for analysis and
						design. At a high level of abstraction, it is necessary to
						be precise too. With the exception of BON, object-oriented
						analysis and design methods tend to favor abstraction over
						precision. Thanks to assertions, it is possible to express
						precise properties of a system
						(&quot;<SPAN CLASS="italics">At what speed should the alarm
						start sounding?</SPAN>&quot;) without making any commitment
						to implementation. The discussion of deferred classes
						(<A HREF="tutorial-10.html#48949">&quot;Applications of deferred classes&quot;</A>)
						will show how to write a purely descriptive, non-software
						model in Eiffel, using contracts to describe the essential
						properties of a system without any computer or software aspect.</LI>

						<LI>Assertions also serve to control the power of
						inheritance-related mechanisms -- redeclaration,
						polymorphism, dynamic binding -- and channel them to correct
						uses by assigning the proper semantic limits. See
						<A HREF="tutorial-10.html#83610">&quot;Inheritance and contracts&quot;</A>.</LI>
					</UL>

					<P CLASS="seealso"><B>See also</B><BR />
						<A HREF="tutorial-10.html">Inheritance</A>
					</P>
				</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FOOTER" ID="Table3">
			<TR>
				<TD>© 2003-2004 Eiffel Software. All rights reserved.</TD>
			</TR>
		</TABLE>
	</BODY>
</HTML>