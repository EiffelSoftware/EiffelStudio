<document title="Genericity">
	<meta_data>
		<help>
			<toc>
				<envision_location>Eiffel\Eiffel for .NET</envision_location>
				<envision_pseudo_name>40</envision_pseudo_name>
				<envision_title>Genericity</envision_title>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph>We got a very short introduction to generic classes when we were looking at the formal generic part of class structure in 
			<link>
				<url>../../eiffel_dotnet_language/20_language/10_eiffel_classes.xml</url>
				<label>Eiffel Classes</label>
			</link>. That discussion left to the imagination the motivation and benefits for creating generic classes.
		</paragraph>
		<paragraph>You will see that most of the generic classes model containers for multiple items and at least one of their formal generic parameters represents the type of items that are to be stored in the container. Some generic classes, like 
			<class_name>LINKABLE</class_name>, care for only one instance of the type represented by their formal generic parameter.
		</paragraph>
		<heading>
			<size>2</size>Motivation
		</heading>
		<paragraph>Imagine that a software producer is planning to build a class which would represent a list of things. Some one might ask "What kinds of things?" To which the producer would reply, "Just things. I want my list to be usable for all kinds of things."</paragraph>
		<paragraph>Using the idea of polymorphic attachment that we learned in 
			<link>
				<url>../../eiffel_dotnet_language/20_language/30_inheritance.xml</url>
				<label>Inheritance</label>
			</link>, the producer could build such a class. It might have a query 
			<feature_name>item</feature_name> which would return the thing from the list to which a cursor currently points. It might have a command 
			<feature_name>put</feature_name> which would enter some new thing into the list.
		</paragraph>
		<paragraph>What would be the type of 
			<feature_name>item</feature_name>? And what would be the type of the argument to 
			<feature_name>put</feature_name>?
		</paragraph>
		<paragraph>If the producer wants the class to handle all kinds of things, then the answer must be class 
			<class_name>ANY</class_name>, the class from which all others inherit.
		</paragraph>
		<code_block>
<keyword>class</keyword>
	<class_name>LIST_OF_THINGS</class_name>
		.
		.

<keyword>feature</keyword>   <comment>-- Access</comment>

	<feature_name>item</feature_name><symbol>:</symbol> <class_name>ANY</class_name>
			<comment>-- The thing currently pointed to by cursor</comment>

		.

<keyword>feature</keyword>   <comment>-- Element change</comment>

	<feature_name>put</feature_name> <symbol>(</symbol>new_item<symbol>:</symbol> <class_name>ANY</class_name><symbol>)</symbol>
			<comment>-- Add `new_item' at the end of the list</comment>
		.
		.
</code_block>
		<paragraph>This will work, but has some definite disadvantages. Suppose you choose to use this class to maintain a list of cats in one of your classes. You might make this declaration:</paragraph>
		<code_block>
	<feature_name>my_cats</feature_name><symbol>:</symbol> <class_name>LIST_OF_THINGS</class_name>
			<comment>-- A list of my cats</comment>
</code_block>
		<paragraph>Then you could add individual instances to the list:</paragraph>
		<code_block>
	<feature_name>fluffy</feature_name>, <feature_name>twinkie</feature_name><symbol>:</symbol> <class_name>CAT</class_name>
		.
		.
	<feature_name>my_cats</feature_name>.<feature_name>put</feature_name> <symbol>(</symbol><feature_name>fluffy</feature_name><symbol>)</symbol>
	<feature_name>my_cats</feature_name>.<feature_name>put</feature_name> <symbol>(</symbol><feature_name>twinkie</feature_name><symbol>)</symbol>
</code_block>
		<paragraph>One problem with this type of list is that the type system will not help you keep from doing something pathological like:</paragraph>
		<code_block>
	<feature_name>fluffy</feature_name>, <feature_name>twinkie</feature_name><symbol>:</symbol> <class_name>CAT</class_name>
	<feature_name>thor</feature_name><symbol>:</symbol> <class_name>PSYCHOTIC_HYDROPHOBIC_CAT_HATING_DOG</class_name>
		.
		.
	<feature_name>my_cats</feature_name>.<feature_name>put</feature_name> <symbol>(</symbol><feature_name>fluffy</feature_name><symbol>)</symbol>
	<feature_name>my_cats</feature_name>.<feature_name>put</feature_name> <symbol>(</symbol><feature_name>twinkie</feature_name><symbol>)</symbol>
	<feature_name>my_cats</feature_name>.<feature_name>put</feature_name> <symbol>(</symbol><feature_name>thor</feature_name><symbol>)</symbol>
</code_block>
		<paragraph>Another problem is that to do any <class_name>CAT</class_name> things with an item in the list, you must reattach it to a <class_name>CAT</class_name> entity. The following is invalid.</paragraph>
		<code_block>
	<feature_name>my_cats</feature_name>.<feature_name>item</feature_name>.<feature_name>purr</feature_name>	<comment>-- Is invalid</comment>
</code_block>
		<paragraph>This is because "item" is type <class_name>ANY</class_name> and although it may be currently attached to an instance of <class_name>CAT</class_name>, the static typing system cannot guarantee that. So you must use assignment attempt as we saw in the polymorphism example in 
			<link>
				<url>../../eiffel_dotnet_language/20_language/30_inheritance.xml</url>
				<label>Inheritance</label>
			</link>.
		</paragraph>
		<code_block>
	<feature_name>some_cat</feature_name><symbol>:</symbol> <class_name>CAT</class_name>
		.
		.
	<feature_name>some_cat</feature_name> <symbol>?</symbol><symbol>=</symbol> <feature_name>my_cats</feature_name>.<feature_name>item</feature_name>
	<keyword>if</keyword> <feature_name>some_cat</feature_name> <symbol>/</symbol><symbol>=</symbol> Void <keyword>then</keyword>
		<feature_name>some_cat</feature_name>.<feature_name>purr</feature_name>
	<keyword>end</keyword>
</code_block>
		<paragraph>You can see that this type of list has its drawbacks. Of course you could build a 
			<class_name>LIST_OF_CATS</class_name> class in which 
			<feature_name>item</feature_name> and the argument for 
			<feature_name>put</feature_name> would be of type 
			<class_name>CAT</class_name>. This would let you 
			<feature_name>purr</feature_name> a cat without pulling it out of the list, and it would also prevent you from accidently letting old Thor in with the cats. But, every time you needed a list to hold a different type of object, you have to write a new class.
		</paragraph>
		<paragraph>Indeed, this is how things are done in environements without facilities genericity.</paragraph>
		<paragraph>What we would like to have is a way to produce the text of the list class once. Then only when we make declarations do we add the additional information about the particular types we want allowed in the list.</paragraph>
		<heading>
			<size>2</size>Basic Genericity
		</heading>
		<paragraph>In Eiffel this is accomplished through generic classes. Generic classes are written relative not to a specific class but to a kind of phony class name called a formal generic parameter. With genericity, the 
			<class_name>LIST_OF_THINGS</class_name> class might become a class called 
			<class_name>LIST</class_name> which is a list of items of type 
			<code>
				<generics>G</generics>
			</code>. In class 
			<class_name>LIST</class_name> we would declare 
			<feature_name>item</feature_name> as type G, as well as the argument to 
			<feature_name>put</feature_name>.
		</paragraph>
		<code_block>
<keyword>class</keyword>
	<class_name>LIST</class_name> <symbol>[</symbol><class_name>G</class_name><symbol>]</symbol>
		.
		.
<keyword>feature</keyword>   <comment>-- Access</comment>
	<feature_name>item</feature_name><symbol>:</symbol> <class_name>G</class_name>
			<comment>-- The item currently pointed to by cursor</comment>
		.
<keyword>feature</keyword>   <comment>-- Element change</comment>
	<feature_name>put</feature_name> <symbol>(</symbol>new_item<symbol>:</symbol> <class_name>G</class_name><symbol>)</symbol>
			<comment>-- Add `new_item' at the end of the list</comment>
		.
		.
</code_block>
		<paragraph>We could declare feature 
			<feature_name>my_cats</feature_name> as a 
			<class_name>LIST</class_name> of items of type 
			<class_name>CAT</class_name>. By doing so we are providing 
			<class_name>CAT</class_name> as an "actual generic parameter" in the declaration. Then we are free to treat the features of 
			<class_name>LIST</class_name> as if the class name 
			<class_name>CAT</class_name> had been substituted for every occurrence of the formal generic parameter 
			<code>
				<generics>G</generics>
			</code>.
		</paragraph>
		<code_block>
	<feature_name>my_cats</feature_name><symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>CAT</class_name><symbol>]</symbol>
		<comment>-- A list of my cats</comment>
	<feature_name>fluffy</feature_name>, <feature_name>twinkie</feature_name><symbol>:</symbol> <class_name>CAT</class_name>
		.
		.
	<feature_name>my_cats</feature_name>.<feature_name>put</feature_name> <symbol>(</symbol><feature_name>fluffy</feature_name><symbol>)</symbol>
	<feature_name>my_cats</feature_name>.<feature_name>put</feature_name> <symbol>(</symbol><feature_name>twinkie</feature_name><symbol>)</symbol>
		.
	<feature_name>my_cats</feature_name>.<feature_name>item</feature_name>.<feature_name>purr</feature_name>	<comment>-- Valid now</comment>
</code_block>
		<paragraph>The following would no longer be valid:</paragraph>
		<code_block>
	<feature_name>my_cats</feature_name><symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>CAT</class_name><symbol>]</symbol>
			<comment>-- A list of my cats</comment>

	<feature_name>thor</feature_name><symbol>:</symbol> <class_name>PSYCHOTIC_HYDROPHOBIC_CAT_HATING_DOG</class_name>

		.
		.

	<feature_name>my_cats</feature_name>.<feature_name>put</feature_name> <symbol>(</symbol><feature_name>thor</feature_name><symbol>)</symbol>	 <comment>-- Is invalid</comment>
</code_block>
		<heading>
			<size>2</size>Constrained Genericity
		</heading>
		<paragraph>The generic class 
			<class_name>LIST</class_name> illustrated above is perfectly useful for making typed lists of any type of object. The features of the 
			<class_name>LIST</class_name> will not attempt to use the objects in the list in any way. Sometimes though, it is important for a class to be guaranteed more about the nature of the types that can be substituted for its formal generic parameter.
		</paragraph>
		<paragraph>Take for example the case of a class called 
			<class_name>SORTED_LIST</class_name>. A 
			<class_name>SORTED_LIST</class_name> is a list, of course, but it is special in that it acts upon the elements that it holds to keep them in order.
		</paragraph>
		<paragraph>A 
			<class_name>SORTED_LIST</class_name> needs to be able to order its elements. So, it must be able to apply queries to those elements to determine which should sort high than which. The elements themselves must respond to ordering operations.
		</paragraph>
		<paragraph>If 
			<class_name>SORTED_LIST</class_name> were defined like we did 
			<class_name>LIST</class_name>
		</paragraph>
		<code_block>
<keyword>class</keyword>
	<class_name>SORTED_LIST</class_name> <symbol>[</symbol><class_name>G</class_name><symbol>]</symbol>
</code_block>
		<paragraph>there would be no guarantee that ordering operations, like "&lt;" and "&gt;" could be applied to all types that could be listed. An Eiffel facility called "constrained genericity" will solve this problemfor us. In the case of 
			<class_name>SORTED_LIST</class_name>, we would add to the formal generic part as follows.
		</paragraph>
		<code_block>
<keyword>class</keyword>
	<class_name>SORTED_LIST</class_name> <symbol>[</symbol><class_name>G</class_name> -&gt; <class_name>COMPARABLE</class_name><symbol>]</symbol>
</code_block>
		<paragraph>You may remember from 
			<link>
				<url>../../eiffel_dotnet_language/20_language/30_inheritance.xml</url>
				<label>Inheritance</label>
			</link> that if we make instances of a class comparable with each other, then we make the class inherit from 
			<class_name>COMPARABLE</class_name> and effect the feature "&lt;".
		</paragraph>
		<paragraph>Here, constrained genericity does two things for us.</paragraph>
		<list ordered="false">
			<item>First, it states that any candidate for substitution for 
				<code>
					<generics>G</generics>
				</code> must conform to class 
				<class_name>COMPARABLE</class_name>. Typically this means it must inherit from 
				<class_name>COMPARABLE</class_name>.
			</item>
			<item>Second, it allows, within the features of 
				<class_name>SORTED_LIST</class_name>, the features of 
				<class_name>COMPARABLE</class_name> to be applied to any item which has a type of 
				<code>
					<generics>G</generics>
				</code>.
			</item>
		</list>
	</paragraph></document>
