#! /bin/sh
#
# If these # comments don't work, trim them. Don't worry about any
# other shell scripts, Configure will trim # comments from them for you.
#
# (If you are trying to port this package to a machine without sh,
# I would suggest you have a look at the prototypical config_h.SH file
# and edit it to reflect your system. Some packages may include samples
# of config.h for certain machines, so you might look for one of those.)
#
# Yes, you may rip this off to use in other distribution packages. This
# script belongs to the public domain and cannot be copyrighted.
#
# (Note: this Configure script was generated automatically. Rather than
# working with this copy of Configure, you may wish to get metaconfig.
# Write to either:
#
#     harlan@mumps.pfcs.com (Harlan Stenn)
#     ram@eiffel.com (Raphael Manfredi)
#
# and we will send you -or point you to- the latest revision of the dist
# package, which includes metaconfig.)
#

# $Id$
#
# Generated on Tue Jan 26 13:51:28 PST 1993 [metaconfig 2.9dev PL0]

cat >/tmp/c1$$ <<EOF
ARGGGHHHH!!!!!

SCO csh still thinks true is false.  Write to SCO today and tell them that next
year Configure ought to "rm /bin/csh" unless they fix their blasted shell. :-)

(Actually, Configure ought to just patch csh in place.  Hmm.  Hmmmmm.  All
we'd have to do is go in and swap the && and || tokens, wherever they are.)

[End of diatribe. We now return you to your regularly scheduled programming...]
EOF
cat >/tmp/c2$$ <<EOF
OOPS!  You naughty creature!  You didn't run Configure with sh!
I will attempt to remedy the situation by running sh for you...

EOF

true || cat /tmp/c1$$ /tmp/c2$$
true || exec sh $0 $*

export PATH || cat /tmp/c2$$
export PATH || exec sh $0 $*
rm -f /tmp/c1$$ /tmp/c2$$

: Sanity checks
PATH=".:$PATH:/bin:/usr/bin:/usr/local/bin:/usr/ucb:/usr/local:/usr/lbin"
PATH=$PATH:'/usr/5bin:/etc:/usr/gnu/bin:/usr/new:/usr/new/bin:/usr/nbin'
PATH=$PATH:'/sys5.3/bin:/sys5.3/usr/bin:/bsd4.3/bin:/bsd4.3/usr/ucb'
PATH=$PATH:'/bsd4.3/usr/bin:/usr/bsd:/bsd43/bin:/usr/ccs/bin'
PATH=$PATH:'/etc:/usr/lib:/lib:/usr/ccs/lib'
export PATH

if test ! -t 0; then
	echo "Say 'sh Configure', not 'sh <Configure'"
	exit 1
fi

: Warn them if they use ksh
(alias) >/dev/null 2>&1 && \
	cat <<'EOM'
(I see you are using the Korn shell.  Some ksh's blow up on Configure,
especially on exotic machines.  If yours does, try the Bourne shell instead.)
EOM

: Configure runs within the UU subdirectory
test -d UU || mkdir UU
cd UU && rm -f *

cf_by=''
cf_time=''
d_bsd=''
d_eunice=''
d_xenix=''
eunicefix=''
Mcc=''
awk=''
bison=''
cat=''
chgrp=''
chmod=''
chown=''
compress=''
cp=''
cpio=''
cpp=''
csh=''
date=''
echo=''
egrep=''
emacs=''
expr=''
flex=''
gcc=''
grep=''
inews=''
less=''
line=''
lint=''
ln=''
lp=''
lpr=''
ls=''
mail=''
mailx=''
make=''
mkdir=''
more=''
mv=''
nroff=''
perl=''
pg=''
pmake=''
pr=''
rm=''
rmail=''
sed=''
sendmail=''
shar=''
sleep=''
smail=''
sort=''
submit=''
tail=''
tar=''
tbl=''
test=''
touch=''
tr=''
troff=''
uname=''
uniq=''
uuname=''
vi=''
zcat=''
hint=''
myuname=''
Author=''
Date=''
Header=''
Id=''
Locker=''
Log=''
RCSfile=''
Revision=''
Source=''
State=''
abortsig=''
add_log=''
alignbytes=''
bin=''
bitpbyte=''
byteorder=''
cc=''
ccflags=''
cppflags=''
ldflags=''
lkflags=''
optimize=''
charsize=''
contains=''
cppminus=''
cppstdin=''
d_gettblsz=''
nofile=''
tablesize=''
d_access=''
d_bcmp=''
d_bcopy=''
d_bsdjmp=''
d_bzero=''
d_dup2=''
d_eofpipe=''
d_fcntl=''
d_ftime=''
d_gettimeod=''
d_gethid=''
aphostname=''
d_gethname=''
d_phostname=''
d_uname=''
d_getopt=''
d_getpagsz=''
pagesize=''
d_index=''
d_keepsig=''
d_lstat=''
d_mkdir=''
d_open3=''
d_pidcheck=''
d_portable=''
d_readdir=''
d_rename=''
d_rmdir=''
d_rusage=''
d_bsdpgrp=''
d_setpgrp=''
d_siglist=''
d_sigsetmk=''
d_sigaction=''
d_sigintrp=''
d_sigvec=''
d_sigvectr=''
d_oldsock=''
d_socket=''
d_sockpair=''
sockethdr=''
socketlib=''
d_strctcpy=''
d_strerrm=''
d_strerror=''
d_sysernlst=''
d_syserrlst=''
d_time=''
timetype=''
clocktype=''
d_times=''
d_usleep=''
d_voidsig=''
signal_t=''
doublesize=''
floatsize=''
h_fcntl=''
h_sysfile=''
d_dirnamlen=''
i_dirent=''
i_fcntl=''
i_limits=''
i_niin=''
i_sysin=''
i_stdarg=''
i_string=''
strings=''
i_sysdir=''
i_sysfile=''
d_voidtty=''
i_bsdioctl=''
i_sysioctl=''
i_syssockio=''
i_sysndir=''
i_sysresrc=''
i_sysselct=''
i_syssock=''
i_systimeb=''
i_systimes=''
i_sysun=''
i_sgtty=''
i_termio=''
i_termios=''
i_systime=''
i_systimek=''
i_time=''
timeincl=''
i_varargs=''
i_varhdr=''
intsize=''
libc=''
libpth=''
plibpth=''
xlibpath=''
libs=''
longsize=''
mallocobj=''
mallocsrc=''
malloctype=''
usemymalloc=''
manext=''
mansrc=''
mkdep=''
huge=''
large=''
medium=''
models=''
small=''
split=''
mydomain=''
myhostname=''
phostname=''
c=''
n=''
orderlib=''
ranlib=''
package=''
d_maypanic=''
pidtype=''
prototype=''
ptrsize=''
reg10=''
reg11=''
reg12=''
reg13=''
reg14=''
reg15=''
reg16=''
reg1=''
reg2=''
reg3=''
reg4=''
reg5=''
reg6=''
reg7=''
reg8=''
reg9=''
registers=''
sbrktype=''
scriptdir=''
d_keepalive=''
sharpbang=''
shsharp=''
spitshell=''
startsh=''
sysman=''
uidtype=''
nm_opt=''
runnm=''
usenm=''
incpath=''
mips=''
mips_type=''
usrinc=''
yacc=''
yaccflags=''
d_whoami=''
CONFIG=''

: script used to extract .SH files with variable substitutions
cat >extract <<'EOS'
CONFIG=true
echo "Doing variable substitutions on .SH files..."
if test -f MANIFEST; then
	set x `awk '{print $1}' <MANIFEST | $grep '\.SH'`
else
	echo "(Looking for .SH files under the current directory.)"
	set x `find . -name "*.SH" -print`
fi
shift
case $# in
0) set x *.SH; shift;;
esac
if test ! -f $1; then
	shift
fi
for file in $*; do
	case "$file" in
	*/*)
		dir=`$expr X$file : 'X\(.*\)/'`
		file=`$expr X$file : 'X.*/\(.*\)'`
		(cd $dir && . $file)
		;;
	*)
		. $file
		;;
	esac
done
if test -f config_h.SH; then
	if test ! -f config.h; then
	: oops, they left it out of MANIFEST, probably, so do it anyway.
	. config_h.SH
	fi
fi
EOS

: process the command line options
set X `for arg in "$@"; do echo $arg; done | awk '
BEGIN {
	optstr = "deEf:hrsSV";	# getopt-style specification

	len = length(optstr);
	for (i = 1; i <= len; i++) {
		c = substr(optstr, i, 1);
		if (i < len) a = substr(optstr, i + 1, 1); else a = "";
		if (a == ":") {
			arg[c] = 1;
			i++;
		}
		opt[c] = 1;
	}
}
{
	expect = 0;
	str = $0;
	if (substr(str, 1, 1) != "-") {
		printf("'"'%s'"'\n", str);
		next;
	}
	len = length($0);
	for (i = 2; i <= len; i++) {
		c = substr(str, i, 1);
		if (!opt[c]) {
			printf("-%s\n", substr(str, i));
			next;
		}
		printf("-%s\n", c);
		if (arg[c]) {
			if (i < len)
				printf("'"'%s'"'\n", substr(str, i + 1));
			else
				expect = 1;
			next;
		}
	}
}
END {
	if (expect)
		print "?";
}
'`
eval "set $*"
shift
		
: set up default values
reuseval=false
config_sh=''
alldone=''
error=''
silent=''
extractsh=''

: option parsing
while test $# -gt 0; do
	case "$1" in
	-d) shift; fastread=yes;;
	-e) shift; alldone=cont;;
	-f)
		shift
		cd ..
		if test -r "$1"; then
			config_sh="$1"
		else
			echo "Configure: cannot read config file $1." >&2
			error=true
		fi
		cd UU
		shift;;
	-h) shift; error=true;;
	-r) shift; reuseval=true;;
	-s) shift; silent=true;;
	-E) shift; alldone=exit;;
	-S) shift; extractsh=true;;
	-V) echo "Configure generated by metaconfig 2.9dev PL0." >&2
		exit 0;;
	--) break;;
	-*) echo "Configure: unknown option $1" >&2; shift; error=true;;
	*) break;;
	esac
done

case "$error" in
true)
	cat >&2 <<EOM
Usage: Configure [-dehrESV] [-f config.sh]
  -d : use defaults for all answers.
  -e : go on without questioning past the production of config.sh.
  -f : specify an alternate default configuration file.
  -h : print this help message and exit (with an error status).
  -r : reuse C symbols value if possible (skips costly nm extraction).
  -s : silent mode, only echoes questions and essential information.
  -E : stop at the end of questions, after having produced config.sh.
  -S : perform variable substitutions on all .SH files (can mix with -f)
  -V : print version number and exit (with a zero status).
EOM
	exit 1
	;;
esac

exec 3>&1
case "$silent" in
true) exec 1>/dev/null;;
esac

case "$extractsh" in
true)
	case "$config_sh" in
	'') config_sh='config.sh'; config='./config.sh';;
	/*) config="$config_sh";;
	*) config="./$config_sh";;
	esac
	echo " "
	echo "Fetching answers from $config_sh..."
	cd ..
	. $config
	echo " "
	. ./UU/extract
	rm -rf UU
	echo "Done."
	exit 0
	;;
esac

: set package name
package=Eiffel-3.0

: Eunice requires " " instead of "", can you believe it
echo " "
: Here we go...
echo "Beginning of configuration questions for $package kit."

define='define'
undef='undef'
smallmach='pdp11 i8086 z8000 i80286 iAPX286'
rmlist=''

trap 'echo " "; rm -rf $rmlist; exit 1' 1 2 3 15

: We must find out about Eunice early
eunicefix=':'
if test -f /etc/unixtovms; then
	eunicefix=/etc/unixtovms
fi
if test -f /etc/unixtovms.exe; then
	eunicefix=/etc/unixtovms.exe
fi

: list of known cpp symbols
attrlist="DGUX M_I186 M_I286 M_I386 M_I8086 M_XENIX UTS __DGUX__"
attrlist="$attrlist _AIX __STDC__ __m88k__ ansi bsd4_2 gcos gimpel"
attrlist="$attrlist hp9000s300 hp9000s400 hp9000s500 hp9000s700"
attrlist="$attrlist hp9000s800 hpux"
attrlist="$attrlist i186 i386 i486 i8086 iAPX286 ibm interdata"
attrlist="$attrlist m88k mc300 mc500 mc68000 mc68k mc700 mert"
attrlist="$attrlist mips NeXT ns16000 ns32000 nsc32000 os pdp11 posix"
attrlist="$attrlist pyr sinix sony sparc sun tower tower32 tower32_600"
attrlist="$attrlist tower32_800 tss u3b2 u3b20 u3b200 u3b5 ultrix unix"
attrlist="$attrlist vax venix xenix z8000"

: no include file wanted by default
inclwanted=''

: change the next line if compiling for Xenix/286 on Xenix/386
xlibpath='/usr/lib/386 /lib/386'

: general looking path for locating libraries
libpth='/usr/lib/large /lib '$xlibpth' /lib/large'
libpth=$libpth' /usr/lib/small /lib/small'

: libraries wanted for XDR support and socket support
libswanted="c_s rpc xdr bsd socket inet nsl m"

: Now test for existence of everything in MANIFEST
echo " "
if test -f ../MANIFEST; then
	echo "First let's make sure your kit is complete.  Checking..." >&3
	awk '$1 !~ /PACK[A-Z]+/ {print $1}' ../MANIFEST | split -50
	rm -f missing
	for filelist in x??; do
		(cd ..; ls `cat UU/$filelist` >/dev/null 2>>UU/missing)
	done
	if test -s missing; then
		cat missing
		cat >&3 <<'EOM'

THIS PACKAGE SEEMS TO BE INCOMPLETE.

To continue the configuration process AT YOUR OWN RISKS, you may press the
RETURN key now. If you wish to stop the script, enter 'no' and press RETURN.

PRESS RETURN TO CONTINUE OR ENTER 'n' TO STOP.
EOM
		read ans
		if test "$ans"; then
			echo "ABORTING..." >&3
			kill $$
		else
			echo "Continuing..." >&3
			rm -f missing
		fi
	else
		echo "Looks good..." >&3
	fi
else
	echo "There is no MANIFEST file.  I hope your kit is complete !"
fi
rm -f missing x??

: Some greps do not return status, grrr.
echo "grimblepritz" >grimble
if grep blurfldyick grimble >/dev/null 2>&1 ; then
	contains=contains
elif grep grimblepritz grimble >/dev/null 2>&1 ; then
	contains=grep
else
	contains=contains
fi
rm -f grimble
: the following should work in any shell
case "$contains" in
contains*)
	echo " "
	echo "AGH!  Grep doesn't return a status.  Attempting remedial action."
	cat >contains <<'EOSS'
grep "$1" "$2" >.greptmp && cat .greptmp && test -s .greptmp
EOSS
chmod +x contains
esac

: first determine how to suppress newline on echo command
echo " "
echo "Checking echo to see how to suppress newlines..."
(echo "hi there\c" ; echo " ") >.echotmp
if $contains c .echotmp >/dev/null 2>&1 ; then
	echo "...using -n."
	n='-n'
	c=''
else
	cat <<'EOM'
...using \c
EOM
	n=''
	c='\c'
fi
echo $n "The star should be here-->$c"
echo '*'
rm -f .echotmp

: compute the number of columns on the terminal for proper question formatting
case "$COLUMNS" in
'') COLUMNS='80';;
esac

: set up the echo used in my read
myecho="case \"\$xxxm\" in
'') echo $n \"\$rp $c\" >&3;;
*) case \"\$rp\" in
	'') echo $n \"[\$xxxm] $c\";;
	*)
		if test \`echo \"\$rp [\$xxxm]  \" | wc -c\` -ge $COLUMNS; then
			echo \"\$rp\" >&3
			echo $n \"[\$xxxm] $c\" >&3
		else
			echo $n \"\$rp [\$xxxm] $c\" >&3
		fi
		;;
	esac;;
esac"

: now set up to do reads with possible shell escape and default assignment
cat <<EOSC >myread
xxxm=\$dflt
$myecho
ans='!'
case "\$fastread" in
yes) case "\$dflt" in
	'') ;;
	*) ans='';
		case "\$silent-\$rp" in
		true-) ;;
		*) echo " " >&3;;
		esac;;
	esac;;
*) case "\$silent" in
	true) case "\$rp" in
		'') ans='';;
		esac;;
	esac;;
esac
while expr "X\$ans" : "X!" >/dev/null; do
	read answ
	set x \$xxxm
	shift
	aok=''; eval "ans=\"\$answ\"" && aok=y
	case  "\$answ" in
	"\$ans")
		case "\$ans" in
		!)
			sh
			echo " "
			$myecho
			;;
		!*)
			set x \`expr "X\$ans" : "X!\(.*\)\$"\`
			shift
			sh -c "\$*"
			echo " "
			$myecho
			;;
		esac;;
	*)
		case "\$aok" in
		y)
			echo "*** Substitution done -- please confirm."
			xxxm="\$ans"
			ans=\`echo $n "\$ans$c" | tr '\012' ' '\`
			xxxm="\$ans"
			ans=!
			;;
		*)
			echo "*** Error -- try again."
			ans=!
			;;
		esac
		$myecho
		;;
	esac
done
case "\$ans" in
'') ans="\$xxxm";;
esac
EOSC

: general instructions
cat <<EOH
 
This installation shell script will examine your system and ask you questions
to determine how the Eiffel-3.0 package should be installed.  If you get stuck
on a question, you may use a ! shell escape to start a subshell or execute a
command.  Many of the questions will have default answers in square brackets;
typing carriage return will give you the default.

On some of the questions which ask for file or directory names you are allowed
to use the ~name construct to specify the login directory belonging to "name",
even if you don't have a shell which knows about that.  Questions where this is
allowed will be marked "(~name ok)".

EOH
rp=''
dflt='Type carriage return to continue'
. myread
cat <<'EOH'

The prompter used in this script allows you to use shell variables and
backticks in your answers.  You may use $1, $2, etc...  to refer to the words
in the default answer, as if the default line was a set of arguments given to a
script shell.  This means you may also use $* to repeat the whole default line,
so you do not have to re-type everything to add something to the default.

Everytime there is a substitution, you will have to confirm.  If there is an
error (e.g. an unmatched backtick), the default answer will remain unchanged
and you will be prompted again.

If you are in a hurry, you may run 'Configure -d'.  This will bypass nearly all
the questions and use the computed defaults (or the previous answers if there
was already a config.sh file).

EOH
. myread
cat <<EOH

Much effort has been expended to ensure that this shell script will run on any
Unix system.  If despite that it blows up on yours, your best bet is to edit
Configure and run it again.  Also, let me (ram@york.eiffel.com)
know how I blew it.  If you can't run Configure for some reason, you'll have to
generate a config.sh file by hand.

This installation script affects things in two ways:

1) it may do direct variable substitutions on some of the files included
   in this kit.
2) it builds a config.h file for inclusion in C programs.  You may edit
   any of these files as the need arises after running this script.

If you make a mistake on a question, there is no easy way to back up to it
currently.  The easiest thing to do is to edit config.sh and rerun all the SH
files.  Configure will offer to let you do this before it runs the SH files.

EOH
dflt='Type carriage return to continue'
. myread

: see if sh knows # comments
echo " "
echo "Checking your sh to see if it knows about # comments..." >&3
if sh -c '#' >/dev/null 2>&1 ; then
	echo "Your sh handles # comments correctly."
	shsharp=true
	spitshell=cat
	echo " "
	echo "Okay, let's see if #! works on this system..."
	echo "#!/bin/cat" >try
	$eunicefix try
	chmod +x try
	try > today
	if test -s today; then
		echo "It does."
		sharpbang='#!'
	else
		echo "#! /bin/cat" > try
		$eunicefix try
		chmod +x try
		try > today
		if test -s today; then
			echo "It does."
			sharpbang='#! '
		else
			echo "It doesn't."
			sharpbang=': use '
		fi
	fi
else
	echo "Your sh doesn't grok # comments--I will strip them later on."
	shsharp=false
	echo "exec grep -v '^[ 	]*#'" >spitshell
	chmod +x spitshell
	$eunicefix spitshell
	spitshell=`pwd`/spitshell
	echo "I presume that if # doesn't work, #! won't work either!"
	sharpbang=': use '
fi
rm -f try today

: figure out how to guarantee sh startup
echo " "
echo "Checking out how to guarantee sh startup..." >&3
startsh=$sharpbang'/bin/sh'
echo "Let's see if '$startsh' works..."
cat >try <<EOSS
$startsh
set abc
test "$?abc" != 1
EOSS

chmod +x try
$eunicefix try
if try; then
	echo "Yup, it does."
else
echo "Nope.  You may have to fix up the shell scripts to make sure sh runs them."
fi
rm -f try

: find out where common programs are
echo " "
echo "Locating common programs..." >&3
cat <<EOSC >loc
$startsh
case \$# in
0) exit 1;;
esac
thing=\$1
shift
dflt=\$1
shift
for dir in \$*; do
	case "\$thing" in
	.)
	if test -d \$dir/\$thing; then
		echo \$dir
		exit 0
	fi
	;;
	*)
	if test -f \$dir/\$thing; then
		echo \$dir/\$thing
		exit 0
	elif test -f \$dir/\$thing.exe; then
		: on Eunice apparently
		echo \$dir/\$thing
		exit 0
	fi
	;;
	esac
done
echo \$dflt
exit 1
EOSC
chmod +x loc
$eunicefix loc
loclist="
awk
cat
chgrp
chmod
chown
cp
echo
expr
grep
ln
mv
rm
sed
sort
tr
uniq
"
trylist="
Mcc
bison
cpp
date
nroff
test
uname
"
pth=`echo $PATH | sed -e 's/:/ /g'`
pth="$pth /lib /usr/lib"
for file in $loclist; do
	xxx=`./loc $file $file $pth`
	eval $file=$xxx
	eval _$file=$xxx
	case "$xxx" in
	/*)
		echo $file is in $xxx.
		;;
	*)
		echo "I don't know where $file is.  I hope it's in everyone's PATH."
		;;
	esac
done
echo " "
echo "Don't worry if any of the following aren't found..."
ans=offhand
for file in $trylist; do
	xxx=`./loc $file $file $pth`
	eval $file=$xxx
	eval _$file=$xxx
	case "$xxx" in
	/*)
		echo $file is in $xxx.
		;;
	*)
		echo "I don't see $file out there, $ans."
		ans=either
		;;
	esac
done
case "$egrep" in
egrep)
	echo "Substituting grep for egrep."
	egrep=$grep
	;;
esac
case "$test" in
test)
	echo "Hopefully test is built into your sh."
	;;
/bin/test)
	if sh -c "PATH= test true" >/dev/null 2>&1; then
		echo "Using the test built into your sh."
		test=test
	fi
	;;
*)
	test=test
	;;
esac
case "$echo" in
echo)
	echo "Hopefully echo is built into your sh."
	;;
/bin/echo)
	echo " "
echo "Checking compatibility between /bin/echo and builtin echo (if any)..." >&3
	$echo $n "hi there$c" >foo1
	echo $n "hi there$c" >foo2
	if cmp foo1 foo2 >/dev/null 2>&1; then
		echo "They are compatible.  In fact, they may be identical."
	else
		case "$n" in
		'-n') n='' c='\c';;
		*) n='-n' c='';;
		esac
		cat <<FOO
They are not compatible!  You are probably running ksh on a non-USG system.
I'll have to use /bin/echo instead of the builtin, since Bourne shell doesn't
have echo built in and we may have to run some Bourne shell scripts.  That
means I'll have to use $ans to suppress newlines now.  Life is ridiculous.

FOO
		$echo $n "The star should be here-->$c"
		$echo "*"
	fi
	$rm -f foo1 foo2
	;;
*)
	: cross your fingers
	echo=echo
	;;
esac

: Try to determine whether config.sh was made on this system
case "$config_sh" in
'')
: indentation wrong on purpose--RAM
myuname=`( ($uname -a) 2>/dev/null || hostname) 2>&1`
dflt=n
if test -f ../config.sh; then
	xxx=$myuname
	eval "`grep myuname= ../config.sh`"
	if test "X$xxx" = "X$myuname"; then
		dflt=y
	fi
fi

: Get old answers from old config file if Configure was run on the
: same system, otherwise use the hints.
hint=default
cd ..
if test -f config.sh; then
	echo " "
	rp="I see a config.sh file.  Did Configure make it on THIS system?"
	. UU/myread
	case "$ans" in
	n*|N*) echo "OK, I'll ignore it."; mv config.sh config.sh.old;;
	*)  echo "Fetching default answers from your old config.sh file..." >&3
		tmp="$n"
		ans="$c"
		. ./config.sh
		cp config.sh UU
		n="$tmp"
		c="$ans"
		hint=previous
		;;
	esac
fi
if test ! -f config.sh; then
	$cat <<EOM

First time through, eh?  I have some defaults handy for the following systems:

EOM
	cd hints; ls -C *.sh | $sed 's/\.sh/   /g' >&3
	dflt=''
	: Half the following guesses are probably wrong... If you have better
	: tests or hints, please send them to ram@york.eiffel.com
	: The metaconfig authors would also appreciate a copy...
	$test -f /irix && dflt="$dflt sgi"
	$test -f /xenix && dflt="$dflt sco_xenix"
	$test -f /dynix && dflt="$dflt dynix"
	$test -f /dnix && dflt="$dflt dnix"
	$test -f /bin/mips && /bin/mips && dflt="$dflt mips"
	$test -d /NextApps && test -f /usr/adm/software_version && dflt="$dflt next"
	if $test -f $uname; then
		set `$uname -a | tr '[A-Z]' '[a-z]'`

		$test -f $5.sh && dflt="$dflt $5"

		case "$5" in
		fps*) dflt="$dflt fps";;
		mips*)
			case "$4" in
			umips) dflt="$dflt umips";;
			*) dflt="$dflt mips";;
			esac;;
		[23]100) dflt="$dflt mips";;
		next*) dflt="$dflt next" ;;
		news*) dflt="$dflt news" ;;
		esac

		case "$1" in
		aix) dflt="$dflt aix_rs" ;;
		sunos) case "$3" in
			3.4) dflt="$dflt sunos_3_4" ;;
			3.5) dflt="$dflt sunos_3_5" ;;
			4.0.1) dflt="$dflt sunos_4_0_1" ;;
			4.0.2) dflt="$dflt sunos_4_0_2" ;;
			esac
			;;
		dnix) dflt="$dflt dnix" ;;
		dgux) dflt="$dflt dgux" ;;
		genix) dflt="$dflt genix" ;;
		hp*ux) dflt="$dflt hpux" ;;
		next) dflt="$dflt next" ;;
		irix) dflt="$dflt sgi" ;;
		ultrix) case "$3" in
			3*) dflt="$dflt ultrix_3" ;;
			4*) dflt="$dflt ultrix_4" ;;
			esac
			;;
		uts) dflt="$dflt uts" ;;
		$2) if test -f /etc/systemid; then
				set `echo $3 | sed 's/\./ /'` $4
				if $test -f sco_$1_$2_$3.sh; then
					dflt="$dflt sco_$1_$2_$3"
				elif $test -f sco_$1_$2.sh; then
					dflt="$dflt sco_$1_$2"
				elif $test -f sco_$1.sh; then
					dflt="$dflt sco_$1"
				fi
			fi
			;;
		esac
	else
		if test -f /vmunix; then
			(what /vmunix | tr '[A-Z]' '[a-z]') > ../UU/kernel.what 2>&1
			if $contains news-os ../UU/kernel.what >/dev/null 2>&1; then
				dflt="$dflt news_os"
			fi
			$rm -f ../UU/kernel.what
		fi
	fi
	set X `echo $dflt | tr ' ' '\012' | sort | uniq`
	shift
	dflt=''
	for file in $*; do
		if $test -f "$file.sh"; then
			dflt="$dflt $file"
		fi
	done
	set X $dflt
	shift
	dflt=${1+"$@"}
	case "$dflt" in
	'') dflt=none;;
	esac
	$cat <<EOM

You may give one or more space-separated answers, or "none" if appropriate.
If your OS version has no hints, DO NOT give a wrong version -- say "none".

EOM
	rp="Which of these apply, if any?"
	. ../UU/myread
	for file in $ans; do
		if $test -f $file.sh; then
			. ./$file.sh
			$cat $file.sh >> ../UU/config.sh
		fi
	done
	hint=recommended
	cd ..
fi
cd UU
: remember, indentation is wrong--RAM
;;
*)
	echo " "
	echo "Fetching default answers from $config_sh..." >&3
	tmp="$n"
	ans="$c"
	cd ..
	cp $config_sh config.sh 2>/dev/null
	. ./config.sh
	cd UU
	cp ../config.sh .
	n="$tmp"
	c="$ans"
	hint=previous
	;;
esac

: Restore computed paths
for file in $loclist $trylist; do
	eval $file="\$_$file"
done

: set up shell script to do ~ expansion
cat >filexp <<EOSS
$startsh
: expand filename
case "\$1" in
 ~/*|~)
	echo \$1 | $sed "s|~|\${HOME-\$LOGDIR}|"
	;;
 ~*)
	if $test -f /bin/csh; then
		/bin/csh -f -c "glob \$1"
		failed=$?
		echo ""
		exit \$failed
	else
		name=\`$expr x\$1 : '..\([^/]*\)'\`
		dir=\`$sed -n -e "/^\${name}:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\).*"'\$'"/\1/" -e p -e q -e '}' </etc/passwd\`
		if $test ! -d "\$dir"; then
			me=\`basename \$0\`
			echo "\$me: can't locate home directory for: \$name" >&2
			exit 1
		fi
		case "\$1" in
		*/*)
			echo \$dir/\`$expr x\$1 : '..[^/]*/\(.*\)'\`
			;;
		*)
			echo \$dir
			;;
		esac
	fi
	;;
*)
	echo \$1
	;;
esac
EOSS
chmod +x filexp
$eunicefix filexp

: determine where manual pages are on this system
echo " "
case "$sysman" in
'') sysman=`loc . /usr/man/man1 /usr/man/man1 /usr/man/mann /usr/man/manl /usr/man/local/man1 /usr/man/u_man/man1 /usr/share/man/man1 /usr/catman/u_man/man1 /usr/man/l_man/man1 /usr/local/man/u_man/man1 /usr/local/man/l_man/man1 /usr/man/man.L`
	;;
esac
if test -d "$sysman"; then
	echo "System manual is in $sysman." >&3
else
	echo "Could not find manual pages in source form." >&3
fi

: see what memory models we can support
case "$models" in
'')
	$cat >pdp11.c <<'EOP'
main() {
#ifdef pdp11
	exit(0);
#else
	exit(1);
#endif
}
EOP
	cc -o pdp11 pdp11.c >/dev/null 2>&1
	if ./pdp11 2>/dev/null; then
		dflt='unsplit split'
	else
		ans=`loc . X /lib/small /lib/large /usr/lib/small /usr/lib/large /lib/medium /usr/lib/medium /lib/huge`
		case "$ans" in
		X) dflt='none';;
		*) if $test -d /lib/small || $test -d /usr/lib/small; then
				dflt='small'
			else
				dflt=''
			fi
			if $test -d /lib/medium || $test -d /usr/lib/medium; then
				dflt="$dflt medium"
			fi
			if $test -d /lib/large || $test -d /usr/lib/large; then
				dflt="$dflt large"
			fi
			if $test -d /lib/huge || $test -d /usr/lib/huge; then
				dflt="$dflt huge"
			fi
		esac
	fi;;
*) dflt="$models";;
esac
$cat <<EOM
 
Some systems have different model sizes.  On most systems they are called
small, medium, large, and huge.  On the PDP11 they are called unsplit and
split.  If your system doesn't support different memory models, say "none".
If you wish to force everything to one memory model, say "none" here and
put the appropriate flags later when it asks you for other cc and ld flags.
Venix systems may wish to put "none" and let the compiler figure things out.
(In the following question multiple model names should be space separated.)

EOM
rp="Which memory models are supported?"
. myread
models="$ans"

case "$models" in
none)
	small=''
	medium=''
	large=''
	huge=''
	unsplit=''
	split=''
	;;
*split)
	case "$split" in
	'') if $contains '\-i' $sysman/ld.1 >/dev/null 2>&1 || \
			 $contains '\-i' $sysman/cc.1 >/dev/null 2>&1; then
			dflt='-i'
		else
			dflt='none'
		fi;;
	*) dflt="$split";;
	esac
	rp="What flag indicates separate I and D space?"
	. myread
	case "$ans" in
	none) ans='';;
	esac
	split="$ans"
	unsplit='';;
*large*|*small*|*medium*|*huge*)
	case "$model" in
	*large*)
		case "$large" in
		'') dflt='-Ml';;
		*) dflt="$large";;
		esac
	rp="What flag indicates large model?"
	. myread
	case "$ans" in
	none) ans='';
	esac
	large="$ans";;
	*) large='';;
	esac
	case "$model" in
	*huge*) case "$huge" in
		'') dflt='-Mh';;
		*) dflt="$huge";;
		esac
		rp="What flag indicates huge model?"
		. myread
		case "$ans" in
		none) ans='';
		esac
		huge="$ans";;
	*) huge="$large";;
	esac
	case "$model" in
	*medium*) case "$medium" in
		'') dflt='-Mm';;
		*) dflt="$medium";;
		esac
		rp="What flag indicates medium model?"
		. myread
		case "$ans" in
		none) ans='';
		esac
		medium="$ans";;
	*) medium="$large";;
	esac
	case "$model" in
	*small*) case "$small" in
		'') dflt='none';;
		*) dflt="$small";;
		esac
		rp="What flag indicates small model?"
		. myread
		case "$ans" in
		none) ans='';
		esac
		small="$ans";;
	*) small='';;
	esac
	;;
*)
	echo "Unrecognized memory models--you may have to edit Makefile.SH" >&3
	;;
esac

: make some quick guesses about what we are up against
echo " "
$echo $n "Hmm...  $c" >&3
$cat /usr/include/signal.h /usr/include/sys/signal.h >foo 2>/dev/null
if test `echo abc | tr a-z A-Z` = Abc ; then
	xxx=`./loc addbib blurfl $pth`
	if $test -f $xxx; then
echo "Looks kind of like a USG system with BSD features, but we'll see..." >&3
		echo exit 0 >bsd
		echo exit 0 >usg
		echo exit 1 >v7
	else
		if $contains SIGTSTP foo >/dev/null 2>&1 ; then
		echo "Looks kind of like an extended USG system, but we'll see..." >&3
		else
			echo "Looks kind of like a USG system, but we'll see..." >&3
		fi
		echo exit 1 >bsd
		echo exit 0 >usg
		echo exit 1 >v7
	fi
	d_bsd="$undef"
elif $contains SIGTSTP foo >/dev/null 2>&1 ; then
	echo "Looks kind of like a BSD system, but we'll see..." >&3
	d_bsd="$define"
	echo exit 0 >bsd
	echo exit 1 >usg
	echo exit 1 >v7
else
	echo "Looks kind of like a Version 7 system, but we'll see..." >&3
	d_bsd="$undef"
	echo exit 1 >bsd
	echo exit 1 >usg
	echo exit 0 >v7
fi
case "$eunicefix" in
*unixtovms*)
	cat <<'EOI'
There is, however, a strange, musty smell in the air that reminds me of
something...hmm...yes...I've got it...there's a VMS nearby, or I'm a Blit.
EOI
	echo "exit 0" >eunice
	d_eunice="$define"
: it so happens the Eunice I know will not run shell scripts in Unix format
	;;
*)
	echo " "
	echo "Congratulations.  You aren't running Eunice."
	d_eunice="$undef"
	echo "exit 1" >eunice
	;;
esac
if test -f /xenix; then
	echo "Actually, this looks more like a XENIX system..."
	echo "exit 0" >xenix
	d_xenix="$define"
else
	echo " "
	echo "It's not Xenix..."
	echo "exit 1" >xenix
	d_xenix="$undef"
fi
chmod +x xenix
$eunicefix xenix
if test -f /venix; then
	echo "Actually, this looks more like a VENIX system..."
	echo "exit 0" >venix
else
	echo " "
	if xenix; then
		: null
	else
		echo "Nor is it Venix..."
	fi
	echo "exit 1" >venix
fi
chmod +x bsd usg v7 eunice venix
$eunicefix bsd usg v7 eunice venix
$rm -f foo

: see if we need a special compiler
echo " "
if usg; then
	case "$cc" in
	'') case "$Mcc" in
		/*) dflt='Mcc';;
		*) case "$large" in
			-M*) dflt='cc';;
			*)	if $contains '\-M' $sysman/cc.1 >/dev/null 2>&1 ; then
					if $contains '\-M' $sysman/cpp.1 >/dev/null 2>&1; then
						dflt='cc'
					else
						dflt='cc -M'
					fi
				else
					dflt='cc'
				fi;;
			esac;;
		esac;;
	*)  dflt="$cc";;
	esac
	$cat <<'EOM'
On some systems the default C compiler will not resolve multiple global
references that happen to have the same name.  On some such systems the "Mcc"
command may be used to force these to be resolved.  On other systems a "cc -M"
command is required.  (Note that the -M flag on other systems indicates a
memory model to use!) If you have the Gnu C compiler, you might wish to use
that instead.

EOM
	rp="What command will force resolution on this system?"
	. myread
	cc="$ans"
else
	case "$cc" in
	'') dflt=cc;;
	*) dflt="$cc";;
	esac
	rp="Use which C compiler?"
	. myread
	cc="$ans"
fi
case "$cc" in
gcc*) cpp=`loc gcc-cpp $cpp $pth`;;
esac

: decide how portable to be
case "$d_portable" in
"$define") dflt=y;;
*)	dflt=n;;
esac
$cat <<'EOH'
 
I can set things up so that your shell scripts and binaries are more portable,
at what may be a noticable cost in performance.  In particular, if you
ask to be portable, the following happens:

     1) Shell scripts will rely on the PATH variable rather than using
	the paths derived above.
     2) ~username interpretations will be done at run time rather than
	by Configure.
     3) The system name will be determined at run time, if at all possible.

EOH
rp="Do you expect to run these scripts and binaries on multiple machines?"
. myread
case "$ans" in
	y*) d_portable="$define"
	for file in $loclist; do
		eval $file=$file
	done
	;;
	*)  d_portable="$undef" ;;
esac

: now set up to get a file name with possible "~name" substitutions
cat <<'EOSC' >getfile
tilde=''
fullpath=''
already=''
skip=''
none_ok=''
orig_rp="$rp"
orig_dflt="$dflt"

case "$fn" in
*~*) tilde=true;;
esac
case "$fn" in
*/*) fullpath=true;;
esac
case "$fn" in
*+*) skip=true;;
esac
case "$fn" in
*n*) none_ok=true;;
esac

case "$fn" in
*f*) type='File';;
*d*) type='Directory';;
*l*) type='Locate'; fn=`expr $fn : '.*:\(.*\)'`;;
esac

what="$type"
case "$what" in
Locate) what='File';;
esac

while test "$type"; do
	redo=''
	rp="$orig_rp"
	dflt="$orig_dflt"
	case "$tilde" in
	true) rp="$rp (~name ok)";;
	esac
	. myread
	case "$ans" in
	none)
		value=''
		case "$none_ok" in
		true) type='';;
		esac
		;;
	*)
		case "$tilde" in
		'') value="$ans";;
		*)
			value=`./filexp $ans`
			case $? in
			0)
				if test "$ans" != "$value"; then
					echo "(That is $value on this particular system.)"
				fi
				;;
			*) value="$ans";;
			esac
			case "$d_portable" in
			"$define") value="$ans";;
			esac
			;;
		esac
		case "$fullpath" in
		true)
			case "$value" in
			/*) ;;
			*)
				redo=true
				case "$already" in
				true)
				echo "I shall only accept a full path name, as in /bin/ls." >&3
				echo "Use a ! shell escape if you wish to check pathnames." >&3
					;;
				*)
				echo "Please give a full path name, starting with slash." >&3
					case "$tilde" in
					true)
				echo "Note that using ~name is ok provided it expands well." >&3
						already=true
						;;
					esac
				esac
				;;
			esac
			;;
		esac
		case "$redo" in
		'')
			case "$type" in
			File)
				if test -f "$value"; then
					type=''
				elif test -r "$value" || (test -h "$value") >/dev/null 2>&1
				then
					echo "($value is not a plain file, but that's ok.)"
					type=''
				fi
				;;
			Directory)
				if test -d "$value"; then
					type=''
				fi
				;;
			Locate)
				if test -d "$value"; then
					echo "(Looking for $fn in directory $value.)"
					value="$value/$fn"
				fi
				if test -f "$value"; then
					type=''
				fi
				;;
			esac

			case "$skip" in
			true) type='';
			esac

			case "$type" in
			'') ;;
			*)
				if test "$fastread" = yes; then
					dflt=y
				else
					dflt=n
				fi
				rp="$what $value doesn't exist.  Use that name anyway?"
				. myread
				dflt=''
				case "$ans" in
				y*) type='';;
				*) echo " ";;
				esac
				;;
			esac
			;;
		esac
		;;
	esac
done
ans="$value"
rp="$orig_rp"
dflt="$orig_dflt"
EOSC

: What should the include directory be ?
echo " "
$echo $n "Hmm...  $c"
case "$usrinc" in
'') dflt='/usr/include';;
*) dflt=$usrinc;;
esac
incpath=''
mips_type=''
if $test -f /bin/mips && /bin/mips; then
	echo "Looks like a MIPS system..."
	$cat >usr.c <<'EOCP'
#ifdef SYSTYPE_BSD43
/bsd43
#endif
EOCP
	if $cc -E usr.c > usr.out && $contains / usr.out >/dev/null 2>&1; then
		dflt='/bsd43/usr/include'
		incpath='/bsd43'
		mips_type='BSD 4.3'
	else
		mips_type='System V'
	fi
	$rm -f usr.c usr.out
	echo "and you're compiling with the $mips_type compiler and libraries."
else
	echo "Doesn't look like a MIPS system."
	echo "exit 1" >mips
	chmod +x mips
	$eunicefix mips
fi
echo " "
fn=d/
rp='Where are the include files you want to use?'
. getfile
usrinc="$ans"

: determine optimize, if desired, or use for debug flag also
case "$optimize" in
' ') dflt="none";;
'') dflt="-O";;
*) dflt="$optimize";;
esac
$cat <<EOH

Some C compilers have problems with their optimizers, by default, $package
compiles with the -O flag to use the optimizer.  Alternately, you might want to
use the symbolic debugger, which uses the -g flag (on traditional Unix systems).
Either flag can be specified here. To use neither flag, specify the word "none".

EOH
rp="What optimizer/debugger flag should be used?"
. myread
optimize="$ans"
case "$optimize" in
'none') optimize=" ";;
esac

case "$ccflags" in
'') case "$cc" in
	*gcc*) dflt='-fpcc-struct-return';;
	*) dflt='';;
	esac
	;;
*) dflt="$ccflags"
	case "$cc" in
	*gcc*) case "$dflt" in
		*-fpcc-struct-return*) ;;
		*) dflt="$dflt -fpcc-struct-return";;
		esac;;
	esac;;
esac

case "$mips_type" in
*BSD*) ;;
'') ;;
*) inclwanted="$inclwanted $usrinc/bsd";;
esac
for thisincl in $inclwanted; do
	if $test -d $thisincl; then
		if $test x$thisincl != x$usrinc; then
			case "$dflt" in
			*$thisincl*);;
			*) dflt="$dflt -I$thisincl";;
			esac
		fi
	fi
done

case "$optimize" in
-g*)
	case "$dflt" in
	*DEBUG*);;
	*) dflt="$dflt -DDEBUG";;
	esac
	;;
esac

inctest='if $contains $2 $usrinc/$1 >/dev/null 2>&1; then
	xxx=true;
elif $contains $2 $usrinc/sys/$1 >/dev/null 2>&1; then
	xxx=true;
else
	xxx=false;
fi;
if $xxx; then
	case "$dflt" in
	*$2*);;
	*) dflt="$dflt -D$2";;
	esac;
fi'

set signal.h LANGUAGE_C; eval $inctest
set signal.h NO_PROTOTYPE; eval $inctest
set signal.h _NO_PROTO; eval $inctest

case "$dflt" in
'') dflt=none;;
esac
$cat <<EOH

Your C compiler may want other flags.  For this question you should include
-I/whatever and -DWHATEVER flags and any other flags used by the C compiler,
but you should NOT include libraries or ld flags like -lwhatever.  To use no
flags, specify the word "none".

EOH
set X $dflt
shift
dflt=${1+"$@"}
rp="Any additional cc flags?"
. myread
case "$ans" in
none) ans='';
esac
ccflags="$ans"

: the following weeds options from ccflags that are of no interest to cpp
cppflags="$ccflags"
case "$cc" in
*gcc*) cppflags="$cppflags -D__GNUC__";;
esac
case "$mips_type" in
'');;
*BSD*) cppflags="$cppflags -DSYSTYPE_BSD43";;
esac
case "$cppflags" in
'');;
*)  set X $cppflags
	cppflags=''
	for flag
	do
		case $flag in
		-D*|-I*|-traditional|-ansi|-nostdinc) cppflags="$cppflags $flag";;
		esac
	done
	case "$cppflags" in
	*-*)  echo "(C preprocessor flags: $cppflags)";;
	esac
	;;
esac

: flags used in final linking phase
case "$ldflags" in
'') if venix; then
		dflt='-i -z'
	else
		dflt='none'
	fi
	;;
*) dflt="$ldflags";;
esac
echo " "
rp="Any additional ld flags (NOT including libraries)?"
. myread
case "$ans" in
none) ans='';
esac
ldflags="$ans"
rmlist="$rmlist pdp11"

: Initialize h_fcntl
h_fcntl=false

: Initialize h_sysfile
h_sysfile=false

: Set private lib path
case "$plibpth" in
'') if mips; then
		plibpth="$incpath/usr/lib /usr/local/lib /usr/ccs/lib"
	else
		plibpth="/usr/ccs/lib /usr/lib /usr/ucblib /usr/local/lib"
	fi;;
esac
libpth="$plibpth $libpth"

: Looking for optional libraries
echo " "
echo "Checking for optional libraries..." >&3
case "$libs" in
'') dflt='';;
*) dflt="$libs";;
esac
case "$libswanted" in
'') libswanted='c_s';;
esac
for thislib in $libswanted; do
	case "$thislib" in
	dbm) thatlib=ndbm;;
	*_s) thatlib=NONE;;
	*) thatlib="${thislib}_s";;
	*) thatlib=NONE;;
	esac
	yyy="$incpath/usr/ccs/lib $incpath/usr/lib $incpath/usr/ucblib"
	yyy="$yyy $incpath/usr/local/lib $incpath/lib"
	xxx=`loc lib$thislib.a X $yyy`
	if $test -f $xxx; then
		echo "Found -l$thislib."
		case "$dflt" in
		*-l$thislib*|*-l$thatlib*);;
		*) dflt="$dflt -l$thislib";;
		esac
	else
		xxx=`loc lib$thislib.a X $libpth`
		if $test -f $xxx; then
			echo "Found $xxx."
			case "$dflt" in
			*$xxx*);;
			*) dflt="$dflt $xxx";;
			esac
		else
			xxx=`loc Slib$thislib.a X $xlibpth`
			if $test -f $xxx; then
				echo "Found -l$thislib."
				case "$dflt" in
				*-l$thislib*|*-l$thatlib*);;
				*) dflt="$dflt -l$thislib";;
				esac
			else
				echo "No -l$thislib."
			fi
		fi
	fi
done
set X $dflt
shift
dflt="$*"
case "$libs" in
'') dflt="$dflt";;
*) dflt="$libs";;
esac
case "$dflt" in
'') dflt='none';;
esac

$cat <<EOM
 
Some versions of Unix support shared libraries, which make executables smaller
but make load time slightly longer.

On some systems, mostly newer Unix System V's, the shared library is included
by putting the option "-lc_s" as the last thing on the cc command line when
linking.  Other systems use shared libraries by default.  There may be other
libraries needed to compile $package on your machine as well.  If your system
needs the "-lc_s" option, include it here.  Include any other special libraries
here as well.  Say "none" for none.
EOM

echo " "
rp="Any additional libraries?"
. myread
case "$ans" in
none) ans='';
esac
libs="$ans"

: see if nm is to be used to determine whether a symbol is defined or not
case "$usenm" in
'')
	dflt=`egrep 'inlibc|csym' ../Configure | wc -l 2>/dev/null`
	if $test $dflt -gt 20; then
		dflt=y
	else
		dflt=n
	fi
	;;
*)
	case "$usenm" in
	true) dflt=y;;
	*) dflt=n;;
	esac
	;;
esac
$cat <<EOM

I can use 'nm' to extract the symbols from your C libraries. This is a time
consuming task which may generate huge output on the disk (up to 3 megabytes)
but that should make the symbols extraction faster. The alternative is to skip
the 'nm' extraction part and to compile a small test program instead to
determine whether each symbol is present. If you have a fast C compiler and/or
if your 'nm' output cannot be parsed, this may be the best solution.

EOM
rp='Shall I use nm to extract C symbols from the libraries?'
. myread
case "$ans" in
n|N) usenm=false;;
*) usenm=true;;
esac

runnm=$usenm
case "$reuseval" in
true) runnm=false;
esac

: nm options which may be necessary
case "$nm_opt" in
'') if $test -f /mach_boot; then
		nm_opt=''
	elif $test -d /usr/ccs/lib; then
		nm_opt='-p'
	elif $test -f /dgux; then
		nm_opt='-p'
	else
		nm_opt=''
	fi;;
esac

case "$runnm" in
true)
: indentation is wrong on purpose--RAM
: get list of predefined functions in a handy place
echo " "
case "$libc" in
'') libc=unknown
	case "$libs" in
	*-lc_s*) libc=`loc libc_s.a $libc $libpth`
	esac
	;;
esac
libpth="$plibpth $libpth"
libnames='';
case "$libs" in
'') ;;
*)  for thislib in $libs; do
	case "$thislib" in
	-l*)
		thislib=`expr X$thislib : 'X-l\(.*\)'`
		try=`loc lib$thislib.a blurfl/dyick $libpth`
		if test ! -f $try; then
			try=`loc lib$thislib blurfl/dyick $libpth`
			if test ! -f $try; then
				try=`loc $thislib blurfl/dyick $libpth`
				if test ! -f $try; then
					try=`loc Slib$thislib.a blurfl/dyick $xlibpth`
					if test ! -f $try; then
						try=''
					fi
				fi
			fi
		fi
		libnames="$libnames $try"
		;;
	*) libnames="$libnames $thislib" ;;
	esac
	done
	;;
esac
case "$libc" in
unknown)
	set /usr/ccs/lib/libc.so
	$test -r $1 || set /usr/lib/libc.so
	$test -r $1 || set /usr/lib/libc.so.[0-9]*
	$test -r $1 || set /lib/libsys_s.a
	eval set \$$#
	;;
*)
	set blurfl
	;;
esac
if $test -r "$1"; then
	echo "Your (shared) C library seems to be in $1."
	libc="$1"
elif $test -r /lib/libc && $test -r /lib/clib; then
	echo "Your C library seems to be in both /lib/clib and /lib/libc."
	libc='/lib/clib /lib/libc'
	if $test -r /lib/syslib; then
		echo "(Your math library is in /lib/syslib.)"
		libc="$libc /lib/syslib"
	fi
elif $test -r "$libc" || (test -h "$libc") >/dev/null 2>&1; then
	echo "Your C library seems to be in $libc, as you said before."
elif $test -r $incpath/usr/lib/libc.a; then
	libc=$incpath/usr/lib/libc.a;
	echo "Your C library seems to be in $libc.  That's fine."
elif $test -r /lib/libc.a; then
	libc=/lib/libc.a;
	echo "Your C library seems to be in $libc.  You're normal."
else
	if ans=`./loc libc.a blurfl/dyick $libpth`; $test -r "$ans"; then
		:
	elif ans=`./loc libc blurfl/dyick $libpth`; $test -r "$ans"; then
		libnames="$libnames "`./loc clib blurfl/dyick $libpth`
	elif ans=`./loc clib blurfl/dyick $libpth`; $test -r "$ans"; then
		:
	elif ans=`./loc Slibc.a blurfl/dyick $xlibpth`; $test -r "$ans"; then
		:
	elif ans=`./loc Mlibc.a blurfl/dyick $xlibpth`; $test -r "$ans"; then
		:
	else
		ans=`./loc Llibc.a blurfl/dyick $xlibpth`
	fi
	if $test -r "$ans"; then
		echo "Your C library seems to be in $ans, of all places."
		libc=$ans
	else
		libc='blurfl'
	fi
fi
if $test -r "$libc" || (test -h "$libc") >/dev/null 2>&1; then
	dflt="$libc"
	cat <<EOM

If the guess above is wrong (which it might be if you're using a strange
compiler, or your machine supports multiple models), you can override it here.

EOM
else
	dflt=''
	echo $libpth | tr ' ' '\012' | sort | uniq > libpath
	cat >&3 <<EOM
I can't seem to find your C library.  I've looked in the following places:

EOM
	$sed 's/^/	/' libpath
	cat <<EOM

None of these seems to contain your C library. I need to get its name...

EOM
fi
fn=f
rp='Where is your C library?'
. getfile
libc="$ans"

echo " "
echo $libc $libnames | tr ' ' '\012' | sort | uniq > libnames
set X `cat libnames`
shift
xxx=files
case $# in 1) xxx=file; esac
echo "Extracting names from the following $xxx for later perusal:" >&3
echo " "
$sed 's/^/	/' libnames >&3
echo " "
$echo $n "This may take a while...$c" >&3

nm $nm_opt $* 2>/dev/null >libc.tmp
$echo $n ".$c"
$grep fprintf libc.tmp > libc.ptf
xscan='eval "<libc.ptf $com >libc.list"; $echo $n ".$c" >&3'
xrun='eval "<libc.tmp $com >libc.list"; echo "done" >&3'
if com="$sed -n -e 's/^.* [ADTS]  *_[_.]*//p' -e 's/^.* [ADTS] //p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^__*//' -e 's/^\([a-zA-Z_0-9$]*\).*xtern.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e '/|UNDEF/d' -e '/FUNC..GL/s/^.*|__*//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.* D __*//p' -e 's/^.* D //p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^_//' -e 's/^\([a-zA-Z_0-9]*\).*xtern.*text.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$grep '|' | $sed -n -e '/|COMMON/d' -e '/|DATA/d' \
				-e '/ file/d' -e 's/^\([^ 	]*\).*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p' -e 's/^.*|FUNC |WEAK .*|//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^__//' -e '/|Undef/d' -e '/|Proc/s/ .*//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
else
	nm -p $* 2>/dev/null >libc.tmp
	com="$sed -n -e 's/^.* [ADTS]  *_[_.]*//p' -e 's/^.* [ADTS] //p'";\
	eval "<libc.tmp $com >libc.list"
	if $contains '^fprintf$' libc.list >/dev/null 2>&1; then
		nm_opt='-p'
		echo "done" >&3
	else
		echo " "
		echo "nm didn't seem to work right. Trying ar instead..." >&3
		com=''
		if ar t $libc > libc.tmp; then
			for thisname in $libnames; do
				ar t $thisname >>libc.tmp
			done
			$sed -e 's/\.o$//' < libc.tmp > libc.list
			echo "Ok." >&3
		else
			echo "ar didn't seem to work right." >&3
			echo "Maybe this is a Cray...trying bld instead..." >&3
			if bld t $libc | $sed -e 's/.*\///' -e 's/\.o:.*$//' > libc.list; then
				for thisname in $libnames; do
					bld t $libnames | \
					$sed -e 's/.*\///' -e 's/\.o:.*$//' >>libc.list
					ar t $thisname >>libc.tmp
				done
				echo "Ok." >&3
			else
				echo "That didn't work either.  Giving up." >&3
				exit 1
			fi
		fi
	fi
fi
nm_extract="$com"
if $test -f /lib/syscalls.exp; then
	echo " "
	echo "Also extracting names from /lib/syscalls.exp for good ole AIX..." >&3
	$sed -n 's/^\([^ 	]*\)[ 	]*syscall$/\1/p' /lib/syscalls.exp >>libc.list
fi
: remember, indentation is wrong on purpose--RAM
;;
esac
$rm -f libnames libpath

: is a C symbol defined?
csym='tlook=$1;
case "$3" in
-v) tf=libc.tmp; tc=""; tdc="";;
-a) tf=libc.tmp; tc="[0]"; tdc=[];;
*) tlook="^$1\$"; tf=libc.list; tc="()"; tdc="()";;
esac;
tx=yes;
case "$reuseval-$4" in
true-) ;;
true-*) tx=no; eval "tval=\$$4"; case "$tval" in "") tx=yes;; esac;;
esac;
case "$tx" in
yes)
	case "$runnm" in
	true)
		if $contains $tlook $tf >/dev/null 2>&1;
		then tval=true;
		else tval=false;
		fi;;
	*)
		echo "main() { extern int $1$tdc; printf(\"%d\", $1$tc); }" > t.c;
		if $cc $ccflags -o t t.c $libs >/dev/null 2>&1;
		then tval=true;
		else tval=false;
		fi;
		$rm -f t t.c;;
	esac;;
*)
	case "$tval" in
	$define) tval=true;;
	*) tval=false;;
	esac;;
esac;
eval "$2=$tval'

: set up the script used to warn in case of inconsistency
cat <<'EOSC' >whoa
dflt=y
echo " "
echo "*** WHOA THERE!!! ***" >&3
echo "    The $hint value for \$$var on this machine was \"$was\"!" >&3
rp="    Keep the $hint value?"
. myread
case "$ans" in
y) td=$was; tu=$was;;
esac
EOSC

: define an is-in-libc? function
inlibc='echo " "; td=$define; tu=$undef;
sym=$1; var=$2; eval "was=\$$2";
tx=yes;
case "$reuseval$was" in
true) ;;
true*) tx=no;;
esac;
case "$tx" in
yes)
	set $sym tres -f;
	eval $csym;
	case "$tres" in
	true)
		echo "$sym() found." >&3;
		case "$was" in $undef) . whoa; esac; eval "$var=\$td";;
	*)
		echo "$sym() NOT found." >&3;
		case "$was" in $define) . whoa; esac; eval "$var=\$tu";;
	esac;;
*)
	case "$was" in
	$define) echo "$sym() found." >&3;;
	*) echo "$sym() NOT found." >&3;;
	esac;;
esac'

: see how we invoke the C preprocessor
echo " "
echo "Now, how can we feed standard input to your C preprocessor..." >&3
cat <<'EOT' >testcpp.c
#define ABC abc
#define XYZ xyz
ABC.XYZ
EOT
cd ..
echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
chmod 755 cppstdin
wrapper=`pwd`/cppstdin
cd UU
if $test "X$cppstdin" != "X" && \
	$cppstdin $cppminus <testcpp.c >testcpp.out 2>&1 && \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "You used to use $cppstdin $cppminus so we'll use that again."
elif $test "$cc" = gcc && \
	(echo "Using gcc, eh?  We'll try to force gcc -E using a wrapper..."; \
	$wrapper <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1) ; then
	echo "Yup, we can."
	cppstdin="$wrapper"
	cppminus='';
elif echo 'Maybe "'"$cc"' -E" will work...'; \
	$cc -E <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	cppstdin="$cc -E"
	cppminus='';
elif echo 'Nope...maybe "'"$cc"' -E -" will work...'; \
	$cc -E - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	cppstdin="$cc -E"
	cppminus='-';
elif echo 'Uh-uh.  Time to get fancy.  Trying a wrapper...'; \
	$wrapper <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	cppstdin="$wrapper"
	cppminus=''
	echo "Eureka!"
elif echo 'No such luck, maybe "'$cpp'" will work...'; \
	$cpp <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "It works!"
	cppstdin="$cpp"
	cppminus='';
elif echo 'Nixed again...maybe "'$cpp' -" will work...'; \
	$cpp - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Hooray, it works!  I was beginning to wonder."
	cppstdin="$cpp"
	cppminus='-';
elif echo 'Nope...maybe "'"$cc"' -P" will work...'; \
	$cc -P <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yipee, that works!"
	cppstdin="$cc -P"
	cppminus='';
elif echo 'Nope...maybe "'"$cc"' -P -" will work...'; \
	$cc -P - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "At long last!"
	cppstdin="$cc -P"
	cppminus='-';
else
	dflt=''
	rp="No dice.  I can't find a C preprocessor.  Name one:"
	. myread
	cppstdin="$ans"
	$cppstdin <testcpp.c >testcpp.out 2>&1
	if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
		echo "OK, that will do." >&3
	else
echo "Sorry, I can't get that to work.  Go find one and rerun Configure." >&3
		exit 1
	fi
fi
$rm -f testcpp.c testcpp.out

: determine filename position in cpp output
echo " "
echo "Computing filename position in cpp output for #include directives..." >&3
echo '#include <stdio.h>' > foo.c
$cat >fieldn <<EOF
$startsh
$cppstdin $cppminus $cppflags <foo.c 2>/dev/null | \
$grep '^[ 	]*#.*stdio\.h' | \
while read cline; do
	pos=1
	set \$cline
	while $test \$# -gt 0; do
		if $test -r \`echo \$1 | $tr -d '"'\`; then
			echo "\$pos"
			exit 0
		fi
		shift
		pos=\`expr \$pos + 1\`
	done
done
EOF
chmod +x fieldn
fieldn=`./fieldn`
$rm -f foo.c fieldn
case $fieldn in
'') pos='???';;
1) pos=first;;
2) pos=second;;
3) pos=third;;
*) pos="${fieldn}th";;
esac
echo "Your cpp writes the filename in the $pos field of the line."

: locate header file
$cat >findhdr <<EOF
$startsh
wanted=\$1
name=''
if test -f $usrinc/\$wanted; then
	echo "$usrinc/\$wanted"
	exit 0
fi
awkprg='{ print \$$fieldn }'
echo "#include <\$wanted>" > foo\$\$.c
$cppstdin $cppminus $cppflags < foo\$\$.c 2>/dev/null | \
$grep "^[ 	]*#.*\$wanted" | \
while read cline; do
	name=\`echo \$cline | $awk "\$awkprg" | $tr -d '"'\`
	case "\$name" in
	*/\$wanted) echo "\$name"; exit 0;;
	*) name='';;
	esac;
done;
$rm -f foo\$\$.c;
case "\$name" in
'') exit 1;;
esac
EOF
chmod +x findhdr

: access call always available on UNIX
set access d_access
eval $inlibc

: locate the flags for 'access()'
case "$d_access" in
"$define")
	echo " "
	$cat >access.c <<'EOCP'
#include <sys/types.h>
#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif
#ifdef I_UNISTD
#include <unistd.h>
#endif
main() {
	exit(R_OK);
}
EOCP
	: check sys/file.h first, no particular reason here
	if $test `./findhdr sys/file.h` && \
		$cc $cppflags -DI_SYS_FILE access.c -o access >/dev/null 2>&1 ; then
		h_sysfile=true;
		echo "<sys/file.h> defines the *_OK access constants." >&3
	elif $test `./findhdr fcntl.h` && \
		$cc $cppflags -DI_FCNTL access.c -o access >/dev/null 2>&1 ; then
		h_fcntl=true;
		echo "<fcntl.h> defines the *_OK access constants." >&3
	else
		echo "I can't find the four *_OK access constants--I'll use mine." >&3
	fi
	;;
esac
$rm -f access*

: see if bcmp exists
case "$d_bcmp" in
$define) d_bcmp="$undef";;
$undef) d_bcmp="$define";;
esac
set bcmp d_bcmp
eval $inlibc
case "$d_bcmp" in
$define) d_bcmp="$undef";;
*) d_bcmp="$define";;
esac

: see if bcopy exists
case "$d_bcopy" in
$define) d_bcopy="$undef";;
$undef) d_bcopy="$define";;
esac
set bcopy d_bcopy
eval $inlibc
case "$d_bcopy" in
$define) d_bcopy="$undef";;
*) d_bcopy="$define";;
esac

: function used to set $1 to $val
setvar='var=$1; eval "was=\$$1"; td=$define; tu=$undef;
case "$val$was" in
$define$undef) . whoa; eval "$var=\$td";;
$undef$define) . whoa; eval "$var=\$tu";;
*) eval "$var=$val";;
esac'

: see if _setjmp and _longjmp exists
echo " "
case "$d_bsdjmp" in
'')
	$cat >set.c <<EOP
#include <setjmp.h>
jmp_buf env;
int set = 1;
main()
{
	if (_setjmp(env))
		exit(set);
	set = 0;
	_longjmp(env, 1);
	exit(1);
}
EOP
	if $cc set.c -o set $libs >/dev/null 2>&1; then
		if ./set >/dev/null 2>&1; then
			echo "Good! You have BSD _setjmp and _longjmp routines." >&3
			val="$define"
		else
			$cat <<EOM
Uh-Oh! You have BSD _setjmp and _longjmp, but they do not work properly!!
EOM
			val="$undef"
		fi
	else
		if usg; then
			echo "You do not have _setjmp and _longjmp, but that's fine." >&3
		else
			cat <<EOM
It sounds strange for a BSD system to miss _setjmp and _longjmp, but that's ok.
EOM
		fi
		val="$undef"
	fi
	;;
*) val="$d_bsdjmp"
	case "$d_bsdjmp" in
	$define) echo "Good! You have BSD _setjmp and _longjmp routines." >&3;;
	$undef) echo "You do not have _setjmp and _longjmp, but that's fine." >&3;;
	esac
	;;
esac
set d_bsdjmp
eval $setvar
$rm -f set.c set

: see if setpgrp exists
set setpgrp d_setpgrp
eval $inlibc

: see which flavor of setpgrp is in use
case "$d_setpgrp" in
"$define")
	echo " "
	$cat >set.c <<EOP
main()
{
	if (getuid() == 0) {
		printf("(I see you are running Configure as super-user...)\n");
		setuid(1);
	}
	if (-1 == setpgrp(1, 1))
		exit(1);
	exit(0);
}
EOP
	if $cc $ccflags -o set set.c $libs >/dev/null 2>&1; then
		./set 2>/dev/null
		case $? in
		0) echo "You have to use setpgrp() instead of setpgrp(pid, pgrp)." >&3
			val="$undef";;
		*) echo "You have to use setpgrp(pid, pgrp) instead of setpgrp()." >&3
			val="$define";;
		esac
	else
		if usg; then
			xxx="USG one, i.e. you use setpgrp()."
			val="$undef"
		else
			xxx="BSD one, i.e. you use setpgrp(pid, pgrp)."
			val="$define"
		fi
		echo "Assuming your setpgrp is a $xxx" >&3
	fi
	;;
*) val="$undef";;
esac
set d_bsdpgrp
eval $setvar
$rm -f set set.c

: see if bzero exists
case "$d_bzero" in
$define) d_bzero="$undef";;
$undef) d_bzero="$define";;
esac
set bzero d_bzero
eval $inlibc
case "$d_bzero" in
$define) d_bzero="$undef";;
*) d_bzero="$define";;
esac

: see if this is a dirent system
echo " "
if xinc=`./findhdr dirent.h`; $test "$xinc"; then
	val="$define"
	echo "<dirent.h> found." >&3
else
	val="$undef"
	if xinc=`./findhdr sys/dir.h`; $test "$xinc"; then
		echo "<sys/dir.h> found." >&3
		echo " "
	else
		xinc=`./findhdr sys/ndir.h`
	fi
	echo "<dirent.h> NOT found." >&3
fi
set i_dirent
eval $setvar

: see if the directory entry stores field length
echo " "
if $contains 'd_namlen' $xinc >/dev/null 2>&1; then
	echo "Good, your directory entry keeps length information in d_namlen." >&3
	val="$define"
else
	echo "Your directory entry does not know about the d_namlen field." >&3
	val="$undef"
fi
set d_dirnamlen
eval $setvar

: see if dup2 exists
set dup2 d_dup2
eval $inlibc

: see if pipe correctly gives the EOF condition
echo " "
case "$d_eofpipe" in
'')
	echo "Let's see if your pipes return EOF to select() upon closing..." >&3
	$cat >pipe.c <<'EOP'
main()
{
	int pd[2];
	int mask;

	pipe(pd);
	if (0 == fork()) {
		close(pd[0]);
		close(pd[1]);
		exit(0);
	}

	close(pd[1]);
	mask = 1 << pd[0];
	alarm(2);
	select(32, &mask, (int *) 0, (int *) 0, (char *) 0);
	if (0 == read(pd[0], &mask, 1))
		exit(0);
	
	exit(1);
}
EOP
	if $cc $ccflags pipe.c -o pipe $libs >/dev/null 2>&1; then
		echo "./pipe || exit 1" > mpipe
		chmod +x mpipe
		./mpipe >/dev/null 2>&1
		case $? in
		0) d_eofpipe="$define";;
		*) d_eofpipe="$undef";;
		esac
	else
		echo "(The test program did not compile correctly -- Guessing.)"
		if bsd; then
			d_eofpipe="$define"
		else
			d_eofpipe="$undef"
		fi
	fi
	case "$d_eofpipe" in
	"$define") echo "Yes, they do.";;
	*) echo "No, they don't! (sigh)";;
	esac
	;;
*)
	$echo $n "Your pipes $c"
	case "$d_eofpipe" in
	"$define") echo "allow select() to see EOF upon closing.";;
	*) echo "won't let select() see EOF on closing.";;
	esac
	;;
esac
$rm -f *pipe* core

: see if this is an fcntl system
set fcntl d_fcntl
eval $inlibc

: see if gettimeofday or ftime exists
set gettimeofday d_gettimeod
eval $inlibc
case "$d_gettimeod" in
"$undef")
	set ftime d_ftime 
	eval $inlibc
	;;
*)
	val="$undef"; set d_ftime; eval $setvar
	;;
esac
case "$d_gettimeod$d_ftime" in
"$undef$undef")
	echo " "
	echo 'No ftime() nor gettimeofday() -- timing may be less accurate.' >&3
	;;
esac

: see if gethid exists
set gethostid d_gethid
eval $inlibc

: now get the host name
echo " "
echo "Figuring out host name..." >&3
cont=true
echo 'Maybe "hostname" will work...'
if ans=`sh -c hostname 2>&1` ; then
	myhostname=$ans
	phostname=hostname
	cont=''
fi
if $test "$cont"; then
	if xenix; then
		echo 'Oh, dear.  Maybe "/etc/systemid" is the key...'
		if ans=`cat /etc/systemid 2>&1` ; then
			myhostname=$ans
			phostname='cat /etc/systemid'
			echo "Whadyaknow.  Xenix always was a bit strange..."
			cont=''
		fi
	elif $test -r /etc/systemid; then
		echo "(What is a non-Xenix system doing with /etc/systemid?)"
	fi
fi
if $test "$cont"; then
	echo 'No, maybe "uuname -l" will work...'
	if ans=`sh -c 'uuname -l' 2>&1` ; then
		myhostname=$ans
		phostname='uuname -l'
	else
		echo 'Strange.  Maybe "uname -n" will work...'
		if ans=`sh -c 'uname -n' 2>&1` ; then
			myhostname=$ans
			phostname='uname -n'
		else
			echo 'Oh well, maybe I can mine it out of whoami.h...'
			if ans=`sh -c $contains' sysname $usrinc/whoami.h' 2>&1` ; then
				myhostname=`echo "$ans" | $sed 's/^.*"\(.*\)"/\1/'`
				phostname="sed -n -e '"'/sysname/s/^.*\"\\(.*\\)\"/\1/{'"' -e p -e q -e '}' <$usrinc/whoami.h"
			else
				case "$myhostname" in
				'') echo "Does this machine have an identity crisis or something?"
					phostname='';;
				*) echo "Well, you said $myhostname before...";;
				esac
			fi
		fi
	fi
fi
: you do not want to know about this
set $myhostname
myhostname=$1

: translate upper to lower if necessary
case "$myhostname" in
*[A-Z]*)
	myhostname=`echo $myhostname | tr '[A-Z]' '[a-z]'`
	echo "(Normalizing case in your host name)"
	;;
esac

: verify guess
if $test "$myhostname" ; then
	dflt=y
	rp='Your host name appears to be "'$myhostname'".'" Right?"
	. myread
	case "$ans" in
	y*) ;;
	*) myhostname='';;
	esac
fi

: bad guess or no guess
while $test "X$myhostname" = X ; do
	dflt=''
	rp="Please type the (one word) name of your host:"
	. myread
	myhostname="$ans"
done

: a little sanity check here
case "$phostname" in
'') ;;
*)
	case `$phostname` in
	$myhostname$mydomain|$myhostname) ;;
	*)
		case "$phostname" in
		sed*)
			echo "(That doesn't agree with your whoami.h file, by the way.)"
			;;
		*)
			echo "(That doesn't agree with your $phostname command, by the way.)"
			;;
		esac
	phostname=''
	;;
	esac
	;;
esac

: see how we will look up host name
echo " "
if false; then
	: dummy stub to allow use of elif
elif set gethostname val -f d_gethname; eval $csym; $val; then
	echo 'gethostname() found.' >&3
	d_gethname="$define"
	ans=gethostname
elif set uname val -f d_uname; eval $csym; $val; then
	if xenix; then
		$cat <<'EOM'
uname() was found, but you're running xenix, and older versions of xenix
have a broken uname(). If you don't really know whether your xenix is old
enough to have a broken system call, use the default answer.

EOM
		dflt=y
		case "$d_uname" in
		"$define") dflt=n;;
		esac
		rp='Is your uname() broken?'
		. myread
		case "$and" in
		n*) d_uname="$define"; ans=uname;;
		esac
	else
		echo 'uname() found.' >&3
		d_uname="$define"
		ans=uname
	fi
fi
case "$d_gethname" in
'') d_gethname="$undef";;
esac
case "$d_uname" in
'') d_uname="$undef";;
esac
case "$d_uname$d_gethname" in
*define*)
	dflt=n
	cat <<EOM
 
Every now and then someone has a $ans() that lies about the hostname
but can't be fixed for political or economic reasons.  If you wish, I can
pretend $ans() isn't there and maybe compute hostname at run-time
thanks to the '$phostname' command.

EOM
	rp="Shall I ignore $ans() from now on?"
	. myread
	case "$ans" in
	y*) d_uname="$undef" d_gethname="$undef"; $echo $n "Okay...$c";;
	esac;;
esac
case "$phostname" in
'') aphostname='';;
*) case "$aphostname" in
	/*) ;;
	*) set X $phostname
		shift
		file=$1
		shift
		file=`loc $file $file $pth`
		aphostname=`echo $file $*`
		;;
	esac
	;;
esac
case "$d_uname$d_gethname" in
*define*) ;;
*)
	case "$phostname" in
	'')
		echo "There will be no way for $package to get your hostname." >&3;;
	*)
	echo "I'll use 'popen("'"'$aphostname'", "r")'"' to get your hostname." >&3
		;;
	esac;;
esac
case "$d_phostname" in
'') d_phostname="$undef";;
esac

: see if getopt exists
set getopt d_getopt
eval $inlibc

: see which of string.h or strings.h is needed
echo " "
strings=`./findhdr string.h`
val="$undef"
if $test "$strings" && $test -r "$strings"; then
	echo "Using <string.h> instead of <strings.h>." >&3
	if bsd; then
		echo "(Actually, this looks more like it were an USG system)"
	fi
	val="$define"
else
	strings=`./findhdr strings.h`
	if $test "$strings" && $test -r "$strings"; then
		echo "Using <strings.h> instead of <string.h>." >&3
		if usg; then
			echo "(Actually, this looks more like it were a BSD system)"
		fi
	else
		echo "No string header found--You'll surely have problems." >&3
	fi
fi
set i_string
eval $setvar

: index or strchr
echo " "
case "$d_index" in
$define) dflt=n;;
*) dflt=y;;
esac
if set index val -f; eval $csym; $val; then
	if set strchr val -f d_index; eval $csym; $val; then
		if $contains strchr "$strings" >/dev/null 2>&1 ; then
			if $contains index "$strings" >/dev/null 2>&1 ; then
				echo "Your system has both index() and strchr()." >&3
				rp="Shall I use index() rather than strchr()?"
				. myread
				case "$ans" in
					n*) val="$define" ;;
					*)  val="$undef" ;;
				esac
			else
				val="$define"
				echo "strchr() found." >&3
			fi
		else
			val="$undef"
			echo "index() found." >&3
		fi
	else
		val="$undef"
		echo "index() found." >&3
	fi
else
	if set strchr val -f d_index; eval $csym; $val; then
		val="$define"
		echo "strchr() found." >&3
	else
		echo "No index() or strchr() found!" >&3
		val="$undef"
	fi
fi
set d_index
eval $setvar

socketlib=''
sockethdr=''
: see whether socket exists
echo " "
$echo $n "Hmm... $c" >&3
if set socket val -f d_socket; eval $csym; $val; then
	echo "Looks like you have Berkeley networking support." >&3
	d_socket="$define"
	if set setsockopt val -f; eval $csym; $val; then
		d_oldsock="$undef"
	else
		echo "...but it uses the old 4.1c interface, rather than 4.2" >&3
		d_oldsock="$define"
	fi
else
	if $contains socklib libc.list >/dev/null 2>&1; then
		echo "Looks like you have Berkeley networking support." >&3
		d_socket="$define"
		: we will have to assume that it supports the 4.2 BSD interface
		d_oldsock="$undef"
	else
		echo "You don't have Berkeley networking in libc.a..." >&3
		if test -f /usr/lib/libnet.a; then
			( (nm $nm_opt /usr/lib/libnet.a | eval $nm_extract) ||  \
			ar t /usr/lib/libnet.a) 2>/dev/null >> libc.list
			if $contains socket libc.list >/dev/null 2>&1; then
			echo "...but the Wollongong group seems to have hacked it in." >&3
				socketlib="-lnet"
				sockethdr="-I/usr/netinclude"
				d_socket="$define"
				if $contains setsockopt libc.list >/dev/null 2>&1; then
					d_oldsock="$undef"
				else
					echo "...using the old 4.1c interface, rather than 4.2" >&3
					d_oldsock="$define"
				fi
			else
				echo "or even in libnet.a, which is peculiar." >&3
				d_socket="$undef"
				d_oldsock="$undef"
			fi
		else
			echo "or anywhere else I see." >&3
			d_socket="$undef"
			d_oldsock="$undef"
		fi
	fi
fi

: see if setsockopt with SO_KEEPALIVE works as advertised
echo " "
case "$d_oldsock" in
"$undef")
	if $contains SO_KEEPALIVE `./findhdr sys/socket.h` \
		/dev/null >/dev/null 2>&1
	then
		echo "OK, let's see if SO_KEEPALIVE works as advertised..." >&3
		$cat > socket.c <<EOP
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

main()
{
	int s = socket(AF_INET, SOCK_STREAM, 0);
	if (s == -1)
		exit(1);
	if (-1 == setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, 0, 0))
		exit(2);
	exit(0);
}
EOP
		if $cc $ccflags $sockethdr socket.c -o socket $libs \
			$socketlib >/dev/null 2>&1; then
			./socket >/dev/null 2>&1
			case $? in
			0) echo "Yes, it does!"
				val="$define";;
			1) $cat <<EOM
(Something went wrong -- Assuming SO_KEEPALIVE is broken)
EOM
				val="$undef";;
			2) echo "No, it doesn't.  Don't trust your manuals!!"
				val="$undef";;
			esac
		else
			cat <<EOM
(I can't compile the test program -- Assuming SO_KEEPALIVE is broken)
EOM
			val="$undef"
		fi
	else
		echo "Strange!! You have BSD 4.2 sockets but no SO_KEEPALIVE option."
		val="$undef"
	fi;;
*) cat <<EOM
As you have an old socket interface, you can't have heard of SO_KEEPALIVE.
EOM
	val="$undef";;
esac
set d_keepalive
eval $setvar
$rm -f socket socket.c

: see if signals are kept
val="$undef";
echo " "
echo "Checking to see if signal handlers stick around..." >&3
$cat >try.c <<'EOCP'
foo() {}

main()
{
	signal(2, foo);
	kill(getpid(), 2);
	kill(getpid(), 2);
	printf("abc\n");
}
EOCP
if $cc -o try $ccflags try.c >/dev/null 2>&1; then
	sh -c ./try > try.out 2>/dev/null
	if $contains abc try.out >/dev/null 2>&1; then
		echo "Yes, they do."
		val="$define";
	else
		echo "No, they don't."
	fi
else
	$echo $n "(I can't seem to compile the test program. Assuming $c"
	if bsd; then
		echo "they do.)"
		val="$define"
	else
		echo "they don't.)"
	fi
fi
set d_keepsig
eval $setvar
$rm -f try*

: see if lstat exists
set lstat d_lstat
eval $inlibc

: see if we want to allow run-time panics
case "$d_maypanic" in
"$define") dflt=y ;;
*) dflt=n ;;
esac
$cat <<'EOM'

I can set up the run-time to do extra sanity checks which will incur a slight
execution overhead but provide better error tracking in case an inconsitency
appears. Typical checks include free-list consistency checks, stack overflow
or underflow, etc... Detecting the inconsistency when it appears simply avoids
cascade effects which may produce an inextricable mess in memory. This is only
an insurance against unexpected problems: in a perfect world, it would not
make things any different.

EOM
rp='Do you want to enable run-time extra checks?'
. myread
case "$ans" in
y*) val="$define" ;;
*) val="$undef" ;;
esac
set d_maypanic
eval $setvar

: see if mkdir exists
set mkdir d_mkdir
eval $inlibc

: Locate the flags for 'open()'
echo " "
$cat >open3.c <<'EOCP'
#include <sys/types.h>
#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif
main() {
	if(O_RDONLY);
#ifdef O_TRUNC
	exit(0);
#else
	exit(1);
#endif
}
EOCP
: check sys/file.h first to get FREAD on Sun
if $test `./findhdr sys/file.h` && \
		$cc $cppflags "-DI_SYS_FILE" open3.c -o open3 >/dev/null 2>&1 ; then
	h_sysfile=true;
	echo "<sys/file.h> defines the O_* constants..." >&3
	if ./open3; then
		echo "and you have the 3 argument form of open()." >&3
		val="$define"
	else
		echo "but not the 3 argument form of open().  Oh, well." >&3
		val="$undef"
	fi
elif $test `./findhdr fcntl.h` && \
		$cc "-DI_FCNTL" open3.c -o open3 >/dev/null 2>&1 ; then
	h_fcntl=true;
	echo "<fcntl.h> defines the O_* constants..." >&3
	if ./open3; then
		echo "and you have the 3 argument form of open()." >&3
		val="$define"
	else
		echo "but not the 3 argument form of open().  Oh, well." >&3
		val="$undef"
	fi
else
	val="$undef"
	echo "I can't find the O_* constant definitions!  You got problems." >&3
fi
set d_open3
eval $setvar
$rm -f open3*

: check for "kill(pid, 0)"
echo " "
case "$d_pidcheck" in
"$define")
echo "I already know your system supports kill(pid, 0) for pid checks." >&3
	;;
"$undef")
echo "We both know your system does not support signal #0 for pid checks." >&3
	;;
*)
	echo "Checking to see if kill(pid, 0) works..." >&3
	$cat >try.c <<'EOCP'
main()
	{
	int	pid, status0, status9;

	if ((pid = fork()) == 0)
		{
		sleep(30);
		exit(1);
		}
	status0 = kill(pid, 0);
	status9 = kill(pid, 9);
	exit(status0 == status9);
	}
EOCP
	if $cc try.c -o try >/dev/null 2>&1 ; then
		if try >/dev/null 2>&1 ; then
			echo "Yes, it does marvels."
			d_pidcheck="$undef"
		else
			d_pidcheck="$define"
			echo "No, it doesn't."
		fi
	else
		echo "(I was unable to compile the test program.)"
		echo "Your system does not appear to support kill(pid, 0)."
		d_pidcheck="$undef"
	fi
	$rm -f try.c try.o try
	;;
esac

: see if readdir exists
set readdir d_readdir
eval $inlibc

: see if rename exists
set rename d_rename
eval $inlibc

: see if rmdir exists
set rmdir d_rmdir
eval $inlibc

: see if getrusage exists
set getrusage d_rusage
eval $inlibc

: see if sys_siglist[] exist
echo " "
if set sys_siglist val -a d_siglist; eval $csym; $val; then	
	echo "You have sys_siglist[] for signal description." >&3
	val="$define"
else
	echo "You don't have sys_siglist[]." >&3
	val="$undef"
fi
set d_siglist
eval $setvar

: see if sigsetmask exists
echo " "
if set sigsetmask val -f d_sigsetmk; eval $csym; $val; then
	echo 'sigsetmask() found.' >&3
	val="$define"
else
	echo "sigsetmask() not found -- We'll use signal()." >&3
	val="$undef"
fi
set d_sigsetmk
eval $setvar

: see if sigvector exists -- since sigvec will match the substring
echo " "
if set sigvector val -f d_sigvectr; eval $csym; $val; then
	echo 'sigvector() found--you must be running HP-UX.' >&3
	d_sigvectr="$define"
	d_sigvec="$define"
else
: try the original name
	d_sigvectr="$undef"
	if set sigvec val -f d_sigvec; eval $csym; $val; then
		echo 'sigvec() found.' >&3
		d_sigvec="$define"
	else
		echo 'sigvec() not found--race conditions with signals may occur.' >&3
		d_sigvec="$undef"
	fi
fi

: check for structure copying
echo " "
echo "Checking to see if your C compiler can copy structs..." >&3
$cat >try.c <<'EOCP'
main()
{
	struct blurfl {
		int dyick;
	} foo, bar;

	foo = bar;
}
EOCP
if $cc -c try.c >/dev/null 2>&1 ; then
	val="$define"
	echo "Yup, it can."
else
	val="$undef"
	echo "Nope, it can't."
fi
set d_strctcpy
eval $setvar
$rm -f try.*

: see if strerror and/or sys_errlist[] exist
echo " "
if set strerror val -f d_strerror; eval $csym; $val; then
	echo 'strerror() found.' >&3
	d_strerror="$define"
	d_strerrm="$undef"
	if set sys_errlist val -a d_syserrlst; eval $csym; $val; then	
		echo "(You also have sys_errlist[], so we could roll our own strerror.)" 
		d_syserrlst="$define"
	else
	echo "(Since you don't have sys_errlist[], sterror() is welcome.)"
		d_syserrlst="$undef"
	fi
elif xxx=`./findhdr string.h`; test "$xxx" || xxx=`./findhdr strings.h`; \
	$contains '#[ 	]*define.*strerror' "$xxx" >/dev/null 2>&1; then
	echo 'strerror() found in string header.' >&3
	d_strerror="$define"
	d_strerrm="$undef"
	if set sys_errlist val -a d_syserrlst; eval $csym; $val; then	
		echo "(Most probably, strerror() uses sys_errlist[] for descriptions.)"
		d_syserrlst="$define"
	else
		echo "(You don't appear to have any sys_errlist[], how can this be?)"
		d_syserrlst="$undef"
	fi
elif set sys_errlist val -a d_syserrlst; eval $csym; $val; then
echo "strerror() not found, but you have sys_errlist[] so we'll use that." >&3
	d_strerror="$undef"
	d_syserrlst="$define"
	d_strerrm="$define"
else
	echo 'strerror() and sys_errlist[] NOT found.' >&3
	d_strerror="$undef"
	d_syserrlst="$undef"
	d_strerrm="$undef"
fi
if set sys_errnolist val -a d_sysernlst; eval $csym; $val; then
	echo "(Symbolic error codes can be fetched via the sys_errnolist[] array.)"
	d_sysernlst="$define"
else
	echo "(However, I can't extract the symbolic error code out of errno.)"
	d_sysernlst="$undef"
fi

: see if time exists
echo " "
if set time val -f d_time; eval $csym; $val; then
	echo 'time() found.' >&3
	val="$define"
	case "$timetype" in
	'')
		if $contains 'time_t;' `./findhdr sys/types.h` >/dev/null 2>&1 ; then
			dflt='time_t';
		else
			dflt='long';
		fi
		;;
	*)  dflt="$timetype"
		;;
	esac
	cont=true
	echo " "
	rp="What type is returned by time() on this sytem?"
	. myread
	timetype="$ans"
else
	echo 'time() not found, hope that will do.' >&3
	val="$undef"
	timetype='int';
fi
set d_time
eval $setvar

: see if times exists
echo " "
if set times val -f d_times; eval $csym; $val; then
	echo 'times() found.' >&3
	d_times="$define"
	case "$clocktype" in
	'')
		if $contains 'clock_t;' `./findhdr sys/types.h` >/dev/null 2>&1 ; then
			dflt='clock_t';
		elif $contains 'clock_t;' `./findhdr sys/times.h` >/dev/null 2>&1; then
			dflt='clock_t';
		else
			dflt='long';
		fi
		;;
	*)  dflt="$clocktype"
		;;
	esac
	cont=true
	echo " "
	rp="What type is returned by times() on this sytem?"
	. myread
	clocktype="$ans"
else
	echo 'times() not found, hope that will do.' >&3
	d_times="$undef"
	clocktype='int'
fi

: see if usleep exists
set usleep d_usleep
eval $inlibc

: get C preprocessor symbols handy
echo " "
echo $attrlist | $tr ' ' '\012' >Cppsym.know
$cat <<EOSS >Cppsym
$startsh
case "\$1" in
-l) list=true
	shift
	;;
esac
unknown=''
case "\$list\$#" in
1|2)
	for sym do
		if $contains "^\$1$" Cppsym.true >/dev/null 2>&1; then
			exit 0
		elif $contains "^\$1$" Cppsym.know >/dev/null 2>&1; then
			:
		else
			unknown="\$unknown \$sym"
		fi
	done
	set X \$unknown
	shift
	;;
esac
case \$# in
0) exit 1;;
esac
echo \$* | $tr ' ' '\012' | $sed -e 's/\(.*\)/\\
#ifdef \1\\
exit 0; _ _ _ _\1\\	 \1\\
#endif\\
/' >Cppsym\$\$
echo "exit 1; _ _ _" >>Cppsym\$\$
$cppstdin $cppminus <Cppsym\$\$ | $grep '^exit [01]; _ _'  >Cppsym2\$\$
case "\$list" in
true) $awk 'NF > 5 {print substr(\$6,2,100)}' <Cppsym2\$\$ ;;
*)
	sh Cppsym2\$\$
	status=\$?
	;;
esac
$rm -f Cppsym\$\$ Cppsym2\$\$
exit \$status
EOSS
chmod +x Cppsym
$eunicefix Cppsym
echo "Your C preprocessor defines the following symbols:"
Cppsym -l $attrlist >Cppsym.true
$cat Cppsym.true

: see if this is a termio system
val="$undef"
val2="$undef"
val3="$undef"
if $test `./findhdr termios.h`; then
	set tcsetattr i_termios
	eval $inlibc
	val3="$i_termios"
fi
echo " "
case "$val3" in
"$define") echo "You have POSIX termios.h... good!" >&3;;
*) if Cppsym pyr; then
		case "`bin/universe`" in
		ucb) if $test `./findhdr sgtty.h`; then
				val2="$define"
				echo "<sgtty.h> found." >&3
			else
				echo "System is pyramid with BSD universe."
				echo "<sgtty.h> not found--you could have problems." >&3
			fi;;
		*) if $test `./findhdr termio.h`; then
				val="$define"
				echo "<termio.h> found." >&3
			else
				echo "System is pyramid with USG universe."
				echo "<termio.h> not found--you could have problems." >&3
			fi;;
		esac
	elif usg; then
		if $test `./findhdr termio.h`; then
			echo "<termio.h> found." >&3
			val="$define"
		elif $test `./findhdr sgtty.h`; then
			echo "<sgtty.h> found." >&3
			val2="$define"
		else
echo "Neither <termio.h> nor <sgtty.h> found--you could have problems." >&3
		fi
	else
		if $test `./findhdr sgtty.h`; then
			echo "<sgtty.h> found." >&3
			val2="$define"
		elif $test `./findhdr termio.h`; then
			echo "<termio.h> found." >&3
			val="$define"
		else
echo "Neither <sgtty.h> nor <termio.h> found--you could have problems." >&3
		fi
	fi;;
esac
set i_termio; eval $setvar
val=$val2; set i_sgtty; eval $setvar
val=$val3; set i_termios; eval $setvar

: see if ioctl defs are in sgtty/termio or sys/ioctl
echo " "
if $test `./findhdr sys/ioctl.h`; then
	val="$define"
	echo "<sys/ioctl.h> found." >&3
else
	val="$undef"
	$test $i_termio = "$define" && xxx="termio.h"
	$test $i_termios = "$define" && xxx="termios.h"
	$test $i_sgtty = "$define" && xxx="sgtty.h"
echo "No <sys/ioctl.h> found, assuming ioctl args are defined in <$xxx>." >&3
fi
set i_sysioctl
eval $setvar

: check how to void tty association
echo " "
case "$i_sysioctl" in
"$define") xxx=`./findhdr sys/ioctl.h`;;
*) xxx=`./findhdr $xxx`;;
esac
if $contains TIOCNOTTY $xxx >/dev/null 2>&1; then
	val="$define"
	echo "TIOCNOTTY found in $xxx." >&3
	echo "Using ioctl() call on /dev/tty to void tty association." >&3
else
	val="$undef"
	echo "Closing standard file descriptors should void tty association." >&3
fi
set d_voidtty
eval $setvar

: preserve RCS keywords in files with variable substitution, grrr
Id='$Id'
Log='$Log'

: which signal is sent by abort ?
echo " "
case "$abortsig" in
'')
	echo "Checking to see which signal is sent to the process by abort()..." >&3
	echo "abort" > abort.sh
	chmod +x abort.sh
	for signal in SIGIOT SIGILL SIGABRT; do
		case "$abortsig" in
		'') $cat >abort.c <<EOP
#include <signal.h>
caught() { exit(0); }
main()
{
#ifdef $signal
	signal($signal, caught);
#endif
	if (-1 == abort())
		exit(1);
	exit(1);
}
EOP
			if $cc $ccflags -o abort abort.c >/dev/null 2>&1; then
				(./abort.sh) >/dev/null 2>&1
				case $? in
				0) abortsig="$signal";;
				esac
			fi
			;;
		esac
	done
	;;
esac
case "$abortsig" in
'') echo "(I wasn't able to compute the signal name--guessing)"
	if usg; then
		dflt="SIGIOT"
	else
		dflt="SIGILL"
	fi;;
*)  dflt="$abortsig"
	;;
esac
rp="Which signal does abort() send to the process (signal name)?"
. myread
abortsig="$ans"
$rm -f core abort.sh abort abort.c

: logging level stuff
add_log="$undef"

: check for alignment requirements
echo " "
case "$alignbytes" in
'') echo "Checking alignment constraints..." >&3
	$cat >try.c <<'EOCP'
struct foobar {
	char foo;
	double bar;
} try;
main()
{
	printf("%d\n", (char *)&try.bar - (char *)&try.foo);
}
EOCP
	if $cc $ccflags try.c -o try >/dev/null 2>&1; then
		dflt=`./try`
	else
		dflt='8'
		echo"(I can't seem to compile the test program...)"
	fi
	;;
*) dflt="$alignbytes"
	;;
esac
rp="Doubles must be aligned on a how-many-byte boundary?"
. myread
alignbytes="$ans"
$rm -f try.c try

: determine where public executables go
echo " "
case "$bin" in
'')
	dflt=`loc . /bin /usr/local/bin /usr/lbin /usr/local /usr/bin`
	;;
*)
	dflt="$bin"
	;;
esac
fn=d~
rp='Where do you want to put the public executables?'
. getfile
bin="$ans"

: check for length of byte
echo " "
case "$bitpbyte" in
'')
	echo "Checking to see how many bits there are in a byte..." >&3
	$cat >try.c <<'EOCP'
#include <stdio.h>
#ifdef __STDC__
#include <limits.h>
#ifndef CHAR_BIT
#define CHAR_BIT 8
#endif
#ifndef BITSPERBYTE
#define BITSPERBYTE CHAR_BIT
#endif
#else
#include <values.h>
#ifndef BITSPERBYTE
#define BITSPERBYTE 8
#endif
#endif
main()
{
	printf("%d\n", BITSPERBYTE);
}
EOCP
	if $cc $ccflags try.c -o try >/dev/null 2>&1 ; then
		dflt=`./try`
	else
		dflt='8'
		echo "(I can't seem to compile the test program.  Guessing...)"
	fi
	;;
*)
	dflt="$bitpbyte"
	;;
esac
rp="What is the length of a byte (in bits)?"
. myread
bitpbyte="$ans"
$rm -f try.c try

: check for ordering of bytes in a long
case "$byteorder" in
'')
	$cat <<'EOM'
  
In the following, larger digits indicate more significance.  A big-endian
machine like a Pyramid or a Motorola 680?0 chip will come out to 4321. A
little-endian machine like a Vax or an Intel 80?86 chip would be 1234. Other
machines may have weird orders like 3412.  A Cray will report 87654321. If
the test program works the default is probably right.
I'm now running the test program...
EOM
	$cat >try.c <<'EOCP'
#include <stdio.h>
main()
{
	int i;
	union {
		unsigned long l;
		char c[sizeof(long)];
	} u;

	if (sizeof(long) > 4)
		u.l = (0x08070605 << 32) | 0x04030201;
	else
		u.l = 0x04030201;
	for (i = 0; i < sizeof(long); i++)
		printf("%c", u.c[i]+'0');
	printf("\n");
}
EOCP
	if $cc $ccflags try.c -o try >/dev/null 2>&1 ; then
		dflt=`./try`
		case "$dflt" in
		????|????????) echo "(The test program ran ok.)";;
		*) echo "(The test program didn't run right for some reason.)";;
		esac
	else
		dflt='4321'
		cat <<'EOM'
(I can't seem to compile the test program.  Guessing big-endian...)
EOM
	fi
	;;
*)
	echo " "
	dflt="$byteorder"
	;;
esac
rp="What is the order of bytes in a long?"
. myread
byteorder="$ans"
$rm -f try.c try

: check for length of character
echo " "
case "$charsize" in
'')
	echo "Checking to see how big your characters are..." >&3
	$cat >try.c <<'EOCP'
#include <stdio.h>
main()
{
	printf("%d\n", sizeof(char));
}
EOCP
	if $cc $ccflags try.c -o try >/dev/null 2>&1 ; then
		dflt=`./try`
	else
		dflt='1'
		echo "(I can't seem to compile the test program.  Guessing...)"
	fi
	;;
*)
	dflt="$charsize"
	;;
esac
rp="What is the size of a character (in bytes)?"
. myread
charsize="$ans"
$rm -f try.c try

: check for length of double
echo " "
case "$doublesize" in
'')
	echo "Checking to see how big your double precision numbers are..." >&3
	$cat >try.c <<'EOCP'
#include <stdio.h>
main()
{
	printf("%d\n", sizeof(double));
}
EOCP
	if $cc $ccflags try.c -o try >/dev/null 2>&1 ; then
		dflt=`./try`
	else
		dflt='8'
		echo "(I can't seem to compile the test program.  Guessing...)"
	fi
	;;
*)
	dflt="$doublesize"
	;;
esac
rp="What is the size of a double precision number (in bytes)?"
. myread
doublesize="$ans"
$rm -f try.c try

: check for length of float
echo " "
case "$floatsize" in
'')
	echo "Checking to see how big your floating point numbers are..." >&3
	$cat >try.c <<'EOCP'
#include <stdio.h>
main()
{
	printf("%d\n", sizeof(float));
}
EOCP
	if $cc $ccflags try.c -o try >/dev/null 2>&1 ; then
		dflt=`./try`
	else
		dflt='4'
		echo "(I can't seem to compile the test program.  Guessing...)"
	fi
	;;
*)
	dflt="$floatsize"
	;;
esac
rp="What is the size of a floating point number (in bytes)?"
. myread
floatsize="$ans"
$rm -f try.c try

: check for length of integer
echo " "
case "$intsize" in
'')
	echo "Checking to see how big your integers are..." >&3
	$cat >try.c <<'EOCP'
#include <stdio.h>
main()
{
	printf("%d\n", sizeof(int));
}
EOCP
	if $cc $ccflags try.c -o try >/dev/null 2>&1 ; then
		dflt=`./try`
	else
		dflt='4'
		echo "(I can't seem to compile the test program.  Guessing...)"
	fi
	;;
*)
	dflt="$intsize"
	;;
esac
rp="What is the size of an integer (in bytes)?"
. myread
intsize="$ans"
$rm -f try.c try

: check for length of long
echo " "
case "$longsize" in
'')
	echo "Checking to see how big your long integers are..." >&3
	$cat >try.c <<'EOCP'
#include <stdio.h>
main()
{
	printf("%d\n", sizeof(long));
}
EOCP
	if $cc $ccflags try.c -o try >/dev/null 2>&1 ; then
		dflt=`./try`
	else
		dflt='4'
		echo "(I can't seem to compile the test program.  Guessing...)"
	fi
	;;
*)
	dflt="$longsize"
	;;
esac
rp="What is the size of a long integer (in bytes)?"
. myread
longsize="$ans"
$rm -f try.c try

: compute the type returned by malloc
echo " "
case "$malloctype" in
'')
	if $test `./findhdr malloc.h`; then
		echo "#include <malloc.h>" > malloc.c
	fi
#include <malloc.h>
	$cat >>malloc.c <<'END'
void *malloc();
END
	if $cc $ccflags -c malloc.c >/dev/null 2>&1; then
		malloctype='void *'
	else
		malloctype='char *'
	fi
	$rm -f malloc.[co]
	;;
esac
echo "Your system wants malloc to return '$malloctype', it would seem." >&3

: determine where manual pages go
$cat <<EOM

$package has manual pages available in source form.
EOM
case "$nroff" in
nroff)
	echo "However, you don't have nroff, so they're probably useless to you."
	case "$mansrc" in
	'') mansrc="none";;
	esac;;
esac
echo "If you don't want the manual sources installed, answer 'none'."
case "$mansrc" in
'')
	dflt="$sysman"
	;;
*)  dflt="$mansrc"
	;;
esac
echo " "
fn=dn~
rp='Where do the manual pages (source) go?'
. getfile
mansrc="$ans"
case "$mansrc" in
'') manext='0';;
*l) manext=l;;
*n) manext=n;;
*o) manext=l;;
*p) manext=n;;
*C) manext=C;;
*L) manext=L;;
*) manext=1;;
esac

: find out how to generate dependencies
echo " "
echo "Checking how to generate makefile dependencies on your machine..." >&3
toplev=`cd ..;pwd`
$cat >dep.c <<'EOCP'
#include "dep.h"
EOCP
$cat >dep.h <<'EOCP'

EOCP
takeflags='flags=""
case "$@" in
*--*)
	for arg
	do
		shift
		case "$arg" in
		--) break;;
		*) flags="$flags $arg";;
		esac
	done;;
esac'
case "$mkdep" in
'')
	;;
*)
	if test -x "$mkdep" &&
		$mkdep dep.c >dep.out 2>/dev/null &&
		$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
	then
		echo "$mkdep works."
	else
		mkdep=
	fi
esac

case "$mkdep" in
'')
	$spitshell > ../mkdep <<EOM
$startsh
$takeflags
for srcfile
do
	$cpp -M -I. $cppflags \$flags \$srcfile 2>/dev/null
done
EOM
	mkdep=$toplev/mkdep
	chmod +x $mkdep
	$eunicefix $mkdep
	if $mkdep dep.c >dep.out 2>/dev/null &&
		$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
	then
		echo "Looks like we can use $cpp -M."
	else
		mkdep=
	fi
	;;
esac

case "$mkdep" in
'')
	$spitshell > ../mkdep <<EOM
$startsh
$takeflags
for srcfile
do
	$cc -MM -I. $cppflags \$flags \$srcfile 2>/dev/null
done
EOM
	mkdep=$toplev/mkdep
	chmod +x $mkdep
	$eunicefix $mkdep
	if $mkdep dep.c >dep.out 2>/dev/null &&
		$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
	then
		echo "Looks like we can use $cc -MM."
	else
		mkdep=
	fi
	;;
esac

case "$mkdep" in
'')
	$spitshell >../mkdep <<EOS
$startsh
$takeflags
for srcfile
do
	case "\$srcfile" in
	*.c) c='.c';;
	*.y) c='.y';;
	*.l) c='.l';;
	esac
	filebase=\`basename \$srcfile \$c\`
	<\$srcfile $cpp $cppminus $cppflags -I. \$flags 2>/dev/null | \\
	$sed -e '/^# *[0-9]/!d' \\
		-e 's/^.*"\(.*\)".*\$/'\$filebase'.o: \1/' \\
		-e 's|: \./|: |' \\
		-e 's|: *$|: '\$srcfile'|' | \\
	$grep -v '^#' | $sort | $uniq
done
EOS
	mkdep=$toplev/mkdep
	chmod +x $mkdep
	$eunicefix $mkdep
	if $mkdep dep.c >dep.out 2>/dev/null &&
		$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
	then
		echo "A shell script using $cpp does the trick."
	else
		echo "$cpp doesn't seem to be any use at all."
		$spitshell >../mkdep <<EOS
$startsh
$takeflags
files="\$@"
set X \$flags
shift
inc='.'
while test \$# -gt 0
do
	case "\$1" in
	-I) 
		shift
		inc="\$inc:\$1"
		;;
	-I*)
		dir=\`echo \$1 | sed -e 's/^-I//'\`
		inc="\$inc:\$dir"
		;;
	esac
	shift
done
set X \$files
shift
trap "$rm -f /tmp/mkdep\$\$; exit 1" 1 2 3 15
for srcfile
do
	case "\$srcfile" in
	*.c) c='.c';;
	*.y) c='.y';;
	*.l) c='.l';;
	esac
	filebase=\`basename \$srcfile \$c\`
	echo \$filebase.o: \$srcfile
	$grep '^#[  ]*include' \$srcfile /dev/null | \
	$sed -n -e 's/#[   ]*include[  ]*//' \\
		-e '/<\(.*\)>/ d' \\
		-e 's/:[^"]*"\([^"]*\)".*/: \1/' \\
		-e 's/\.c:/\.o:/p' > /tmp/mkdep\$\$
	IFS=': '
	while read file dep; do
		for dir in \$inc; do
			if $test -f "\$dir/\$dep"; then
				dep="\$dir/\$dep"
				break
			fi
		done
		echo "\$file: \$dep" | $sed -e 's,: \./,: ,'
	done </tmp/mkdep\$\$
	IFS=' '
	$rm -f /tmp/mkdep\$\$
done
EOS
		mkdep=$toplev/mkdep
		chmod +x $mkdep
		$eunicefix $mkdep
		if $mkdep dep.c >dep.out 2>/dev/null &&
			$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
		then
			cat << EOM

I can use a script with grep instead, but it will make some incorrect
dependencies, since it doesn't understand about conditional compilation.
Moreover, some dependencies may be missing, because scanning won't be
a recursive process.
If you have a program which generates makefile dependencies, you may want
to use it.  If not, you can use the script and edit the Makefile by hand
if you need to.
EOM
		else
			mkdep=
			cat << EOM

I can't seem to generate makefile dependencies at all!  Perhaps you have a
program that does?  If you don't, you might look at the mkdep script to
see if you can create one which works.
EOM
		fi
	fi
esac
dflt="$mkdep"
fn=f~/
rp="Name of program to make makefile dependencies?"
. getfile
mkdep="$ans"
$rm -f dep.c dep.h dep.o dep.out

: see if getdtablesize exists
echo " "
case "$d_gettblsz" in
$define) d_gettblsz="$undef";;
$undef) d_gettblsz="$define";;
esac
if set getdtablesize val -f d_gettblsz; eval $csym; $val; then
	echo 'getdtablesize() found.' >&3
	d_gettblsz="$undef"
	tablesize=''
	$cat >nofile.c <<'EOCP'
#include <stdio.h>
main()
{
	printf("%d\n", getdtablesize());
}
EOCP
	nofile=''
	if $cc $ccflags nofile.c -o nofile $libs >/dev/null 2>&1; then
		nofile=`./nofile 2>/dev/null`
	fi
	if $test "$nofile"; then
		echo "(You have $nofile file descriptors available per process.)"
	else
		nofile='20'
		if ./bsd; then
			nofile='64'
		fi
	echo "(Hmm... Let's say you have $nofile file descriptors available.)"
	fi
else
	echo 'getdtablesize() NOT found...' >&3
	if set ulimit val -f; eval $csym; $val; then
		echo 'Maybe ulimit(4,0) will work...'
		$cat >nofile.c <<'EOCP'
#include <stdio.h>
#ifdef GETPARAM_H
#include <sys/param.h>
#endif
main()
{
	printf("%d %d\n",
#ifdef NOFILE
		NOFILE,
#else
		0,
#endif
		ulimit(4,0));
		exit(0);
}
EOCP
		if $cc $ccflags -DGETPARAM_H nofile.c -o nofile $libs >/dev/null 2>&1 \
			|| $cc $ccflags nofile.c -o nofile $libs >/dev/null 2>&1 ; then
			set `./nofile`
			d_gettblsz=$1
			d_ulimit4=$2
			if $test "$d_ulimit4" -lt 0; then
				echo "Your ulimit() call doesn't tell me what I want to know."
				echo "We'll just use NOFILE in this case."
				nofile=$d_gettblsz
				d_gettblsz="$define"
				tablesize='NOFILE'
			else
				if $test "$d_gettblsz" -gt 0; then
				echo "Your system defines NOFILE to be $d_gettblsz, and" >&3
				else
				echo "I had trouble getting NOFILE from your system, but" >&3
				fi
echo "ulimit returns $d_ulimit4 as the number of available file descriptors." >&3
				dflt='y';
				echo " "
	rp='Should I use ulimit to get the number of available file descriptors?'
				. myread
				case "$ans" in
				y*)
					nofile=$d_ulimit4
					d_gettblsz="$define"
					tablesize='ulimit(4, 0L)'
					echo "Using ulimit(4,0)."
					;;
				*)
					nofile=$d_gettblsz
					d_gettblsz="$define"
					tablesize='NOFILE'
					echo "Using NOFILE."
					;;
				esac
			fi
		else
			echo "Strange, I couldn't get my test program to compile."
			echo "We'll just use NOFILE in this case."
			d_gettblsz="$define"
			tablesize='NOFILE'
			nofile=''
		fi
	else
		echo 'Using NOFILE instead.'
		d_gettblsz="$define"
		tablesize='NOFILE'
		nofile=''
	fi
fi
case "$nofile" in
'')
	$cat >nofile.c <<'EOCP'
#include <stdio.h>
#ifdef GETPARAM_H
#include <sys/param.h>
#endif
main()
{
	printf("%d\n",
#ifdef NOFILE
		NOFILE,
#else
		0,
#endif
		);
		exit(0);
}
EOCP
	if $cc $ccflags -DGETPARAM_H nofile.c -o nofile $libs >/dev/null 2>&1 \
		|| $cc $ccflags nofile.c -o nofile $libs >/dev/null 2>&1 ; then
		nofile=`./nofile 2>/dev/null`
	fi
	if $test "$nofile"; then
		echo "(You have $nofile file descriptors available per process.)"
	else
		nofile='20'
		if ./bsd; then
			nofile='64'
		fi
	echo "(Hmm... Let's say you have $nofile file descriptors available.)"
	fi
	;;
esac
$rm -f nofile*

: see if getpagesize exists
set getpagesize d_getpagsz
eval $inlibc

: determine the system page size
echo " "
guess=' (OK to guess)'
case "$pagesize" in
'')
	$cat >page.c <<EOP
extern int getpagesize();
main()
{
	printf("%d\n", getpagesize());
}
EOP
	echo "Computing the granularity of memory management calls..." >&3
	dflt='4096'
	case "$d_getpagsz" in
	"$define")
		if $cc $ccflags page.c -o page $libs >/dev/null 2>&1; then
			dflt=`./page`
			guess=''
		else
			echo "(I can't seem to compile the test program--guessing)"
		fi
		;;
	*)
		if $cc $ccflags page.c -o page $libs -lPW >/dev/null 2>&1; then
			dflt=`./page`
			guess=''
			echo "(For your eyes only: I used the getpagesize() from -lPW.)"
		else
			if $contains PAGESIZE `./findhdr sys/param.h` >/dev/null 2>&1; then
				$cat >page.c <<EOP
#include <sys/param.h>
main()
{
	printf("%d\n", PAGESIZE);
}
EOP
				if $cc $ccflags page.c -o page $libs >/dev/null 2>&1; then
					dflt=`./page`
					guess=''
					echo "(Using value of PAGESIZE found in <sys/param.h>.)"
				fi
			fi
		fi
		;;
	esac
	;;
*) dflt="$pagesize"; guess='';;
esac
rp="What is the system page size, in bytes$guess?"
. myread
pagesize=$ans
$rm -f page.c page

: see what type pids are declared as in the kernel
case "$pidtype" in
'')
	if $contains 'pid_t;' `./findhdr sys/types.h` >/dev/null 2>&1 ; then
		dflt='pid_t';
	else
		dflt="int"
	fi
	;;
*)  dflt="$pidtype";;
esac
echo " "
rp="What type are process ids on this system declared as?"
. myread
pidtype="$ans"

: Cruising for prototypes
echo " "
echo "Checking out function prototypes..." >&3
$cat >prototype.c <<'EOCP'
main(int argc, char *argv[]) {
	exit(0);}
EOCP
if $cc -c prototype.c >prototype.out 2>&1 ; then
	echo "Your C compiler appears to support function prototypes."
	val=define
else
	echo "Your C compiler doesn't seem to understand function prototypes."
	val=undef
fi
set prototype
eval $setvar
$rm -f prototype*

: check for length of pointer
echo " "
case "$ptrsize" in
'')
	echo "Checking to see how big your pointers are..." >&3
	$cat >try.c <<'EOCP'
#include <stdio.h>
main()
{
	printf("%d\n", sizeof(char *));
}
EOCP
	if $cc $ccflags try.c -o try >/dev/null 2>&1 ; then
		dflt=`./try`
	else
		dflt='4'
		echo "(I can't seem to compile the test program.  Guessing...)"
	fi
	;;
*)
	dflt="$ptrsize"
	;;
esac
rp="What is the size of a pointer (in bytes)?"
. myread
ptrsize="$ans"
$rm -f try.c try

: see if ar generates random libraries by itself
echo " "
echo "Checking how to generate random libraries on your machine..." >&3
$cat >a.c <<EOP
f() { exit(0); }
EOP
cc -c a.c >/dev/null 2>&1
ar rc ran.a a.o >/dev/null 2>&1
$cat >b.c <<EOP
main() { f(); }
EOP
cp ran.a lib.a
if ar ts ran.a >/dev/null 2>&1; then
	if $cc -o b b.c lib.a >/dev/null 2>&1; then
		echo "ar appears to generate random libraries itself."
		orderlib=false
		ranlib=":"
	else
		echo "a table of contents needs to be added with 'ar ts'."
		orderlib=false
		ranlib="ar ts"
	fi
else
	if $test -f /usr/bin/ranlib; then
		ranlib=/usr/bin/ranlib
	elif $test -f /bin/ranlib; then
		ranlib=/bin/ranlib
	fi

	if $test -n "$ranlib"; then
		echo "your system has $ranlib; we'll use that."
		orderlib=false
	else
		echo "your system doesn't seem to support random libraries"
		echo "so we'll use lorder and tsort to order the libraries."
		orderlib=true
		ranlib=":"
	fi
fi
$rm -f a.* b.c b.o b ran.a lib.a

: see how many register declarations we want to use
case "$registers" in
'')
	if Cppsym vax; then
		dflt=6
	elif Cppsym sun mc68000 mips; then
		dflt=10
	elif Cppsym pyr; then
		dflt=14
	elif Cppsym ns32000 ns16000; then
		dflt=5
	elif Cppsym $smallmach; then
		dflt=3
	else
		: if you have any other numbers for me, please send them in
		dflt=6
	fi;;
*) dflt=$registers ;;
esac
cat <<EOM
 
Different C compilers on different machines pay attention to different numbers
of register declarations.  About how many register declarations in each routine
does your C compiler pay attention to?  (OK to guess)

EOM
rp="Maximum register declarations?"
. myread
registers=$ans
reg1=''
$awk "BEGIN { for (i=1; i<=16; i++) printf \"reg%d=''\n\", i}" </dev/null >.foo
. .foo
$awk "BEGIN { for (i=1; i<=$registers; i++) printf \"reg%d=register\n\", i}" \
	</dev/null >.foo
. .foo
$rm -f .foo

: see what type sbrk is declared as in the kernel
case "$sbrktype" in
'')
	if $contains 'caddr_t;' `./findhdr sys/types.h` >/dev/null 2>&1 ; then
		dflt='caddr_t';
	else
		dflt='char *';
	fi
	;;
*)  dflt="$sbrktype"
	;;
esac
cont=true
echo " "
rp="What is the return type of sbrk() on this system?"
. myread
sbrktype="$ans"

: determine where public executables go
case "$scriptdir" in
'')
	dflt="$bin"
	: guess some guesses
	$test -d /usr/share/scripts && dflt=/usr/share/scripts
	$test -d /usr/share/bin && dflt=/usr/share/bin
	;;
*)  dflt="$scriptdir"
	;;
esac
$cat <<EOM
 
Some installations have a separate directory just for executable scripts so
that they can mount it across multiple architectures but keep the scripts in
one spot.  You might, for example, have a subdirectory of /usr/share for this.
Or you might just lump your scripts in with all your other executables.
 
EOM
fn=d~
rp='Where do you keep publicly executable scripts?'
. getfile
scriptdir="$ans"

: see if signal is declared as pointer to function returning int or void
echo " "
xxx=`./findhdr signal.h`
$test "$xxx" && $cppstdin $cppminus $cppflags < $xxx >$$.tmp 2>/dev/null
if $contains 'int.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have int (*signal())() instead of void." >&3
	val="$undef"
	signal_t="int"
elif $contains 'void.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have void (*signal())() instead of int." >&3
	val="$define"
	signal_t="void"
elif $contains 'extern[ 	]*[(\*]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have int (*signal())() instead of void." >&3
	val="$undef"
	signal_t="int"
else
	case "$d_voidsig" in
	'')
	echo "I can't determine whether signal handler returns void or int..." >&3
		dflt=void
		rp="What type does your signal handler returns?"
		. myread
		case "$ans" in
		void) val="$define"; signal_t="void";;
		*) val="$undef"; signal_t="int";;
		esac;;
	*) echo "As you already told me, signal handler returns $signal_t." >&3;;
	esac
fi
set d_voidsig
eval $setvar
$rm -f $$.tmp

: see what type uids are declared as in the kernel
case "$uidtype" in
'')
	if $contains 'uid_t;' `./findhdr sys/types.h` >/dev/null 2>&1 ; then
		dflt='uid_t';
	else
		xxx=`./findhdr sys/user.h`
		set `grep '_ruid;' "$xxx" 2>/dev/null` unsigned short
		case $1 in
		unsigned) dflt="$1 $2" ;;
		*) dflt="$1" ;;
		esac
	fi
	;;
*)  dflt="$uidtype";;
esac
echo " "
rp="What type are user ids on this system declared as?"
. myread
uidtype="$ans"

: determine compiler compiler
case "$yacc" in
'')
	dflt=yacc;;
*)
	dflt="$yacc";;
esac
echo " "
rp="Which compiler compiler (yacc or bison -y) shall I use?"
. myread
yacc="$ans"
case "$yacc" in
*bis*)
	case "$yacc" in
	*-y*) ;;
	*)
		yacc="$yacc -y"
		echo "(Adding -y option to bison to get yacc-compatible behaviour.)"
		;;
	esac
	;;
esac

: see if we need extra yacc flags
dflt="$yaccflags"
case "$dflt" in
'') dflt=none;;
esac
$cat <<EOH

Your yacc program may need extra flags to normally process the parser sources.
Do NOT specify any -d or -v flags here, since those are explicitely known
by the various Makefiles. However, if your machine has strange/undocumented
options (like -Sr# on SCO to specify the maximum number of grammar rules), then
please add them here.  To use no flags, specify the word "none".

EOH
rp="Any additional yacc flags?"
. myread
case "$ans" in
none) yaccflags='';;
*) yaccflags="$ans";;
esac

: define an alternate in-header-list? function
inhdr='echo " "; td=$define; tu=$undef; yyy=$@;
cont=true; xxf="echo \"<\$1> found.\" >&3";
case $# in 2) xxnf="echo \"<\$1> NOT found.\" >&3";;
*) xxnf="echo \"<\$1> NOT found, ...\" >&3";;
esac;
case $# in 4) instead=instead;; *) instead="at last";; esac;
while $test "$cont"; do
	xxx=`./findhdr $1`
	var=$2; eval "was=\$$2";
	if $test "$xxx" && $test -r "$xxx";
	then eval $xxf;
		eval "case \"\$$var\" in $undef) . whoa; esac"; eval "$var=\$td";
		cont="";
	else eval $xxnf;
		eval "case \"\$$var\" in $define) . whoa; esac"; eval "$var=\$tu"; fi;
	set $yyy; shift; shift; yyy=$@;
	case $# in 0) cont="";;
	2) xxf="echo \"but I found <\$1> $instead.\" >&3";
		xxnf="echo \"and I did not find <\$1> either.\" >&3";;
	*) xxf="echo \"but I found <\$1\> instead.\" >&3";
		xxnf="echo \"there is no <\$1>, ...\" >&3";;
	esac;
done;
while $test "$yyy";
do set $yyy; var=$2; eval "was=\$$2";
	eval "case \"\$$var\" in $define) . whoa; esac"; eval "$var=\$tu";
	set $yyy; shift; shift; yyy=$@;
done'

: see if this is a sys/file.h system
val=''
set sys/file.h val
eval $inhdr

: do we need to #include <sys/file.h> ?
case "$val" in
"$define")
	echo " "
	if $h_sysfile; then
		val="$define"
		echo "We'll be including <sys/file.h>." >&3
	else
		val="$undef"
		echo "We won't be including <sys/file.h>." >&3
	fi
	;;
*)
	h_sysfile=false
	;;
esac
set i_sysfile
eval $setvar

: see if fcntl.h is there
val=''
set fcntl.h val
eval $inhdr

: see if we can include fcntl.h
case "$val" in
"$define")
	echo " "
	if $h_fcntl; then
		val="$define"
		echo "We'll be including <fcntl.h>." >&3
	else
		val="$undef"
		if $h_sysfile; then
	echo "We don't need to include <fcntl.h> if we include <sys/file.h>." >&3
		else
			echo "We won't be including <fcntl.h>." >&3
		fi
	fi
	;;
*)
	h_fcntl=false
	val="$undef"
	;;
esac
set i_fcntl
eval $setvar

: see if this is a limits.h system
set limits.h i_limits
eval $inhdr

: see if this is a netinet/in.h or sys/in.h system
set netinet/in.h i_niin sys/in.h i_sysin
eval $inhdr

: see if stdarg is available
set stdarg.h i_stdarg
eval $inhdr

: see if this is an sysdir system
set sys/dir.h i_sysdir
eval $inhdr

: see if this is an sysndir system
set sys/ndir.h i_sysndir
eval $inhdr

: see if sys/resource.h has to be included
set sys/resource.h i_sysresrc
eval $inhdr

: see if sys/select.h has to be included
set sys/select.h i_sysselct
eval $inhdr

: see if this is a sys/socket.h system
set sys/socket.h i_syssock
eval $inhdr

: see if we should include time.h, sys/time.h, or both
echo " "
echo "Testing to see if we should include <time.h>, <sys/time.h> or both." >&3
$echo $n "I'm now running the test program...$c"
$cat >try.c <<'EOCP'
#include <sys/types.h>
#ifdef I_TIME
#include <time.h>
#endif
#ifdef I_SYSTIME
#ifdef SYSTIMEKERNEL
#define KERNEL
#endif
#include <sys/time.h>
#endif
#ifdef I_SYSSELECT
#include <sys/select.h>
#endif
main()
{
	struct tm foo;
#ifdef S_TIMEVAL
	struct timeval bar;
#endif
#ifdef S_TIMEZONE
	struct timezone tzp;
#endif
	if (foo.tm_sec == foo.tm_sec)
		exit(0);
#ifdef S_TIMEVAL
	if (bar.tv_sec == bar.tv_sec)
		exit(0);
#endif
	exit(1);
}
EOCP
flags=''
for s_timezone in '-DS_TIMEZONE' ''; do
sysselect=''
for s_timeval in '-DS_TIMEVAL' ''; do
for i_systimek in '' '-DSYSTIMEKERNEL'; do
for i_time in '' '-DI_TIME'; do
for i_systime in '-DI_SYSTIME' ''; do
	case "$flags" in
	'') $echo $n ".$c"
		if $cc $ccflags \
		$i_time $i_systime $i_systimek $sysselect $s_timeval $s_timezone \
		try.c -o try >/dev/null 2>&1 ; then
			set X $i_time $i_systime $i_systimek $sysselect $s_timeval
			shift
			flags="$*"
			echo " "
			$echo $n "Succeeded with $flags$c"
		fi
		;;
	esac
done
done
done
done
done
timeincl=''
echo " "
case "$flags" in
*SYSTIMEKERNEL*) i_systimek="$define"
	timeincl=`./findhdr sys/time.h`
	echo "We'll include <sys/time.h> with KERNEL defined." >&3;;
*) i_systimek="$undef";;
esac
case "$flags" in
*I_TIME*) i_time="$define"
	timeincl=`./findhdr time.h`" $timeincl"
	echo "We'll include <time.h>." >&3;;
*) i_time="$undef";;
esac
case "$flags" in
*I_SYSTIME*) i_systime="$define"
	timeincl=`./findhdr sys/time.h`" $timeincl"
	echo "We'll include <sys/time.h>." >&3;;
*) i_systime="$undef";;
esac
$rm -f try.c try

: see where struct timeb is defined
echo " "
xxx=`./findhdr sys/timeb.h`
if $test "$xxx"; then
	if $contains 'struct timeb' $xxx >/dev/null 2>&1; then
		val="$define"
		echo "You have struct timeb defined in <sys/timeb.h>." >&3
	else
		val="$undef"
		echo "Assuming struct timeb is defined in <sys/time.h>." >&3
	fi
else
	val="$undef"
echo "No <sys/timeb.h> -- Assuming struct timeb is defined in <sys/time.h>." >&3
fi
set i_systimeb
eval $setvar

: see if this is a sys/times.h system
set sys/times.h i_systimes
eval $inhdr

: see if this is a sys/un.h system
set sys/un.h i_sysun
eval $inhdr

: see if this is a varargs system
echo " "
if $test `./findhdr varargs.h`; then
	val="$define"
	echo "<varargs.h> found." >&3
else
	val="$undef"
	echo "<varargs.h> NOT found, but that's ok (I hope)." >&3
fi
set i_varargs
eval $setvar

: set up the varargs testing programs
$cat > varargs.c <<EOP
#ifdef I_STDARG
#include <stdarg.h>
#endif
#ifdef I_VARARGS
#include <varargs.h>
#endif

int f(va_alist)
va_dcl
{
	va_list ap;
	char *p;
	va_start(ap);
	p = va_arg(ap, char *);
	va_end(ap);
}
EOP
$cat > varargs <<EOP
if $cc -c $ccflags -D\$1 varargs.c >/dev/null 2>&1; then
	echo "true"
else
	echo "false"
fi
$rm -f varargs.o
EOP
chmod +x varargs

: now check which varargs header should be included
echo " "
i_varhdr=''
case "$i_varargs" in
"$define")
	if `./varargs I_VARARGS`; then
		i_varhdr='varargs.h'
		i_stdarg="$undef"
	elif `./varargs I_STDARG`; then
		i_varhdr='stdarg.h'
		i_varargs="$undef"
	fi
	;;
*)
	if `./varargs I_STDARG`; then
		i_varhdr='stdarg.h'
	fi
	;;
esac
case "$i_varhdr" in
'')
echo "I could not find the definition for va_dcl... You have problems..." >&3
	;;
*) echo "We'll include <$i_varhdr> to get va_dcl definition." >&3;;
esac
$rm -f varargs*

: end of configuration questions
echo " "
echo "End of configuration questions."
echo " "

: create config.sh file
echo " "
if test -d ../UU; then
	cd ..
fi
echo "Creating config.sh..." >&3
cf_time=`$date 2>&1`
cf_by=`( (logname) 2>/dev/null || whoami) 2>&1`
$spitshell <<EOT >config.sh
$startsh
#
# This file was produced by running the Configure script. It holds all the
# definitions figured out by Configure. Should you modify one of these values,
# do not forget to propagate your changes by running "Configure -der". You may
# instead choose to run each of the .SH files by yourself, or "Configure -S".
#

# Configuration time: $cf_time
# Configured by: $cf_by
# Target system: $myuname

cf_by='$cf_by'
cf_time='$cf_time'
d_bsd='$d_bsd'
d_eunice='$d_eunice'
d_xenix='$d_xenix'
eunicefix='$eunicefix'
Mcc='$Mcc'
awk='$awk'
bison='$bison'
cat='$cat'
chgrp='$chgrp'
chmod='$chmod'
chown='$chown'
compress='$compress'
cp='$cp'
cpio='$cpio'
cpp='$cpp'
csh='$csh'
date='$date'
echo='$echo'
egrep='$egrep'
emacs='$emacs'
expr='$expr'
flex='$flex'
gcc='$gcc'
grep='$grep'
inews='$inews'
less='$less'
line='$line'
lint='$lint'
ln='$ln'
lp='$lp'
lpr='$lpr'
ls='$ls'
mail='$mail'
mailx='$mailx'
make='$make'
mkdir='$mkdir'
more='$more'
mv='$mv'
nroff='$nroff'
perl='$perl'
pg='$pg'
pmake='$pmake'
pr='$pr'
rm='$rm'
rmail='$rmail'
sed='$sed'
sendmail='$sendmail'
shar='$shar'
sleep='$sleep'
smail='$smail'
sort='$sort'
submit='$submit'
tail='$tail'
tar='$tar'
tbl='$tbl'
test='$test'
touch='$touch'
tr='$tr'
troff='$troff'
uname='$uname'
uniq='$uniq'
uuname='$uuname'
vi='$vi'
zcat='$zcat'
hint='$hint'
myuname='$myuname'
Author='$Author'
Date='$Date'
Header='$Header'
Id='$Id'
Locker='$Locker'
Log='$Log'
RCSfile='$RCSfile'
Revision='$Revision'
Source='$Source'
State='$State'
abortsig='$abortsig'
add_log='$add_log'
alignbytes='$alignbytes'
bin='$bin'
bitpbyte='$bitpbyte'
byteorder='$byteorder'
cc='$cc'
ccflags='$ccflags'
cppflags='$cppflags'
ldflags='$ldflags'
lkflags='$lkflags'
optimize='$optimize'
charsize='$charsize'
contains='$contains'
cppminus='$cppminus'
cppstdin='$cppstdin'
d_gettblsz='$d_gettblsz'
nofile='$nofile'
tablesize='$tablesize'
d_access='$d_access'
d_bcmp='$d_bcmp'
d_bcopy='$d_bcopy'
d_bsdjmp='$d_bsdjmp'
d_bzero='$d_bzero'
d_dup2='$d_dup2'
d_eofpipe='$d_eofpipe'
d_fcntl='$d_fcntl'
d_ftime='$d_ftime'
d_gettimeod='$d_gettimeod'
d_gethid='$d_gethid'
aphostname='$aphostname'
d_gethname='$d_gethname'
d_phostname='$d_phostname'
d_uname='$d_uname'
d_getopt='$d_getopt'
d_getpagsz='$d_getpagsz'
pagesize='$pagesize'
d_index='$d_index'
d_keepsig='$d_keepsig'
d_lstat='$d_lstat'
d_mkdir='$d_mkdir'
d_open3='$d_open3'
d_pidcheck='$d_pidcheck'
d_portable='$d_portable'
d_readdir='$d_readdir'
d_rename='$d_rename'
d_rmdir='$d_rmdir'
d_rusage='$d_rusage'
d_bsdpgrp='$d_bsdpgrp'
d_setpgrp='$d_setpgrp'
d_siglist='$d_siglist'
d_sigsetmk='$d_sigsetmk'
d_sigaction='$d_sigaction'
d_sigintrp='$d_sigintrp'
d_sigvec='$d_sigvec'
d_sigvectr='$d_sigvectr'
d_oldsock='$d_oldsock'
d_socket='$d_socket'
d_sockpair='$d_sockpair'
sockethdr='$sockethdr'
socketlib='$socketlib'
d_strctcpy='$d_strctcpy'
d_strerrm='$d_strerrm'
d_strerror='$d_strerror'
d_sysernlst='$d_sysernlst'
d_syserrlst='$d_syserrlst'
d_time='$d_time'
timetype='$timetype'
clocktype='$clocktype'
d_times='$d_times'
d_usleep='$d_usleep'
d_voidsig='$d_voidsig'
signal_t='$signal_t'
doublesize='$doublesize'
floatsize='$floatsize'
h_fcntl='$h_fcntl'
h_sysfile='$h_sysfile'
d_dirnamlen='$d_dirnamlen'
i_dirent='$i_dirent'
i_fcntl='$i_fcntl'
i_limits='$i_limits'
i_niin='$i_niin'
i_sysin='$i_sysin'
i_stdarg='$i_stdarg'
i_string='$i_string'
strings='$strings'
i_sysdir='$i_sysdir'
i_sysfile='$i_sysfile'
d_voidtty='$d_voidtty'
i_bsdioctl='$i_bsdioctl'
i_sysioctl='$i_sysioctl'
i_syssockio='$i_syssockio'
i_sysndir='$i_sysndir'
i_sysresrc='$i_sysresrc'
i_sysselct='$i_sysselct'
i_syssock='$i_syssock'
i_systimeb='$i_systimeb'
i_systimes='$i_systimes'
i_sysun='$i_sysun'
i_sgtty='$i_sgtty'
i_termio='$i_termio'
i_termios='$i_termios'
i_systime='$i_systime'
i_systimek='$i_systimek'
i_time='$i_time'
timeincl='$timeincl'
i_varargs='$i_varargs'
i_varhdr='$i_varhdr'
intsize='$intsize'
libc='$libc'
libpth='$libpth'
plibpth='$plibpth'
xlibpath='$xlibpath'
libs='$libs'
longsize='$longsize'
mallocobj='$mallocobj'
mallocsrc='$mallocsrc'
malloctype='$malloctype'
usemymalloc='$usemymalloc'
manext='$manext'
mansrc='$mansrc'
mkdep='$mkdep'
huge='$huge'
large='$large'
medium='$medium'
models='$models'
small='$small'
split='$split'
mydomain='$mydomain'
myhostname='$myhostname'
phostname='$phostname'
c='$c'
n='$n'
orderlib='$orderlib'
ranlib='$ranlib'
package='$package'
d_maypanic='$d_maypanic'
pidtype='$pidtype'
prototype='$prototype'
ptrsize='$ptrsize'
reg10='$reg10'
reg11='$reg11'
reg12='$reg12'
reg13='$reg13'
reg14='$reg14'
reg15='$reg15'
reg16='$reg16'
reg1='$reg1'
reg2='$reg2'
reg3='$reg3'
reg4='$reg4'
reg5='$reg5'
reg6='$reg6'
reg7='$reg7'
reg8='$reg8'
reg9='$reg9'
registers='$registers'
sbrktype='$sbrktype'
scriptdir='$scriptdir'
d_keepalive='$d_keepalive'
sharpbang='$sharpbang'
shsharp='$shsharp'
spitshell='$spitshell'
startsh='$startsh'
sysman='$sysman'
uidtype='$uidtype'
nm_opt='$nm_opt'
runnm='$runnm'
usenm='$usenm'
incpath='$incpath'
mips='$mips'
mips_type='$mips_type'
usrinc='$usrinc'
yacc='$yacc'
yaccflags='$yaccflags'
EOT

: add special variables
case "$lastuname" in
'') lastuname="$myuname";;
esac
echo "lastuname='$lastuname'" >>config.sh
$test -f patchlevel.h && \
awk '/^#define/ {printf "%s=%s\n",$2,$3}' patchlevel.h >>config.sh
echo "CONFIG=true" >>config.sh

: propagate old symbols
if $test -f UU/config.sh; then
	<UU/config.sh sort | uniq >UU/oldconfig.sh
	sed -n 's/^\([a-zA-Z_0-9]*\)=.*/\1/p' config.sh config.sh UU/oldconfig.sh |\
	sort | uniq -u >UU/oldsyms
	set X `cat UU/oldsyms`
	shift
	case $# in
	0) ;;
	*)	echo "Hmm...You had some extra variables I don't know about...I'll try to keep 'em..."
	for sym in `cat UU/oldsyms`; do
		echo "    Propagating $hint variable "'$'"$sym..."
		eval 'tmp="$'"${sym}"'"'
		echo "$tmp" | \
		sed -e "s/'/'\"'\"'/g" -e "s/^/$sym='/" -e "s/$/'/" >>config.sh
	done
	;;
	esac
fi

: Finish up by extracting the .SH files
case "$alldone" in
exit)
	$rm -rf UU
	echo "Done."
	exit 0
	;;
cont)
	;;
'')
	echo " "
	dflt=''
echo "If you didn't make any mistakes, then just type a carriage return here."
	rp="If you need to edit config.sh, do it as a shell escape here:"
	. ./UU/myread
	case "$ans" in
	'') ;;
	*) : in case they cannot read
		eval $ans;;
	esac
	;;
esac

: if this fails, just run all the .SH files by hand
. ./config.sh

echo " "
exec 1>&3
. ./UU/extract

if $contains '^depend:' [Mm]akefile >/dev/null 2>&1; then
	dflt=n
	case "$silent" in
	true) ;;
	*)
		$cat <<EOM

Now you need to generate make dependencies by running "make depend".
You might prefer to run it in background: "make depend > makedepend.out &"
It can take a while, so you might not want to run it right now.

EOM
		;;
	esac
	rp="Run make depend now?"
	. UU/myread
	case "$ans" in
	y*)
		make depend && echo "Now you must run a make."
		;;
	*)
		echo "You must run 'make depend' then 'make'."
		;;
	esac
elif test -f [Mm]akefile; then
	echo " "
	echo "Now you must run a make."
else
	echo "Done."
fi

$rm -f kit*isdone ark*isdone
$rm -rf UU
: End of Configure
