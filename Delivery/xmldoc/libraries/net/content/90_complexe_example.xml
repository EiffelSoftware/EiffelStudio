<document output="studio" title="A more complex example">
	<meta_data/>
	<paragraph>
		<table><border>1</border>
			<row>
				<cell>The example classes discussed in this section appear in the        subdirectory 
					<italic>advanced </italic>of the example directory
				</cell>
			</row>
		</table>
		<paragraph>The last example exercises most of EiffelNet's major facilities. It    consists of a server that allows an arbitrary number of clients to    connect to it. Each time the user of one of the client systems types a    line on the keyboard, the client sends this character to the server,    which then broadcasts it to all the clients (including the original    sender). This scheme allows several people to talk together, hence the    names chosen: the server class is called 
			<class_name>CHAT</class_name>, and the client is    called 
			<class_name>JOIN</class_name>.
		</paragraph>
		<paragraph>The example uses the network mode of communication, based on the 
			<link>
				<url>../reference/network/client_server/network_client_chart.xml</url>
				<label>NETWORK_CLIENT</label>
			</link>    and 
			<link>
				<url>../reference/network/client_server/network_server_chart.xml</url>
				<label>NETWORK_SERVER    </label>
			</link>classes. It uses automatic polling through 
			<link>
				<url>../reference/polling/abstract/medium_poller_chart.xml</url>
				<label>MEDIUM_POLLER</label>
			</link>    as in the previous example; the relevant command is given by class    
			<class_name>CONNECTION</class_name>, an heir of 
			<link>
				<url>../reference/polling/abstract/poll_command_chart.xml</url>
				<label>POLL_COMMAND</label>
			</link>.    The information exchanged between the server and its clients is    described by class 
			<class_name>MESSAGE</class_name>, an heir of 
			<link>
				<url>../../base/reference/structures/list/linked_list_chart.xml</url>
				<label>LINKED_LIST</label>
			</link>    [ 
			<link>
				<url>../../base/reference/kernel/string_chart.xml</url>
				<label>STRING</label>
			</link>]    similar to the earlier examples' OUR_MESSAGE
			<italic/> (see 
			<link>
				<url>50_working_at_predefined_level.xml</url>
				<label>see    "Object structures"</label>
			</link>). Attributes include,    the name 
			<italic>client_name</italic> of the client that has sent this message,    the boolean 
			<italic>new</italic> indicating whether the current message is the    first from a client that is trying to connect to the server, and 
			<italic>over    </italic>indicating that the message is the last sent by a client before    disconnecting.
		</paragraph>
		<paragraph>The server maintains a list of the currently active connections. In    the 
			<italic>receive</italic> routine, it checks on the main socket for any client    trying to connect. The socket is set to be non-blocking to enable the    server to continue checking the already connected clients. If the    connection is successful, the server sends to the new client the list of    clients already connected and adds the new connection to its list. Then    it polls the connections in the list, and processes the messages, if    any. If the message is tagged 
			<italic>new</italic>, the server sends a message to    all the clients indicating that a new client has joined the server; if    it is tagged 
			<italic>over</italic>, it sends a message indicating that the client    has opted out.
		</paragraph>
		<paragraph>Each client uses the 
			<link>
				<url>../reference/polling/abstract/medium_poller_chart.xml</url>
				<label>MEDIUM_POLLER</label>
			</link>    to check any message coming from the server and immediately displays any such message. It also checks a special connection, created with 
			<italic>io</italic>l<italic>input</italic>    as a medium, to check what the user is typing and then send it to the    server. If the user types 
			<italic>bye</italic>, the client terminates, sending a    message tagged 
			<italic>over </italic>to the server.
		</paragraph>
	</paragraph></document>
