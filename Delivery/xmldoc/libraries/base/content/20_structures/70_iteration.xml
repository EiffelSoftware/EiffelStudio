<document title="EiffelBase, Iteration">
	<meta_data>
		<help>
			<toc>
				<envision_location>Class Libraries\EiffelBase\EiffelBase\EiffelBase Data Structures Overview</envision_location>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph> The classes of the Iteration cluster encapsulate control structures representing common traversal operations.</paragraph>
		<heading>
			<size>1</size>Iterators and Agents
		</heading>
		<paragraph> The recent introduction of the agents mechanism in Eiffel offers an attractive alternative to the 
			<cluster_name>Iterator</cluster_name> cluster of EiffelBase.
		</paragraph>
		<heading>
			<size>1</size>The Notion of iterator
		</heading>
		<paragraph>  Let us first explore the role of iterators in the architecture of a system.</paragraph>
		<heading>
			<size>2</size>Iterating over data structures
		</heading>
		<paragraph>  Client software that uses data structures of a certain type, for example lists or trees,  often needs to traverse a data structure of that type in a predetermined order so as to  apply a certain action to all the items of the structure, or to all items that satisfy a certain  criterion. Such a systematic traversal is called an iteration.
			<line_break></line_break>  Cases of iteration can be found in almost any system. Here are a few typical  examples:
		</paragraph>
		<list ordered="false">
			<item>A text processing system may maintain a list of paragraphs. In response to a user  command, such as a request to resize the column width, the system will iterate  over the entire list so as to update all paragraphs.</item>
			<item>A business system may maintain a list of customers. If the company decides that  a special promotion will target all customers satisfying a certain criterion (for  example all customers that have bought at least one product over the past six  months), the system will iterate over the list, generating a mailing for every list  item that satisfies the criterion.</item>
			<item>An interactive development environment for a programming language may  maintain a syntax tree. In response to a program change, the system will traverse  the tree to determine what nodes are affected by the change and update them.</item>
		</list>
		<paragraph> These examples illustrate the general properties of iteration. An iteration involves a data structure of a known general type and a particular ordering of the structure's items. For some structures, more than one ordering will be available; for example a tree iteration may use preorder, postorder or breadth-first (as defined below). The iteration involves an operation, say 
			<feature_name>item_action</feature_name>, to be applied to the selected items. It may also involve a boolean-valued query, say 
			<feature_name>item_test</feature_name>, applicable to candidate items. Finally, it involves a certain policy, usually based on 
			<feature_name>item_test</feature_name>, as to which items should be subjected to <feature_name>item_action</feature_name>. Typical example policies are:
		</paragraph>
		<list ordered="false">
			<item>Apply 
				<feature_name>item_action</feature_name> to all the items in the structure.  (In this case item_test is not relevant).
			</item>
			<item>Apply 
				<feature_name>item_action</feature_name> to all items that satisfy  
				<feature_name>item_test</feature_name>.
			</item>
			<item>Apply 
				<feature_name>item_action</feature_name> to all items up to the first one  that satisfies 
				<feature_name>item_test</feature_name>.
			</item>
		</list>
		<paragraph>  The Iteration library provides many more, covering in particular all the standard  control structures.</paragraph>
		<heading>
			<size>2</size>Iterations and control structures
		</heading>
		<paragraph>  You can perform iterations without any special iteration classes. For example if  customers is declared as</paragraph>
		<code_block><feature_name>customers</feature_name><symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>CUSTOMER</class_name><symbol>]</symbol></code_block>
		<paragraph>  then a class 
			<class_name>SPECIAL_PROMOTION</class_name> of a text processing  system may include in one of its routines a loop of the form
		</paragraph>
		<code_block>
	<keyword>from</keyword>
    		<feature_name>customers</feature_name>.<feature_name>start</feature_name>
	<keyword>until</keyword>
	    	<feature_name>customers</feature_name>.<feature_name>exhausted</feature_name>
	<keyword>loop</keyword>
	    	<keyword>if</keyword> <feature_name>recent_purchases</feature_name>.<feature_name>has</feature_name> <symbol>(</symbol><feature_name>customers</feature_name>.<feature_name>item></feature_name><symbol>)</symbol> <keyword>then</keyword>
        		<feature_name>target_list</feature_name>.<feature_name>put</feature_name> <symbol>(</symbol><feature_name>customers</feature_name>.<feature_name>item></feature_name><symbol>)</symbol>
	    	<keyword>end</keyword>
	    	<feature_name>customers</feature_name>.<feature_name>forth</feature_name>
	<keyword>end</keyword></code_block>
		<paragraph>  Such schemes are quite common. But it is precisely because they occur frequently  that it is useful to rely on library classes to handle them. One of the principal tasks of  object-oriented software development is to identify recurring patterns and build reusable  classes that encapsulate them, so that future developers will be able to rely on ready-made  solutions.
			<line_break></line_break>  The classes of the Iteration library address this need. Using them offers two  benefits:
		</paragraph>
		<list ordered="false">
			<item>You avoid writing loops, in which the definition of sub-components such as exit  conditions, variants and invariants is often delicate or error-prone.</item>
			<item>You can more easily adapt the resulting features in descendant classes.  The rest of this chapter shows how to obtain these benefits.</item>
		</list>
		<heading>
			<size>1</size>Simple Examples
		</heading>
		<paragraph>  To get a first grasp of how one can work with the Iteration library, let us look at a typical  iteration class and a typical iteration client.</paragraph>
		<heading>
			<size>2</size>An example iterator routine
		</heading>
		<paragraph>  Here, given with its full implementation, is a typical Iteration library routine: the  procedure until_do from  
			<link>
				<url>../../reference/structures/iteration/linear_iterator_chart.xml</url>
				<label><link><url>/libraries/base/reference/structures/iteration/linear_iterator_chart.xml</url><label>LINEAR_ITERATOR</label></link></label>
			</link>, the class  defining iteration mechanisms on linear (sequential) structures.
		</paragraph>
		<code_block>
<feature_name>until_do</feature_name> <keyword>is</keyword>
			<comment>-- Apply action to every item of target,</comment>
			<comment>-- up to but excluding first one satisfying test.</comment>
			<comment>-- (Apply to full list if no item satisfies test.)</comment>
	<keyword>require</keyword>
        		<indexing_tag>traversable_exists</indexing_tag><symbol>:</symbol> <feature_name>target</feature_name> <symbol>/=</symbol> Void
    	<keyword>do</keyword>
		<keyword>from</keyword>
			<feature_name>target</feature_name>.<feature_name>start</feature_name>
		<keyword>invariant</keyword>
			<italic>invariant_value</italic>
		<keyword>until</keyword>
			<feature_name>target</feature_name>.<feature_name>exhausted</feature_name> <keyword>or</keyword> <keyword>else</keyword> test
		<keyword>loop</keyword>
			<feature_name>action</feature_name>
			<feature_name>target</feature_name>.<feature_name>forth</feature_name>
		<keyword>end</keyword>
	<keyword>ensure</keyword>
		<indexing_tag>achieved</indexing_tag><symbol>:</symbol> <feature_name>target</feature_name>.<feature_name>exhausted</feature_name> <keyword>or</keyword> <keyword>else</keyword> test
		<indexing_tag>invariant_satisfied</indexing_tag><symbol>:</symbol> <italic>invariant_value</italic>
	<keyword>end</keyword></code_block>
		<paragraph>  The precise form of the procedure in the class relies on a call to another procedure,  until_continue,  and on inherited assertions. Here everything has been unfolded for illustration  purposes.
			<line_break></line_break>  This procedure will traverse the linear structure identified by  target  and apply the procedure called  action  on every item up to but excluding the first one satisfying test.
			<line_break></line_break>  The class similarly offers  <feature_name>do_all</feature_name>,  <feature_name>do_while</feature_name>,  <feature_name>do_for</feature_name>,  <feature_name>do_if</feature_name>  and other procedures representing the common control structures.  It also includes functions such as <feature_name>exists</feature_name> and <feature_name>forall</feature_name>, corresponding to the usual quantifiers.
			<line_break></line_break>  These iteration schemes depend on the procedure <feature_name>action</feature_name>, defining the action to be applied to successive elements, and on the function <feature_name>test</feature_name>, defining the boolean query to be applied to these elements. These features are declared in class  <link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link> (the highest-level deferred class of the Iteration library); here is <feature_name>test</feature_name>:
		</paragraph>
		<code_block>
<feature_name>test</feature_name><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
			<comment>-- Test to be applied to item at current position in</comment>
			<comment>-- target (default: value of item_test on item)</comment>
	<keyword>require</keyword>
		<indexing_tag>traversable_exists</indexing_tag><symbol>:</symbol> <feature_name>target</feature_name> <symbol>/=</symbol> Void
		<indexing_tag>not_off</indexing_tag><symbol>:</symbol> <keyword>not</keyword> <feature_name>target</feature_name>.<feature_name>off</feature_name>
	<keyword>do</keyword>
		Result <symbol>:</symbol><symbol>=</symbol> <feature_name>item_test</feature_name> <symbol>(</symbol><feature_name>target</feature_name>.<feature_name>item></feature_name><symbol>)</symbol>
	<keyword>ensure</keyword>
		<indexing_tag>not_off</indexing_tag><symbol>:</symbol> <keyword>not</keyword> <feature_name>target</feature_name>.<feature_name>off</feature_name>
	<keyword>end</keyword></code_block>
		<paragraph> This indicates that the value of the boolean function <feature_name>test</feature_name> will be obtained by applying <feature_name>item_test</feature_name> to the item at the current position in the target structure. In <link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link>, function <feature_name>item_test</feature_name> always return 
			; descendant classes will redefine it so as to describe the desired test. Similarly, <feature_name>action</feature_name> is declared in class <link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link> as a call to <feature_name>item_action</feature_name>. Descendants will redefine <feature_name>item_action</feature_name>, which as initially declared in <link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link> is a procedure with a null body.
			<line_break></line_break> Going through <feature_name>item_action</feature_name> and <feature_name>item_test</feature_name> provides an extra degree of flexibility. Normally the action and test performed at each step apply to <feature_name>target</feature_name> 
			<code>
				<symbol>.</symbol>
			</code><feature_name>item></feature_name>, so that it suffices to redefine the <feature_name>item_features</feature_name>. This is the case with all examples studied in this chapter. In a more general setting, however, you might need to redefine <feature_name>action</feature_name> and <feature_name>test</feature_name> themselves.
		</paragraph>
		<heading>
			<size>2</size>An example use of iteration
		</heading>
		<paragraph>  Here now is an example illustrating the use of these mechanisms. The result will enable  us to resize all the paragraphs of a text up to the first one that has been modified - as we  might need to do, in a text processing system, to process an interactive user request.  Assume a class 
			<class_name>TEXT</class_name> that describes lists of paragraphs  with certain additional features. The example will also assume a class  
			<class_name>PARAGRAPH</class_name> with a procedure 
			<feature_name>resize</feature_name>,  and a boolean-valued attribute 
			<feature_name>modified</feature_name> which indicates whether a paragraph has been modified. Class 
			<class_name>TEXT</class_name> inherits  from <link><url>/libraries/base/reference/structures/list/linked_list_chart.xml</url><label>LINKED_LIST</label></link> and  so is a descendant of <link><url>/libraries/base/reference/structures/traversing/linear_chart.xml</url><label>LINEAR</label></link>:
		</paragraph>
		<code_block>
<keyword>class</keyword>
	<class_name>TEXT</class_name>

<keyword>inherit</keyword>
	<class_name>LINKED_LIST</class_name> <symbol>[</symbol><class_name>PARAGRAPH</class_name><symbol>]</symbol>
		...
<keyword>feature</keyword>
		...
<keyword>end</keyword></code_block>
		<paragraph>  In a class 
			<class_name>TEXT_PROCESSOR</class_name>, you can use an iteration procedure to write a very simple procedure 
			<feature_name>resize_ paragraphs</feature_name> that will resize all paragraphs up to but excluding the first one that has been modified:
		</paragraph>
		<code_block>
	<keyword>class</keyword>
		<class_name>TEXT_PROCESSOR</class_name>

	<keyword>inherit</keyword>
		<class_name><url>/libraries/base/reference/structures/iteration/linear_iterator_chart.xml</url><label>LINEAR_ITERATOR</label></class_name> <symbol>[</symbol><class_name>PARAGRAPH</class_name><symbol>]</symbol>
			<keyword>redefine</keyword>
				<feature_name>item_action</feature_name>, <feature_name>item_test</feature_name>
			<keyword>end</keyword>

	<keyword>feature</keyword>

<keyword>feature</keyword>

	<feature_name>resize_paragraphs</feature_name> <symbol>(</symbol>t<symbol>:</symbol> <class_name>TEXT</class_name><symbol>)</symbol> <keyword>is</keyword>
			<comment>-- Resize all the paragraphs of t up to but excluding</comment>
			<comment>-- the first one that has been modified.</comment>
		<keyword>do</keyword>
			<feature_name>set</feature_name> <symbol>(</symbol>t<symbol>)</symbol>
			<feature_name>until_do</feature_name>
		<keyword>end</keyword>

<keyword>feature</keyword> <symbol>{</symbol>NONE<symbol>}</symbol>

	<feature_name>item_test</feature_name> <symbol>(</symbol>p <class_name>PARAGRAPH</class_name><symbol>)</symbol><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
			<comment>-- Has p been modified?</comment>
		<keyword>do</keyword>
			Result <symbol>:</symbol><symbol>=</symbol> <feature_name>p</feature_name>.<feature_name>modified</feature_name>
		<keyword>end</keyword>

	<feature_name>item_action</feature_name> <symbol>(</symbol>p<symbol>:</symbol> <class_name>PARAGRAPH</class_name><symbol>)</symbol> <keyword>is</keyword>
			<comment>-- Resize p.</comment>
		<keyword>do</keyword>
			<feature_name>p</feature_name>.<feature_name>resize</feature_name>
		<keyword>end</keyword>
	...
<keyword>end</keyword></code_block>
		<paragraph>  Thanks to the iteration mechanism, the procedure 
			<feature_name>resize_paragraphs</feature_name>  simply needs two procedure calls:
		</paragraph>
		<list ordered="false">
			<item>To set its argument 
				<code>
					<local_variable>t</local_variable>
				</code> as the iteration target, it uses procedure  
				<feature_name>set</feature_name>. (This procedure is from class  <link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link>  which passes it on to all iterator classes.)
			</item>
			<item>Then it simply calls <feature_name>until_do</feature_name> as defined above.</item>
		</list>
		<paragraph>  Procedure  <feature_name>item_action</feature_name>  is redefined to describe the operation to be performed on each successive element. Function  <feature_name>item_test</feature_name>  is redefined to describe the exit test.
			<line_break></line_break>  As presented so far, the mechanism seems to limit every descendant of an iteration class to just  one form of iteration. As shown later in this chapter, it is in fact easy to generalize the  technique to allow a class to use an arbitrary number of iteration schemes.
			<line_break></line_break>  What is interesting here is that the redefinitions of  <feature_name>item_test</feature_name>  and  <feature_name>item_action</feature_name>  take care of all the details. There is no need to write any loop or other control structure. We  are at the very heart of the object-oriented method, enjoying the ability to encapsulate  useful and common software schemes so that client developers will only need to fill in  what is specific to their application.
		</paragraph>
		<heading>
			<size>1</size>Using the Iteration Library
		</heading>
		<paragraph>  Let us now explore the classes of the Iteration library and the different ways of using  them.</paragraph>
		<heading>
			<size>2</size>Overview of the classes
		</heading>
		<paragraph>  There are only four Iteration classes, whose simple inheritance structure appeared at the  beginning of this chapter.</paragraph>
		<list ordered="false">
			<item><link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link>,  a deferred class which describes the most general notion.</item>
			<item><link><url>/libraries/base/reference/structures/iteration/linear_iterator_chart.xml</url><label>LINEAR_ITERATOR</label></link>,  for iterating over linear structures and chains.</item>
			<item><link><url>/libraries/base/reference/structures/iteration/two_way_chain_iterator_chart.xml</url><label>TWO_WAY_CHAIN_ITERATOR</label></link>,  a repeated heir of  <link><url>/libraries/base/reference/structures/iteration/linear_iterator_chart.xml</url><label>LINEAR_ITERATOR</label></link>,  for iterating in either direction over a bilinear structure.</item>
			<item><link><url>/libraries/base/reference/structures/iteration/cursor_tree_iterator_chart.xml</url><label>CURSOR_TREE_ITERATOR</label></link>,  for iterating over trees.</item>
		</list>
		<paragraph>  As you will remember from the 
			<link>
				<url>/libraries/base/content/20_structures/10_taxonomy.xml</url>
				<label>presentation</label>
			</link> of the abstract overall taxonomy,  the traversal hierarchy describes how data structures can be traversed; its most general class  is <link><url>/libraries/base/reference/structures/list/two_way_list_chart.xml</url><label>TRAVERSABLE</label></link>.
			<line_break></line_break>  Each one of the iterator classes is paired with a traversal class (or two in one case):
		</paragraph>
		<table>
			<row>
				<cell><link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link></cell>
				<cell><link><url>/libraries/base/reference/structures/list/two_way_list_chart.xml</url><label>TRAVERSABLE</label></link></cell>
			</row>
			<row>
				<cell><link><url>/libraries/base/reference/structures/iteration/linear_iterator_chart.xml</url><label>LINEAR_ITERATOR</label></link></cell>
				<cell><link><url>/libraries/base/reference/structures/traversing/linear_chart.xml</url><label>LINEAR</label></link></cell>
			</row>
			<row>
				<cell><link><url>/libraries/base/reference/structures/iteration/two_way_chain_iterator_chart.xml</url><label>TWO_WAY_CHAIN_ITERATOR</label></link></cell>
				<cell><link><url>/libraries/base/reference/structures/list/two_way_list_chart.xml</url><label>TWO_WAY_LIST</label></link></cell>
			</row>
			<row>
				<cell><link><url>/libraries/base/reference/structures/iteration/two_way_chain_iterator_chart.xml</url><label>TWO_WAY_CHAIN_ITERATOR</label></link></cell>
				<cell><link><url>/libraries/base/reference/structures/list/two_way_list_chart.xml</url><label>TWO_WAY_LIST</label></link>, <link><url>/libraries/base/reference/structures/list/two_way_circular_chart.xml</url><label>TWO_WAY_CIRCULAR</label></link></cell>
			</row>
			<row>
				<cell><link><url>/libraries/base/reference/structures/iteration/cursor_tree_iterator_chart.xml</url><label>CURSOR_TREE_ITERATOR</label></link></cell>
				<cell><link><url>/libraries/base/reference/structures/cursor_tree/cursor_tree_chart.xml</url><label>CURSOR_TREE</label></link></cell>
			</row>
		</table>
		<paragraph>Each iterator class relies on the corresponding traversal class to provide the features for traversing the corresponding data structures, such as <feature_name>start</feature_name>, <feature_name>forth</feature_name> and <feature_name>exhausted</feature_name> for  linear structures.
			<line_break></line_break>  Of course the data structure class used in connection with a given iterator class does not need to  be the iterator's exact correspondent as given by the above table; it may be any one of its  descendants. For example you may use  <link><url>/libraries/base/reference/structures/iteration/linear_iterator_chart.xml</url><label>LINEAR_ITERATOR</label></link> to iterate over data structures described not just by  <link><url>/libraries/base/reference/structures/traversing/linear_chart.xml</url><label>LINEAR</label></link>  but also by such descendants as  <link><url>/libraries/base/reference/structures/list/list_chart.xml</url><label>LIST</label></link>, <link><url>/libraries/base/reference/structures/list/linked_list_chart.xml</url><label>LINKED_LIST</label></link>,  <link><url>/libraries/base/reference/structures/list/arrayed_list_chart.xml</url><label>ARRAYED_LIST</label></link>,  or even  <link><url>/libraries/base/reference/structures/list/two_way_list_chart.xml</url><label>TWO_WAY_LIST</label></link>  if you do not need the backward iteration features (for which you will have to use  <link><url>/libraries/base/reference/structures/iteration/two_way_chain_iterator_chart.xml</url><label>TWO_WAY_CHAIN_ITERATOR</label></link>  ).
		</paragraph>
		<heading>
			<size>2</size>General iteration facilities
		</heading>
		<paragraph>  Class  <link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link>  defines the features that apply to all forms of iterator.
			<line_break></line_break>  An iterator will always apply to a certain target structure. The target is introduced in  <link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link> by the feature  target:  <link><url>/libraries/base/reference/structures/traversing/traversable_chart.xml</url><label>TRAVERSABLE</label></link> [G]
			<line_break></line_break>  Both the iterator classes and the traversal classes are generic, with a formal generic  parameter G. The actual generic parameters will be matched through the choice of  iteration target: for a generic derivation of the form  
			<class_name>SOME_ITERATOR</class_name> [
			<class_name>ACTUAL_TYPE</class_name>]  the target can only be of type  
			<class_name>SOME_TRAVERSABLE</class_name> [
			<class_name>ACTUAL_TYPE</class_name>]  for the same 
			<class_name>ACTUAL_TYPE</class_name>, where  
			<class_name>SOME_TRAVERSABLE</class_name> is the traversal class matching  
			<class_name>SOME_ITERATOR</class_name> according to the preceding table  (<link><url>/libraries/base/reference/structures/traversing/linear_chart.xml</url><label>LINEAR</label></link>  for  <link><url>/libraries/base/reference/structures/iteration/linear_iterator_chart.xml</url><label>LINEAR_ITERATOR</label></link>and so on), or one of its proper descendants.
			<line_break></line_break>  Each of the proper descendants of  <link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link>  redefines the type of target to the matching proper descendant of  <link><url>/libraries/base/reference/structures/traversing/traversable_chart.xml</url><label>TRAVERSABLE</label></link>,  to cover more specific variants of the iteration target, For example in  <link><url>/libraries/base/reference/structures/iteration/linear_iterator_chart.xml</url><label>LINEAR_ITERATOR</label></link>the feature is redefined to be of  type <link><url>/libraries/base/reference/structures/traversing/linear_chart.xml</url><label>LINEAR</label></link>.  <link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link>  also introduces the procedure for selecting a target:
		</paragraph>
		<code_block>
	<feature_name>set</feature_name> <symbol>(</symbol>s<symbol>:</symbol> <keyword>like</keyword> target<symbol>)</symbol> <keyword>is</keyword>
			<comment>-- Make s the new target of iterations.</comment>
		<keyword>require</keyword>
			s <symbol>/=</symbol> Void
 		<keyword>do</keyword>
 			<feature_name>target</feature_name> <symbol>:</symbol><symbol>=</symbol> s
		<keyword>ensure</keyword>
 			<feature_name>target</feature_name> <symbol>=</symbol> s
			<feature_name>target</feature_name> <symbol>/= Void</symbol>
		<keyword>end</keyword></code_block>
		<paragraph>  Next  <link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link>  introduces the routines describing the elementary action and test  that will be applied to items of the iteration targets:</paragraph>
		<code_block>
	action <keyword>is</keyword>
    			<comment>-- Action to be applied to item at current position in</comment>
			<comment>-- target.</comment>
			<comment>-- (default: item_action on item at current position.)</comment>
			<comment>-- Note: for iterators to work properly, redefined</comment>
			<comment>-- versions of this feature should not change the</comment>
			<comment>-- traversable structure.</comment>
		<keyword>require</keyword>
			<indexing_tag>traversable_exists</indexing_tag><symbol>:</symbol> <feature_name>target</feature_name> <symbol>/=</symbol> Void
			<indexing_tag>not_off</indexing_tag><symbol>:</symbol> <keyword>not</keyword> <feature_name>target</feature_name>.<feature_name>off</feature_name>
			<indexing_tag>invariant_satisfied</indexing_tag><symbol>:</symbol> invariant_value
		<keyword>do</keyword>
			<feature_name>item_action </feature_name><symbol>(</symbol><feature_name>target</feature_name>.<feature_name>item></feature_name><symbol>)</symbol>
		<keyword>ensure</keyword>
			<indexing_tag>not_off</indexing_tag><symbol>:</symbol> <keyword>not</keyword> <feature_name>target</feature_name>.<feature_name>off</feature_name>
			<indexing_tag>invariant_satisfied</indexing_tag><symbol>:</symbol> invariant_value
		<keyword>end</keyword>

	<feature_name>test</feature_name><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
			<comment>-- Test to be applied to item at current position in</comment>
			<comment>-- target (default: value of item_test on item)</comment>
		<keyword>require</keyword>
			<indexing_tag>traversable_exists</indexing_tag><symbol>:</symbol> <feature_name>target</feature_name> <symbol>/=</symbol> Void
			<indexing_tag>not_off</indexing_tag><symbol>:</symbol> <keyword>not</keyword> <feature_name>target</feature_name>.<feature_name>off</feature_name>
		<keyword>do</keyword>
			Result <symbol>:</symbol><symbol>=</symbol><feature_name> item_test </feature_name><symbol>(</symbol><feature_name>target</feature_name>.<feature_name>item></feature_name><symbol>)</symbol>
		<keyword>ensure</keyword>
			<keyword>not</keyword> <feature_name>target</feature_name>.<feature_name>off</feature_name>
		<keyword>end</keyword></code_block>
		<paragraph>  These routines rely on two others,  <feature_name>item_action</feature_name> and  <feature_name>item_test</feature_name>,  which both take an argument of type G, the formal generic parameter. The reason, already noted above, is  that in a vast majority of cases the iterated action and test solely depend, at each step of  the traversal, on the item (of type G) at the current position. To define an iteration  process, then, it suffices to redefine<feature_name> item_action</feature_name> and <feature_name>item_test</feature_name> in a descendant of the  appropriate iteration class. Only in complex cases will it be necessary to redefine <feature_name>action</feature_name> and <feature_name>test</feature_name> themselves.
			<line_break></line_break>  If you encounter such a case, note the caveat about action changing the target's structure.  Understandably enough, an iterator that attempts to change the data structure while traversing it  may engage in strange behavior. No such risk exists if you only redefine <feature_name>item_action</feature_name>, which  may change the contents of items but not the structure itself.
			<line_break></line_break>  Another feature introduced in  <link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link>  is the query  <feature_name>invariant_value</feature_name>,  describing invariant properties that must be ensured at the beginning of any iteration and preserved  by every iteration step. As declared in  <link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link>  this query always returns true, but proper descendants can redefine it to describe more interesting  invariant properties.
			<line_break></line_break>  Finally,  <link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link>  introduces in deferred form the general iteration routines applicable to all iteration variants.  They include two queries corresponding to the quantifiers of first-order predicate calculus:
		</paragraph>
		<list ordered="false">
			<item><feature_name>for_all</feature_name> will return true if all items of the target structure satisfy test.</item>
			<item><feature_name>exists</feature_name> will return true if at least one item satisfies test.</item>
		</list>
		<paragraph>  The other routines are commands which will traverse the target structure and apply action to items selected through test:</paragraph>
		<list ordered="false">
			<item><feature_name>do_all</feature_name> applies <feature_name>action</feature_name> to all items.</item>
			<item><feature_name>do_if</feature_name>, to those items which satisfy test.</item>
			<item><feature_name>until_do</feature_name>, to all items up to but excluding the first one that satisfies test.</item>
			<item><feature_name>do_until</feature_name>, to all items up to and including the first one that satisfies test.</item>
			<item><feature_name>while_do</feature_name> and  <feature_name>do_while</feature_name>,  to all items up to the first one that does not satisfy  test.  (This can also be achieved with  <feature_name>until_do</feature_name>  or  <feature_name>do_until </feature_name> by choosing the opposite test.)</item>
		</list>
		<paragraph>  All these features, and most of the other iteration features introduced in proper  descendants of  <link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link>  and described next, have no argument. Information about the target of iteration comes  from feature  <feature_name>target</feature_name>,  set by procedure  <feature_name>set</feature_name>;  information about what needs to be done for each item of the target structure comes from  <feature_name>item_action</feature_name>  and  <feature_name>item_test</feature_name>.</paragraph>
		<heading>
			<size>2</size>Linear and chain iteration
		</heading>
		<paragraph><link><url>/libraries/base/reference/structures/iteration/linear_iterator_chart.xml</url><label>LINEAR_ITERATOR</label></link>,  an effective class, refines the iteration mechanisms for cases in which the target is a linear  structure, such as a list in any implementation or a circular chain.
			<line_break></line_break>  The class effects all the deferred features inherited from  <link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link>,  taking advantage of the linear traversal mechanisms present in the corresponding traversal class,  <link><url>/libraries/base/reference/structures/traversing/linear_chart.xml</url><label>LINEAR</label></link>.  Here for example is the effecting of  <feature_name>do_if</feature_name>:
		</paragraph>
		<code_block>
	<feature_name>do_if</feature_name> <keyword>is</keyword>
			<comment>-- Apply action to every item of target satisfying         </comment>
			<comment>-- test.</comment>
		<keyword>do</keyword>
			<keyword>from</keyword>
				<feature_name>target</feature_name>.<feature_name>start</feature_name>
			<keyword>invariant</keyword>
				invariant_value
			<keyword>until</keyword>
				<feature_name>target</feature_name>.<feature_name>exhausted</feature_name>
			<keyword>loop</keyword>
				<keyword>if</keyword> <feature_name>test</feature_name> <keyword>then</keyword>
					<feature_name>action</feature_name>
				<keyword>end</keyword>
				<feature_name>forth</feature_name>
			<keyword>end</keyword>
		<keyword>end</keyword></code_block>
		<paragraph>  This routine text relies on features  <feature_name>start</feature_name>,  <feature_name>forth</feature_name> and  <feature_name>exhausted</feature_name>  which, together with  <feature_name>off</feature_name>,  have for convenience been carried over to  <link><url>/libraries/base/reference/structures/iteration/linear_iterator_chart.xml</url><label>LINEAR_ITERATOR</label></link> from their counterparts in  <link><url>/libraries/base/reference/structures/traversing/linear_chart.xml</url><label>LINEAR</label></link>,  with feature declarations such as</paragraph>
		<code_block>
	<feature_name>off</feature_name><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
			<comment>-- Is position of target off?</comment>
    		<keyword>require</keyword>
        			<indexing_tag>traversable_exists</indexing_tag><symbol>:</symbol> target <symbol>/=</symbol> Void
    		<keyword>do</keyword>
        			Result <symbol>:</symbol><symbol>=</symbol> <feature_name>target</feature_name>.<feature_name>off</feature_name>
    		<keyword>end</keyword></code_block>
		<paragraph>  and similarly for the others.
			<line_break></line_break>  In addition to effecting the general iteration features from  <link><url>/libraries/base/reference/structures/iteration/iterator_chart.xml</url><label>ITERATOR</label></link>,  class  <link><url>/libraries/base/reference/structures/iteration/linear_iterator_chart.xml</url><label>LINEAR_ITERATOR</label></link>  introduces iteration features that apply to the specific case of linear structures:
		</paragraph>
		<list ordered="false">
			<item><feature_name>search </feature_name>
				<code>
					<symbol>(</symbol>
					<local_variable>b</local_variable>
					<symbol>:</symbol>BOOLEAN)  moves the iteration to the first position satisfying test if 
					<local_variable>b</local_variable>  is true, or not satisfying test if 
					<local_variable>b</local_variable>
				</code> is false. This use of a boolean argument to  switch between two opposite semantics is not part of the recommended style, and  you will find few if any other examples in the Base libraries. Here, however, it  was deemed preferable to the alternative, which would have involved four  separate procedures (if together with  <feature_name>search</feature_name>  we consider  <feature_name>continue_search</feature_name>  discussed next).
			</item>
			<item>With a linear structure we can implement an iteration corresponding to the 'for'  loop of traditional programming languages, defined by three integers: the starting  position, the number of items to be traversed, and the step between consecutive  items. This is provided by procedure  <feature_name>do_for</feature_name> 
				<code>
					<symbol>(</symbol>
					<local_variable>starting</local_variable> 
					<symbol>,</symbol>
					<local_variable>number</local_variable> 
					<symbol>,</symbol>
					<local_variable>step</local_variable> 
					<symbol>:</symbol>INTEGER).
				</code>
			</item>
			<item>Since with a linear target the iterator can advance the cursor step by step, the  basic iteration operations are complemented by variants which pick up from the  position reached by the last call:  <feature_name>continue_until</feature_name>,  <feature_name>until_continue</feature_name>,  <feature_name>continue_while</feature_name>,  <feature_name>while_continue</feature_name>,  <feature_name>continue_search</feature_name>,  <feature_name>continue_for</feature_name>.</item>
		</list>
		<heading>
			<size>2</size>Two-way iteration
		</heading>
		<paragraph>  Class  <link><url>/libraries/base/reference/structures/iteration/two_way_chain_iterator_chart.xml</url><label>TWO_WAY_CHAIN_ITERATOR</label></link>  has all the features of  <link><url>/libraries/base/reference/structures/iteration/linear_iterator_chart.xml</url><label>LINEAR_ITERATOR</label></link>,  to which it adds features for iterating backward as well as forward.
			<line_break></line_break>  The class introduces commands  <feature_name>finish</feature_name> and  <feature_name>back</feature_name>,  applying the corresponding operations to the two-way target. It also has a backward variant for every iteration  feature. The name of each such variant is the name of the forward feature followed by  
			<italic>_back</italic>:  <feature_name>do_all_back</feature_name>,  <feature_name>until_do_back</feature_name>  and so on.
			<line_break></line_break>  An alternative design would have kept just one set of features and added two features: a  command reverse to reverse the direction of future iteration operations, and a query backward  to find out the direction currently in force.
			<line_break></line_break>  Contrary to what one might at first imagine, class  <link><url>/libraries/base/reference/structures/iteration/two_way_chain_iterator_chart.xml</url><label>TWO_WAY_CHAIN_ITERATOR</label></link>  is extremely short and simple; its 
			<code>
				<keyword>Feature</keyword>
			</code> clause only contains the declarations of two  features,  <feature_name>finish</feature_name> and  <feature_name>back</feature_name>.
			<line_break></line_break>  The trick is to use repeated inheritance.  <link><url>/libraries/base/reference/structures/iteration/two_way_chain_iterator_chart.xml</url><label>TWO_WAY_CHAIN_ITERATOR</label></link>  inherits twice from  <link><url>/libraries/base/reference/structures/iteration/linear_iterator_chart.xml</url><label>LINEAR_ITERATOR</label></link>;  the first inheritance branch yields the forward iteration features,  the second yields those for backward iteration. There is  no need for any explicit declaration or redeclaration of iteration features. Here is the  entire class text that yields this result:
		</paragraph>
		<code_block>
	<keyword>class</keyword>
    		<class_name>TWO_WAY_CHAIN_ITERATOR</class_name> <symbol>[</symbol><class_name>G</class_name><symbol>]</symbol>

	<keyword>inherit</keyword>
    		<class_name>LINEAR_ITERATOR</class_name> <symbol>[</symbol><class_name>G</class_name><symbol>]</symbol>
        		<keyword>redefine</keyword>
            			<feature_name>target</feature_name>
        		<keyword>select</keyword>
            			<feature_name>start</feature_name>,
            			<feature_name>forth</feature_name>,
             			<feature_name>do_all</feature_name>,
            			<feature_name>until_do</feature_name>,
            			<feature_name>do_until</feature_name>,
            			<feature_name>do_if</feature_name>,
            			<feature_name>do_for</feature_name>,
            			<feature_name>search</feature_name>,
            			<feature_name>forall</feature_name>,
            			<feature_name>exists</feature_name>,
             			<feature_name>until_continue</feature_name>,
            			<feature_name>continue_until</feature_name>,
             			<feature_name>continue_for</feature_name>,
            			<feature_name>continue_search</feature_name>
        		<keyword>end</keyword>

		<class_name>LINEAR_ITERATOR</class_name> <symbol>[</symbol><class_name>G</class_name><symbol>]</symbol>
			<keyword>rename</keyword>
   				<feature_name>start</feature_name> <keyword>as</keyword> <feature_name>finish</feature_name>,
   				<feature_name>forth</feature_name> <keyword>as</keyword> <feature_name>back</feature_name>,
   				<feature_name>do_all</feature_name> <keyword>as</keyword> <feature_name>do_all_back</feature_name>,
   				<feature_name>until_do</feature_name> <keyword>as</keyword> <feature_name>until_do_back</feature_name>,
   				<feature_name>do_until</feature_name> <keyword>as</keyword> <feature_name>do_until_back</feature_name>,
   				<feature_name>do_if</feature_name> <keyword>as</keyword> <feature_name>do_if_back</feature_name>,
   				<feature_name>do_for</feature_name> <keyword>as</keyword> <feature_name>do_for_back</feature_name>,
   				<feature_name>search</feature_name> <keyword>as</keyword> <feature_name>search_back</feature_name>,
   				<feature_name>forall</feature_name> <keyword>as</keyword> <feature_name>forall_back</feature_name>,
   				<feature_name>exists</feature_name> <keyword>as</keyword> <feature_name>exists_back</feature_name>,
   				<feature_name>until_continue</feature_name> <keyword>as</keyword> <feature_name>until_continue_back</feature_name>,
   				<feature_name>continue_until</feature_name> <keyword>as</keyword> <feature_name>continue_until_back</feature_name>,
   				<feature_name>continue_for</feature_name> <keyword>as</keyword> <feature_name>continue_for_back</feature_name>,
   				<feature_name>continue_search</feature_name> <keyword>as</keyword> <feature_name>continue_search_back</feature_name>
        		<keyword>redefine</keyword>
            			<feature_name>target</feature_name>
        		<keyword>end</keyword>

	<keyword>feature</keyword> -- Status report

    		<feature_name>target</feature_name><symbol>:</symbol> <class_name>BI_LINEAR</class_name> <symbol>[</symbol><class_name>G</class_name><symbol>]</symbol>
            		<comment>-- The structure to which iteration features will</comment>
            		<comment>-- apply</comment>

	<keyword>feature</keyword> -- Curs<keyword>or</keyword> movement

    		<feature_name>finish</feature_name> <keyword>is</keyword>
        			<comment>-- Move cursor of target to last position.</comment>
        		<keyword>do</keyword>
            			<feature_name>target</feature_name>.<feature_name>finish</feature_name>
        		<keyword>end</keyword>

    		<feature_name>back</feature_name> <keyword>is</keyword>
            			<comment>-- Move cursor of target backward one position.</comment>
        		<keyword>do</keyword>
            			<feature_name>target</feature_name>.<feature_name>back</feature_name>
        		<keyword>end</keyword>
	<keyword>end</keyword>
		</code_block>
		<paragraph>  This class provides a good example of the economy of expression that the full  inheritance mechanism affords through the combination of renaming, redefinition,  repeated inheritance rules and selection, without sacrificing clarity and maintainability.</paragraph>
		<heading>
			<size>2</size>Tree iteration
		</heading>
		<paragraph>  Tree iterations, provided by class  <link><url>/libraries/base/reference/structures/iteration/cursor_tree_iterator_chart.xml</url><label>CURSOR_TREE_ITERATOR</label></link>,  work on trees of the cursor tree form; only with this form of tree are traversal operations possible.  Three forms of iteration are provided: preorder, postorder and breadth-first. They  correspond to the three traversal policies described in the discussion of trees.  Here too it would seem that a rather lengthy class is needed, but repeated  inheritance works wonders.
			<line_break></line_break><link><url>/libraries/base/reference/structures/iteration/cursor_tree_iterator_chart.xml</url><label>CURSOR_TREE_ITERATOR</label></link>  simply inherits three times from  <link><url>/libraries/base/reference/structures/iteration/linear_iterator_chart.xml</url><label>LINEAR_ITERATOR</label></link>,  renaming the features appropriately in each case:
		</paragraph>
		<list ordered="false">
			<item>
				<feature_name>pre_do_all</feature_name>,  
				<feature_name>pre_until</feature_name>  and so on.
			</item>
			<item>
				<feature_name>post_do_all</feature_name>,  
				<feature_name>post_until</feature_name>  and so on.
			</item>
			<item>
				<feature_name>breadth_do_all</feature_name>,  
				<feature_name>breadth_until</feature_name>  and so on.
			</item>
		</list>
		<paragraph>  All it needs to do then is to redefine the type of target to be  <link><url>/libraries/base/reference/structures/cursor_tree/cursor_tree_chart.xml</url><label>CURSOR_TREE</label></link> 
			<code>
				<symbol>[</symbol>
			</code>
			<class_name>G</class_name>
			<code>
				<symbol>]</symbol>
			</code>,  and to redefine six features: the three renamed  start  ( 
			<feature_name>pre_start</feature_name>  etc.) and the three  forth  ( 
			<feature_name>pre_ forth</feature_name>  and so on). These seven redefinitions give us a full-fledged battery of tree  iteration mechanisms.
		</paragraph>
		<heading>
			<size>1</size>Building and Using Iterators
		</heading>
		<paragraph>  To conclude this discussion, let us now put together the various mechanisms studied so  far, to see how authors of client software can use the Iteration library to perform  possibly complex iterations on various data structures without ever writing a single loop  or test. The basic ideas were sketched above but now we have all the elements for the  full view.
			<line_break></line_break>  An application class may use one of the iteration classes in either of two ways: as a  descendant (single or repeated) or as a client. The descendant technique is extremely  simple but less versatile.
		</paragraph>
		<heading>
			<size>2</size>The single descendant technique
		</heading>
		<paragraph>  Assume an application class  
			<class_name>PROCESSOR</class_name>  that is a proper descendant of one of the effective iteration classes studied in this chapter.  Then a routine of  
			<class_name>PROCESSOR</class_name>, say  
			<feature_name>iterate</feature_name>, may iterate a certain action over a data structure, subject to a certain test.  First, class 
			<class_name>PROCESSOR</class_name> must specify the action by redefining  item_action and  item_test  (or, in the most general case,  action and  test).  Then routine iterate must specify the target data structure through a call of the form  set 
			<code>
				<symbol>(</symbol>
			</code>
			<code>
				<local_variable>t</local_variable>
				<symbol>)</symbol>  where 
				<local_variable>t</local_variable> represents the selected target data structure. The type of  
				<local_variable>t</local_variable> must correspond tothe iteration class selected as ancestor of  
			</code>
			<class_name>PROCESSOR</class_name>:  for  <link><url>/libraries/base/reference/structures/iteration/linear_iterator_chart.xml</url><label>LINEAR_ITERATOR</label></link>it must be a descendant of  <link><url>/libraries/base/reference/structures/traversing/linear_chart.xml</url><label>LINEAR</label></link>  (such as  <link><url>/libraries/base/reference/structures/list/linked_list_chart.xml</url><label>LINKED_LIST</label></link>,  <link><url>/libraries/base/reference/structures/list/arrayed_list_chart.xml</url><label>ARRAYED_LIST</label></link>,  LINKED_CIRCULAR  or any other list or circular chain classes); for  <link><url>/libraries/base/reference/structures/iteration/two_way_chain_iterator_chart.xml</url><label>TWO_WAY_CHAIN_ITERATOR</label></link>  it must be a descendant of  BI<link><url>/libraries/base/reference/structures/traversing/linear_chart.xml</url><label>LINEAR</label></link>  such as  <link><url>/libraries/base/reference/structures/list/two_way_list_chart.xml</url><label>TWO_WAY_LIST</label></link>  or  <link><url>/libraries/base/reference/structures/list/two_way_circular_chart.xml</url><label>TWO_WAY_CIRCULAR</label></link>;  for  <link><url>/libraries/base/reference/structures/iteration/cursor_tree_iterator_chart.xml</url><label>CURSOR_TREE_ITERATOR</label></link>it must be a descendant of  <link><url>/libraries/base/reference/structures/cursor_tree/cursor_tree_chart.xml</url><label>CURSOR_TREE</label></link>.  In all cases the actual generic parameters of the iterator class and ofthe data structure class must be compatible.  Then the iteration proper is obtained simply by calling the appropriate procedure, without any qualification  or arguments, for example:  do_ if
			<line_break></line_break>  It is hard to imagine a simpler scheme: no loops, no initialization, no arguments.  Feature  item_action  may need to rely on some variable values. Because it does not take any  argument, such values will have to be treated as attributes, with the corresponding 
			<feature_name>set_...</feature_name>  procedures to set and change their values. This also applies to the two schemes set next.
			<line_break></line_break>  The single descendant technique has one drawback: it provides the iterating class,  
			<class_name>PROCESSOR</class_name>,  with only one set of iteration particulars. This limitation does not affect  the number of targets: you may use as many targets as you wish, as long as they are of  compatible types, by calling a routine such as iterate several times, or calling several  such routines, each call being preceded by a call to set to define a new target. The  limitation also does not affect the iterating scheme: one iteration could use  do_if,  the next  do_all  and so on. But it does require the action and test to be the same in all cases.
			<line_break></line_break>  The next two techniques will remove this limitation.
		</paragraph>
		<heading>
			<size>2</size>Using repeated inheritance
		</heading>
		<paragraph>  One way to obtain several iteration schemes is a simple extension to the single  descendant technique. You can use repeated inheritance to provide two or more variants.  We have in fact already encountered the technique when studying how to derive  <link><url>/libraries/base/reference/structures/iteration/two_way_chain_iterator_chart.xml</url><label>TWO_WAY_CHAIN_ITERATOR</label></link>  and  <link><url>/libraries/base/reference/structures/iteration/cursor_tree_iterator_chart.xml</url><label>CURSOR_TREE_ITERATOR</label></link>from  <link><url>/libraries/base/reference/structures/iteration/linear_iterator_chart.xml</url><label>LINEAR_ITERATOR</label></link>.  The general pattern, applied here to just two iteration schemes but easily generalized to  more, is straightforward:</paragraph>
		<code_block>
	<keyword>class</keyword>
		<class_name>DUAL_PROCESSOR</class_name>

	<keyword>inherit</keyword>
		<class_name>LINEAR_ITERATOR</class_name> <symbol>[</symbol><class_name>SOME_TYPE</class_name><symbol>]</symbol>
 			<keyword>rename</keyword>
				<feature_name>item_action</feature_name> <keyword>as</keyword> <feature_name>action1</feature_name>,
 				<feature_name>item_test</feature_name> <keyword>as</keyword> <feature_name>test1</feature_name>,
				<feature_name>do_if</feature_name> <keyword>as</keyword> <feature_name>do_if1</feature_name>,
			<keyword>redefine</keyword>
				<feature_name>action1</feature_name>, <feature_name>test1</feature_name>
			<keyword>select</keyword>
				<feature_name>action1</feature_name>, <feature_name>test1</feature_name>
        		<keyword>end</keyword>

		<class_name>LINEAR_ITERATOR</class_name> <symbol>[</symbol><class_name>SOME_TYPE</class_name><symbol>]</symbol>
			<keyword>rename</keyword>
				<feature_name>item_action</feature_name> <keyword>as</keyword> <feature_name>action2</feature_name>,
				<feature_name>item_test</feature_name> <keyword>as</keyword> <feature_name>test2</feature_name>,
				<feature_name>do_if</feature_name> <keyword>as</keyword> <feature_name>do_if2</feature_name>,
			<keyword>redefine</keyword>
				<feature_name>action2</feature_name>, <feature_name>test2</feature_name>
			<keyword>end</keyword>

	<keyword>feature</keyword>

		<feature_name>action1</feature_name> <keyword>is</keyword>
				<comment>-- Action for the first scheme</comment>
			<keyword>do</keyword>
				...
			<keyword>end</keyword>

		<feature_name>test1</feature_name><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
				<comment>-- Test for the first scheme</comment>
			<keyword>do</keyword>
				...
			<keyword>end</keyword>

		<feature_name>action2</feature_name> <keyword>is</keyword>
				<comment>-- Action for the second scheme</comment>
			<keyword>do</keyword>
				...
			<keyword>end</keyword>

		<feature_name>test2</feature_name><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
				<comment>-- Test for the second scheme</comment>
			<keyword>do</keyword>
				...
			<keyword>end</keyword>

		<feature_name>iterate1</feature_name> <keyword>is</keyword>
				<comment>-- Execute iteration of first kind.</comment>
			<keyword>do</keyword>
				<feature_name>set </feature_name><symbol>(</symbol>...<symbol>)</symbol>
				<feature_name>do_if1</feature_name>
			<keyword>end</keyword>

		<feature_name>iterate2</feature_name> <keyword>is</keyword>
				<comment>-- Execute iteration of second kind.</comment>
			<keyword>do</keyword>
				<feature_name>set</feature_name> <symbol>(</symbol>...<symbol>)</symbol>
				<feature_name>do_if2</feature_name>
			<keyword>end</keyword>

			... 
		</code_block>
		<paragraph>  The repeated inheritance machinery takes care of the rest.</paragraph>
		<heading>
			<size>2</size>Using explicit iterator objects
		</heading>
		<paragraph>  To obtain maximum flexibility, classes that need iteration facilities should be clients  rather than descendants of the iteration classes. The resulting scheme is completely  dynamic: to perform iterations you use iterator objects as discussed earlier.
			<line_break></line_break>  The following example illustrates the technique. Consider a deferred class  
			<class_name>FIGURE</class_name> describing the notion of graphical figure,  with many effective descendants ( 
			<class_name>POLYGON</class_name>,  
			<class_name>CIRCLE</class_name> and so on). It is useful to define  
			<class_name>COMPLEX_FIGURE</class_name>, describing figures that  are recursively composed of sub-figures. This is a remarkable example of multiple  inheritance:
		</paragraph>
		<code_block>
	<keyword>class</keyword>
    		<class_name>COMPLEX_FIGURE</class_name>

	<keyword>inherit</keyword>
    		<class_name>FIGURE</class_name>,
    		<class_name>LINKED_LIST</class_name> <symbol>[</symbol><class_name>FIGURE</class_name><symbol>]</symbol>

	<keyword>feature</keyword>
    		... <keyword>end</keyword> 
		</code_block>
		<paragraph>  In the feature clause we want to provide the appropriate effectings for the deferred  features of class 
			<class_name>FIGURE</class_name>:  
			<feature_name>display</feature_name>, 
			<feature_name>hide</feature_name>,  
			<feature_name>translate</feature_name> and all other basic figure operations.
			<line_break></line_break>  We can use loops for that purpose, for example
		</paragraph>
		<code_block>
	display <keyword>is</keyword>
        		<comment>-- Recursively display all components of the complex</comment>
        		<comment>-- figure</comment>
    		<keyword>do</keyword>
        		<keyword>from</keyword>
            			<feature_name>start</feature_name>
        		<keyword>until</keyword>
            			<feature_name>exhausted</feature_name>
        		<keyword>loop</keyword>
				<feature_name>item></feature_name>.<feature_name>display</feature_name>
            			<feature_name>forth</feature_name>
        		<keyword>end</keyword>
    		<keyword>end</keyword>
		</code_block>
		<paragraph>  Although acceptable and even elegant, this scheme will cause significant  duplication: all the 
			<class_name>FIGURE</class_name> features - not  just 
			<feature_name>display</feature_name> but also 
			<feature_name>hide</feature_name>,  
			<feature_name>rotate</feature_name>, 
			<feature_name>move</feature_name> and  others - will have the same structure, with a loop. We can use iterators to avoid this  duplication. The repeated inheritance technique would work, but given the large number  of 
			<class_name>FIGURE</class_name> features the amount of repeated inheritance that would be needed seems  unwieldy. It is also not very desirable to have to change the inheritance structure of the  system just to add a new feature to 
			<class_name>FIGURE</class_name>. The more dynamic approach using iterator  objects seems preferable.
			<line_break></line_break>  To implement this approach, define a class for iterating on complex figures: 
		</paragraph>
		<code_block>
	<keyword>class</keyword>
    		<class_name>COMPLEX_FIGURE_ITERATOR</class_name>

	<keyword>inherit</keyword>
    		<class_name>LINEAR_ITERATOR</class_name>
        		<keyword>redefine</keyword>
            			<feature_name>target</feature_name>
        		<keyword>end</keyword>

	<keyword>create</keyword>
    		<feature_name>set</feature_name>

	<keyword>feature</keyword>

    		<feature_name>target</feature_name><symbol>:</symbol> <class_name>COMPLEX_FIGURE</class_name>

	<keyword>end</keyword> 
		</code_block>
		<paragraph>  Then for each operation to be iterated define a small class. For example:</paragraph>
		<code_block>
	<keyword>class</keyword>
    		<class_name>FIGURE_DISPLAYER</class_name>

	<keyword>inherit</keyword>
    		<class_name>COMPLEX_FIGURE_ITERATOR</class_name>
        		<keyword>redefine</keyword>
            			<feature_name>item_action</feature_name>
        		<keyword>end</keyword>

	<keyword>create</keyword>
    		<feature_name>set</feature_name>

	<keyword>feature</keyword>

    		<feature_name>item_action</feature_name> <symbol>(</symbol>f<symbol>:</symbol> <class_name>FIGURE</class_name><symbol>)</symbol> <keyword>is</keyword>
		            	<comment>-- Action to be applied to each figure: display</comment>
            			<comment>-- it.</comment>
        		<keyword>do</keyword>
            			<feature_name>f</feature_name>.<feature_name>display</feature_name>
       			<keyword>end</keyword>
    	<keyword>end</keyword>
		</code_block>
		<paragraph>  Similarly, you may define 
			<class_name>FIGURE_HIDER</class_name>, 
			<class_name>FIGURE_MOVER</class_name> and others. Then  the features of 
			<class_name>COMPLEX_FIGURE</class_name> are written almost trivially, without any explicit loops; for example:
		</paragraph>
		<code_block>
	<feature_name>display</feature_name> <keyword>is</keyword>
        		<comment>-- Recursively display all components of the complex</comment>
        		<comment>-- figure</comment>
    		<keyword>local</keyword>
        		<feature_name>disp</feature_name><symbol>:</symbol> <class_name>FIGURE_DISPLAYER</class_name>
    		<keyword>do</keyword>
        		<keyword>create</keyword> <feature_name>disp</feature_name>.<feature_name>set</feature_name> <symbol>(</symbol>Current<symbol>)</symbol>
        		<feature_name>disp</feature_name>.<feature_name>do_all</feature_name>
    		<keyword>end</keyword>
		</code_block>
		<paragraph>  and similarly for all the others.
			<line_break></line_break>  Note the use of 
			<feature_name>set</feature_name> as creation procedure, which is more convenient than requiring  the clients first to create an iterator object and then to call 
			<feature_name>set</feature_name>. This is also safer, since  with 
			<feature_name>set</feature_name> as a creation procedure the client cannot forget to initialize the target. (If a class  
			<class_name>C</class_name> has a creation clause, the creation instruction  
			<code>
				<keyword>create</keyword>
			</code>  
			<class_name>C</class_name>.)
		</paragraph>
	</paragraph></document>
