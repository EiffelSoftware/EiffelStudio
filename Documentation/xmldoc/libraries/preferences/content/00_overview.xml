<document title="Overview">
	<meta_data/>
	<paragraph>
		<paragraph>This document gives a brief overview of the preference library.</paragraph>
		<heading>
			<size>2</size>Introduction
		</heading>
		<paragraph>Simply, preferences are name-value pairs.  All preferences are descendents of the deferred class 
			<class_name>PREFERENCE</class_name>, and therefore all inherit the common properties of name, value, default values and string representations.  Common to all 
			<class_name>PREFERENCE</class_name> objects is the notion of `manager'.  All preferences belong to a manager, which is a helper class used for organizational and hierarchical management of your applications preferences.
		</paragraph>
		<paragraph>So, all preferences belong to a 
			<class_name>PREFERENCE_MANAGER</class_name>.  The manager itself belongs to a set of related 
			<class_name>PREFERENCES</class_name>.  Infact, when you create a new manager for a group of preferences you must provide a 
			<class_name>PREFERENCES</class_name> object to the creation routine to indicate which set of preferences the new manager will be associated:
		</paragraph>
		<code_block>make <symbol>(</symbol>a_preferences<symbol>:</symbol> <class_name>PREFERENCES</class_name>; a_namespace<symbol>:</symbol> <class_name>STRING</class_name><symbol>)</symbol> <keyword>is</keyword>
			<comment>-- New manager.</comment>
		<keyword>require</keyword>
			preferences_not_void<symbol>:</symbol> a_preferences /<symbol>=</symbol> Void
			namespace_not_void<symbol>:</symbol> a_namespace /<symbol>=</symbol> Void
			namespace_not_empty<symbol>:</symbol> <keyword>not</keyword> <feature_name>a_namespace</feature_name>.<feature_name>is_empty</feature_name>
		<keyword>ensure</keyword>
			has_preferences<symbol>:</symbol> preferences /<symbol>=</symbol> Void
			inserted_in_preferences<symbol>:</symbol> <feature_name>preferences</feature_name>.<feature_name>has_manager</feature_name> <symbol>(</symbol>namespace<symbol>)</symbol>
			has_namespace<symbol>:</symbol> namespace /<symbol>=</symbol> Void
			namesapce_valid<symbol>:</symbol> <keyword>not</keyword> <feature_name>a_namespace</feature_name>.<feature_name>is_empty</feature_name>
		<keyword>end</keyword>		</code_block>
		<paragraph>You can see in the post-condition 
			<feature_name>inserted_in_preferences</feature_name> that indeed the 
			<class_name>PREFERENCES</class_name> object will have the new manager in its list of managers.
		</paragraph>
		<paragraph>For every group of preferences or configuration values you therefore wish to create for your project, you will need a corresponding 
			<class_name>PREFERENCES</class_name> object.  In general one 
			<class_name>PREFERENCE</class_name> object should be sufficient for most applications, and will be the point of reference for all preference values in the entire application.  This class may be initialized in a number of ways, depending on the specific configuration of your application.  It will be used to create new managers, store default preference values, and handle the saving and retrieval of preference values to and from the underlying data store between sessions.  In between sessions the preference name and value pairs are persisted to an underlying data store.  This may be any imaginable datastore, such as a file, database or external storage device.  Support for XML and the Windows Registry is provided in the library by default, but it would not be be too difficult to provide 
an implementation for your needs (such as SQL database store).
		</paragraph>
	</paragraph></document>
