%|----------------------------------------------------------------
%| EiffelCase: Postscript Module
%| Copyright (C) 1992, 1993, 1994, 1995,
%|   Interactive Software Engineering Inc.
%| All rights reserved. Duplication and distribution prohibited.
%|
%| 270 Storke Road, Suite 7, Goleta, CA 93117 USA
%| Telephone 805-685-1006
%| Fax 805-685-6869
%| Electronic mail <info@eiffel.com>
%| Customer support e-mail <support@eiffel.com>
%|----------------------------------------------------------------

% Fields indexes for class structure

/classname 0 def				% Class's name (string)
/classcircle 1 def			% Is the class persistent (boolean)
/classstar 2 def				% Is the class abstracted (boolean)
/classtriangle 3 def			% Is the class an interface-class (boolean)
% /classsquare 4 def			% Is the class recoverable (boolean)
/classplus 4 def				% Is the class actual (boolean)
/classroot 5 def				% Is the class the root class (boolean)
/classreused 6 def			% Is the class reused (boolean)
/classgeneric 7 def			% Generic parameter (string)
/classx 8 def					% X position of the class's center (numerical)
/classy 9 def					% Y position of the class's center (numerical)
/classwidth 10 def			% Class's width (numerical)
/classheight 11 def			% Class's height (numerical)
/classred 12 def
/classgreen 13 def
/classblue 14 def

% Fields indexes for cluster structure

/clustername 0 def			% Cluster's name (string)
/clusterx 1 def				% X position of the upper-left corner (numerical)
/clustery 2 def				% Y position of the upper-left corner (numerical)
/clusterwidth 3 def			% Cluster's width (numerical)
/clusterheight 4 def			% Cluster's height (numerical)
/clustertagissouth 5 def	% Is cluster's tag in south
/clustertagrelativex 6 def	% Relative horizontal position of tag
/clusterred 7 def
/clustergreen 8 def
/clusterblue 9 def

% Fields indexes for icon structure

/iconname 0 def				% Icon's name (string)
/iconx 1 def					% X position of the upper-left corner (numerical)
/icony 2 def					% Y position of the upper-left corner (numerical)
/iconwidth 3 def				% Icon's width (numerical)

% Fields indexes for link structure
/indlink 0 def
/linkfromtype 0 def		% From entity type (class or cluster)
/linkfrom 1 def			% From entity number (integer)
/linktotype 2 def		% To entity type (class or cluster)
/linkto 3 def			% To entity number (integer)
/linklabel 4 def		% Link's label
/linkhandles 5 def		% Handles in links (array of 2xinteger)
/linkoritype 6 def		% Link's origin symbol type
/linkdestype 7 def		% Link's destination symbol type
/linkshared 8 def	   	% Is there a shared symbol (true or false)
/separatorshared 9 def  	% Is the shared symbol separated (true or false)
/leftsharedval 10 def   	% Normal value for shared notation (-1 means no value)
/rightsharedval 11 def  	% Reverse value for shared notation (-1 means no value)
/linkrevlabel 12 def		% Reverse link's label
/linkmultiple 13 def		% Is there a multiple symbol (true or false)
/separatormultiple 14 def	% Is the multiple symbol separated (true or false)
/leftmultval 15 def		% Normal value for multiple notation (-1 means no value)
/rightmultval 16 def		% Reverse value for multiple notation (-1 means no value)
/leftlabelpos 17 def		% Position of link's label with regard to link's arrow (true or false)
/revleftlabelpos 18 def		% Position of link's label with regard to link's arrow (true or false)
/labelvertical 19 def		% Is the label drawn Vertically ? (true or false)
/labelwords 20 def		% Array of words composing the label, drawn vertically (1 word per line)
/revlabelvertical 21 def	% Is the reverse label drawn Vertically ? (true or false)
/revlabelwords 22 def		% Array of words composing the reverse label, drawn vertically (1 word per line)
/labelposition 23 def		% Label position information
/revlabelposition 24 def	% Reverse label position information
/linkred 25 def
/linkgreen 26 def
/linkblue 27 def 

/typeclass 0 def			% Type class (see below)
/typeicon 1 def			% Type icon (see below)
/typecluster 2 def		% Type cluster (see below)

/typenone 0 def			% No symbol
/typearrow 1 def			% Arrow symbol
/typebracket 2 def		% Bracket symbol

% Graphic constants
/bitmapwidth 5 def			% Bitmaps's width
/bitmapheight 5 def			% Bitmaps's height
/spacebetween 2 def			% Space between items in class
/classvmargin 8 def			% Vertical margin between items and ellipse
/classhmargin 12 def			% Horizontal margin between items and ellipse
/classfont
/Times-BoldItalic def		% Class's items font
/classfontsize 10 def		% Class's items font's size
/roundradius 8 def			% Radius of round corners
/clustermargin 5 def			% Margin around cluster's title
/clusterfont
/Times-Roman def				% Cluster's title font
/clusterfontsize 12 def		% Cluster's title font's size
/iconmargin 5 def				% Margin around icon's title
/iconfont
/Times-Roman def				% Icon's title font
/iconfontsize 12 def			% Icon's title font's size
/iconmarginwidth 5 def		% Icon's width in inches
/iconheight 30 def			% Icon's height in inches
/arrowwidth 6 def		  % Arrow's width
/arrowheight 8 def		 % Arrow's height
/bracketsize 3.5 def			% Bracket's size
/linklabelfont
/Helvetica-Oblique def	 % Link's label font
/linklabelfontsize 8 def   % Link's label font's size
/sharedradius 8 def
/multiplesize 9 def
/linklabelinterline 3 def

% ellipse : x y rad1 rad2 ang1 ang2 ellipse -
% Draw an ellipse centered on x, y, of horizontal radian rad1,
% and vertical radian rad2, beginning at ang1 to ang2.

/ellipsedict 8 dict def
ellipsedict /mtrx matrix put
/ellipse {
	ellipsedict begin
		/endangle exch def
		/startangle exch def
		/yrad exch def
		/xrad exch def
		/y exch def
		/x exch def
		/savematrix mtrx currentmatrix def
		x y translate
		xrad yrad scale
		0 0 1 startangle endangle arc
		savematrix setmatrix
	end
} def

% drawcircle : x y drawcircle -
% Draw a little white circle bitmap with an down-left corner at x, y

/drawcircle {
	0.5 setlinewidth
	newpath exch bitmapwidth 2 div add exch bitmapheight 2 div add
	bitmapwidth 2 div bitmapheight 2 div 0 360 ellipse fill
	1 setlinewidth
} def


% drawstarsegment : x1 y1 dx dy drawstarsegment -
/drawstarsegdict 8 dict def
drawstarsegdict /mtrx matrix put
/drawstarsegment {
	drawstarsegdict begin
		/dy exch def
		/dx exch def
		/y1 exch def
		/x1 exch def

		x1 y1 moveto x1 dx add y1 dy add lineto stroke
		x1 dx add y1 dy add 0.5 0.5 0 360 ellipse fill
	end
} def

% drawstar : x y drawstar -
% Draw a little star bitmap with an down-left corner at x, y

/drawstardict 8 dict def
drawstardict /mtrx matrix put
/drawstar {
	drawstardict begin
	  /cy exch bitmapwidth 2 div add def
	  /cx exch bitmapheight 2 div add def
	  0.25 setlinewidth
	  newpath cx cy moveto
	  cx cy 2 1 drawstarsegment
	  cx cy 0 2 drawstarsegment
	  cx cy -2 1 drawstarsegment
	  cx cy -2 -1 drawstarsegment
	  cx cy 0 -2 drawstarsegment
	  cx cy 2 -1 drawstarsegment
	  1 setlinewidth
	end
} def

% drawtriangle : x y drawtriangle -
% Draw a little black triangle bitmap with an down-left corner at x, y

/drawtriangle {
	newpath moveto
	bitmapwidth 2 div bitmapheight rlineto
	bitmapwidth 2 div bitmapheight neg rlineto
	fill
} def

% drawsquare : x y drawsquare -
% Draw a little black square bitmap with an down-left corner at x, y

/drawsquare {
	newpath moveto
	0 bitmapheight rlineto
	bitmapwidth 0 rlineto
	0 bitmapheight neg rlineto
	fill
} def

% drawplus : x y drawplus -
% Draw a little plus bitmap with an down-left corner at x, y

/drawplus {
	0.5 setlinewidth 2 copy newpath
	bitmapheight 2 div add moveto bitmapwidth 0 rlineto stroke newpath
	exch bitmapwidth 2 div add exch moveto 0 bitmapheight rlineto stroke
	1 setlinewidth
} def

% drawroundrectangle : x y width height drawroundrectangle -
% Draw a rectangle with round corner

/roundrectangledict 4 dict def
/drawroundrectangle {
	roundrectangledict begin
		% retrieve corners' coordinates
		/y2 exch 3 index add def
		/x2 exch 3 index add def
		/y1 exch def
		/x1 exch def

		newpath
		x1 roundradius add y1 moveto
		x2 y1 x2 y2 roundradius arcto 4 {pop} repeat
		x2 y2 x1 y2 roundradius arcto 4 {pop} repeat
		x1 y2 x1 y1 roundradius arcto 4 {pop} repeat
		x1 y1 x2 y1 roundradius arcto 4 {pop} repeat
		closepath stroke
	end
} def

% matrixendoflink: x1 y1 x2 y2 matrixendoflink -
% Translate and rotate the coordinate system to draw an end of link
% (arrow or bracket)

/matrixendoflink {
	% Place the center of coordinates at the final point
	2 copy translate

	% Rotate the coordinates
	2 index 1 index sub 4 index 3 index sub dup 0 eq {
		pop 0 gt {90} {270} ifelse
	} {
		atan
	} ifelse rotate

	% Wipe out the stack
	4 {pop} repeat
} def

% drawarrow : x1 y1 x2 y2 drawarrow -
% Draw an arrow at an extremity of the link

/arrowdict 2 dict def
arrowdict /mtrx matrix put
/drawarrow {
	arrowdict begin

		% Save the matrix
		/savematrix mtrx currentmatrix def

		% Translate and rotate the coordinate system
		matrixendoflink

		% Erase the path
		1 setgray newpath
		newpath 0 1.5 moveto arrowheight 0 rlineto
		0 3 neg rlineto arrowheight neg 0 rlineto fill

		% Draw the arrow
		0 setgray newpath
		newpath 0 0 moveto arrowheight arrowwidth 2 div rlineto
		0 arrowwidth neg rlineto 
		redlink greenlink bluelink setrgbcolor
		fill

		% Retrieve the old matrix
		savematrix setmatrix
	end
} def

% drawbracket : x1 y1 x2 y2 drawbracket -
% Draw an bracket at the end of the link

/bracketdict 2 dict def
bracketdict /mtrx matrix put
/drawbracket {
	bracketdict begin
		% Save the matrix
		/savematrix mtrx currentmatrix def

		% Translate and rotate the coordinate system
		matrixendoflink

		% Draw the bracket
		1 setgray newpath
		bracketsize 2 mul 1 moveto
		bracketsize 1 bracketsize dup 1 add bracketsize arcto 4 {pop} repeat
		bracketsize dup 2 mul 1 add 0 1 index bracketsize arcto
		4 {pop} repeat
		0 bracketsize 2 mul 1 add neg lineto
		bracketsize dup 2 mul 1 add neg
		bracketsize dup 1 add neg bracketsize arcto 4 {pop} repeat
		bracketsize -1 bracketsize 2 mul -1 bracketsize arcto 4 {pop} repeat
		fill

		0 setgray newpath
		bracketsize 2 mul 1 moveto
		bracketsize 1 bracketsize dup 1 add bracketsize -1.5 add arcto 4 {pop} repeat
		bracketsize dup 2 mul 1 add 0 1 index bracketsize -1.5 add arcto
		4 {pop} repeat 
		redlink greenlink bluelink setrgbcolor	
		stroke

		newpath
		bracketsize 2 mul -1 moveto
		bracketsize -1 bracketsize dup 1 add neg bracketsize -1.5 add arcto 4 {pop} repeat
		bracketsize dup 2 mul 1 add neg 0 1 index bracketsize -1.5 add arcto
		4 {pop} repeat 
		redlink greenlink bluelink setrgbcolor
		stroke


		% Retrieve the old matrix
		savematrix setmatrix
	end
} def

% drawlabel : x y xoffset yoffset orientation words vertical
%				onleft label drawlabel
% Draw a label at (x, y) position (default : onleft = false)

/labeldict 12 dict def
/drawlabel {
	labeldict begin
		/label exch def
		/onleft exch def
		/vertical exch def
		/words exch def
		/orientation exch def
		/yoffset exch 3 add def
		/xoffset exch 3 add def
		/y exch def
		/x exch def
		/nbline words length def
		/width
			vertical
			{
				0 words {stringwidth pop 2 copy lt
						{
							exch pop
						}{
							pop
						} ifelse
					} forall
			}{
				label stringwidth pop
			} ifelse
		def
		/height
			vertical
			{
				nbline 1 sub linklabelfontsize linklabelinterline add mul
			}{
				0
			} ifelse
		def
 
		onleft
		{
			x xoffset sub width sub
		}{
			x xoffset add
		} ifelse
 
		orientation 2 eq
		orientation 3 eq or
		orientation 6 eq or
		orientation -1 eq or
		{
			onleft
			{
				y yoffset add height add
			}{
				y yoffset sub linklabelfontsize sub
			} ifelse
		}{
			orientation 4 eq
			orientation 7 eq or
			orientation 8 eq or
			{
				onleft
				{
					y yoffset sub linklabelfontsize sub
				}{
					y yoffset add height add
				} ifelse
			}{
				y yoffset add height add
			} ifelse
		} ifelse
 
		vertical
		{
			words {3 1 roll 2 copy 5 2 roll moveto show
				linklabelfontsize linklabelinterline add sub} forall pop pop
		}{
			moveto label show
		} ifelse
	end
} def


% drawclass : class drawclass -
% Compute items' positions in class and draw them.
% Class is an array with fields indexed by constants of type class???

/classdict 7 dict def
/drawclass {
	classdict begin
		/class exch def					% Class to draw
		/miny 0 def							% Minimum vertical position of items
		/maxy classfontsize def			% Maximum vertical position of items
		/totalsymbnb 0 def				% Number of symbols
		/localwidth 0 def					% Class's width
		/localheight 0 def				% Class's height
		/localyoffset 0 def				% Vertical offset to add to items' position
		/redclass class classred get def
		/greenclass class classgreen get def
		/blueclass class classblue get def

		% Count the number of symbols
		classcircle 1 classplus {
			class exch get {
				/totalsymbnb totalsymbnb 1 add def
			} if
		} for

		% If totalsymbnb > 0, add spacebetween+bitmapheight to maxy
		totalsymbnb 0 gt {
			/maxy maxy spacebetween bitmapheight add add def
		} if

		% If the class is reused, substract spacebetween+1 to miny
		class classreused get {
			/miny 1 spacebetween add neg def
		} if

		% If the class is generic (generic string not empty), substract
		% spacebetween+classfontsize to miny
		class classgeneric get length 0 gt {
			/miny miny spacebetween classfontsize add sub def
		} if

		% Compute localyoffset and localheight according to miny and maxy
		/localyoffset maxy miny add 2 div neg def
		/localheight maxy miny sub classvmargin 2 mul add def

		% Set localwidth to (bitmapwidth+spacebetween)*totalsymbnb
		/localwidth bitmapwidth spacebetween add totalsymbnb mul def

		% Set localwidth to the maximum of localwidth and of class name width
		class classname get stringwidth pop dup localwidth gt {
			dup /localwidth exch def
		} if
		pop

		% Set localwidth to the maximum of localwidth and of
		% generic parameters width
		class classgeneric get dup length 0 gt {
			dup stringwidth pop dup localwidth gt {
				dup /localwidth exch def
			} if
			pop
		} if
		pop

		% Set localwidth to the minimum of localheight*2 and
		% of localwidth+classhmargin*2
		localwidth classhmargin 2 mul add localheight 2 mul lt {
			/localwidth localheight 2 mul def
		} {
			/localwidth localwidth classhmargin 2 mul add def
		} ifelse

		% If the class is the root class, add 8 to the localwidth and localheight
		class classroot get {
			/localwidth localwidth 8 add def
			/localheight localheight 8 add def
		} if

		% Draw the class's ellipse
		newpath class classx get class classy get
		localwidth 2 div localheight 2 div
		0 360 ellipse 
		redclass greenclass blueclass setrgbcolor 
		stroke

		% Draw another ellipse if the class is the root class
		class classroot get {
			newpath class classx get class classy get
			localwidth 2 div 4 sub localheight 2 div 4 sub
			0 360 ellipse stroke
		} if

		% Draw symbols
		class classy get localyoffset add classfontsize spacebetween add add
		class classx get totalsymbnb bitmapwidth spacebetween add mul 2 div sub
		class classcircle get {
			2 copy exch drawcircle
			bitmapwidth spacebetween add add
		} if 
		class classstar get {
			2 copy exch drawstar
			bitmapwidth spacebetween add add
		} if
		class classtriangle get {
			2 copy exch drawtriangle
			bitmapwidth spacebetween add add
		} if
		%class classsquare get {
			%2 copy exch drawsquare
			%bitmapwidth spacebetween add add
		%} if
		class classplus get {
			2 copy exch drawplus
			bitmapwidth spacebetween add add
		} if
		pop pop

		% Draw the class name
		class classname get class classx get 1 index stringwidth pop 2 div sub
		class classy get localyoffset add 2 add moveto show

		% Underline the class name if the class is reused
		class classreused get {
			0.5 setlinewidth newpath
			class classname get class classx get 1 index stringwidth pop 2 div sub
			class classy get localyoffset add 1 spacebetween add sub moveto
			stringwidth pop 0 rlineto stroke 1 setlinewidth
		} if

		% Draw the generic parameters
		class classgeneric get dup length 0 gt {
			dup class classx get 1 index stringwidth pop 2 div sub
			class classy get localyoffset add
			spacebetween classfontsize add sub moveto show
		} if
		pop
		class classwidth localwidth put
		class classheight localheight put
	end
} def

% drawcluster : cluster drawcluster -
% Compute items' positions in cluster and draw them.
% Cluster is an array with fields indexed by constants of type cluster???

/clusterdict 2 dict def
/drawcluster {
	clusterdict begin
		/cluster exch def					% Cluster to draw
		/titlewidth 0 def				% Cluster's title width

		% Compute titlewidth
		/titlewidth cluster clustername get stringwidth pop def

		% Set dash pattern
		[4] 0 setdash

		% Draw the main rectangle
		cluster clusterx get cluster clustery get
		cluster clusterwidth get cluster clusterheight get
		/redcluster cluster clusterred get def  
		/greencluster cluster clustergreen get def  
		/bluecluster cluster clusterblue get def  
		redcluster greencluster bluecluster setrgbcolor 	
		drawroundrectangle

		% Draw the title rectangle
		cluster clusterx get cluster clustertagrelativex get add
		cluster clustery get
		cluster clustertagissouth get {
			clustermargin 2 mul clusterfontsize add sub
		} {
			cluster clusterheight get add
		} ifelse
		titlewidth clustermargin 2 mul add
		clustermargin 2 mul clusterfontsize add
		drawroundrectangle

		% Reset default dash pattern
		[] 0 setdash

		% Draw title
		cluster clusterx get cluster clustertagrelativex get
		clustermargin add add
		cluster clustery get
		cluster clustertagissouth get {
			clustermargin clusterfontsize add sub
		} {
			cluster clusterheight get add clustermargin add
		} ifelse
		moveto
		cluster clustername get show
	end
} def

% drawicon : icon drawicon -
% Compute items' positions in icon and draw them.
% Icon is an array with fields indexed by constants of type icon???

/icondict 2 dict def
/drawicon {
	icondict begin
		/icon exch def						% Icon to draw
		/titlewidth 0 def					% Icon's title width

		% Compute titlewidth
		/titlewidth icon iconname get stringwidth pop def

		% Set dash pattern
		[4] 0 setdash

		% Draw the title rectangle
		icon iconx get iconmarginwidth add
		icon icony get
		titlewidth iconmargin 2 mul add
		iconmargin 2 mul iconfontsize add
		drawroundrectangle

		% Draw the icon rectangle
		icon iconx get
		icon icony get iconheight sub
		iconmarginwidth 2 mul titlewidth iconmargin 2 mul add add
		icon iconwidth 2 index put
		iconheight drawroundrectangle

		% Reset default dash pattern
		[] 0 setdash

		% Draw title
		icon iconx get iconmarginwidth add iconmargin add
		icon icony get iconmargin add
		moveto
		icon iconname get show
	end
} def

% handlefrom : x y index type handlefrom hx hy
% Compute coordinates of handle of entity index of type type to reach (x,y)
/handledict 14 dict def
/handlefrom {
	handledict begin
		/etype exch def
		/indx exch def
		/y exch def
		/x exch def
		/class 0 def
		/cluster 0 def
		/icon 0 def
		/diffx 0 def
		/diffy 0 def
		/redlink 0 def
		/greenlink 0 def
		/bluelink 1 def
 
		etype typeclass eq {

			% Compute if entity is a class
			/class classes indx get def
			/centerx class classx get def
			/centery class classy get def
			/a1 class classheight get 2 div def
			/a2 class classwidth get 2 div def
			/a3 a1 a1 mul x centerx sub dup mul mul
				a2 a2 mul y centery sub dup mul mul add sqrt def
			x centerx sub a1 a2 mul mul a3 div centerx add
			y centery sub a1 a2 mul mul a3 div centery add

		} {
			etype typecluster eq {

				% Compute if entity is a cluster
				/cluster clusters indx get def
				x cluster clusterx get lt {
					cluster clusterx get
					y cluster clustery get lt {
						cluster clustery get
					} {
						y cluster clustery get cluster clusterheight get add gt {
							cluster clustery get cluster clusterheight get add
						} {
							y
						} ifelse
					} ifelse
				} {
					x cluster clusterx get cluster clusterwidth get add gt {
						cluster clusterx get cluster clusterwidth get add
						y cluster clustery get lt {
							cluster clustery get
						} {
							y cluster clustery get cluster clusterheight get add gt {
								cluster clustery get cluster clusterheight get add
							} {
								y
							} ifelse
						} ifelse
					} {
						x
						y cluster clustery get lt {
							cluster clustery get
						} {
							y cluster clustery get cluster clusterheight get add gt {
								cluster clustery get cluster clusterheight get add
							} {
								y
							} ifelse
						} ifelse
					} ifelse
				} ifelse
			} {

				% Compute if entity is an icon
				/icon icons indx get def
				x icon iconx get lt {
					icon iconx get
					y icon icony get iconheight sub lt {
						icon icony get iconheight sub
					} {
						y icon icony get gt {
							icon icony get
						} {
							y
						} ifelse
					} ifelse
				} {
					x icon iconx get icon iconwidth get add gt {
						icon iconx get icon iconwidth get add
						y icon icony get iconheight sub lt {
							icon icony get iconheight sub
						} {
							y icon icony get gt {
								icon icony get
							} {
								y
							} ifelse
						} ifelse
					} {
						x
						y icon icony get iconheight sub lt {
							icon icony get iconheight sub
						} {
							y icon icony get gt {
								icon icony get
							} {
								y
							} ifelse
						} ifelse
					} ifelse
				} ifelse
			} ifelse
		} ifelse
	end
} def

% computelink : link computelink x0 y0 x1 y1 ... xn yn n
% Compute item's position in link and leave coordinates on stack
% Link is an array with fields indexed by constants of type link???

/linkdict 13 dict def
/computelink {
	linkdict begin
		/link exch def
		/x1 0 def
		/y1 0 def
		/x2 0 def
		/y2 0 def
		
	link linkhandles get length 0 eq {


		link linkfrom get link linkto get eq link linktotype get
							link linkfromtype get eq and {
			% Compute the reflexive link

			link linkfromtype get typeclass eq {
				classes link linkfrom get get dup
				classx get /x1 exch def
				classy get /y1 exch def
			} if
			x1 100 sub y1 5 sub link linkfrom get link linkfromtype get handlefrom
			/y1 exch def /x1 exch def
			x1 1 add y1 x1 20 sub y1 x1 20 sub y1 13 add x1 2 add y1 13 add 4
		} {
			% Compute the normal link if there's no handle
			% First pass

			link linkfromtype get typeclass eq {
				classes link linkfrom get get dup
				classx get /x1 exch def
				classy get /y1 exch def
			} {
				link linkfromtype get typecluster eq {
					clusters link linkfrom get get dup
					dup clusterx get exch clusterwidth get 2 div add /x1 exch def
					dup clustery get exch clusterheight get 2 div add /y1 exch def
				} {
					icons link linkfrom get get dup
					dup iconx get exch iconwidth get 2 div add /x1 exch def
					icony get iconheight 2 div sub /y1 exch def
				} ifelse
			} ifelse

			link linktotype get typeclass eq {
				classes link linkto get get dup
				classx get /x2 exch def
				classy get /y2 exch def
			} {
				link linktotype get typecluster eq {
					clusters link linkto get get dup
					dup clusterx get exch clusterwidth get 2 div add /x2 exch def
					dup clustery get exch clusterheight get 2 div add /y2 exch def
				} {
					icons link linkto get get dup
					dup iconx get exch iconwidth get 2 div add /x2 exch def
					icony get iconheight 2 div sub /y2 exch def
				} ifelse
			} ifelse

			% Second pass
			link linkfromtype get link linktotype get ge {
				x2 y2 link linkfrom get link linkfromtype get handlefrom
				/y1 exch def /x1 exch def
				x1 y1 link linkto get link linktotype get handlefrom
				/y2 exch def /x2 exch def
			} {
				x1 y1 link linkto get link linktotype get handlefrom
				/y2 exch def /x2 exch def
				x2 y2 link linkfrom get link linkfromtype get handlefrom
				/y1 exch def /x1 exch def
			} ifelse

			% Push data on stack
			x1 y1 x2 y2 2
		} ifelse
	} {

			% Compute the link if there's one handle at least

			% Compute the start point
			link linkhandles get dup 0 get exch 1 get
			link linkfrom get link linkfromtype get handlefrom
			/y1 exch def
			/x1 exch def

			% Compute the final point
			link linkhandles get dup dup length 2 sub get
			exch dup length 1 sub get
			link linkto get link linktotype get handlefrom
			/y2 exch def
			/x2 exch def

			% Fill stack
			x1 y1
			link linkhandles get aload
			x2 y2
			3 2 roll length 2 idiv 2 add
		} ifelse
	end
} def

% drawinherit : link drawinherit -
% Compute items' positions in inherit link and draw them.
% Inherit is an array with fields indexed by constants of type link???

/drawinherit {
% Bug fix for beta 1.0 dup 0 get 2 eq {dup dup 1 get 1 add 1 exch put} if
% Bug fix for beta 1.0 dup 2 get 2 eq {dup dup 3 get 1 add 3 exch put} if
	% Compute the link
	computelink

	% Draw the link
	dup 2 mul 1 add copy newpath
	3 1 roll moveto 1 sub {lineto} repeat
	stroke

	% Draw the arrow
	4 {4 index} repeat drawarrow

	% Wipe out the stack
	dup 2 mul 1 add {pop} repeat
} def

/drawlink1 {
    /redlink clisups indlink get linkred get def
    /bluelink clisups indlink get linkblue get def
    /greenlink clisups indlink get linkgreen get def
    /indlink indlink 1 add def
    redlink greenlink bluelink setrgbcolor
    drawclisupLine
} def

/drawlink2 {
    /redlink clisups indlink get linkred get def
    /bluelink clisups indlink get linkblue get def
    /greenlink clisups indlink get linkgreen get def
    /indlink indlink 1 add def
    redlink greenlink bluelink setrgbcolor
    drawclisup
} def

/drawlink3 {
	/rredlink linkred -1 sub def 
	/redlink inherits indlink get 24 get def
    /bluelink inherits indlink get 26 get def
    /greenlink inherits indlink get 25 get def
    /indlink indlink 1 add def
    redlink greenlink bluelink setrgbcolor
	drawinherit
} def


% drawclisupLine : link drawclisup -
% Draw line for client/supplier relations.
/drawclisupLine {
	computelink

	newpath
	3 1 roll moveto 1 sub {lineto} repeat
	stroke 
} def

% drawclisup : link drawclisup -
% Compute items' positions in client/supplier link and draw them.
% link is an array with fields indexed by constants of type link???

/drawclisup {
	dup /labelinfo exch labelposition get def
	dup /revlabelinfo exch revlabelposition get def
	% Compute the link
	dup revlabelwords get exch
	dup revlabelvertical get exch
	dup revleftlabelpos get exch
	dup linkrevlabel get exch
	dup labelwords get exch
	dup labelvertical get exch
	dup leftlabelpos get exch
	dup linklabel get exch 
	dup rightmultval get exch
	dup leftmultval get exch
	dup separatormultiple get exch
	dup linkmultiple get exch
	dup rightsharedval get exch
	dup leftsharedval get exch
	dup separatorshared get exch
	dup linkshared get exch
	dup linkdestype get exch 
	dup linkoritype get exch
	computelink

	% Draw the symbol at the origin
	dup 2 mul 1 add index dup typenone ne {
		typearrow eq {
			dup 2 mul 1 add 4 {dup index exch} repeat pop 2 {3 index} repeat
			drawarrow 
			pop pop
		} {
			dup 2 mul 1 add 4 {dup index exch} repeat pop 2 {3 index} repeat
			drawbracket 
			pop pop
		} ifelse
	} {
		pop
	} ifelse

	% Draw the symbol at end
	dup 2 mul 2 add index dup typenone ne {
		typearrow eq {
			4 {4 index} repeat drawarrow
		} {
			4 {4 index} repeat drawbracket
		} ifelse
	} {
		pop
	} ifelse

	% Draw the label
	labelinfo 0 get -1 eq
	{
		% Reflexive link
		2 {6 index} repeat
		labelinfo dup 3 get exch
		dup 4 get exch
		0 get
		5 index 2 mul 20 add 4 {dup index exch} repeat pop drawlabel
	}{
		labelinfo dup 1 get exch
		dup 2 get exch
		dup 3 get exch
		dup 4 get exch
		0 get
		5 index 2 mul 20 add 4 {dup index exch} repeat pop drawlabel
	} ifelse

	% Draw the share symbol
	dup dup 2 mul 8 add index exch 2 mul 8 add 4 {dup index exch} repeat pop {
		% Symbol coordinates: half of last segment
		4 -1 roll
		{
			7 index 6 index eq
			{
				7 index
				7 index 6 index add 2 div sharedradius sub
			}{
				7 index 6 index add 2 div sharedradius add
				7 index
			} ifelse
		}{
			7 index 6 index add 2 div
			7 index 6 index add 2 div
		} ifelse
		2 array astore

		dup newpath
		aload pop sharedradius 0 360 arc
		1 setgray gsave fill grestore 0 setgray stroke
		exch
		{
			dup 0 get exch 1 get 2 {1 index} repeat dup 8 index eq {
				sharedradius sub moveto 0 sharedradius 2 mul rlineto stroke
				2 {1 index} repeat
				moveto 1 index 3 index exch 8 index gt
				{
					sharedradius neg 1.2 add -2
				}{
					1.2 -2
				} ifelse
				rmoveto dup -1 ne
				{
					2 string cvs show
				}{
					pop
				} ifelse

				1 index 4 1 roll moveto pop 4 index gt
				{
					1.2 -2
				}{
					sharedradius neg 1.2 add -2
				} ifelse
				rmoveto dup -1 ne {
					2 string cvs show
				}{
					pop
				} ifelse
			}{
				exch sharedradius sub exch moveto sharedradius 2 mul 0 rlineto stroke
				2 {1 index} repeat
				moveto dup 3 index exch 7 index lt
				{
					-2.5 1.2
				}{
					-2.5 sharedradius neg 1.2 add
				} ifelse
				rmoveto dup -1 ne {
					2 string cvs show
				}{
					pop
				} ifelse

				dup 4 1 roll moveto pop 3 index lt
				{
					-2.5 sharedradius neg 1.2 add
				}{
					-2.5 1.2
				} ifelse
				rmoveto dup -1 ne {
					2 string cvs show
				}{
					pop
				} ifelse
			} ifelse
		}{
			dup 0 get 3 sub exch 1 get 2 sub moveto dup -1 ne {
				2 string cvs show
			}{
				pop
			} ifelse
			pop
		} ifelse
	}{
		4 {pop} repeat
	} ifelse

	% Draw the reverse label
	revlabelinfo 0 get -1 eq
	{
		% Reflexive link
		2 {4 index} repeat
%		dup 2 mul 1 sub 2 {dup index exch} repeat pop
		revlabelinfo dup 3 get exch
		dup 4 get exch
		0 get
		5 index 2 mul 24 add 4 {dup index exch} repeat pop drawlabel
	}{
		revlabelinfo dup 1 get exch
		dup 2 get exch
		dup 3 get exch
		dup 4 get exch
		0 get
		5 index 2 mul 24 add 4 {dup index exch} repeat pop drawlabel
	} ifelse

	% Draw the multiple symbol
	dup dup 2 mul 4 add index exch 2 mul 12 add 4 {dup index exch} repeat pop
	{
		4 {8 index} repeat drawmultiple
	}
	{
		4 {pop} repeat
	} ifelse

	% Wipe out the stack
	2 mul 18 add {pop} repeat
} def %% drawclisup

% drawmultiple : shared rightmultval leftmultval separated x1 y1 x2 y2 drawmultiple -
% draw a lozenge on the segment defined by x1 y1 x2 y2, with contains 
% values leftmultval and rightmultval if separated
% if the link is shared the lozenge is translated by sharedradius * 2

/multipledict 10 dict def
/drawmultiple {
	multipledict begin
		/y2 exch def
		/x2 exch def
		/y1 exch def
		/x1 exch def
		/separated exch def
		/leftmultval exch def
		/rightmultval exch def
		/shared exch def
		/xi x1 x2 add 2 div def
		/yi y1 y2 add 2 div def
		newpath
		x1 x2 eq shared and {/yi yi multiplesize add def } if
		y1 y2 eq shared and {/xi xi multiplesize sub def} if
		xi yi multiplesize add moveto
		multiplesize multiplesize neg rlineto multiplesize neg multiplesize neg rlineto
		multiplesize neg multiplesize rlineto closepath
		1 setgray gsave fill grestore 0 setgray stroke
		separated
		{
			x1 x2 eq
			{
				xi multiplesize sub yi moveto multiplesize 2 mul 0 rlineto stroke
				xi 3 sub yi 1.2 add moveto
				y2 y1 gt {leftmultval} {rightmultval} ifelse dup -1 ne {2 string cvs show} if
				xi 3 sub yi multiplesize sub 1.8 add moveto
				y2 y1 gt {rightmultval} {leftmultval} ifelse dup -1 ne {2 string cvs show} if
			}{
				xi yi multiplesize sub moveto 0 multiplesize 2 mul rlineto stroke
				xi multiplesize sub 2.3 add yi 3 sub moveto
				x2 x1 lt {leftmultval} {rightmultval} ifelse dup -1 ne {2 string cvs show} if
				xi 1 add yi 3 sub moveto
				x2 x1 lt {rightmultval} {leftmultval} ifelse dup -1 ne {2 string cvs show} if
			} ifelse
		}{
			xi 3 sub yi 2 sub moveto leftmultval dup -1 ne
			{
				2 string cvs show
			} if
		} ifelse
	end
} def %% drawmultiple

% Principal program
% Draw classes
classfont findfont classfontsize scalefont setfont
1 setlinewidth 
classes {drawclass} forall

% Draw clusters
clusterfont findfont clusterfontsize scalefont setfont
1 setlinewidth 0 setgray clusters {drawcluster} forall

% Draw icons
iconfont findfont iconfontsize scalefont setfont
1 setlinewidth 0 setgray icons {drawicon} forall

linklabelfont findfont linklabelfontsize scalefont setfont

% Draw inherit links
1 setlinewidth 0 setgray inherits {drawlink3} forall
/indlink 0 def

% Draw thick black line for client/supplier links
3 setlinewidth 0 setgray clisups {drawlink1} forall
/indlink 0 def

% Draw middle white line for client/supplier links
1 setlinewidth 1 setgray clisups {drawlink1} forall
/indlink 0 def

% Draw client/supplier links
1 setlinewidth 0 setgray clisups {drawlink2} forall

showpage
