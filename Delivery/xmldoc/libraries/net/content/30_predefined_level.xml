<document output="studio" title="The predefined level">
	<meta_data/>
	<paragraph>
		<paragraph>Many client-server applications follow a standard scheme that relies    on the facilities outlined so far. When your application conforms to    this scheme, you can avoid most of the work by relying on the client and    server classes of the predefined level. There is no need to consider    sockets explicitly or to worry about synchronization.</paragraph>
		<paragraph>As in many other cases found in the ISE Eiffel 5 libraries, the    object-oriented method makes it possible here to encapsulate the    standard pattern found in most usual cases.</paragraph>
		<heading>
			<size>3</size>The predefined client and server classes
		</heading>
		<paragraph>The classes of the predefined level, which only support stream    communication (not datagrams), are 
			<link>
				<url>../reference/abstract/client_server/client_chart.xml</url>
				<label>CLIENT</label>
			</link>,    
			<link>
				<url>../reference/abstract/client_server/server_chart.xml</url>
				<label>SERVER</label>
			</link>,    and their descendants 
			<link>
				<url>../reference/local/client_server/unix_client_chart.xml</url>
				<label>UNIX_CLIENT</label>
			</link>,    
			<link>
				<url>../reference/local/client_server/unix_server_chart.xml</url>
				<label>UNIX_SERVER</label>
			</link>,    
			<link>
				<url>../reference/network/client_server/network_client_chart.xml</url>
				<label>NETWORK_CLIENT</label>
			</link>    and 
			<link>
				<url>../reference/network/client_server/network_server_chart.xml</url>
				<label>NETWORK_SERVER</label>
			</link>.    All the architecture of a client-server application is already available    through these classes. All you have to do is to specify the address you    want to use, what you want to send, when you want to send it, and what    you want to do when you receive data. The rest will be taken care of    automatically.
		</paragraph>
		<paragraph>The UNIX_
			<italic/>classes are meant for systems running on the same    machine, using 
			<link>
				<url>../reference/local/socket/unix_stream_socket_chart.xml</url>
				<label>UNIX_STREAM_SOCKET</label>
			</link>;    the NETWORK_
			<italic/>classes support inter-machine communication, using 
			<link>
				<url>../reference/network/socket/network_socket_chart.xml</url>
				<label>NETWORK_SOCKET</label>
			</link>.
		</paragraph>
		<heading>
			<size>3</size>Using the client classes
		</heading>
		<paragraph>When you want to write an application, your client should inherit    from 
			<link>
				<url>../reference/local/client_server/unix_client_chart.xml</url>
				<label>UNIX_CLIENT</label>
			</link>    for example, and in your creation procedure, you have to setup your    address, and then call the inherited make routine, with your address as    an argument. You are then provided with some send and receive routines.
		</paragraph>
		<heading>
			<size>3</size>Using the server classes
		</heading>
		<paragraph>For the server, you inherit for example from 
			<link>
				<url>../reference/local/client_server/unix_server_chart.xml</url>
				<label>UNIX_SERVER</label>
			</link>.    In the same way as for the client, you set up your address in the    creation procedure, and then call the 
			<italic>make</italic> creation procedure    inherited from 
			<link>
				<url>../reference/local/client_server/unix_server_chart.xml</url>
				<label>UNIX_SERVER</label>
			</link>.    After that your creation procedure should call 
			<italic>execute</italic>, which is    inherited from 
			<link>
				<url>../reference/abstract/client_server/server_chart.xml</url>
				<label>SERVER</label>
			</link>,    and provides you with a loop calling 
			<italic>receive</italic>, 
			<italic>process_message</italic>,    
			<italic>respond</italic> and 
			<italic>clean_up</italic>. Then, you should redefine these    routines to do what you want your server to do.
		</paragraph>
	</paragraph></document>
