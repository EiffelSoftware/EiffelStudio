<?xml version="1.0"?>
<document output="envision" title="Precompiled Libraries">
  <meta_data>
    <help>
      <toc>
        <envision_title>Precompiled Libraries</envision_title>
        <envision_pseudo_name>50</envision_pseudo_name>
      </toc>
      <xml>
        <xmlkeyword>
          <index>K</index>
          <term>Precompiled Libraries</term>
        </xmlkeyword>
        <xmlkeyword>
          <index>K</index>
          <term>References, Precompiled Libraries</term>
        </xmlkeyword>
        <xmlkeyword>
          <index>K</index>
          <term>Projects, Precompiled Libraries</term>
        </xmlkeyword>
      </xml>
    </help>
  </meta_data>
  <paragraph>
    <paragraph>
			EiffelEnvision projects cannot reference other EiffelEnvision projects using the <link><url>ms-help//MS.VSCC.2003/MS.MSDNQTR.2003FEB.1033/vsintro7/html/urfAddReferenceDialogBox.htm</url><label>Project</label></link> tab of the <link><url>ms-help//MS.VSCC.2003/MS.MSDNQTR.2003FEB.1033/vsintro7/html/vxurfComponentSelectorDialogBoxS.htm</url><label>Component Selector Dialog Box</label></link>, as you would be able to do when referencing, say EiffelEnvision projects from Visual C# or vice-versa.
		</paragraph>
    <paragraph>
			The mode of reuse in EiffelEnvision is through <bold>Precompiled Libraries</bold>. This mode of binary reuse, as opposed to referencing assemblies directly, overcomes some of the limitations imposed by the .NET Framework and the <bold>Common Language Runtime</bold> (<bold>CLR</bold>). Precompiled libraries permit ongoing support for many of the features elided from other languages, some of which are mentioned later in this document.
		</paragraph>
    <anchor>overcoming_limitations</anchor>
    <heading>
      <size>2</size>
      <content>Overcoming the Limitations of the CLR</content>
    </heading>
    <paragraph>
			The <link><url>../../../../eiffel_for_dotnet/index.xml</url><label>Eiffel for .NET</label></link> language compiler is complex compared to that of the Visual C#, Visual Basic .NET and many other compilers. Both the Eiffel Language and the <link><url>../../../../eiffel_for_dotnet/index.xml</url><label>Eiffel for .NET</label></link>  compiler support many concepts and language attributes that are not natively supported by the .NET framework; features such as <link><url>../../../../../../technologies/dotnet/eiffel_dotnet_language/20_language/30_inheritance.xml</url><label>Multiple Inheritance</label></link> and <link><url>../../../../../../technologies/dotnet/eiffel_dotnet_language/20_language/40_genericity.xml</url><label>Generics</label></link>. To adapt to the underlying CLR, the <link><url>../../../../eiffel_for_dotnet/index.xml</url><label>Eiffel for .NET</label></link>  compiler generates code which will not directly reflect the code class for class, often generating additional classes or varying the class name to appease the CLR. As a consequence the assemblies generated by the <link><url>../../../../eiffel_for_dotnet/index.xml</url><label>Eiffel for .NET</label></link>  compiler in EiffelEnvision cannot be referenced directly from other EiffelEnvision projects.
		</paragraph>
    <paragraph>
			As a means of demonstrating of one of the more basic issues concerning Generics regarding this adaptation, imagine the following Eiffel class declaration in an EiffelEnvision project.
		</paragraph>
    <code_block>
      <keyword>class</keyword>
      <class_name>GENERIC_CLASS</class_name>
      <symbol>[</symbol>
      <generics>G</generics>
      <symbol>-&gt;</symbol>
      <class_name>ANY</class_name>
      <symbol>]</symbol>
      <keyword>inherit</keyword>
      <class_name>ARRAY</class_name>
      <symbol>[</symbol>
      <generics>G</generics>
      <symbol>]</symbol>
      <keyword>redefine</keyword>
      <feature_name>make</feature_name>
      <keyword>end</keyword>
      <keyword>create</keyword>
      <feature_name>make</feature_name>
      <keyword>feature</keyword>
      <symbol>{</symbol>NONE<symbol>}</symbol><comment>-- Initialization</comment><feature_name>make</feature_name><symbol>(</symbol><local_variable>n</local_variable><symbol>:</symbol><class_name>INTEGER</class_name><symbol>)</symbol><keyword>is</keyword><comment>-- Initialize instance.</comment><keyword>do</keyword><keyword>Precursor</keyword><symbol>{</symbol><class_name>ARRAY</class_name><symbol>}</symbol><symbol>(</symbol><local_variable>n</local_variable><symbol>)</symbol><comment>-- Other initialization logic</comment><keyword>end</keyword><keyword>end</keyword><comment>-- GENERIC_CLASS</comment></code_block>
    <paragraph>
			The .NET Framework and the CLR do not currently support <link><url>../../../../../../technologies/dotnet/eiffel_dotnet_language/20_language/40_genericity.xml</url><label>Generics</label></link>, but in the example two generic classes are specified; the <class_name>GENERIC_CLASS</class_name> is declared as with formal generic parameter, making it a Generic class, and ARRAY, a generic class from EiffelBase is being inherited.
		</paragraph>
    <paragraph>
			To resolve this non-supportive issue, the <link><url>../../../../eiffel_for_dotnet/index.xml</url><label>Eiffel for .NET</label></link>  compiler will subsequently generate a <class_name>GENERIC_CLASS</class_name><italic>_X</italic> where the _X suffix is the name of the actual generic parameter specified when making use of the GENERIC_CLASS class. This means <class_name>GENERIC_CLASS</class_name> [<class_name>INTEGER</class_name>] would yield <class_name>GENERIC_CLASS</class_name><italic>_INTEGER</italic>.
		</paragraph>
    <paragraph>
			The problem with referencing the assembly with the type <class_name>GENERIC_CLASS</class_name><italic>_X</italic> is that <class_name>GENERIC_CLASS</class_name><italic>_X</italic> is no longer a generic class stunting <class_name>GENERIC_CLASS</class_name>'s original usage intention. This will become an issue when facets of future projects require the original genericity of <class_name>GENERIC_CLASS</class_name>. 
		</paragraph>
    <paragraph>
			Dealing with the issue of <link><url>../../../../../../technologies/dotnet/eiffel_dotnet_language/20_language/30_inheritance.xml</url><label>Multiple Inheritance</label></link> in a single implementation inheritance framework is far more complex than the issue with generics. This will not be discussed in this documentation.
		</paragraph>
    <anchor>precompiled_solution</anchor>
    <heading>
      <size>2</size>
      <content>Precompiled Library Solution</content>
    </heading>
    <paragraph>
			The answer to the problem of assembly reuse when you want to use an EiffelEnvision project from another EiffelEnvision project is to use precompiled libraries. Precompiled libraries are similar to class library projects, but the <link><url>../../../../eiffel_for_dotnet/index.xml</url><label>Eiffel for .NET</label></link>  compiler generates extra compilation information so two projects can be "merged." At first it may seem like the contents of a precompiled library will end up in a referencing project's, but this is not the case. The <link><url>../../../../eiffel_for_dotnet/index.xml</url><label>Eiffel for .NET</label></link>  compiler will only put the contents of the project in a generated assembly, and that assembly in turn will reference the precompiled library's assembly, just in the way <italic>System.dll</italic> references <italic>mscorlib.dll</italic>, in <italic>System.dll</italic>'s assembly manifest.
		</paragraph>
    <anchor>referencing_precompiled_libraries</anchor>
    <heading>
      <size>2</size>
      <content>Precompiled Library Solution</content>
    </heading>
    <paragraph>
			Only one precompiled library can be referenced per project. This means that if you want to reference multiple precompiled libraries, you must build each in an incremental fashion and then reference the top most precompiled library in your project. 
		</paragraph>
    <paragraph>
			Precompiled libraries can be specified by selecting the folder containing the precompiled library compiler information. This folder will always contain a <italic>precomp.epr</italic> (Eiffel Project file). In EiffelEnvision, the location of the precomp.epr will always be in a precompiled library's <bold>ProjectName</bold>\<bold>obj</bold>\<bold>ConfigurationName</bold> folder. To specify a precompiled library, use the <link><url>../project_configuration/precompiled.xml</url><label>Precompiled Library Properties</label></link>.
		</paragraph>
    <anchor>no_using_precompiled_libraries</anchor>
    <heading>
      <size>2</size>
      <content>Not Using Precompiled Libraries</content>
    </heading>
    <paragraph>
			Using precompiled libraries is not essential by any means. Eiffel's principle reuse has always been on source code reuse, hence the notion of <link><url>../../../../../../technologies/dotnet/eiffel_dotnet_language/10_conventions/10_terminology.xml</url><label>clusters</label></link>, which reference other "libraries" of code. The use of precompiled libraries, however, will make initial code compilations faster, reducing debug startup times and creating much smaller assemblies for the projects that use them.
		</paragraph>
    <anchor>optimizing</anchor>
    <heading>
      <size>2</size>
      <content>Optimizing</content>
    </heading>
    <paragraph>
			Precompiled libraries can be optimized. When choosing to <link><url>../project_configuration/build.xml</url><anchor_name>optimize_code</anchor_name><label>Optimize Code</label></link> for the precompiled library, a <bold>debug</bold> version and an optimized version of the precompiled library assembly will be generated. Projects using the precompiled library can specify to Use Optimized Precompile in the Precompiled Library Properties. When set to <bold>Yes</bold> the <bold>debug</bold> version will be used in referencing project configurations with <link><url>../project_configuration/build.xml</url><anchor_name>optimize_code</anchor_name><label>Optimize Code</label></link> set to <bold>No</bold> and the optimized version will be used when <bold>Yes</bold> is selected.
			<tip><bold>Recommended</bold>: It recommended that you always create precompiled libraries with the <link><url>../project_configuration/build.xml</url><anchor_name>optimize_cpde</anchor_name><label>Optimize Code</label></link> set to <bold>Yes</bold> in all <link><url>ms-help//MS.VSCC.2003/MS.MSDNQTR.2003FEB.1033/vsintro7/html/vxconBuildConfigurations.htm</url><label>Build Configurations</label></link>.
			</tip></paragraph>
    <anchor>creating_precompiled_projects</anchor>
    <heading>
      <size>2</size>
      <content>Creating New Precompiled Projects</content>
    </heading>
    <paragraph>
			EiffelEnvision has a new project template for precompiled libraries. The new project is called Eiffel Class Library Project.
			<tip><bold>Recommended</bold>: Due to the nature of precompiled libraries, when modified, projects will cause a Rebuild to be performed instead of a standard Build, regardless of selecting Build. EiffelEnvision projects are compiled on an as-needed basis, so it is recommended that you only use Eiffel Class Library Projects for projects that do not change often.
			</tip></paragraph>
    <anchor>also_see</anchor>
    <heading>
      <size>2</size>
      <content>Related Sections</content>
    </heading>
    <seealso>
      <bold>See Also:</bold>
      <line_break />
      <link>
        <url>../index.xml</url>
        <label>Configuring Projects</label>
      </link>
      <line_break />
      <link>
        <url>../../structure/references/index.xml</url>
        <label>Project References</label>
      </link>
      <line_break />
      <link>
        <url>../project_configuration/precompiled.xml</url>
        <label>Precompiled Library Properties</label>
      </link>
      <line_break />
      <link>
        <url>../../structure/known_folders.xml</url>
        <label>Known Folders</label>
      </link>
    </seealso>
  </paragraph>
</document>
