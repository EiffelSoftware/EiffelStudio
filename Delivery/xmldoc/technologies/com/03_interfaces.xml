<document title="COM Interfaces" output="studio">
	<meta_data/>
	<paragraph><paragraph>Interfaces are at the heart of any COM component. Interfaces are described in the definition file of a component. They consist of a group of semantically related functions that can be accessed by the clients of the component. Although they are a specification, they also have a physical representation. A client can request a pointer on an interface and access the component functions through that pointer. Interfaces are the only possible way to access functions from a component. They enforce information hiding by providing only the public functions to the client.</paragraph>
		<paragraph>Interfaces also define the type of a component. Each interface corresponds to a specific view of the component. It can be compared to polymorphism in the Object Oriented world. Whenever an interface from a component is requested, only the functions defined on that interface are accessible as if the component was polymorphically cast into an object of the type of that interface. </paragraph>
		<paragraph>The COM specification requires that any interface provides access to all interfaces on the same component. All interfaces should include a specific function called <bold>QueryInterface</bold> that will provide a pointer on any other interface of the component. Interfaces are identified with a globally unique identifier (GUID) guaranteed to be unique in time and space. Since this function has to be on every interface, it has been abstracted into a specific interface called <bold>IUnknown</bold> which all other interfaces must inherit from. </paragraph>
		<paragraph>The two other functions exposed by <bold>IUnknown</bold> are <bold>AddRef</bold> and <bold>Release</bold>. These functions should be called respectively when a client gets a reference on an interface or when it discards that reference. These two functions define the lifetime of the component: each interface keeps track of clients keeping a reference on them and when no clients have references anymore, the component can be unloaded from memory. You might start worrying thinking that this business of reference counting will imply lots of headaches, memory leaks, etc. and you would be right should you choose a low-level language to implement your components. Fortunately, you will never have to implement or use these functions in Eiffel: all the processing related to IUnknown is provided by the EiffelCOM runtime. Calls to <bold>QueryInterface</bold> are done "behind the scene" and only when needed. The lifetime of the component is also taken care of by the EiffelCOM runtime. </paragraph>
		<seealso>
			<bold>See Also</bold>
			<line_break/>
			<link>
				<url>../../tools/wizards/com/index.xml</url>
				<label>EiffelCOM wizard</label>
			</link>
			<line_break/>
			<link>
				<url>../../libraries/com/index.xml</url>
				<label> EiffelCOM library</label>
			</link>
			<line_break/>
			<link>
				<url>01_introduction.xml</url>
				<label> Introduction</label>
			</link>
			<line_break/>
			<link>
				<url>02_generalities.xml</url>
				<label>Generalities</label>
			</link>
			<line_break/>
			<link>
				<url>04_coclass.xml</url>
				<label> Coclasses</label>
			</link>
			<line_break/>
			<link>
				<url>05_component_location.xml</url>
				<label> Component Location</label>
			</link>
			<line_break/>
			<link>
				<url>06_access_type.xml</url>
				<label> Access Type</label>
			</link>
			<line_break/>
			<link>
				<url>07_deeper_into_com.xml</url>
				<label> Deeper into COM</label>
			</link>
		</seealso>
	</paragraph></document>
