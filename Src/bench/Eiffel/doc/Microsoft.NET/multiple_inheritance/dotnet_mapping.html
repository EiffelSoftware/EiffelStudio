<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Multiple inheritance mapping to</title>
<link rel="stylesheet" type="text/css" href="../default.css">
</head>

<body bgcolor="#FEFFE3">

<h1>Multiple inheritance mapping to .NET</h1>

<h2>Goals</h2>
<p>Our goal is to generate a mapping that is both:</p>
<ol>
  <li>Efficient</li>
  <li>CLS compliant</li>
</ol>
<p>Efficiency is always important for a compiler, no one wants their code to run
slowly because the compiler did a very bad job at generating the code. Here
efficiency means to generate as few as possible interfaces to map the Eiffel
classes.</p>
<p>CLS compliant is very important for people who choose Eiffel as a programming
language (mostly because of its benefits: assertions, genericity,...) and who want to produce reusable components.</p>
<h2>General description</h2>
<p>Basically, we will promote classes that are multiply-inherited into .NET
interfaces. To give an example if in Eiffel you have:</p>
<pre>class
	C
inherit
	A
	B
end</pre>
<p>then in .NET you might have the following set of classes and interfaces:</p>
<pre>class A implements IA
class B implements IB
class C implements IA and IB

interface IA
interface IB</pre>
<p>This is one way of seeing it, but we could generate it in many different
ways. It is important that:</p>

<ul>
  <li>the Eiffel for .NET compiler through the Assembly
Manager can re-read the metadata
to go back to the original form</li>
  <li>other languages can understand the
metadata.</li>
</ul>

<p>Because of the last point, we decided that we would indeed generate the
following set of classes and interfaces:</p>
<pre>class A_IMP implements A
class B_IMP implements B
class C_IMP implements A and B and inherits A_IMP

interface B
interface C</pre>

<p class="note"><b>Note:<br>
</b>Class C_IMP inherits most of its implementation from A_IMP. This is done to
avoid code duplication.</p>

<p>So if in Eiffel you have the following piece of code:</p>

<pre>b: B
c: C

create c
b := c</pre>

<p>It will translate in C# as:</p>

<pre>B b;
C c;

/* Method 1 */
c = new C_IMP();
b = c;

/* Method 2 */
c = EiffelFactory.new_C();
b = c;</pre>

<p class="note"><b>Note:<br>
</b>Creation is performed in two different ways. One through the use of a .NET
constructor, and the second one through a factory call. Both will be implemented
in case there is no way to use the .NET constructor mechanism, but we will try
to stick as much as possible on the use of .NET constructor.</p>

<h2>
A real example</h2>

<p>
Let's suppose we have the following example. In which we do most of what can be
seen in an Eiffel library that uses multiple inheritance.
<pre>class
	A
feature
	f is do ... end
	g (x: X) is do ... end
end</pre>
<pre>class B
inherit
	A
		rename f as h
		redefine g
		end
feature
	g (y: Y) is do ... end
end</pre>
<pre>class C
inherit
	A
end</pre>
<pre>class
	D
inherit
	B
		select
			g
		end
	C
		rename
			g as A_g
		select
			f
		end
end</pre>
<pre>deferred class F
feature
	f is
		do
		end
end</pre>
<pre>class E
inherit
	C
		undefine f end
	F
end</pre>
<pre>class X
end</pre>
<pre>class Y
inherit X
end</pre>
<p>This is better described by the following BON diagram:<p align="center"><img border="0" src="diamond_inheritance.png" width="484" height="216"><p>Let's
have a look at what we should generate as an inheritance hierarchy:<p align="center"><img border="0" src="diamond_inheritance_on_dotnet.png" width="661" height="476">
<p>The hierarchy is quite complex, but it is required to export the Eiffel
multiple inheritance to other languages. So far not other simple solutions have
been found, apart from implemented natively multiple inheritance on .NET.</p>
</body>

</html>
