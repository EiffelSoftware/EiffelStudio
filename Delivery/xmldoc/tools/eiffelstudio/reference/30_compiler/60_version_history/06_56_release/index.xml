<document title="Major changes between ISE Eiffel 5.5 and ISE Eiffel 5.6">
	<meta_data>
		<help>
			<toc>
				<envision_location>EiffelEnvision\Introduction to EiffelEnvision\History and Known Issues\Compiler History</envision_location>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<heading>
			<size>2</size>What's new
		</heading>
		<seealso>See also: <link><label>Differences between standard ECMA-367 and Eiffel Software implementation</label><url>../../10_ise_eiffel_specific/ecma.xml</url></link></seealso>
		<list ordered="false">
			<item>Implemented once manifest strings. They can be used at the same places where normal manifest strings can be used, e.g.:
				<code_block><local_variable>s</local_variable> <symbol>:=</symbol> <keyword>once</keyword> <string>"abc"</string>
<feature_name>io</feature_name>.<feature_name>put_string</feature_name> (<keyword>once</keyword> <string>"Hello World!"</string>)</code_block>
				Once manifest strings are not created every time they are accessed. Instead one instance is created at the first access and then it is reused for subsequent accesses. In multithreaded application one instance is created for one thread.</item>
			<item>Supported aligned and non-aligned verbatim strings. Aligned verbatim strings use characters <code><character>[</character></code> and <code><character>]</character></code> in opening and closing sequence respectively, non-aligned verbatim strings use <code><character>{</character></code> and <code><character>}</character></code>.</item>
			<item>Added support for manifest type expression "{<class_name>MY_TYPE</class_name>}" which gives an instance of <feature_name>TYPE</feature_name> [<feature_name>MY_TYPE</feature_name>].</item>
			<item>New syntax for manifest constants. Now they can be preceeded by a manifest type expression. For example <number>1</number> is of type <class_name>INTEGER</class_name>, whereas {<class_name>INTEGER_8</class_name>} 1 is of type <class_name>INTEGER_8</class_name>.</item>
			<item>Support for <class_name>NATURAL_XX</class_name> types which are unsigned integers.</item>
			<item>Supported new feature alias syntax to specify operator and bracket names:
				<code_block><feature_name>negate</feature_name> <keyword>alias</keyword> <string>"-"</string>: <keyword>like</keyword> <keyword>Current</keyword> ...
<feature_name>multiply</feature_name> <keyword>alias</keyword> <string>"*"</string> (<local_variable>other</local_variable>: <keyword>like</keyword> <keyword>Current</keyword>): <keyword>like</keyword> <keyword>Current</keyword> ...
<feature_name>item</feature_name> <keyword>alias</keyword> <string>"[]"</string> (<local_variable>index</local_variable>: <class_name>INTEGER</class_name>): <generics>G</generics> ...</code_block>
				The first two declarations can be used similar to features <code><keyword>prefix</keyword> <string>"-"</string></code> and <code><keyword>infix</keyword> <string>"*"</string></code>. The last one can be used to make feature calls with bracket expressions like
				<code_block><local_variable>letter</local_variable> <symbol> :=</symbol> <local_variable>letters</local_variable> <symbol>[</symbol><local_variable>i</local_variable><symbol>]</symbol></code_block>
				Operator and bracket aliases can also be used in <keyword>rename</keyword> subclause to change an alias name associated with a feature.
			</item>
			<item>Supported new feature assigner syntax to associate feature with an assigner command:
				<code_block><feature_name>item</feature_name> <symbol> <keyword>alias</keyword> <string>"[]"</string> (</symbol><local_variable>index</local_variable><symbol>:</symbol> <class_name>INTEGER</class_name><symbol>):</symbol> <generics>G</generics> <keyword>assign</keyword> <feature_name>put</feature_name> ...
<feature_name>put</feature_name> <symbol>(</symbol><local_variable>value</local_variable><symbol>:</symbol> <generics>G</generics><symbol>;</symbol> <local_variable>index</local_variable><symbol>:</symbol> <class_name>INTEGER</class_name><symbol>)</symbol> ...</code_block>
				Given the declaration above the following instructions become equivalent:
				<code_block><local_variable>x</local_variable><symbol>.</symbol><feature_name>put</feature_name> <symbol>(</symbol><local_variable>x</local_variable><symbol>.</symbol><feature_name>item</feature_name> <symbol>(</symbol><local_variable>i</local_variable><symbol> <symbol>+</symbol> <number>1</number>)</symbol><symbol>,</symbol> <local_variable>i</local_variable><symbol>)</symbol>
<local_variable>x</local_variable><symbol>.</symbol><feature_name>item</feature_name> <symbol>(</symbol><local_variable>i</local_variable><symbol>)</symbol> <symbol>:=</symbol> <local_variable>x</local_variable><symbol>.</symbol><feature_name>item</feature_name> <symbol>(</symbol><local_variable>i</local_variable><symbol> <symbol>+</symbol> <number>1</number>)</symbol>
<local_variable>x</local_variable> <symbol>[</symbol><local_variable>i</local_variable><symbol>]</symbol> <symbol>:=</symbol> <local_variable>x</local_variable> <symbol>[</symbol><local_variable>i</local_variable> <symbol>+</symbol> <number>1</number><symbol>]</symbol></code_block>
			</item>
		</list>
		<heading><size>2</size>Improvements</heading>
		<list ordered="false">
			<item>Optimized .NET code generated for <keyword>inspect</keyword> instruction.</item>
			<item>Optimized access to process-relative once routines to avoid heavy-weight synchronization primitives when possible.</item>
			<item>Speed-up access to once routines in finalized multi-threaded applications.</item>
			<item>Improved some error messages to be more precise.</item>
			<item>Removed the requirement to freeze code that declares process-relative once routine.</item>
			<item>Improved multi-threaded application performance in classic mode by using built-in support for thread-local storage provided by some <italic>C</italic> compilers.</item>
			<item>Allowed underscores in hexadecimal literals.</item>
			<item>Provided syntax highlighting for hexadecimal literals in editor.</item>
			<item>Slightly improved reporting of syntax errors.</item>
			<item>Made keyword operator names clickable in flat view.</item>
		</list>
		<heading>
			<size>2</size>Changes
		</heading>
		<list ordered="false">
			<item>Void does not conform to expanded types. As a consequence, assignments of Void to expanded entities will be rejected rather than throwing an exception at run-time. And comparison of expanded entities to Void will cause a <compiler_error>VWEQ</compiler_error> validity error.</item>
			<item>Changed default behavior of once routines in .NET  mode from once-per-process to once-per-thread to match behavior in classic mode.</item>
			<item>Provided project options (<code>old_verbatim_strings</code> and <code>old_verbatim_strings_warning</code>) to support semantics of verbatim strings as in previous versions when they were not left-aligned.</item>
			<item>Changed processing of hexadecimal integer literals to be consistent for different integer types. For example, <number>0xFF</number> gives <number>255</number> when assigned to a variable of type <class_name>INTEGER</class_name> rather than <number>-1</number> as before.</item>
			<item>Due to the new {} syntax, a few older syntax constructs have been removed:
				<list ordered="false">
					<item>"{<class_name>X</class_name>} <keyword>Precursor</keyword> (..)" is rejected and should be replaced by "<keyword>Precursor</keyword> {<class_name>X</class_name>} (...)".</item>
					<item>"<keyword>agent</keyword> <feature_name>f</feature_name> (?, {<class_name>A</class_name>})" is now rejected, as it would conflict with a manifest type expression, instead you should write "<keyword>agent</keyword> <feature_name>f </feature_name>(?, {<class_name>A</class_name>} ?)".</item>
				</list>
			</item>
			<item>In .NET, all usage of <class_name>INTEGER_8</class_name> from .NET libraries have been changed to <class_name>NATURAL_8</class_name>.</item>
			<item>In .NET, renamed <class_name>TYPE</class_name>, <class_name>ATTRIBUTE_</class_name> and <class_name>VOID_</class_name> from the mscorlib assembly into <class_name>SYSTEM_TYPE</class_name>, <class_name>SYSTEM_ATTRIBUTE</class_name> and <class_name>SYSTEM_VOID</class_name>.</item>
			<item>Changed exception handling for once routines so that exception raised during the first call is raised during any subsequent call to this routine.</item>
			<item>Introduced upper limit for value of integer constant used in <code><class_name>BIT</class_name></code> type declaration and extended <code><compiler_error>VTBT</compiler_error></code> rule to cover this change.</item>
			<item>To evaluate the type of a manifest array we now use the first item of the manifest array instead of the last one as a first guessed type.</item>
			<item>Allowed for integer literals with intermediate underscores at arbitrary positions.</item>
			<item>To ensure same behavior on various platforms, the standard output is now unbuffered (it previously was unbuffered on Windows and line buffered on Unix platforms).</item>
		</list>
		<heading>
			<size>2</size>Bug fixes
		</heading>
		<heading>
			<size>3</size>Language issues
		</heading>
		<list ordered="false">
			<item>Used <character>'%N'</character> as an end of line in verbatim strings regardless of the end of line sequence in source code.</item>
			<item>Fixed incorrect handling of negative hexadecimal integer literals when sign before the literal was not taken into account. For example, <number>-0x1</number> could be interpreted as <number>1</number>.</item>
			<item>Implemented checks for input ranges of integer constants and fixed issue with inability to assign minimum integer values to variables of  the corresponding integer types.
				<table>
					<legend>Allowed integer values</legend>
					<row>
						<cell>Type</cell>
						<cell>Integer interval</cell>
						<cell>Unsigned hexadecimal representation</cell>
					</row>
					<row>
						<cell><class_name>INTEGER_8</class_name></cell>
						<cell><code><number>-128</number> <symbol>..</symbol> <number>127</number></code></cell>
						<cell><code><number>0x0</number> <symbol>..</symbol> <number>0xFF</number></code></cell>
					</row>
					<row>
						<cell><class_name>INTEGER_16</class_name></cell>
						<cell><code><number>-32768</number> <symbol>..</symbol> <number>32767</number></code></cell>
						<cell><code><number>0x0</number> <symbol>..</symbol> <number>0xFFFF</number></code></cell>
					</row>
					<row>
						<cell><class_name>INTEGER_32</class_name></cell>
						<cell><code><number>-2147483648</number> <symbol>..</symbol> <number>2147483647</number></code></cell>
						<cell><code><number>0x0</number> <symbol>..</symbol> <number>0xFFFFFFFF</number></code></cell>
					</row>
					<row>
						<cell><class_name>INTEGER_64</class_name></cell>
						<cell><code><number>-9223372036854775808</number> <symbol>..</symbol> <number>9223372036854775807</number></code></cell>
						<cell><code><number>0x0</number> <symbol>..</symbol> <number>0xFFFFFFFFFFFFFFFF</number></code></cell>
					</row>
				</table>
			</item>
			<item>Excluded nonsignificant leading zeroes from determination of allowed integer constant type, so that <code><number>00000000000000123</number></code> is now a valid <class_name>INTEGER_8</class_name> value.</item>
			<item>Shared the same data accross once routines and string constant attributes from different generic derivations of the same class. Added a warning for once routines that appear in a generic class to notify about this change in semantics.</item>
			<item>Correctly supported replication of once features when compiling for .NET.</item>
			<item>Changed order of evaluation of once routines to check precondition with class invariant even when once routine has already been called.</item>
			<item>Added a check that length of identifier, manifest string and free operator does not exceed a maximum value of 32767 bytes.</item>
		</list>
		<heading>
			<size>3</size>Compiler issues
		</heading>
		<list ordered="false">
			<item>Fixed crash of the compiler at the very end of a finalization of a system which has an assignment of a manifest type into a variable of type <class_name>ARRAY</class_name> [<keyword>like</keyword> <feature_name>anchor</feature_name>] where <feature_name>anchor</feature_name> is a feature being redefined with a different type in a descendant class.</item>
			<item>Fixed an issue where compiler would report more than once the same error in an incremental recompilation.</item>
			<item>Fixed issue where changing a normal routine to an external and having a compile error, and then reverting back to a normal routine while fixing the error would cause the compiler to crash.</item>
			<item>Fixed some cases where project could be corrupted after a recompilation.</item>
			<item>Now compiler reports <compiler_error>VTCT</compiler_error> errors at the end of degree 5, rather than during degree 5, so that you can collect all the <compiler_error>VTCT</compiler_error> errors at once.</item>
			<item>Thanks to the improvement in <compiler_error>VTCT</compiler_error> errors reporting, now compiler will not generate an incorrect <compiler_error>VTCT</compiler_error> errors during an incremental recompilation for a class which has actually been removed from the system.</item>
			<item>Supported recompilation of once routines when their status is changed from "process-relative" to "thread-relative" or back.</item>
			<item>Supported output of multi-line obsolete messages.</item>
			<item>Fixed a recompilation bug that resulted in incorrect (or even, in case of .NET, in invalid) generated code when incrementally finalizing a system without explicitly specified root creation procedure.</item>
			<item>Fixed a bug with resolving some generic-like types (i.e., types that are processed in a special way: tuple, native array, typed pointer) that depend on anchored types: before they were converted to "normal" generic types thus loosing their special properties.</item>
			<item>Fixed a bug that caused compiler to crash when finalizing a code that looks like 
<code_block><keyword>if</keyword> <keyword>true</keyword> <keyword>then</keyword> [<keyword>else</keyword>(<keyword>if</keyword>) ...] <keyword>end</keyword></code_block>
i.e. has empty compound for a primary condition which is a constant <code><keyword>true</keyword></code>.</item>
			<item>Fixed a bug in processing <code>Ace</code> option <code><keyword>precompiled</keyword></code> that caused a compiler to crash when no option value was provided.</item>
			<item>Fixed a bug in incremental recompilation when multi-branch validity rules are violated in one class because constant attribute used in the multi-branch instruction is changed in another class, that declares them, into a non-constant feature.</item>
			<item>Fixed multiple bugs in feature basic text view that caused truncated or extraneous output.</item>
			<item>Fixed bug where if an actual generic parameter was an anchor, then if the type containing this actual was used for assignment attempt or for creation we would use an incorrect type for the actual generic. We were using the type of the anchor in the class were the code was written, instead of actually re-evaluating the type of the anchor for each descendant class.</item>
		</list>
		<heading>
			<size>3</size>Runtime/code generation issues
		</heading>
		<list ordered="false">
			<item>Fixed bug in <feature_name>deep_twin</feature_name> from <class_name>ANY</class_name> in .NET which would cause a call on Void target when applied on object of type <class_name>STRING</class_name> and possibly other types.</item>
			<item>Corrected C code on Windows for constants of type <class_name>INTEGER_64</class_name>. Before constants of this type between <number>-2147483648</number> and <number>-1</number> could be processed as positive 64-bit values.</item>
			<item>Fixed incorrect C and IL code generation for <class_name>INTEGER_8</class_name> and <class_name>INTEGER_16</class_name> arithmetic and shift operations that might produce incorrect result when combined in two or more operations in a row. For example,
				<code_block><local_variable>i</local_variable> <symbol>:=</symbol> <symbol>(</symbol><local_variable>i</local_variable> <symbol>+</symbol> <local_variable>i</local_variable><symbol>)</symbol> <symbol>|&gt;&gt;</symbol> <number>1</number></code_block>
				assigned <number>-128</number> to <local_variable>i</local_variable> of type <class_name>INTEGER_8</class_name> if the initial value of <local_variable>i</local_variable> was <number>-128</number>. Now this instruction assigns <number>0</number>.</item>
			<item>Synchronized access to data of process-relative once routines to avoid race conditions when two or more threads simultaneously access the same once routine.</item>
			<item>Avoided permanent blocking of a thread accessing process-relative once routine when this routine is concurrently evaluated in some other thread and raises an exception.</item>
			<item>Fixed bugs in memory allocation in C code for result of a once function that returns basic type:
				<list ordered="false">
					<item>it might cause memory corruption when memory size required to store the result is greater than size of a pointer;</item>
					<item>there was a memory leak.</item>
				</list>
			</item>
			<item>Fixed a bug in classic mode that caused last exception to be cleared after returning from a routine that has a rescue clause but returns normally.</item>
			<item>Fixed several bugs related to handling of nested exceptions in classic mode.</item>
			<item>Changed a limit of maximum class name length in melted byte code from 256 bytes to 32767 bytes.</item>
			<item>Changed C code generation for long strings (that result from long manifest strings, identifiers, etc.) to avoid restrictions imposed by some C compilers on long string literals (in particular, by the Microsoft C compiler <code>cl</code> that issued error C2026).</item>
			<item>Fixed a bug in finalized C code generation when calling <keyword>Precursor</keyword> in a routine which is recursively calling itself before the call to <keyword>Precursor</keyword>. Instead of generating the call to <keyword>Precursor</keyword> we would generate a recursive call to the routine.</item>
		</list>
		<heading>
			<size>3</size>.NET issues
		</heading>
		<list ordered="false">
			<item>Corrected processing of literal floating point fields from external assemblies (such as <cluster_name>System</cluster_name><code><symbol>.</symbol></code><class_name>Math</class_name><code><symbol>.</symbol></code><feature_name>PI</feature_name>) to obtain proper values.</item>
			<item>Fixed a bug where the value -1 was actually 255 on .NET.</item>
			<item>Fixed issue where declaring a <class_name>NATIVE_ARRAY</class_name> of a .NET expanded type would be rejected by the compiler.</item>
			<item>Fixed issue where assigning a .NET expanded type to an entity of type <class_name>ANY</class_name> would be rejected by the compiler.</item>
			<item>Fixed a crash in the compiler when generating the code for a class which inherits from a .NET class and from an Eiffel class which has some anchored types.</item>
			<item>Fixed a bug where calls to <feature_name>standard_is_equal</feature_name> from <class_name>ANY</class_name> on objects whose type is generic would yield <keyword>False</keyword> where it should have been <keyword>True</keyword> in classic Eiffel.</item>
			<item>Fixed a bug in assertion monitoring that could lead to wrong monitoring of assertions that are evaluated concurrently in different threads.</item>
			<item>Fixed a bug in code generation for entry point of executable when root procedure is a redeclaration of a deferred feature that caused an exception <code><class_name>MissingMethodException</class_name></code> to be raised on startup of such an application.</item>
			<item>Fixed a bug in code generation when solely inheriting from a .NET interface.</item>
			<item>Fixed a bug in code generation when inheriting from a .NET class which has a routine whose name is identical to one of the routine of <class_name>ANY</class_name>.</item>
		</list>
		<heading>
			<size>3</size>Store/Retrieve issues
		</heading>
		<list ordered="false">
			<item>Fixed an issue where the GC would be disabled after a failure in a retrieval operation.</item>
		</list>
	</paragraph>
</document>
