<document title="6 Design by Contract and Assertions"><meta_data ><help ><toc ><envision_location >Eiffel, The Language\Tutorials\Invitation to Eiffel</envision_location><envision_pseudo_name>60</envision_pseudo_name><envision_title >Design by Contract and Assertions</envision_title><studio_location /><studio_title /></toc></help></meta_data><paragraph ><heading ><size >1</size><content >6 Design by Contract and Assertions</content></heading><paragraph >If classes are to deserve their definition as abstract data type implementations, they must be known not just by the available operations, but also by the formal properties of these operations, which did not yet appear in the preceding example.  </paragraph><div ><heading ><size >2</size><content >The role of assertions</content></heading><paragraph >Eiffel encourages software developers to express formal properties of classes by writing <bold >assertions</bold>, which may in particular appear in the following roles:</paragraph><list ordered="false"><item >Routine <bold >preconditions</bold> express the requirements that clients must satisfy whenever they call a routine.  For example the designer of <code ><string >ACCOUNT</string></code> may wish to permit a withdrawal operation only if it keeps the account's balance at or above the minimum.  Preconditions are introduced by the keyword <code ><keyword >require</keyword></code> .  </item><item >Routine <bold >postconditions</bold>, introduced by the keyword <code ><keyword >ensure</keyword></code>, express conditions that the routine (the supplier) guarantees on return, if the precondition was satisfied on entry.  </item><item >A class <bold >invariant</bold>  must be satisfied by every instance of the class whenever the instance is externally accessible: after creation, and after any call to an exported routine of the class.  The invariant appears in a clause introduced by the keyword <code ><keyword >invariant</keyword></code>, and represents a general consistency constraint imposed on all routines of the class.  </item></list><paragraph >With appropriate assertions, the class <code ><string >ACCOUNT</string></code> becomes:</paragraph>


<code_block >
class ACCOUNT create

    make

feature

    ... Attributes as before:
         balance , minimum_balance , owner , open ...

    deposit (sum: INTEGER) is

            -- Deposit sum into the account.

         require

            sum &gt;= 0

         do

            add (sum)

         ensure

            balance = old balance + sum

        end

    withdraw (sum: INTEGER) is

            -- Withdraw sum from the account.

         require

            sum &gt;= 0

            sum &lt;= balance - minimum_balance

         do

            add (-sum)

         ensure

            balance = old balance - sum

        end

    may_withdraw ... -- As before

feature {NONE}

    add ... -- As before

    make (initial: INTEGER) is

            -- Initialize account with balance initial.

         require

            initial &gt;= minimum_balance

         do

            balance := initial

         end

invariant

    balance &gt;= minimum_balance

end -- class ACCOUNT
</code_block>

<paragraph >The notation <code ><keyword >old</keyword></code><code ><string > expression</string></code> is only valid in a routine postcondition.  It denotes the value the <code ><string >expression</string></code> had on routine entry.  </paragraph></div><heading ><size >2</size><content >Creation procedures</content></heading><paragraph >In its last version above, the class now includes a creation procedure, <code ><string >make</string></code>.  With the first version, clients used creation instructions such as <code ><keyword >create </keyword></code><code ><string >acc1</string></code> to create accounts; but then the default initialization, setting balance to zero, violated the invariant.  By having one or more creation procedures, listed in the <code ><keyword >create</keyword></code> clause at the beginning of the class text, a class offers a way to override the default initializations.  The effect of</paragraph>


<code_block >
	<keyword >create</keyword> acc1 <symbol >.</symbol> make ( 5_500 )
</code_block>

<paragraph >is to allocate the object (as with the default creation) and to call procedure <code ><string >make</string></code> on this object, with the argument given.  This call is correct since it satisfies the precondition; it will ensure the invariant.  </paragraph><info >The underscore <code ><string >_</string></code> in the integer constant <code ><string >5_500</string></code> has no semantic effect.  The general rule is that you can group digits by sets of three from the right to improve the readability of integer constants.  </info><paragraph >Note that the same keyword, <code ><keyword >create</keyword></code>, serves both to introduce creation instructions and the creation clause listing creation procedures at the beginning of the class.  </paragraph><paragraph >A procedure listed in the creation clause, such as <code ><string >make</string></code>, otherwise enjoys the same properties as other routines, especially for calls.  Here the procedure <code ><string >make</string></code> is secret since it appears in a clause starting with <code ><keyword >feature </keyword></code> <code ><comment >{</comment></code> <code ><string >NONE</string></code> <code ><comment >}</comment></code> ; so it would be invalid for a client to include a call such as</paragraph>


<code_block >
	acc <symbol >.</symbol>make ( 8_000 )
</code_block>

<paragraph >To make such a call valid, it would suffice to move the declaration of <code ><string >make</string></code> to the first <code ><keyword >feature</keyword></code> clause of class <code ><string >ACCOUNT</string></code>, which carries no export restriction.  Such a call does not create any new object, but simply resets the balance of a previously created account.  </paragraph><div ><heading ><size >2</size><content >Design by Contract</content></heading><paragraph >Syntactically, assertions are boolean expressions, with a few extensions such as the <code ><keyword >old </keyword></code>notation.  Also, you may split an assertion into two or more clauses, as here with the precondition of <code ><string >withdraw</string></code> ; this is as if you had separated the clauses with an <code ><keyword >and</keyword></code>, but makes the assertion clearer, especially if it includes many conditions.  </paragraph><paragraph >Assertions play a central part in the Eiffel method for building reliable object-oriented software.  They serve to make explicit the assumptions on which programmers rely when they write software elements that they believe are correct.  Writing assertions amounts to spelling out the terms of the <bold >contract</bold>  which governs the relationship between a routine and its callers.  The precondition binds the callers; the postcondition binds the routine.  </paragraph><paragraph >The underlying theory of <span >Design by Contract</span> <span >TM</span>, the centerpiece of the Eiffel method, views software construction as based on contracts between clients (callers) and suppliers (routines), relying on mutual obligations and benefits made explicit by the assertions.  </paragraph></div><div ><heading ><size >2</size><content >The Contract Form</content></heading><paragraph >Assertions are also an indispensable tool for the documentation of reusable software components: one cannot expect large-scale reuse without a precise documentation of what every component expects (precondition), what it guarantees in return (postcondition) and what general conditions it maintains (invariant).  </paragraph><paragraph >Documentation tools in EiffelStudio use assertions to produce information for client programmers, describing classes in terms of observable behavior, not implementation.  In particular the <bold >Contract Form</bold> of a class, also called its "<span >short form</span> ", which serves as its interface documentation, is obtained from the full text by removing all non-exported features and all implementation information such as <code ><keyword >do</keyword></code> clauses of routines, but keeping interface information and in particular assertions.  Here is the Contract Form of the above class:</paragraph>


<code_block >
class interface ACCOUNT create

    make

feature

    balance: INTEGER

    ...

    deposit (sum: INTEGER) is

            -- Deposit sum into the account.

         require

            sum &gt;= 0

         ensure

            balance = old balance + sum

    withdraw (sum: INTEGER) is

            -- Withdraw sum from the account.

         require

            sum &gt;= 0

            sum &lt;= balance - minimum_balance

         ensure

            balance = old balance - sum



    may_withdraw ...

end -- class ACCOUNT
</code_block>

<paragraph >This is not actual Eiffel, only documentation of Eiffel classes, hence the use of slightly different syntax to avoid any confusion (<code ><keyword >interface class</keyword></code> rather than <code ><keyword >class</keyword></code> ).  In accordance with the Uniform Access Principle (page <link ><url >invitation-05.html#Uniform Access Principle</url></link> ), the output for <code ><string >balance</string></code> would be the same if this feature were a function rather than an attribute.  </paragraph><paragraph >You will find in ISE's EiffelStudio automatic tools to produce the Contract Form of a class.  You can also get the <bold >Flat Contract</bold> form, based on the same ideas but including inherited features along with those introduced in the class itself.  EiffelStudio can produce these forms, and other documentation views of a class, in a variety of output formats including HTML, so that collaborative projects can automatically post the latest versions of their class interfaces on the Internet or an Intranet.  </paragraph></div><div ><heading ><size >2</size><content >Contracts for testing and debugging</content></heading><paragraph >Under EiffelStudio you may also set up compilation options, for the whole system or specific classes only, to evaluate assertions at run time, to uncover potential errors ("bugs").  EiffelStudio provides several levels of assertion monitoring: preconditions only, postconditions etc.  When monitoring is on, an assertion which evaluates to true has no further effect on the execution.  An assertion that evaluates to false will trigger an exception, as described next; unless you have written an appropriate exception handler, the exception will cause an error message and termination with a precise message and a call trace.  </paragraph><paragraph >This ability to check assertions provides a powerful testing and debugging mechanism, in particular because the classes of the EiffelBase Libraries, widely used in Eiffel software development, are protected by carefully written assertions.  </paragraph><paragraph >Run-time monitoring, however, is only one application of assertions, whose role as design and documentation aids, as part of the theory of Design by Contract, exerts a pervasive influence on the Eiffel style of software development.  </paragraph></div></paragraph></document>