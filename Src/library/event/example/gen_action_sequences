#!/usr/bin/perl -w
#===============================================================================
# gen_action_sequences
#-------------------------------------------------------------------------------
# This program translates an action sequence definition file into a collection
# of eiffel classes. 
# The deffinition file has one like per difinition like this:
# name: description; arg_name: ARG_TYPE; arg_name: ARG_TYPE etc
#-------------------------------------------------------------------------------
# Date: $Date$
# Revision: $Revision$
#===============================================================================

while (<>) {
	# Initiailize some arrays.
	@args = ();
	@arg_names = ();
	@arg_types = ();
	# Ignore empty lines, those starting with whitespace and comments.
	if (!/^[\n 	#].*/) {
		chomp;
		@fields = split (/;[ 	]*/,$_);
		# Grab the name and the description.
		$name = shift (@fields);
		@parts = split (/:[ 	]*/,$name);
		$name = $parts[0];
		$desc = $parts[1];
		# Grab the arguments.
		foreach $field (@fields) {
			push (@args, $field);
			@parts = split (/:[	 ]*/,$field);
			push (@arg_names, $parts[0]);
			push (@arg_types, $parts[1]);
		}

		# Prepare the parent class name.
		$parent = "ACTION_SEQUENCE";
		$_ = $parent;
		tr/[A-Z]/[a-z]/;
		$parent_lower = $_;

		# Prepare the class name.
		$_ = $name;
		tr/[a-z]/[A-Z]/;
		$classname = "$_\_$parent";
		$_ = $classname;
		tr/[A-Z]/[a-z]/;
		$lower_classname = $_;

		# Status message.
		print "$classname\n";

		# Prepare the event data type, and some handy argument list strings.
		$data_type = "TUPLE [";
		$wrapper_args = "";
		$arg_name_array = "";
		$arg_name_list = "";
		if ($#args > 0) {
			@ats = @arg_types;
			$t = shift (@ats);
			$data_type = "$data_type$t";
			foreach $type (@ats) {
				$data_type = "$data_type, $type";
			}

			@ans = @arg_names;
			$n = shift (@ans);
			$arg_name_array = "\"$n\"";
			$arg_name_list = "a_$n";
			foreach $name (@ans) {
				$arg_name_array = "$arg_name_array, \"$name\"";
				$arg_name_list = "$arg_name_list, a_$name";
			}

			foreach $field (@fields) {
				$wrapper_args = "${wrapper_args}a_$field; "
			}
			$wrapper_args = "$wrapper_args "
		}
		$data_type = "$data_type]";

		# Open our output file.
		open (OH, ">" . "$lower_classname.e");

		# Dump the classtext.
		print OH <<EOT;
indexing
	description: "Action sequence $desc."
	status: "Generated!"
	keywords: "$name"
	date: "Generated!"
	revision: "Generated!"

class $classname

inherit $parent [$data_type]
		rename
			make as $parent_lower\_make
		end

creation
	make

feature -- Initialization
	
	make is
		do
			$parent_lower\_make ("$name", <<$arg_name_array>>)
		end

feature -- Access

	event_data_type: $data_type

	wrapper (${wrapper_args}action: PROCEDURE [ANY, TUPLE]) is
			-- Use this to circumvent tuple type checking. (at your own risk!)
			-- Calls `action' passing all other arguments.
		do
			action.call ([$arg_name_list])
		end

end
EOT
		close(OH)

	}
}

#===============================================================================
# CVS log
#===============================================================================
#
# $Log$
# Revision 1.7  1999/10/28 00:28:52  oconnor
# added warning comment to generated code
#
# Revision 1.6  1999/10/27 20:48:43  oconnor
# added some more comments
#
# Revision 1.5  1999/10/27 20:43:30  oconnor
# added cvs date revision keywords
#
# Revision 1.4  1999/10/27 20:42:30  oconnor
# added cvs log keyword
#
#
#===============================================================================
# End of CVS log
#===============================================================================
