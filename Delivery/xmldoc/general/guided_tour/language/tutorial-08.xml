<document title="7 Genericity and Arrays">
	<meta_data>
		<help>
			<toc>
				<envision_location>Eiffel\Getting Started</envision_location>
				<envision_pseudo_name>70</envision_pseudo_name>
				<envision_title>Genericity and Arrays</envision_title>
				<studio_location/>
				<studio_title/>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph>Some of the classes that we will need, particularly in libraries, are 
			<bold>container</bold> classes, describing data structures made of a number of objects of the same or similar types.  Examples of containers include arrays, stacks and lists.  The class 
			<code>
				<class_name>DEPOSIT_LIST</class_name>
			</code> posited in earlier examples describes containers.  
		</paragraph>
		<paragraph>It is not hard, with the mechanisms seen so far, to write the class 
			<code>
				<class_name>DEPOSIT_LIST</class_name>
			</code>, which would include such features as 
			<code>
				<feature_name>count</feature_name>
			</code> (query returning the number of deposit objects in the list) and 
			<code>
				<feature_name>put</feature_name>
			</code> (command to insert a new deposit object).  
		</paragraph>
		<paragraph>Most of the operations, however, would be the same for lists of objects other than deposits.  To avoid undue replication of efforts and promote reuse, we need a way to describe 
			<bold>generic</bold> container classes, which we can use to describe containers containing elements of many different types.  
		</paragraph>
			<heading>
				<size>2</size>
				<content>Making a class generic</content>
			</heading>
			<paragraph>The notation</paragraph>
			<code_block><keyword>class</keyword> <class_name>C</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol> ... The rest as for any other class declaration ...</code_block>
			<paragraph>introduces a generic class.  A name such as 
				<code>
					<generics>G</generics>
				</code> appearing in brackets after the class name is known as a 
				<bold>formal generic parameter</bold>; it represents an arbitrary type.  
			</paragraph>
			<paragraph>Within the class text, feature declarations can freely use 
				<code>
					<generics>G</generics>
				</code> even though it is not known what type 
				<code>
					<generics>G</generics>
				</code> stands for.  Class 
				<code>
					<class_name>LIST</class_name>
				</code> of EiffelBase, for example, includes features
			</paragraph>
			<code_block>
first<symbol>:</symbol> <generics>G</generics>    
	<comment>-- Value of first list item</comment>

extend <symbol>(</symbol><local_variable>val</local_variable><symbol>:</symbol> <generics>G</generics><symbol>)</symbol> <keyword>is</keyword>    
	<comment>-- Add a new item of value val at end of list  </comment>  
...
</code_block>
			<paragraph>The operations available on an entity such as 
				<code>
					<feature_name>first</feature_name>
				</code> and 
				<code>
					<local_variable>val</local_variable>
				</code>, whose type is a formal generic parameter, are the operations available on all types: use as source 
				<code>
					<local_variable>y</local_variable>
				</code> of an assignment 
				<code>
					<local_variable>x</local_variable> 
					<symbol>:=</symbol> 
					<local_variable>y</local_variable>
				</code>, use as target 
				<code>
					<local_variable>x</local_variable>
				</code> of such an assignment (although not for 
				<code>
					<local_variable>val</local_variable>
				</code>, which as a formal routine argument is not writable), use in equality comparisons 
				<code>
					<local_variable>x</local_variable>  
					<symbol>=</symbol> 
					<local_variable>y</local_variable>
				</code> or 
				<code>
					<local_variable>x</local_variable> 
					<symbol>/=</symbol> 
					<local_variable>y</local_variable>
				</code>, and application of universal features from 
				<code>
					<class_name>ANY</class_name>
				</code> such as 
				<code>
					<feature_name>clone</feature_name>
				</code>, 
				<code>
					<feature_name>equal</feature_name>
				</code> and 
				<code>
					<feature_name>copy</feature_name>
				</code>.  
			</paragraph>
			<paragraph>To use a generic class such as list, a client will provide a type name as 
				<bold>actual generic parameter</bold>.  So instead of relying on a special purpose class 
				<code>
					<class_name>DEPOSIT_LIST</class_name>
				</code>, the class 
				<code>
					<class_name>ACCOUNT</class_name>
				</code> could include the declaration
			</paragraph>
			<code_block><feature_name>all_deposits</feature_name><symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>DEPOSIT</class_name><symbol>]</symbol></code_block>
			<paragraph>using 
				<code>
					<class_name>LIST</class_name>
				</code> as a generic class and 
				<code>
					<class_name>DEPOSIT</class_name>
				</code> as the actual generic parameter.  Then all features declared in 
				<code>
					<class_name>LIST</class_name>
				</code> as working on values of type 
				<code>
					<class_name>G</class_name>
				</code> will work, when called on the target 
				<code>
					<feature_name>all_deposits</feature_name>
				</code>, on values of type 
				<code>
					<class_name>DEPOSIT</class_name>
				</code>. With the target
			</paragraph>
			<code_block><feature_name>all_accounts</feature_name><symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>ACCOUNT</class_name><symbol>]</symbol></code_block>
			<paragraph>these features would work on values of type 
				<code>
					<class_name>ACCOUNT</class_name>
				</code>.  
			</paragraph>
			<info>A note of terminology: to avoid confusion, Eiffel always uses the word 
				<bold>argument</bold> for routine arguments, reserving 
				<bold>parameter</bold> for the generic parameters of classes.  
			</info>
			<paragraph>Genericity reconciles extendibility and reusability with the static type checking demanded by reliability.  A typical error, such as confusing an account and a deposit, will be detected immediately at compile time, since the call 
				<code>
					<feature_name>all_accounts</feature_name>
				</code>.
				<code>
					<feature_name>extend</feature_name>
				</code> 
				<code>
					<symbol>(</symbol>
				</code>
				<code>
					<feature_name>dep</feature_name>
				</code>
				<code>
					<symbol>)</symbol>
				</code> is invalid for 
				<code>
					<feature_name>dep</feature_name>
				</code> declared of type 
				<code>
					<class_name>DEPOSIT</class_name>
				</code>. What is valid is something like 
				<code>
					<feature_name>all_accounts</feature_name>
				</code>.
				<code>
					<feature_name>extend</feature_name>
				</code> 
				<code>
					<symbol>(</symbol>
				</code> 
				<code>
					<local_variable>acc</local_variable>
				</code>
				<code>
					<symbol>)</symbol>
				</code> for 
				<code>
					<local_variable>acc</local_variable>
				</code> of type 
				<code>
					<class_name>ACCOUNT</class_name>
				</code>.  In other approaches, the same effect might require costly run-time checks (as in Java, C# or Smalltalk), with the risk of run-time errors.  
			</paragraph>
			<info>This form of genericity is known as 
				<bold>unconstrained</bold> because the formal generic parameter, 
				<code>
					<class_name>G</class_name>
				</code> in the example, represents an arbitrary type.  You may also want to use types that are guaranteed to have certai operations available.  This is known as 
				<bold>constrained</bold> genericity and will be studied with inheritance.  
			</info>
			<heading>
				<size>2</size>
				<content>Arrays</content>
			</heading>
			<paragraph>An example of generic class from the Kernel Library is 
				<code>
					<class_name>ARRAY</class_name>
				</code> 
				<code>
					<symbol>[</symbol>
				</code>
				<code>
					<class_name>G</class_name>
				</code>
				<code>
					<symbol>]</symbol>
				</code>,  which describes direct-access arrays.  Features include:
			</paragraph>
			<list ordered="false">
				<item>
					<code>
						<feature_name>put</feature_name>
					</code> to replace an element's value, as in 
					<code>
						<local_variable>my_array</local_variable>
					</code>.
					<code>
						<feature_name>put</feature_name>
					</code> 
					<code>
						<symbol>(</symbol>
					</code>
					<code>
						<local_variable>val</local_variable>
					</code>, 
					<code>
						<number>25</number>
					</code>
					<code>
						<symbol>)</symbol>
					</code> which replaces by 
					<code>
						<local_variable>val</local_variable>
					</code> the value of the array entry at index 25.  
				</item>
				<item>
					<code>
						<feature_name>item</feature_name>
					</code> to access an entry, as in 
					<code>
						<local_variable>my_array</local_variable>
					</code>.
					<code>
						<feature_name>item</feature_name>
					</code> 
					<code>
						<symbol>(</symbol>
					</code>
					<code>
						<number>25</number>
					</code>
					<code>
						<symbol>)</symbol>
					</code> yielding the entry at index 25.  A synonym is 
					<code>
						<keyword>infix</keyword>
					</code> 
					<code>
						<string>"@"</string>
					</code>, so that you may also write more tersely, for the same result, 
					<code>
						<local_variable>my_array</local_variable>
					</code> 
					<code>
						<symbol>@</symbol>
					</code> 
					<code>
						<number>25</number>
					</code>.  
				</item>
				<item> 
					<code>
						<feature_name>lower</feature_name>
					</code>, 
					<code>
						<feature_name>upper</feature_name>
					</code> and 
					<code>
						<feature_name>count</feature_name>
					</code>: queries yielding the bounds and the number of entries.  
				</item>
				<item> The creation procedure 
					<code>
						<feature_name>make</feature_name>
					</code>, as in 
					<code>
						<keyword>create </keyword>
					</code> 
					<code>
						<local_variable>my_array</local_variable>
					</code>. 
					<code>
						<feature_name>make</feature_name>
					</code> 
					<code>
						<symbol>(</symbol>
						<number>1</number>, 
						<number>50</number>
						<symbol>)</symbol>
					</code> which creates an array with the given index bounds.  It is also possible to resize an array through 
					<code>
						<feature_name>resize</feature_name>
					</code>, retaining the old elements.  In general, the Eiffel method abhors built-in limits, favoring instead structures that resize themselves when needed, either from explicit client request or automatically.  
				</item>
			</list>
			<paragraph>The comment made about 
				<code>
					<class_name>INTEGER</class_name>
				</code> and other basic classes applies to 
				<code>
					<class_name>ARRAY</class_name>
				</code> too: Eiffel compilers know about this class, and will be able to process expressions of the form 
				<code>
					<local_variable>my_array</local_variable>
				</code>.
				<code>
					<feature_name>put</feature_name>
				</code> 
				<code>
					<symbol>(</symbol>
				</code>
				<code>
					<local_variable>val</local_variable>
				</code>, 
				<code>
					<number>25</number>
				</code>
				<code>
					<comment>)</comment>
				</code> and 
				<code>
					<local_variable>my_array</local_variable>
				</code> 
				<code>
					<symbol>@</symbol>
				</code> 
				<code>
					<number>25</number>
				</code> in essentially the same way as a C or Fortran array access -- 
				<code>
					<local_variable>my_array</local_variable>
				</code> 
				<code>
					<symbol>[</symbol>
				</code>
				<code>
					<number>25</number>
				</code>
				<code>
					<symbol>]</symbol>
				</code> in C.  But it is consistent and practical to let developers treat 
				<code>
					<class_name>ARRAY</class_name>
				</code> as a class and arrays as objects; many library classes in EiffelBase, for example, inherit from 
				<code>
					<class_name>ARRAY</class_name>
				</code>.  Once again the idea is to get the best of both worlds: the convenience and uniformity of the object-oriented way of thinking; and the efficiency of traditional approaches.  
			</paragraph>
			<paragraph>A similar technique applies to another Kernel Library class, that one not generic: 
				<code>
					<class_name>STRING</class_name>
				</code>, describing character strings with a rich set of string manipulation features.  
			</paragraph>
			<heading>
				<size>2</size>
				<content>Generic derivation</content>
			</heading>
			<paragraph>The introduction of genericity brings up a small difference between classes and types.  A generic class 
				<code>
					<class_name>C</class_name>
				</code> is not directly a type since you cannot declare an entity as being of type 
				<code>
					<class_name>C</class_name>
				</code>: you must use some actual generic parameter 
				<code>
					<generics>T</generics>
				</code> -- itself a type.  
				<code>
					<class_name>C</class_name>
				</code> 
				<code>
					<symbol>[</symbol>
				</code>
				<code>
					<generics>T</generics>
				</code>
				<code>
					<symbol>]</symbol>
				</code> is indeed a type, but class 
				<code>
					<class_name>C</class_name>
				</code> by itself is only a type template.  
			</paragraph>
			<paragraph>The process of obtaining a type 
				<code>
					<class_name>C</class_name>
				</code> 
				<code>
					<symbol>[</symbol>
				</code>
				<code>
					<generics>T</generics>
				</code>
				<code>
					<symbol>]</symbol>
				</code> from a general class 
				<code>
					<class_name>C</class_name>
				</code> is known as a 
				<bold>generic derivation</bold>; 
				<code>
					<class_name>C</class_name>
				</code> 
				<code>
					<symbol>[</symbol>
				</code>
				<code>
					<generics>T</generics>
				</code>
				<code>
					<symbol>]</symbol>
				</code> is a 
				<bold>generically derived type</bold>.  Type 
				<code>
					<generics>T</generics>
				</code> itself is, recursively, either a non-generic class or again a generically derived type 
				<code>
					<class_name>D</class_name>
				</code> 
				<code>
					<symbol>[</symbol>
				</code>
				<code>
					<class_name>U</class_name>
				</code>
				<code>
					<symbol>]</symbol>
				</code> for some 
				<code>
					<class_name>D</class_name>
				</code> and 
				<code>
					<class_name>U</class_name>
				</code>, as in 
				<code>
					<class_name>LIST</class_name>
				</code> 
				<code>
					<symbol>[</symbol>
				</code>
				<code>
					<class_name>ARRAY</class_name>
				</code> 
				<code>
					<symbol>[</symbol>
				</code>
				<code>
					<class_name>INTEGER</class_name>
				</code>
				<code>
					<comment>]]</comment>
				</code>.)
			</paragraph>
			<paragraph>It remains true, however, that every type is based on a class.  The base class of a generically derived type 
				<code>
					<class_name>C</class_name>
				</code> 
				<code>
					<symbol>[</symbol>
				</code>
				<code>
					<generics>T</generics>
				</code>
				<code>
					<symbol>]</symbol>
				</code> is 
				<code>
					<class_name>C</class_name>
				</code>.  
			</paragraph>
	</paragraph></document>
