indexing
	description: "Objects that generate a Vision2 system from XML output%
		%generated by build."
	--| FIXME Initial build will support WINDOWS, TITLED_WINDOWS, BUTTONS,
	--| horizontal_boxes and vertical_boxes.
	author: "Julian Rogers"
	date: "$Date$"
	revision: "$Revision$" 

class
	APPLICATION_GENERATOR

inherit
	EV_APPLICATION
		redefine
			initialize
		end

	GENERATOR_UTILITIES
		undefine
			default_create
		end

	TOE_TREE_FACTORY
		undefine
			default_create
		end

feature -- Initialization

	prepare is
			--Generate the system.	
		do
			--load_and_parse_xml_file ("D:\work\library\newvision2\vision2\components\generator\xml_files\instance_document.xml")
			load_and_parse_xml_file ("c:\store_output_instance.xml")
		end

	initialize is
			-- Initialize application generator.
		do
			Precursor
				-- Create the XML parser.
			parser := create_tree_parser
			create created_objects.make (2500)
			object_count := 0
			create type.make_from_string ("type")
		end

feature -- Access

		-- A hash table containing every object we have created.
		-- Uniquely identified by an integer assigned to them at
		-- creation.
	created_objects: HASH_TABLE [EV_ANY, INTEGER]

		-- The number of objects we have created. Used as an index
		-- into `created_objects'.
	object_count: INTEGER

feature {NONE} -- Implementation

	create_system is
			-- Create a system from the parsed XML file.
		local
			application_element: XML_ELEMENT
			window_element: XML_ELEMENT
		do
			application_element := parser.document.root_element
			from
				application_element.start
			until
				application_element.off
			loop
					--| FIXME We are assuming that an application only
					--| ever contains windows. This may be wrong.
				window_element ?= application_element.item_for_iteration
				if window_element /= Void then
					add_window_to_application (window_element)
				end
				application_element.forth
			end 
		end

	add_window_to_application (element: XML_ELEMENT) is
			-- Add a window to the application and then fill window
			-- from information in `element'.
		local
				a_titled_window: EV_TITLED_WINDOW
				a_window: EV_WINDOW
				attribute_name: STRING
		do
				-- We check that the start tag defines the element as a
				-- window.
			check
				--| FIXME element.name may be void.
				--element_is_window: element.name.to_utf8.is_equal ("window")
			end
			if element.attribute_by_name (type) /= Void then
				attribute_name := element.attribute_by_name (type).value.to_utf8
			end
				-- Create the window and add it to the application.
			if attribute_name /= Void then
				if attribute_name.is_equal ("EV_TITLED_WINDOW") then
					create a_titled_window
					a_titled_window.show
					add_object_to_table (a_titled_window)
					fill_window (a_titled_window, clone(element))
				elseif attribute_name.is_equal ("EV_WINDOW") then
					create a_window
					a_window.show
					add_object_to_table (a_window)
					fill_window (a_window, clone (element))
					--|FIXME I think we should fill in the windows attriburtes here.	
				end
			end
		end

	fill_window (a_window: EV_WINDOW; element: XML_ELEMENT) is
			-- Populate `a_window' from information in `element'.
		local
			current_child_element: XML_ELEMENT
			current_data_element: XML_CHARACTER_DATA
			current_element: XML_ELEMENT
			char_data: STRING
		do
			from
				element.start
			until
				element.off
			loop
				current_element ?= element.item_for_iteration
				if current_element /= Void then
					if current_element.name.to_utf8.is_equal ("EV_COLORIZABLE") then
						setup_EV_COLORIZABLE (a_window, clone (current_element))
					elseif current_element.name.to_utf8.is_equal ("EV_POSITIONABLE") then
						setup_EV_POSITIONABLE (a_window, clone (current_element))
					elseif current_element.name.to_utf8.is_equal ("EV_POSITIONED") then
						setup_EV_POSITIONED (a_window, clone (current_element))
					elseif current_element.name.to_utf8.is_equal ("item") then
						add_widget_to_container (a_window, clone (current_element))
					elseif current_element.name.to_utf8.is_equal ("menu_bar") then
						add_menu_bar (a_window, clone (current_element))
					end
					from
						current_element.start
					until
						current_element.off
					loop
						current_data_element ?= current_element.item_for_iteration
						if current_data_element /= Void then
							char_data := current_data_element.content.to_utf8
							char_data.replace_substring_all ("%T","")
							if data_valid (char_data) then
								if current_element.name.to_utf8.is_equal ("is_modal") then
									--|FIXME
								elseif current_element.name.to_utf8.is_equal ("lower_bar") then
									--|FIXME
								elseif current_element.name.to_utf8.is_equal ("maximum_height") then
									a_window.set_maximum_height (char_data.to_integer)
								elseif current_element.name.to_utf8.is_equal ("maximum_width") then
									a_window.set_maximum_width (char_data.to_integer)
								elseif current_element.name.to_utf8.is_equal ("title") then
									a_window.set_title (char_data)	
								elseif current_element.name.to_utf8.is_equal ("upper_bar") then
									--|FIXME
								elseif current_element.name.to_utf8.is_equal ("user_can_resize") then
									--|FIXME
								end
							end
						end
						current_element.forth
					end	
					--| We should only size the window after all the children have been added,
					--| So they resize evenly.
				end 
				element.forth
			end
		end

	add_menu_bar (window: EV_WINDOW; element: XML_ELEMENT) is
		local
			current_element: XML_ELEMENT
			menu_bar: EV_MENU_BAR
			menu: EV_MENU
			menu_item: EV_MENU_ITEM
		do
			create menu_bar
			window.set_menu_bar (menu_bar)
			from
				element.start
			until
				element.off
			loop
				current_element ?= element.item_for_iteration
				if current_element /= Void then
					if current_element.name.to_utf8.is_equal ("item") then
						if current_element.attribute_by_name (type).value.to_utf8.is_equal ("EV_MENU") then
							create menu
							menu_bar.extend (menu)
							setup_EV_MENU_ITEM (menu, clone (current_element))
						end
					end
				end
				element.forth
			end
		end

	setup_EV_MENU_ITEM (menu_item: EV_MENU_ITEM; element: XML_ELEMENT) is
		local
			current_element: XML_ELEMENT
			menu: EV_MENU
			passed_menu: EV_MENU
			new_menu_item: EV_MENU_ITEM
			info: HASH_TABLE [XML_ELEMENT, STRING]
		do
			setup_EV_ITEM (menu_item, menu_item.parent, element)
			info := get_single_level_elements (element)
			if info.item ("EV_TEXTABLE") /= Void then
				setup_EV_TEXTABLE (menu_item, info.item ("EV_TEXTABLE"))
			end
			if info.item ("EV_SENSITIVE") /= Void then
				setup_EV_SENSITIVE (menu_item, info.item ("EV_TEXTABLE"))
			end
			if info.item ("EV_MENU_ITEM_ACTION_SEQUENCES") /= Void then
				--| FIXME
			end
			passed_menu ?= menu_item
			if passed_menu /=  Void then
				if info.item ("EV_MENU_ITEM_LIST_ACTION_SEQUENCES") /= Void then
					--| FIXME
				end
				from
					element.start
				until
					element.off
				loop
					current_element ?= element.item_for_iteration
					if current_element /= Void then
						if current_element.name.to_utf8.is_equal ("item") then
							if current_element.attribute_by_name (type).value.to_utf8.is_equal ("EV_MENU") then
								create menu
								passed_menu.extend (menu)
								setup_EV_MENU_ITEM (menu, clone (current_element))
							elseif current_element.attribute_by_name (type).value.to_utf8.is_equal ("EV_MENU_ITEM") then
								create new_menu_item
								passed_menu.extend (new_menu_item)
								setup_EV_MENU_ITEM (new_menu_item, clone (current_element))
							end
						end
					end
					element.forth
				end
			end
		end

	setup_EV_TREE_ITEM (tree_item: EV_TREE_ITEM; element: XML_ELEMENT) is
		local
			current_element: XML_ELEMENT
			tree: EV_TREE
			info: HASH_TABLE [ELEMENT_INFORMATION, STRING]
			new_tree_item: EV_TREE_ITEM
		do
			setup_EV_ITEM (tree_item, Void, element)
			info := get_unique_full_info (element)
			if info.item ("EV_TEXTABLE") /= Void then
				setup_EV_TEXTABLE (tree_item, info.item ("EV_TEXTABLE").element)
			end
			if info.item ("EV_SELECTABLE") /= Void then
				setup_EV_SELECTABLE (tree_item, info.item ("EV_SELECTABLE").element)
			end
			if info.item ("EV_TOOLTIPABLE") /= Void then
				setup_EV_TOOLTIPABLE (tree_item, info.item ("EV_TOOLTIPABLE").element)
			end
			--| FIXME implement "EV_TREE_NODE_ACTION_SEQUENCES" here.
			from
				element.start
			until
				element.off
			loop
				current_element ?= element.item_for_iteration
				if current_element /= Void then
					if current_element.name.to_utf8.is_equal ("item") then
						if current_element.attribute_by_name (type).value.to_utf8.is_equal ("EV_TREE_ITEM") then
							create new_tree_item.make_with_text ("item")
							tree_item.extend (new_tree_item)
							setup_EV_TREE_ITEM (new_tree_item, clone (current_element))
						end
					end
				end
				element.forth
			end
			if info.item ("is_expanded") /= Void then
				if info.item ("is_expanded").data.is_equal ("true") then
					tree_item.expand
				end
			end
		end
	
	add_widget_to_container (a_container: EV_CONTAINER; element: XML_ELEMENT) is
			-- Add a widget of type as specified in `element' to `container'.
			-- When this is called `element' name must be equal to `item'.
			--| FIXME There must be a more efficient way of implementing this feature. 
		local
			current_element: XML_ELEMENT 
			widget: EV_WIDGET
			button: EV_BUTTON  
			vertical_box: EV_VERTICAL_BOX
			horizontal_box: EV_HORIZONTAL_BOX
			label: EV_LABEL
			toggle_button:EV_TOGGLE_BUTTON
			radio_button: EV_RADIO_BUTTON
			drawing_area: EV_DRAWING_AREA
			horizontal_scroll_bar: EV_HORIZONTAL_SCROLL_BAR
			vertical_scroll_bar: EV_VERTICAL_SCROLL_BAR
			vertical_range: EV_VERTICAL_RANGE
			horizontal_range: EV_HORIZONTAL_RANGE
			spin_button: EV_SPIN_BUTTON
			check_button: EV_CHECK_BUTTON
			list: EV_LIST
			cell: EV_CELL
			vertical_split_area: EV_VERTICAL_SPLIT_AREA
			horizontal_split_area: EV_HORIZONTAL_SPLIT_AREA
			frame: EV_FRAME
			notebook: EV_NOTEBOOK
			viewport: EV_VIEWPORT
			scrollable_area: EV_SCROLLABLE_AREA
			vertical_separator: EV_VERTICAL_SEPARATOR
			horizontal_separator: EV_HORIZONTAL_SEPARATOR
			tree: EV_TREE
		do
			if element.attribute_by_name (type).value.to_utf8.is_equal ("EV_BUTTON") then
				create button
				widget ?= button
				a_container.extend (button)
				setup_EV_BUTTON (button, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_VERTICAL_BOX") then
				create vertical_box
				widget ?= vertical_box
				a_container.extend (vertical_box)
				setup_EV_BOX (vertical_box, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_HORIZONTAL_BOX") then
				create horizontal_box
				widget ?= horizontal_box
				a_container.extend (horizontal_box)
				setup_EV_BOX (horizontal_box, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_LABEL") then
				create label
				widget ?= label
				a_container.extend (label)
				setup_EV_LABEL (label, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_TOGGLE_BUTTON") then
				create toggle_button
				widget ?= toggle_button
				a_container.extend (toggle_button)
				setup_EV_TOGGLE_BUTTON (toggle_button, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_RADIO_BUTTON") then
				create radio_button
				widget ?= radio_button
				a_container.extend (radio_button)
				setup_EV_RADIO_BUTTON (radio_button, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_DRAWING_AREA") then
				create drawing_area
				widget ?= drawing_area
				a_container.extend (drawing_area)
				setup_EV_DRAWING_AREA (drawing_area, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_HORIZONTAL_SCROLL_BAR") then
				create horizontal_scroll_bar
				widget ?= drawing_area
				a_container.extend (horizontal_scroll_bar)
				setup_EV_SCROLL_BAR (horizontal_scroll_bar, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_VERTICAL_SCROLL_BAR") then
				create vertical_scroll_bar
				widget ?= drawing_area
				a_container.extend (vertical_scroll_bar)
				setup_EV_SCROLL_BAR (vertical_scroll_bar, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_VERTICAL_RANGE") then
				create vertical_range
				widget ?= drawing_area
				a_container.extend (vertical_range)
				setup_EV_RANGE (vertical_range, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_HORIZONTAL_RANGE") then
				create horizontal_range
				widget ?= drawing_area
				a_container.extend (horizontal_range)
				setup_EV_RANGE (horizontal_range, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_SPIN_BUTTON") then
				create spin_button
				widget ?= drawing_area
				a_container.extend (spin_button)
				setup_EV_SPIN_BUTTON (spin_button, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_CHECK_BUTTON") then
				create check_button
				widget ?= check_button
				a_container.extend (check_button)
				setup_EV_TOGGLE_BUTTON (check_button, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_LIST") then
				create list
				widget ?= list
				a_container.extend (list)
				setup_EV_LIST (list, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_CELL") then
				create cell
				widget ?= cell
				a_container.extend (cell)
				setup_EV_CELL (cell, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_HORIZONTAL_SPLIT_AREA") then
				create horizontal_split_area
				widget ?= horizontal_split_area
				a_container.extend (horizontal_split_area)
				setup_EV_SPLIT_AREA (horizontal_split_area, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_VERTICAL_SPLIT_AREA") then
				create vertical_split_area
				widget ?= vertical_split_area
				a_container.extend (vertical_split_area)
				setup_EV_SPLIT_AREA (vertical_split_area, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_FRAME") then
				create frame
				widget ?= frame
				a_container.extend (frame)
				setup_EV_FRAME (frame, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_NOTEBOOK") then
				create notebook
				widget ?= notebook
				a_container.extend (notebook)
				setup_EV_NOTEBOOK (notebook, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_VIEWPORT") then
				create viewport
				widget ?= viewport
				a_container.extend (viewport)
				setup_EV_VIEWPORT (viewport, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_SCROLLABLE_AREA") then
				create scrollable_area
				widget ?= scrollable_area
				a_container.extend (scrollable_area)
				setup_EV_SCROLLABLE_AREA (scrollable_area, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_HORIZONTAL_SEPARATOR") then
				create horizontal_separator
				widget ?= horizontal_separator
				a_container.extend (horizontal_separator)
				setup_EV_SEPARATOR (horizontal_separator, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_VERTICAL_SEPARATOR") then
				create vertical_separator
				widget ?= vertical_separator
				a_container.extend (vertical_separator)
				setup_EV_SEPARATOR (vertical_separator, a_container, clone (element))
			elseif element.attribute_by_name (type).value.to_utf8.is_equal ("EV_TREE") then
				create tree
				widget ?= tree
				a_container.extend (tree)
				setup_EV_TREE (tree, a_container, clone (element))
			else
				io.putstring ("This type is not yet supported") 
				check
					False
				end
			end
			add_object_to_table (widget)
		end

	add_item_to_item_holder (item_list: EV_ITEM_LIST [EV_ITEM]; element: XML_ELEMENT) is
		local
			list_item: EV_LIST_ITEM
		do
			if element.attribute_by_name (type).value.to_utf8.is_equal ("EV_LIST_ITEM") then
				create list_item
				item_list.extend (list_item)
				setup_EV_LIST_ITEM (list_item, item_list, clone (element))
			end
		end

	add_object_to_table (object:EV_ANY) is
			-- Add `object' to created_objects.
		do
			object_count := object_count + 1
			created_objects.extend (object, object_count)
		end

	setup_EV_BOX (box: EV_BOX; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `box' already contained in `parent' from data held in `element'.
		local
			current_element: XML_ELEMENT
			info: HASH_TABLE [ELEMENT_INFORMATION, STRING]
		do
			info := get_unique_full_info (element)
			if info.item ("EV_CONTAINER_ACTION_SEQUENCES") /= Void then
				--| FIXME
			end
			from
				element.start
			until
				element.off
			loop
				current_element ?= element.item_for_iteration
				if current_element /= Void then
					if current_element.name.to_utf8.is_equal ("item") then
						add_widget_to_container (box, clone (current_element))
					end
				end
				element.forth
			end
			setup_EV_WIDGET (box, parent, element)
			if info.item ("border_width") /= Void then
				box.set_border_width (info.item ("border_width").data.to_integer)
			end
			if info.item ("is_homogeneous") /= Void then
				if info.item ("is_homogeneous").data.is_equal ("false") then
					box.disable_homogeneous
				else
					box.enable_homogeneous
				end
			end
			if info.item ("padding") /= Void then
				box.set_padding (info.item ("padding").data.to_integer)
			end
		end

	setup_EV_TREE (tree: EV_TREE; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `notebook' already contained in `parent' from data held in `element'.
		local
			current_element: XML_ELEMENT
			info: HASH_TABLE [STRING, STRING]
			tree_item: EV_TREE_ITEM
		do
			info := get_single_level_attributes (element)
			if info.item ("EV_TREE_ACTION_SEQUENCES") /= Void then
				--| FIXME
			end
			if info.item ("pixmaps_height") /= Void and info.item ("pixmaps_width") /= Void then
				tree.set_pixmaps_size (info.item ("pixmaps_width").to_integer, info.item ("pixmaps_height").to_integer)
			end
			from
				element.start
			until
				element.off
			loop
				current_element ?= element.item_for_iteration
				if current_element /= Void then
					if current_element.name.to_utf8.is_equal ("item") then
						if current_element.attribute_by_name (type).value.to_utf8.is_equal ("EV_TREE_ITEM") then
						create tree_item
						tree.extend (tree_item)
						setup_EV_TREE_ITEM (tree_item, clone (current_element))
						end
					end
				end
				element.forth
			end
			setup_EV_PRIMITIVE (tree, parent, element)
		end

	setup_EV_NOTEBOOK (notebook: EV_NOTEBOOK; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `notebook' already contained in `parent' from data held in `element'.
		local
			current_element: XML_ELEMENT
			current_data_element: XML_CHARACTER_DATA
			info: HASH_TABLE [STRING, STRING]
			counter: INTEGER
			char_data: STRING
		do
			info := get_single_level_attributes (element)
			if info.item ("EV_CONTAINER_ACTION_SEQUENCES") /= Void then
				--| FIXME
			end
			from
				element.start
				counter := 0
			until
				element.off
			loop
				current_element ?= element.item_for_iteration
				if current_element /= Void then
					if current_element.name.to_utf8.is_equal ("item") then
						add_widget_to_container (notebook, clone (current_element))
					end
					from
						current_element.start
					until
						current_element.off
					loop
						current_data_element ?= current_element.item_for_iteration
						if current_data_element /= Void then
							char_data := current_data_element.content.to_utf8
							char_data.replace_substring_all ("%T","")
							if data_valid (char_data) then
								if current_element.name.to_utf8.is_equal ("item_text") then
									counter := counter + 1
									--| FIXME NOT ACTION
									if char_data.count > 29 then
										char_data := char_data.substring (0, 29)
									end
									notebook.set_item_text (notebook.i_th (counter), char_data)
								end
							end
						end
						current_element.forth
					end
				end
				element.forth
			end
			setup_EV_WIDGET (notebook, parent, element)
		end

	setup_EV_CELL (cell: EV_CELL; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `cell' already contained in `parent' from data held in `element'.
		local
			current_element: XML_ELEMENT
			info: HASH_TABLE [STRING, STRING]
		do
			info ?= get_single_level_attributes (element)
			if info.item ("EV_CONTAINER_ACTION_SEQUENCES") /= Void then
				-- FIXME
			end
			from
				element.start
			until
				element.off
			loop
				current_element ?= element.item_for_iteration
				if current_element /= Void then
					if current_element.name.to_utf8.is_equal ("item") then
						add_widget_to_container (cell, clone (current_element))
					end
				end
				element.forth
			end
			setup_EV_WIDGET (cell, parent, element)
		end

	setup_EV_VIEWPORT (viewport: EV_VIEWPORT; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `viewport' already contained in `parent' from data held in `element'.
		local
			current_element: XML_ELEMENT
			info: HASH_TABLE [STRING, STRING]
		do
			setup_EV_CELL (viewport, parent, clone (element))
			--|FIXME NOT ACTION
			--| As soon as more items are supported, this will work.
			if not viewport.empty then
				info ?= get_single_level_attributes (element)
				if info.item ("x_offset") /= Void then
					viewport.set_x_offset (info.item ("x_offset").to_integer)
				end
				if info.item ("y_offset") /= Void then
					viewport.set_y_offset (info.item ("y_offset").to_integer)
				end
			end
		end

	setup_EV_SCROLLABLE_AREA (scrollable_area: EV_SCROLLABLE_AREA; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `scrollable_area' already contained in `parent' from data held in `element'.
		local
			current_element: XML_ELEMENT
			info: HASH_TABLE [STRING, STRING]
		do
			info ?= get_single_level_attributes (element)
			if info.item ("horizontal_step") /= Void then
				scrollable_area.set_horizontal_step (info.item ("horizontal_step").to_integer)
			end
			if info.item ("is_horizontal_scroll_bar_visible") /= Void then
				if info.item ("is_horizontal_scroll_bar_visible").is_equal ("true") then
					scrollable_area.show_horizontal_scroll_bar
				elseif info.item ("is_horizontal_scroll_bar_visible").is_equal ("false") then
					scrollable_area.hide_horizontal_scroll_bar
				end
			end
			if info.item ("is_vertical_scroll_bar_visible") /= Void then
				if info.item ("is_vertical_scroll_bar_visible").is_equal ("true") then
					scrollable_area.show_vertical_scroll_bar
				elseif info.item ("is_vertical_scroll_bar_visible").is_equal ("false") then
					scrollable_area.hide_vertical_scroll_bar
				end
			end
			if info.item ("vertical_step") /= Void then
				scrollable_area.set_vertical_step (info.item ("vertical_step").to_integer)
			end
			setup_EV_VIEWPORT (scrollable_area, parent, clone (element))
		end

	

	setup_EV_FRAME (frame: EV_FRAME; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `cell' already contained in `parent' from data held in `element'.
		local
			current_element: XML_ELEMENT
			info: HASH_TABLE [ELEMENT_INFORMATION, STRING]
		do
			setup_EV_WIDGET (frame, parent, clone (element))
			info ?= get_unique_full_info (element)
			if info.item ("EV_CONTAINER_ACTION_SEQUENCES") /= Void then
				-- FIXME
			end
			from
				element.start
			until
				element.off
			loop
				current_element ?= element.item_for_iteration
				if current_element /= Void then
					if current_element.name.to_utf8.is_equal ("item") then
						add_widget_to_container (frame, clone (current_element))
					end
				end
				element.forth
			end
			if info.item ("style") /= Void then
				frame.set_style (info.item ("style").data.to_integer)
			end
		end

	setup_EV_SPLIT_AREA (split_area: EV_SPLIT_AREA; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `split_area' already contained in `parent' from data held in `element'.
		local
			current_element: XML_ELEMENT
			info: HASH_TABLE [ELEMENT_INFORMATION, STRING]
		do
			info := get_unique_full_info (element)
			if info.item ("EV_CONTAINER_ACTION_SEQUENCES") /= Void then
				--| FIXME
			end
			from
				element.start
			until
				element.off
			loop
				current_element ?= element.item_for_iteration
				if current_element /= Void then
					if current_element.name.to_utf8.is_equal ("item") then
						add_widget_to_container (split_area, clone (current_element))
					end
				end
				element.forth
			end
			setup_EV_WIDGET (split_area, parent, clone (element))
			if info.item ("split_position") /= Void then
				split_area.set_split_position (info.item ("split_position").data.to_integer)
			end
		end

	setup_EV_LIST_ITEM_LIST (list_item_list: EV_LIST_ITEM_LIST; parent: EV_CONTAINER; element: XML_ELEMENT) is
		local
			current_element: XML_ELEMENT
			info: HASH_TABLE [XML_ELEMENT, STRING]
		do
			info ?= get_single_level_attributes (element)
			if info /= Void then
				if info.item ("EV_LIST_ITEM_ACTION_SEQUENCES") /= Void then
					-- FIXME Implement
				end
			end
			from
				element.start
			until
				element.off
			loop
				current_element ?= element.item_for_iteration
				if current_element /= Void then
					if current_element.name.to_utf8.is_equal ("item") then
						add_item_to_item_holder (list_item_list, clone(current_element))
					end
				end
				element.forth
			end
		end

	setup_EV_LIST_ITEM (list_item: EV_LIST_ITEM; parent: EV_ITEM_LIST [EV_ITEM]; element: XML_ELEMENT) is
		local
			info: HASH_TABLE [XML_ELEMENT, STRING]
		do
			setup_EV_ITEM (list_item, parent, element)
			info := get_single_level_elements (element)
			if info.item ("EV_TEXTABLE") /= Void then
				setup_EV_TEXTABLE (list_item, info.item ("EV_TEXTABLE"))
			end
			if info.item ("EV_SELECTABLE") /= Void then
				setup_EV_SELECTABLE (list_item, info.item ("EV_SELECTABLE"))
			end
			if info.item ("EV_TOOLTIPABLE") /= Void then
				setup_EV_TOOLTIPABLE (list_item, info.item ("EV_TOOLTIPABLE"))
			end
			if info.item ("EV_LIST_ITEM_ACTION_SEQUENCES") /= Void then
				--| FIXME
			end
		end

	setup_EV_ITEM (item: EV_ITEM; parent: EV_ITEM_LIST [EV_ITEM]; element: XML_ELEMENT) is
		local
			info: HASH_TABLE [XML_ELEMENT, STRING]
		do
			info := get_single_level_elements (element)
			if info.item ("EV_PICK_AND_DROPABLE") /= Void then
				setup_EV_PICK_AND_DROPABLE (item, info.item ("EV_PICK_AND_DROPABLE"))
			end
			if info.item ("EV_PIXMAPABLE") /= Void then
				--| FIXME
			end
			if info.item ("EV_ITEM_ACTION_SEQUENCES") /= Void then
				--| FIXME
			end
		end

	setup_EV_LIST (list: EV_LIST; parent: EV_CONTAINER; element: XML_ELEMENT) is
		local
			info: HASH_TABLE [STRING, STRING]
		do
			setup_EV_LIST_ITEM_LIST (list, parent, clone(element))
			info ?= get_single_level_attributes (element)
			if info.item ("multiple_selection_enabled") /= Void then
				if info.item ("multiple_selection_enabled").is_equal ("true") then
					list.enable_multiple_selection
				end
			end
			if info.item ("pixmaps_height") /= Void and info.item ("pixmaps_width") /= Void then
				list.set_pixmaps_size (info.item ("pixmaps_width").to_integer, info.item ("pixmaps_height").to_integer)
			end
		end

	setup_EV_LABEL (label: EV_LABEL; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `label' already contained in `parent' from data held in `element'.
		local
			info: HASH_TABLE [XML_ELEMENT, STRING]
		do
			setup_EV_PRIMITIVE (label, parent, clone (element))
			info := get_single_level_elements (element)
			if info.item ("EV_TEXTABLE") /= Void then
				setup_EV_TEXTABLE (label, info.item ("EV_TEXTABLE"))
			end
			if info.item ("EV_FONTABLE") /= Void then
				--| fixme Implement
			end
			if info.item ("EV_BUTTON_ACTION_SEQUENCES") /= Void then
				--| fixme Implement
			end
		end

	setup_EV_SEPARATOR (separator: EV_SEPARATOR; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `separator' already contained in `parent' from data held in `element'.
		do
			setup_EV_PRIMITIVE (separator, parent, clone (element))
		end

	setup_EV_SPIN_BUTTON (spin_button: EV_SPIN_BUTTON; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `spin_button' already contained in `parent' from data held in `element'.
		local
			info: HASH_TABLE [XML_ELEMENT, STRING]
		do
			setup_EV_GAUGE (spin_button, parent, clone (element))
			info := get_single_level_elements (element)
			if info.item ("EV_TEXT_FIELD_BASIC") /= Void then
				setup_EV_TEXT_FIELD_BASIC (spin_button, info.item ("EV_TEXT_FIELD_BASIC"))
			end
		end

	setup_EV_TEXT_FIELD_BASIC (text_field: EV_TEXT_FIELD; element: XML_ELEMENT) is
			-- Initialize `text_field' from data held in `element'.
		local
			info: HASH_TABLE [ELEMENT_INFORMATION, STRING]
		do
			info := get_unique_full_info (element)
			if info.item ("EV_TEXT_COMPONENT_BASIC") /= Void then
				setup_EV_TEXT_COMPONENT_BASIC (text_field, clone(info.item ("EV_TEXT_COMPONENT_BASIC").element))
			end
			if info.item ("EV_TEXT_FIELD_ACTION_SEQUENCES") /= Void then
				--| FIXME 
			end
			if info.item ("capacity") /= Void then
				text_field.set_capacity (info.item ("capacity").data.to_integer)
			end
		end

	setup_EV_TEXT_COMPONENT_BASIC (text_component: EV_TEXT_COMPONENT; element: XML_ELEMENT) is
			-- Initialize `a_text_component' from data held in `element'.
		local
			info: HASH_TABLE [ELEMENT_INFORMATION, STRING]
		do
			info := get_unique_full_info (element)
			if info.item ("EV_TEXT_COMPONENT_ACTION_SEQUENCES") /= Void then
				--| FIXME implement
			end
			if info.item ("caret_position") /= Void then
				text_component.set_caret_position (info.item ("caret_position").data.to_integer)
			end
			if info.item ("text") /= Void then
				text_component.set_text (info.item ("text").data)
			end
			if info.item ("is_editable") /= Void then
				if info.item ("is_editable").data.is_equal ("true") then
					--| FIXME May need to be implemented.
					--| Cannot think why right now.
				elseif info.item ("is_editable").data.is_equal ("true") then
					text_component.disable_edit
				end
			end
		end


	setup_EV_GAUGE (gauge: EV_GAUGE; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `gauge' already contained in `parent' from data held in `element'.
		local
			info: HASH_TABLE [ELEMENT_INFORMATION, STRING]
		do
			setup_EV_PRIMITIVE (gauge, parent, clone (element))
			info := get_unique_full_info (element)
			if info.item ("EV_GAUGE_ACTION_SEQUENCES") /= Void then
				--| FIXME implement
			end
			if info.item ("leap") /= Void then
				gauge.set_leap (info.item ("step").data.to_integer)
			end
			if info.item ("step") /= Void then
				gauge.set_step (info.item ("step").data.to_integer)
			end
			if info.item ("value") /= Void then
				gauge.set_value (info.item ("value").data.to_integer)
			end
			if info.item ("value_range") /= Void then
				setup_value_range (gauge, info.item ("value_range").element)
			end
		end

	setup_value_range (gauge: EV_GAUGE; element: XML_ELEMENT) is
		local
			info: HASH_TABLE [STRING, STRING]
			integer_interval: INTEGER_INTERVAL
		do
			info ?= get_single_level_attributes (element)
			if info.item ("lower") /= Void then
				create integer_interval.make (info.item ("lower").to_integer, gauge.value_range.upper)
				gauge.value_range.adapt (integer_interval)
			end
			if info.item ("upper") /= Void then
				create integer_interval.make (gauge.value_range.lower, info.item ("upper").to_integer)
				gauge.value_range.adapt (integer_interval)
			end
		end


	setup_EV_DRAWING_AREA (a_drawing_area: EV_DRAWING_AREA; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `a_drawing_area' already contained in `parent' from data held in `element'.
		do
			setup_EV_PRIMITIVE (a_drawing_area, parent, clone (element))
		end

	setup_EV_SCROLL_BAR (a_scroll_bar: EV_SCROLL_BAR; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `a_scroll_bar' already contained in `parent' from data held in `element'.
		do
			setup_EV_GAUGE (a_scroll_bar, parent, clone (element))
		end

	setup_EV_RANGE (a_range: EV_RANGE; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `a_range' already contained in `parent' from data held in `element'.
		do
			setup_EV_GAUGE (a_range, parent, clone (element))
		end

	setup_EV_BUTTON (a_button: EV_BUTTON; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `a_button' already contained in `parent' from data held in `element'.
		local
			current_element: XML_ELEMENT
			info: HASH_TABLE [XML_ELEMENT, STRING]
		do
			setup_EV_PRIMITIVE (a_button, parent, clone (element))
			info := get_single_level_elements (element)
			if info.item ("EV_TEXTABLE") /= Void then
				setup_EV_TEXTABLE (a_button, info.item ("EV_TEXTABLE"))
			end
			if info.item ("EV_PIXMAPABLE") /= Void then
				--| fixme Implement
			end
			if info.item ("EV_BUTTON_ACTION_SEQUENCES") /= Void then
				--| fixme Implement
			end
		end

	setup_EV_TOGGLE_BUTTON (a_toggle_button: EV_TOGGLE_BUTTON; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `a_toggle_button' already contained in `parent' from data held in `element'.
		local
			current_element: XML_ELEMENT
			info: HASH_TABLE [XML_ELEMENT, STRING]
		do
			setup_EV_BUTTON (a_toggle_button, parent, clone (element))
			info := get_single_level_elements (element)
			if info.item ("EV_SELECTABLE") /= Void then
				setup_EV_SELECTABLE (a_toggle_button, info.item ("EV_SELECTABLE"))
			end
		end

	setup_EV_RADIO_BUTTON (a_radio_button: EV_RADIO_BUTTON; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `a_radio_button' already contained in `parent' from data held in `element'.
		local
			current_element: XML_ELEMENT
			info: HASH_TABLE [XML_ELEMENT, STRING]
		do
			setup_EV_BUTTON (a_radio_button, parent, clone (element))
			info := get_single_level_elements (element)
			if info.item ("EV_SELECTABLE") /= Void then
				setup_EV_SELECTABLE (a_radio_button, info.item ("EV_SELECTABLE"))
			end
		end
		
	setup_EV_WIDGET (widget: EV_WIDGET; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `widget' already contained in `parent' from data held in `element'.
		local
			split_area: EV_SPLIT_AREA
			box: EV_BOX
			info: HASH_TABLE [ELEMENT_INFORMATION, STRING]
		do
			info := get_unique_full_info (element)
			if info.item ("EV_PICK_AND_DROPABLE") /= Void then
				--| FIXME implement
			end
			if info.item ("EV_SENSITIVE") /= Void then
				setup_EV_SENSITIVE (widget, clone(info.item ("EV_SENSITIVE").element))
			end
			if info.item ("EV_COLORIZABLE") /= Void then
				setup_EV_COLORIZABLE (widget, clone (info.item ("EV_COLORIZABLE").element))
			end
			if info.item ("EV_POSITIONED") /= Void then
				setup_EV_POSITIONED (widget, clone (info.item ("EV_POSITIONED").element))
			end
			if info.item ("actual_drop_target_agent") /= Void then
				--| FIXME implement
			end
			if info.item ("is_show_requested") /= Void then
				if info.item ("is_show_requested").data.is_equal ("false") then
					widget.hide
				else
					widget.show
				end
			end
			--| FIXME Pointer_style needs implementing here.
			if info.item ("expandable") /= Void then
				if info.item ("expandable").data.is_equal ("false") then
						-- Only split area and box have disable_item_expand (09/15/2000).
						-- If any other containers ever get this feature then this
						-- routine must be updated.
					split_area ?= parent
					if split_area /= Void and then split_area.first /= widget then
						split_area.disable_item_expand (widget)
					else
						box ?= parent
						if box /= Void then
							box.disable_item_expand (widget)
						end
					end	
				end
			end
			if info.item ("has_focus") /= Void then
				if info.item ("has_focus").data.is_equal ("true") then
					widget.set_focus
				end
			end
		end
				
	setup_EV_PRIMITIVE (primitive: EV_PRIMITIVE; parent: EV_CONTAINER; element: XML_ELEMENT) is
			-- Initialize `primitive' already contained in `parent' from data held in `element'.
		local
			info: HASH_TABLE [XML_ELEMENT, STRING]
		do
			setup_EV_WIDGET (primitive, parent, clone (element))
			info := get_single_level_elements (element)
			if info.item ("EV_TOOLTIPABLE") /= Void then
				setup_EV_TOOLTIPABLE (primitive, info.item ("EV_TOOLTIPABLE"))
			end
		end

	setup_EV_TEXTABLE (textable: EV_TEXTABLE; element: XML_ELEMENT) is
			-- Initialize `textable' from data held in `element'.
		local
			info: HASH_TABLE [STRING, STRING]
		do
			info ?= get_single_level_attributes (element)
			if info.item ("text") /= Void then
				textable.set_text (info.item ("text"))
			end
			if info.item ("alignment") /= Void then
				if info.item ("alignment").is_equal ("left") then
					textable.align_text_left
				elseif info.item ("alignment").is_equal ("center") then
					textable.align_text_center
				elseif info.item ("alignment").is_equal ("right") then
					textable.align_text_right
				end
			end
		end
	

	setup_EV_TOOLTIPABLE (tooltipable: EV_TOOLTIPABLE; element: XML_ELEMENT) is
			-- Initialize `tooltipable' from data held in `element'.
		local
			info: HASH_TABLE [STRING, STRING]
		do
			info ?= get_single_level_attributes (element)
			if info.item ("tooltip") /= Void then
				tooltipable.set_tooltip (info.item ("tooltip"))
			end
		end
		

	setup_EV_SELECTABLE (selectable: EV_SELECTABLE; element: XML_ELEMENT) is
			-- Initialize `selectable' from data held in `element'.
		local
			info: HASH_TABLE [STRING, STRING]
		do
			info ?= get_single_level_attributes (element)
			if info.item ("is_selected") /= Void then
				if info.item ("is_selected").is_equal ("true") then
					selectable.enable_select
				end
			end
		end
		
	setup_EV_PICK_AND_DROPABLE (pick_and_dropable:EV_PICK_AND_DROPABLE; element: XML_ELEMENT) is
			-- Initialize `pick_and_dropable' from data held in `element'.
		do
			--| FIXME
		end

	setup_EV_SENSITIVE (sensitive: EV_SENSITIVE; element: XML_ELEMENT) is
			-- Initialize `sensitive' from data held in `element'.
		local
			info: HASH_TABLE [STRING, STRING]
		do
			info ?= get_single_level_attributes (element)
			if info.item ("is_sensitive") /= Void then
				if info.item ("is_sensitive").is_equal ("true") then
					sensitive.enable_sensitive
				else
					sensitive.disable_sensitive
				end
			end
		end
		
	setup_EV_POSITIONED (positioned: EV_POSITIONED; element: XML_ELEMENT) is
			-- Initialize `positioned' from data held in `element'.
		local
			info: HASH_TABLE [STRING, STRING]
			widget: EV_WIDGET
		do
			widget ?= positioned
			if widget /= Void then
				info ?= get_single_level_attributes (element)
				if info.item ("minimum_width") /= Void then
					widget.set_minimum_width (info.item ("minimum_width").to_integer) 
				end
				if info.item ("minimum_height") /= Void then
					widget.set_minimum_height (info.item ("minimum_height").to_integer) 
				end
			end
		end

	setup_EV_POSITIONABLE (positionable: EV_POSITIONABLE; element: XML_ELEMENT) is
			-- Initialize `positionable' from data held in `element'.
		require
			positionable_not_void: positionable /= Void
			element_not_void: element /= Void
		local
			info: HASH_TABLE [STRING, STRING]
		do
			info ?= get_single_level_attributes (element)
			if info.item ("width") /= Void then
				positionable.set_width (info.item ("width").to_integer) 
			end
			if info.item ("height") /= Void then
				positionable.set_height (info.item ("height").to_integer) 
			end
			if info.item ("x_position") /= Void then
				positionable.set_x_position (info.item ("x_position").to_integer) 
			end
			if info.item ("y_position") /= Void then
				positionable.set_y_position (info.item ("y_position").to_integer) 
			end
		end

	setup_EV_COLORIZABLE (colorizable: EV_COLORIZABLE; element: XML_ELEMENT) is
			-- Initialize `colorizable' from data held in `element'.
		require
			colorizable_not_void: colorizable /= Void
			element_not_void: element /= Void
		local
			info: HASH_TABLE [XML_ELEMENT, STRING]
		do
			info ?= get_single_level_elements (element)
			if info.item ("foreground_color") /= Void then
				setup_foreground_color (colorizable, info.item ("foreground_color"))
			end
			if info.item ("background_color") /= Void then
				setup_background_color (colorizable, info.item ("background_color"))
			end
		end

	setup_foreground_color (colorizable: EV_COLORIZABLE; element: XML_ELEMENT) is
		local
			info: HASH_TABLE [STRING, STRING]
			red, green, blue: INTEGER
			temp_color: EV_COLOR
		do
			info ?= get_single_level_attributes (element)
			if info.item ("red") /= Void then
				red := info.item ("red").to_integer
			end
			if info.item ("green") /= Void then
				green := info.item ("green").to_integer
			end
			if info.item ("blue") /= Void then
				blue := info.item ("blue").to_integer
			end
			create temp_color.make_with_8_bit_rgb (red, green, blue)
			colorizable.set_foreground_color (temp_color)
		end

	setup_background_color (colorizable: EV_COLORIZABLE; element: XML_ELEMENT) is
		local
			info: HASH_TABLE [STRING, STRING]
			red, green, blue: INTEGER
			temp_color: EV_COLOR
		do
			info ?= get_single_level_attributes (element)
			if info.item ("red") /= Void then
				red := info.item ("red").to_integer
			end
			if info.item ("green") /= Void then
				green := info.item ("green").to_integer
			end
			if info.item ("blue") /= Void then
				blue := info.item ("blue").to_integer
			end
			create temp_color.make_with_8_bit_rgb (red, green, blue)
			colorizable.set_background_color (temp_color)
		end

	load_and_parse_xml_file (a_filename:STRING) is
			-- Load file `a_filename' and parse.
		local
			temp_window: EV_TITLED_WINDOW
			error_dialog:EV_ERROR_DIALOG
		do
			parse_file (a_filename)
			if not parser.is_correct then
				create temp_window
				create error_dialog.make_with_text ("Invalid XML Schema.")
				error_dialog.show_modal_to_window (temp_window)
				temp_window.destroy
			else
				create_system
			end
		end

feature {NONE} -- Implementation

	parse_file (filename: STRING) is
			-- Parse XML file `filename' with `parser'.
		local
			file: RAW_FILE
			buffer: STRING
		do
			create file.make_open_read (filename)
			create buffer.make (file.count) 
			file.start
			file.read_stream (file.count)
			buffer := file.last_string
			parser.parse_from_string (buffer)
			parser.set_end_of_document
		end

		-- The XML parser.
	parser: XML_TREE_PARSER

		-- Constant used for matching type identifier.
	type: UCSTRING

end -- class APPLICATION_GENERATOR
