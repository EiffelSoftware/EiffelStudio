<document title="EiffelVision Introduction">
	<meta_data>
		<help>
			<toc>
				<envision_location>Class Libraries\EiffelVision 2</envision_location>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph>   The EiffelVision library offers an object-oriented framework for graphical user interface (GUI) development. Using EiffelVision, developers can access all necessary GUI components, called 
			<link>
				<url>/libraries/vision2/content/10_widgets/index.xml</url>
				<label>widgets</label>
			</link> (buttons, windows, listviews) as well as truly graphical elements such as points, lines, arcs, polygons and the like -- to develop a modern, functional and good-looking graphical interactive application.  
		</paragraph>
		<paragraph>  EiffelVision has played a major role in ISE Eiffel and provided numerous Eiffel projects with a powerful, portable graphics development platform.  EiffelStudio is totally reliant on EiffelVision for its graphical  elements and overall interaction with the user. </paragraph>
		<list ordered="false">
			<item>
				<link>
					<url>content/index.xml</url>
					<label>Content</label>
				</link>
			</item>
			<item>
				<link>
					<url>samples/index.xml</url>
					<label>Samples</label>
				</link>
			</item>
			<item>
				<link>
					<url>reference/index.xml</url>
					<label>Reference</label>
				</link>
			</item>
		</list>
		<heading>
			<size>2</size>Scope
		</heading>
		<paragraph>  The EiffelVision library addresses all the major needs of developers of systems supporting modern graphical interfaces.  EiffelVision runs on Microsoft Windows and all major variations of Unix (including Linux). All versions are fully source-compatible; with only a recompile, applications will run on every supported platform with the native look-and-feel. </paragraph>
		<paragraph>  EiffelVision provides an effective way of building advanced graphical applications using user interface standards and toolkits (such as Microsoft Windows and GTK) without having to learn the details of the toolkits. Instead, you can use EiffelVision to work entirely in terms of high level abstractions representing windows, buttons, labels, graphical figures, menus, buttons etc., and apply clearly understandable operations to the corresponding objects. </paragraph>
		<heading>
			<size>2</size>Architecture
		</heading>
		<paragraph>  EiffelVision relies on a two-tiered architecture illustrated by the following figure. </paragraph>
		<image> 
			<url>figure1.png</url>
		</image>
		<paragraph>  The two tiers play complementary roles: </paragraph>
		<list ordered="false">
			<item>At the top level, EiffelVision provides fully portable graphics.</item>
			<item>At the lower level, platform-specific libraries cover the graphical mechanisms of graphics platforms such as Windows and GTK.</item>
		</list>
		<paragraph>  The lower tier serves for the implementation of the upper tier, but can also be used independently. For example 
			<link>
				<url>/libraries/wel/00_introduction.xml</url>
				<label>WEL</label>
			</link> has had a resounding success with Windows developers who need an advanced mechanism for building Windows-specific graphical applications, taking advantage of every facility of the Windows API  (Application Programming Interface) and of the Eiffel approach, but do not need portability on the client side. The GEL library is a 
			<bold>wrapper</bold> library, automatically generated from the entire GTK API by a tool named 
			<bold>The Gote Converter</bold>. 
		</paragraph>
		<heading>
			<size>2</size>Features
		</heading>
		<paragraph>  As stated before, the library has undergone some drastic changes since the previous release. Names have been changed to improve consistency. Contracts are added whereever possible. Following is a summary of the other re-engineered aspects of the library: </paragraph>
		<list ordered="false">
			<item>Taking full advantage of the 
				<bold>agent</bold> mechanism of Eiffel, 
				<link>
					<url>/libraries/vision2/content/30_events/index.xml</url>
					<label>events</label>
				</link> are now triggered through 
				<bold>action sequences</bold> (lists of actions) that will be executed in order. This system does not require separate classes to be written for each event, however the command pattern can still be used if desired.
			</item>
			<item>The 
				<link>
					<url>/libraries/vision2/content/40_properties/ev_pick_and_dropable.xml</url>
					<label>pick-and-drop</label>
				</link> mechanism now relies on the Eiffel type system. A 
				<bold>stone</bold> (some transportable object) is now any Eiffel class and can always be dropped on a widget that accepts the type (or a more general type) of that stone.
			</item>
			<item>
				<link>
					<url>/libraries/vision2/content/10_widgets/10_containers/index.xml</url>
					<label>containers</label>
				</link> ( 
				<link>
					<url>/libraries/vision2/content/10_widgets/index.xml</url>
					<label>widgets</label>
				</link> that contain other 
				<link>
					<url>/libraries/vision2/content/10_widgets/index.xml</url>
					<label>widgets</label>
				</link>) are now derived from 
				<link>
					<url>/libraries/base/00_introduction.xml</url>
					<label>EiffelBase</label>
				</link> classes. For example you can now insert 
				<link>
					<url>/libraries/vision2/content/10_widgets/index.xml</url>
					<label>widgets</label>
				</link> in any position and iterate over them.
			</item>
		</list>
		<heading>
			<size>2</size>Design
		</heading>
		<paragraph>EiffelVision provides programmers with high-level classes, that provide all mechanism and data structures needed to build advanced user interfaces for deployment on almost all platforms without having to worry about detailed requirements of toolkits.</paragraph>
		<paragraph>The abstract design has been derived from an analysis of user interfaces. Therefore we have classes with names like MENU, WINDOW, BUTTON, LINE or POLYGON. The features of these classes are simple, clearly defined properties or commands, like the feature `minimize' (a command) on WINDOW or `text' (a property of type STRING) on BUTTON.</paragraph>
		<note>
			<bold>Note</bold>: all class names in EiffelVision are  pre-pended with EV_ to avoid name clashes with existing classes. BUTTON hence becomes <code><class_name>EV_BUTTON</class_name></code>, etc. 
		</note>
		<heading>
			<size>2</size>Properties
		</heading>
		<paragraph>When talking about a property of a class, like `text', in fact we are talking about multiple features. One is a query of the state of the property, in this case simply the query `text'. The other is the set-routine, which is by convention named `set_text' taking exactly one argument of the type of property. A property can be read-only, which means that it cannot be set by clients of the class.</paragraph>
<code_block>
	<feature_name>text</feature_name><symbol>:</symbol> <class_name>STRING</class_name>
	<feature_name>set_text</feature_name> <symbol>(</symbol>a_text<symbol>:</symbol> <class_name>STRING</class_name><symbol>)</symbol> <keyword>is</keyword> <feature_name></feature_name>.<feature_name></feature_name>.<feature_name></feature_name>.<feature_name></feature_name>
</code_block>
		<paragraph>  Boolean properties have a different convention. Instead of one set-routine, it has one enable-routine and one disable-routine. The first one sets the property to true, the second to false. This has been done like this because sometimes these enable/disable features have trivial equivalents, for example for feature `enable_visible' a clearer name is `show'. </paragraph>
<code_block>
	<feature_name>is_sensitive</feature_name><symbol>:</symbol> <class_name>BOOLEAN</class_name>
	<feature_name>enable_sensitive</feature_name> <keyword>is</keyword> <feature_name></feature_name>.<feature_name></feature_name>.<feature_name></feature_name>.<feature_name></feature_name> 
	<feature_name>disable_sensitive</feature_name> <keyword>is</keyword> <feature_name></feature_name>.<feature_name></feature_name>.<feature_name></feature_name>.<feature_name></feature_name> 
</code_block>
		<heading>
			<size>2</size>Implementation
		</heading>
		<paragraph>  For flexibility, EiffelVision is built using the bridge pattern. This means that every platform-dependant component of the library consist of two classes, plus an implementation class for each platform (currently two). One is the 
			<link>
				<url>/libraries/vision2/reference/interface/index.xml</url>
				<label>interface</label>
			</link>. All the features of interfaces do nothing except delegate the call to the implementation object which is coupled to it. This object has the static type of the implementation-interface with the name of the interface class, with _I appended to it. From this implementation-interface, implementation classes inherit to implement platform-specific features. 
		</paragraph>
	</paragraph></document>
