<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML XMLNS:MSHelp="http://msdn.microsoft.com/mshelp">
	<XML>
		<MSHelp:Keyword Index="K" Term="Eiffel Tutorial, Agents" />
		<MSHelp:Attr Name="Product" Value="Eiffel"/>
		<MSHelp:Attr Name="Locale" Value="kbEnglish"/>
	</XML>
	<HEAD>
		<TITLE>An Eiffel Tutorial, Agents</TITLE>
		<LINK HREF="../../../default.css" TYPE="text/css" REL="STYLESHEET">
	</HEAD>
	<BODY>
		<TABLE CLASS="HEADER">
			<TR>
				<TD CLASS="HEADER">Eiffel ENViSioN!</TD>
			</TR>
			<TR>
				<TD CLASS="SUBHEADER">An Eiffel Tutorial, Agents</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FRAME">
			<TR>
				<TD>
					<A NAME="pgfId-555122"></A>
					<P>Our last mechanism, agents, adds one final level of
					expressive power to the framework describe so far.
					Agents apply object-oriented concepts to the modeling of
					<SPAN CLASS="italics">operations</SPAN>.</P>

					<H2>Objects for operations</H2>

					<P>Operations are not objects; in fact, object technology
					starts from the decision to separate these two aspects, and
					to choose object types, rather than the operations, as the
					basis for modular organization of a system, attaching each
					operation to the resulting modules -- the classes.</P>

					<P>In a number of applications, however, we may need objects
					that <SPAN CLASS="italics">represent</SPAN> operations, so
					that we can include them in object structures that some other
					piece of the software will later traverse to uncover the
					operations and, usually, execute them. Such "operation
					wrapper" objects, called agents, are useful in a number of
					application areas such as:</P>

					<UL>
						<LI>GUI (Graphical User Interface) programming, where we
						may associate an agent with a certain event of the
						interface, such as a mouse click at a certain place on
						the screen, to prescribe that if the event occurs -- a
						user clicks there -- it must cause execution of the
						agent's associated operation.</LI>

						<LI>Iteration on data structures, where we may define a
						general-purpose routine that can apply an arbitrary
						operation to all the elements of a structure such as a
						list; to specify a particular operation to iterate, we
						will pass to the iteration mechanism an agent
						representing that operation.</LI>

						<LI>Numerical computation, where we may define a routine
						that computes the integral of any applicable function on
						any applicable interval; to represent that function and
						pass its representation to the integration routine, we
						will use an agent.</LI>
					</UL>

					<P>Operations in Eiffel are expressed as routines, and indeed
					every agent will have an associated routine. Remember,
					however, that the fundamental distinction between objects and
					operations remains: an agent is an object, and it is not a
					routine; it <SPAN CLASS="italics">represents</SPAN> a routine.
					As further evidence that this is a proper data abstraction,
					note that the procedure <SPAN CLASS="efeature">call</SPAN>,
					available on all agents to call the associated routine, is
					only one of the features of agents. Other features may denote
					properties such as the class to which the routine belongs,
					its precondition and postcondition, the result of the last
					call for a function, the number of arguments.</P>

					<H2>Building an agent</H2>

					<P>In the simplest form, also one of the most common, you
					obtain an agent just by writing</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">agent</SPAN>
						<SPAN CLASS="efeature">r</SPAN></P>
					</CODE>

					<P>where <SPAN CLASS="efeature">r</SPAN> is the name of a
					routine of the enclosing class. This is an expression, which
					you may assign to a writable entity, or pass as argument to a
					routine. Here for example is how you will specify event
					handling in the style of the EiffelVision 2 GUI library:</P>

					<CODE>
						<P><SPAN CLASS="elocal">your_icon</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">click_actions</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">extend</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">agent</SPAN>
						<SPAN CLASS="efeature">your_routine</SPAN><SPAN CLASS="esymbol">)</SPAN></P>
					</CODE>

					<P>This adds to the end of
					<SPAN CLASS="elocal">my_icon</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">click_actions</SPAN>
					-- the list of agents associated with the "click" event for
					<SPAN CLASS="elocal">my_icon</SPAN>, denoting an icon in the
					application's user interface -- an agent representing
					<SPAN CLASS="efeature">your_routine</SPAN>. Then when a user
					clicks on the associated icon at execution, the EiffelVision
					2 mechanisms will call the procedure
					<SPAN CLASS="efeature">call</SPAN> on every agent of the
					list, which for this agent will execute
					<SPAN CLASS="efeature">your_routine</SPAN>. This is a simple
					way to associate elements of your application, more precisely
					its "business model" (the processing that you have defined,
					directly connected to the application's business domain),
					with elements of its GUI.</P>

					<P>Similarly although in a completely different area, you may
					request the integration of a function
					<SPAN CLASS="efeature">your_function</SPAN> over the interval
					<SPAN CLASS="enumber">0</SPAN><SPAN CLASS="edot">..</SPAN><SPAN CLASS="enumber">1</SPAN>
					through a call such as</P>

					<CODE>
						<P><SPAN CLASS="elocal">your_integrator</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">integral</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">agent</SPAN>
						<SPAN CLASS="efeature">your_function</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="enumber">0</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="enumber">1</SPAN><SPAN CLASS="esymbol">)</SPAN></P>
					</CODE>

					<P>In the third example area cited above, you may call an
					iterator of EiffelBase through</P>

					<CODE>
						<P><SPAN CLASS="elocal">your_list</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">do_all</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">agent</SPAN>
						<SPAN CLASS="efeature">your_proc</SPAN><SPAN CLASS="esymbol">)</SPAN></P>
					</CODE>

					<P>with <SPAN CLASS="elocal">your_list</SPAN> of a type such
					as <SPAN CLASS="eclass">LIST</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">YOUR_TYPE</SPAN><SPAN CLASS="esymbol">]</SPAN>.
					This will apply <SPAN CLASS="efeature">your_proc</SPAN> to
					every element of the list in turn.</P>

					<P>The agent mechanism is type-checked like the rest of
					Eiffel; so the last example is valid if and only if
					<SPAN CLASS="efeature">your_proc</SPAN> is a procedure with
					one argument of type <SPAN CLASS="eclass">YOUR_TYPE</SPAN>.</P>

					<H2>Operations on agents</H2>

					<P>An agent <SPAN CLASS="ekeyword">agent</SPAN>
					<SPAN CLASS="efeature">r</SPAN> built from a procedure
					<SPAN CLASS="efeature">r</SPAN> is of type
					<SPAN CLASS="eclass">PROCEDURE</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">T</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="eclass">ARGS</SPAN><SPAN CLASS="esymbol">]</SPAN>
					where<SPAN CLASS="eclass">T</SPAN> represents the class to
					which <SPAN CLASS="efeature">r</SPAN> belongs and
					<SPAN CLASS="eclass">ARGS</SPAN> the type of its arguments.
					If <SPAN CLASS="efeature">r</SPAN> is a function of result
					type <SPAN CLASS="eclass">RES</SPAN>, the type is
					<SPAN CLASS="eclass">FUNCTION</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">T</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="eclass">ARGS</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="eclass">RES</SPAN><SPAN CLASS="esymbol">]</SPAN>.
					Classes <SPAN CLASS="eclass">PROCEDURE</SPAN> and
					<SPAN CLASS="eclass">FUNCTION</SPAN> are from the Kernel
					Library of EiffelBase, both inheriting from
					<SPAN CLASS="eclass">ROUTINE</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">T</SPAN>
					<SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="eclass">ARGS</SPAN><SPAN CLASS="esymbol">]</SPAN>.
					</P>

					<P>Among the features of <SPAN CLASS="eclass">ROUTINE</SPAN>
					and its descendants the most important are
					<SPAN CLASS="efeature">call</SPAN>, already noted, which
					calls the associated routine, and
					<SPAN CLASS="efeature">item</SPAN>, appearing only in
					<SPAN CLASS="eclass">FUNCTION</SPAN> and yielding the result
					of the associated function, which it obtains by calling
					<SPAN CLASS="efeature">call</SPAN>.</P>

					<P>As an example of using these mechanisms, here is how the
					function <SPAN CLASS="efeature">integral</SPAN> could look
					like in our <SPAN CLASS="eclass">INTEGRATOR</SPAN> example
					class. The details of the integration algorithm
					(straightforward, and making no claims to numerical
					sophistication) do not matter, but you see, in the
					highlighted line, the place were we evaluate the
					mathematical function associated with
					<SPAN CLASS="efeature">f</SPAN>, by calling
					<SPAN CLASS="efeature">item</SPAN> on
					<SPAN CLASS="efeature">f</SPAN>:</P>

					<CODE>
						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">integral</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">f</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">FUNCTION</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">ANY</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="eclass">TUPLE</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">REAL</SPAN><SPAN CLASS="esymbol">],</SPAN>
						<SPAN CLASS="eclass">REAL</SPAN><SPAN CLASS="esymbol">];</SPAN>
						<SPAN CLASS="elocal">low</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="elocal">high</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">REAL</SPAN><SPAN CLASS="esymbol">):</SPAN>
						<SPAN CLASS="eclass">REAL</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Integral of
						<SPAN CLASS="efeature">f</SPAN> over the interval
						[<SPAN CLASS="elocal">low</SPAN>,
						<SPAN CLASS="elocal">high</SPAN>]</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">require</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">meaningful_interval:</SPAN>
						<SPAN CLASS="elocal">low</SPAN>
						<SPAN CLASS="efeature">&lt;=</SPAN>
						<SPAN CLASS="elocal">high</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">local</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">REAL</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">from</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="elocal">x</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="elocal">low</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">invariant</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="elocal">x</SPAN>
						<SPAN CLASS="efeature">&gt;=</SPAN>
						<SPAN CLASS="elocal">low</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="elocal">x</SPAN>
						<SPAN CLASS="efeature">&lt;=</SPAN>
						<SPAN CLASS="elocal">high</SPAN>
						<SPAN CLASS="efeature">+</SPAN>
						<SPAN CLASS="efeature">step</SPAN>
						</P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">--
						<SPAN CLASS="ekeyword">Result</SPAN> approximates the
						integral over</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- the interval [<SPAN CLASS="elocal">low</SPAN>,
						<SPAN CLASS="elocal">low</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">max</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN>
						<SPAN CLASS="efeature">-</SPAN>
						<SPAN CLASS="efeature">step</SPAN><SPAN CLASS="esymbol">)</SPAN>]</SPAN>
						</P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">until</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="elocal">x</SPAN>
						<SPAN CLASS="efeature">&gt;</SPAN>
						<SPAN CLASS="elocal">high</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">loop</SPAN></P>

						<P class="warning">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">Result</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="ekeyword">Result</SPAN>
						<SPAN CLASS="efeature">+</SPAN>
						<SPAN CLASS="efeature">step</SPAN>
						<SPAN CLASS="efeature">*</SPAN>
						<SPAN CLASS="elocal">f</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">item</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">)</SPAN>
						</P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="elocal">x</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="elocal">x</SPAN>
						<SPAN CLASS="efeature">+</SPAN>
						<SPAN CLASS="efeature">step</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>Function <SPAN CLASS="efeature">integral</SPAN> takes
					three arguments: the agent <SPAN CLASS="elocal">f</SPAN>
					representing the function to be integrated, and the two
					interval bounds. When we need to evaluate that function for
					the value <SPAN CLASS="elocal">x</SPAN>, in the line</P>

					<P CLASS="warning">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
					<SPAN CLASS="ekeyword">Result</SPAN>
					<SPAN CLASS="esymbol">:=</SPAN>
					<SPAN CLASS="ekeyword">Result</SPAN>
					<SPAN CLASS="efeature">+</SPAN>
					<SPAN CLASS="efeature">step</SPAN>
					<SPAN CLASS="efeature">*</SPAN>
					<SPAN CLASS="elocal">f</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">item</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">)</SPAN>
					</P>

					<P>we don't directly pass <SPAN CLASS="elocal">x</SPAN>
					to <SPAN CLASS="efeature">item</SPAN>; instead, we pass a
					one-element tuple
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">]</SPAN>,
					using the syntax for manifest tuples introduced in
					<A HREF="tutorial-11.html#36752">"Tuple types"</A>. You will
					always use tuples for the argument to
					<SPAN CLASS="efeature">call</SPAN> and
					<SPAN CLASS="efeature">item</SPAN>, because these features
					must be applicable to <SPAN CLASS="italics">any</SPAN>
					routine, and so cannot rely on a fixed number of arguments.
					Instead they take a single tuple intended to contain all the
					arguments. This property is reflected in the type of the
					second actual generic parameter to
					<SPAN CLASS="elocal">f</SPAN>, corresponding to
					<SPAN CLASS="estring">ARGS</SPAN> (the formal generic
					parameter of <SPAN CLASS="eclass">FUNCTION</SPAN>): here it's
					<SPAN CLASS="eclass">TUPLE</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">REAL</SPAN><SPAN CLASS="esymbol">]</SPAN>
					to require an argument such as
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">]</SPAN>,
					where <SPAN CLASS="elocal">x</SPAN> is of type
					<SPAN CLASS="eclass">REAL</SPAN>.</P>

					<P>Similarly, consider the agent that the call seen above:</P>

					<CODE>
						<P><SPAN CLASS="elocal">your_icon</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">click_actions</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">extend</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">agent</SPAN>
						<SPAN CLASS="efeature">your_routine</SPAN><SPAN CLASS="esymbol">)</SPAN></P>
					</CODE>

					<P>added to an EiffelVision list. When the EiffelVision
					mechanism detects a mouse click event, it will apply to each
					element <SPAN CLASS="efeature">item</SPAN> of the list of
					agents,
					<SPAN CLASS="elocal">your_icon</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">click_actions</SPAN>,
					an instruction such as</P>

					<CODE>
						<P><SPAN CLASS="efeature">item</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">call</SPAN>
						<SPAN CLASS="esymbol">([</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">])</SPAN></P>
					</CODE>

					<P>>where <SPAN CLASS="elocal">x</SPAN> and
					<SPAN CLASS="elocal">y</SPAN> are the coordinates of the
					mouse clicking position. If
					<SPAN CLASS="efeature">item</SPAN> denotes the list element
					<SPAN CLASS="ekeyword">agent</SPAN> your_routine, inserted by
					the above call to <SPAN CLASS="efeature">extend</SPAN>, the
					effect will be the same as that of calling</P>

					<CODE>
						<P><SPAN CLASS="efeature">your_routine</SPAN><SPAN CLASS="esymbol">(</SPAN>
						<SPAN CLASS="local">x</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">)</SPAN></P>
					</CODE>

					<P>assuming that <SPAN CLASS="efeature">your_routine</SPAN>
					indeed takes arguments of the appropriate type, here
					<SPAN CLASS="eclass">INTEGER</SPAN> representing a
					coordinate in pixels. (Otherwise type checking would have
					rejected the call to <SPAN CLASS="efeature">extend</SPAN>).</P>

					<H2>Open and closed arguments</H2>

					<P>In the examples so far, execution of the agent's
					associated routine, through
					<SPAN CLASS="efeature">item</SPAN> or
					<SPAN CLASS="efeature">call</SPAN>, passed exactly the
					arguments that a direct call to the routine would expect.
					You can have more flexibility. In particular, you may build
					an agent from a routine with more arguments than expected in
					the final call, and you may set the values of some arguments
					at the time you define the agent.</P>

					<P>Assume for example that a cartographical application lets
					a user record the location of a city by clicking on the
					corresponding position on the map. The application may do
					this through a procedure</P>

					<CODE>
						<P><SPAN CLASS="efeature">record_city</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">cn</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">STRING</SPAN><SPAN CLASS="esymbol">;</SPAN>
						<SPAN CLASS="elocal">pop</SPAN><SPAN CLASS="esyombol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">;</SPAN>
						<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Record that the city of name
						<SPAN CLASS="elocal">name</SPAN> is at coordinates</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- <SPAN CLASS="elocal">x</SPAN>
						and <SPAN CLASS="elocal">y</SPAN> with population
						<SPAN CLASS="elocal">pop</SPAN>.</SPAN></P>
					</CODE>

					<P>Then you can associate it with the GUI through a call such
					as</P>

					<CODE>
						<P><SPAN CLASS="elocal">map</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">click_actions</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">extend</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">agent</SPAN>
						<SPAN CLASS="efeature">record_city</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">name</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="elocal">population</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="ekeyword">?</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="ekeyword">?</SPAN><SPAN CLASS="esymbol">))</SPAN></P>
					</CODE>

					<P>assuming that the information on the
					<SPAN CLASS="elocal">name</SPAN> and the
					<SPAN CLASS="elocal">population</SPAN> has already been
					determined. What the agent denotes is the same as
					<SPAN CLASS="ekeyword">agent</SPAN>
					<SPAN CLASS="efeature">your_routine</SPAN> as given before,
					where <SPAN CLASS="efeature">your_routine</SPAN> would be a
					fictitious two-argument routine obtained from record_city --
					a four-argument routine -- by setting the first two arguments
					once and for all to the values given,
					<SPAN CLASS="elocal">name</SPAN> and
					<SPAN CLASS="elocal">population</SPAN>.</P>

					<P>In the agent <SPAN CLASS="ekeyword">agent</SPAN>
					<SPAN CLASS="efeature">record_city</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">name</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="elocal">population</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="ekeyword">?</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="ekeyword">?</SPAN><SPAN CLASS="esymbol">)</SPAN>,
					we say that these first two arguments, with their set values,
					are <SPAN CLASS="bold">closed</SPAN>; the last two are
					<SPAN CLASS="bold">open</SPAN>. The question mark syntax
					introduced by this example may only appear in agent
					expressions; it denotes open arguments. This means, by the
					way, that you may view the basic form used in the preceding
					examples, <SPAN CLASS="ekeyword">agent</SPAN> your_routine,
					as an abbreviation -- assuming your_routine has two arguments
					-- for <SPAN CLASS="ekeyword">agent</SPAN>
					<SPAN CLASS="efeature">your_routine</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">?</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="ekeyword">?</SPAN><SPAN CLASS="esymbol">)</SPAN>.
					It is indeed permitted, to define an agent with all arguments
					open, to omit the argument list altogether; no ambiguity may
					result.</P>

					<P>For type checking, <SPAN CLASS="ekeyword">agent</SPAN>
					<SPAN CLASS="efeature">record_city</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">name</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="elocal">population</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="ekeyword">?</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="ekeyword">?</SPAN><SPAN CLASS="esymbol">)</SPAN> and
					<SPAN CLASS="ekeyword">agent</SPAN>
					<SPAN CLASS="efeature">your_routine</SPAN> are acceptable in
					exactly the same situations, since both represent routines
					with two arguments. The type of both is
					<SPAN CLASS="eclass">PROCEDURE</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">ANY</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="eclass">TUPLE</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">]]</SPAN>
					where the tuple type specifies the open operands.</P>

					<P>A completely closed agent, such as
					<SPAN CLASS="ekeyword">agent</SPAN>
					<SPAN CLASS="efeature">your_routine</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="enumber">25</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="enumber">32</SPAN><SPAN CLASS="esymbol">)</SPAN>
					or <SPAN CLASS="ekeyword">agent</SPAN>
					<SPAN CLASS="efeature">record_city</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">name</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="elocal">population</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="enumber">25</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="enumber">32</SPAN><SPAN CLASS="esymbol">)</SPAN>,
					has the type <SPAN CLASS="eclass">TUPLE</SPAN>, with no
					parameters; you will call it with
					<SPAN CLASS="efeature">call</SPAN>
					<SPAN CLASS="esymbol">([  ])</SPAN>, using an empty tuple as
					argument.</P>

					<P>The freedom to start from a routine with an arbitrary
					number of arguments, and choose which ones you want to
					close and which ones to leave open, provides a good part of
					the attraction of the agent mechanism. It means in particular
					that in GUI applications you can limit to the strict minimum
					the "glue" code (sometimes called the
					<SPAN CLASS="italics">controller</SPAN> in the so-called MVC,
					Model-View Controller, scheme of GUI design) between the user
					interface and "business model" parts of a system. A routine
					such as <SPAN CLASS="efeature">record_city</SPAN> is a
					typical example of an element of the business model,
					uninfluenced -- as it should be -- by considerations of user
					interface design. Yet by passing it in the form of an agent
					with partially open and partially closed arguments, you may
					be able to use it <SPAN CLASS="italics">directly</SPAN> in
					the GUI, as shown above, without any "controller" code.</P>

					<P>As another example of the mechanism's versatility, we saw
					above an integral function that could integrate a function of
					one variable over an interval, as in</P>

					<CODE>
						<P><SPAN CLASS="elocal">your_integrator</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">integral</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">agent</SPAN>
						<SPAN CLASS="efeature">your_function</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="enumber">0</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="enumber">1</SPAN><SPAN CLASS="esymbol">))</SPAN>
					</CODE>

					<P>Now assume that <SPAN CLASS="efeature">function3</SPAN>
					takes three arguments. To integrate
					<SPAN CLASS="efeature">function3</SPAN> with two arguments
					fixed, you don't need a new <SPAN CLASS="efeature">integral</SPAN>
					function; just use the same <SPAN CLASS="efeature">integral</SPAN>
					as before, judiciously selecting what to close and what to leave
					open:</P>

					<CODE>
						<P><SPAN CLASS="elocal">your_integrator</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">integral</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">agent</SPAN>
						<SPAN CLASS="efeature">function3</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="enumber">3.5</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="ekeyword">?</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="enumber">6.0</SPAN><SPAN CLASS="esymbol">),</SPAN>
						<SPAN CLASS="enumber">0</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="enumber">1</SPAN><SPAN CLASS="esymbol">)</SPAN></P>
					</CODE>

					<H2>Open targets</H2>

					<P>All the agent examples seen so far were based on routines
					of the enclosing class. This is not required. Feature calls,
					as you remember, were either unqualified, as in
					<SPAN CLASS="efeature">f</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="elocal">y</SPAN><SPAN CLASS="efeature">)</SPAN>,
					or qualified, as in
					<SPAN CLASS="elocal">a</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">g</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">)</SPAN>.
					Agents, too, have a qualified variant as in</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">agent</SPAN>
						<SPAN CLASS="elocal">a</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">g</SPAN></P>
					</CODE>

					<P>which is closed on its target <SPAN CLASS="elocal">a</SPAN>
					and open on the arguments. Variants such as
					<SPAN CLASS="ekeyword">agent</SPAN>
					<SPAN CLASS="elocal">a</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">g</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">)</SPAN>,
					all closed, and <SPAN CLASS="ekeyword">agent</SPAN>
					<SPAN CLASS="elocal">a</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">g</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">?</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">)</SPAN>,
					open on one argument, are all valid.</P>

					<P>You may also want to make the
					<SPAN CLASS="italics">target</SPAN> open. The question mark
					syntax could not work here, since it wouldn't tell us the
					class to which feature <SPAN CLASS="efeature">g</SPAN>
					belongs, known in the preceding examples from the type of
					<SPAN CLASS="elocal">a</SPAN>. As in creation expressions, we
					must list the type explicitly; the convention is the same:
					write the types in braces, as in</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">agent</SPAN>
						<SPAN CLASS="esymbol">{</SPAN><SPAN CLASS="eclass">SOME_TYPE</SPAN><SPAN CLASS="esymbol">}</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">g</SPAN>
						</P>

						<P><SPAN CLASS="ekeyword">agent</SPAN>
						<SPAN CLASS="esymbol">{</SPAN><SPAN CLASS="eclass">SOME_TYPE</SPAN><SPAN CLASS="esymbol">}</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">g</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">?</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="ekeyword">?</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P><SPAN CLASS="ekeyword">agent</SPAN>
						<SPAN CLASS="esymbol">{</SPAN><SPAN CLASS="eclass">SOME_TYPE</SPAN><SPAN CLASS="esymbol">}</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">g</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">?</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

					</CODE>

					<P>The first two of these examples are open on the target and
					both operands; they mean the same. The third is closed on one
					argument, open on the other and on the target.</P>

					<P>These possibilities give even more flexibility to the
					mechanism because they mean that an operation that needs
					agents with certain arguments open doesn't care whether they
					come from an argument or an operand of the original routine.
					This is particularly useful for iterators and means that if
					you have two lists</P>

					<CODE>
						<P><SPAN CLASS="elocal">your_account_list</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">LIST</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">ACCOUNT</SPAN><SPAN CLASS="esymbol">]</SPAN></P>

						<P><SPAN CLASS="elocal">your_integer_list</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">LIST</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">]</SPAN></P>

					</CODE>

					<P>you may write both</P>

					<CODE>
						<P><SPAN CLASS="elocal">your_acccount_list</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">do_all</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">agent</SPAN>
						<SPAN CLASS="efeature">deposit_one_grand</SPAN><SPAN CLASS="esymbol">)</SPAN>

						<P><SPAN CLASS="elocal">your_integer_list</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">do_all</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">agent</SPAN>
						<SPAN CLASS="efeature">add_to_n</SPAN><SPAN CLASS="esymbol">)</SPAN></P>
					</CODE>

					<P>even though the two procedures used in the agents have
					quite different forms. We are assuming here that the first
					one, in class <SPAN CLASS="eclass">ACCOUNT</SPAN>, is
					something like</P>

					<CODE>
						<P><SPAN CLASS="efeature">deposit_one_grand</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Add one thousand dollars to
						balance of account.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">balance</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="efeature">balance</SPAN>
						<SPAN CLASS="efeature">+</SPAN>
						<SPAN CLASS="enumber">1000</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>so that it doesn't take an argument: it is normally called
					on its target, as in
					<SPAN CLASS="elocal">my_account</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">deposit_one_grand</SPAN>.
					In contrast, the other routine has an argument:</P>

					<CODE>
						<P><SPAN CLASS="efeature">add_to_n</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Add <SPAN CLASS="elocal">x</SPAN>
						to the value of <SPAN CLASS="efeature">total</SPAN>.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">total</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="efeature">total</SPAN>
						<SPAN CLASS="esymbol">+</SPAN>
						<SPAN CLASS="elocal">x</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>where <SPAN CLASS="efeature">total</SPAN> is an integer
					attribute of the enclosing class. Without the versatility of
					playing with open and closed arguments for both the original
					arguments and target, you would have to write separate
					iteration mechanisms for these two cases. Here you can use a
					single iteration routine of <SPAN CLASS="eclass">LIST</SPAN>
					and similar classes of EiffelBase,
					<SPAN CLASS="efeature">do_all</SPAN>, for both purposes:</P>

					<UL>
						<LI>Depositing money on every account in a list of
						accounts.</LI>

						<LI>Adding all the integers in a list of integers.</LI>
					</UL>

					<P>Agents provide a welcome complement to the other
					mechanisms of Eiffel. They do not conflict with them but,
					when appropriate -- as in the examples sketched in this
					section -- provide clear and expressive programming schemes,
					superior to the alternatives.</P>

					<P CLASS="seealso"><B>See also</B><BR />
						<A HREF="tutorial-13.html">Lexical Conventions and Styles Rules</A>
					</P>
				</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FOOTER">
			<TR>
				<TD>© 2003-2004 Eiffel Software. All rights reserved.</TD>
			</TR>
		</TABLE>
	</BODY>
</HTML>