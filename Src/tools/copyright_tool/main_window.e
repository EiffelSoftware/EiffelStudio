indexing
	description: "Objects that represent an EV_TITLED_WINDOW.%
		%The original version of this class was generated by EiffelBuild."
	date: "$Date$"
	revision: "$Revision$"

class
	MAIN_WINDOW

inherit
	MAIN_WINDOW_IMP


feature {NONE} -- Initialization

	user_initialization is
			-- Called by `initialize'.
			-- Any custom user initialization that
			-- could not be performed in `initialize',
			-- (due to regeneration of implementation class)
			-- can be added here.
		local
			l_icon: EV_PIXMAP
			l_accel: EV_ACCELERATOR
			l_pic_name: STRING
			l_env: EXECUTION_ENVIRONMENT
		do
			set_width (800)
			set_height (600)
			read_copyright_texts_list (true)

			create l_icon

			create l_env
			l_pic_name := l_env.current_working_directory + separator.out + "eiffel_icon.png"
			if file_exists (l_pic_name) then
				l_icon.set_with_named_file (l_pic_name)
			end
			eiffel_icon_frame.extend (l_icon)
			instructions_label.set_text (instructions)

			create l_accel.make_with_key_combination (create {EV_KEY}.make_with_code ({EV_KEY_CONSTANTS}.key_s), true, false, false)
			l_accel.actions.extend (agent on_save)
			accelerators.extend (l_accel)

			if not copyright_list.is_empty then
				copyright_list.i_th (1).enable_select
			end
		end

feature -- Access

	last_selected_item : EV_LIST_ITEM
			-- Last selected item.	

	last_open_directory: STRING
			-- Last open directory.

feature -- Status report

	text_changed: BOOLEAN
			-- Is text changed in `copyright_text'?

	is_recursive: BOOLEAN is
			-- Process recursively?
		do
			Result := recursively_process_check_button.is_selected
		end

	stop_when_post_parsing_failed: BOOLEAN is
			-- Stop when post parsing?
		do
			Result := stop_when_post_parsing_failed_button.is_selected
		end

feature {NONE} -- Copyright list

	read_copyright_texts_list (a_show_dlg: BOOLEAN) is
			-- Read copyright texts from `copyright_text_directory' if found.
		local
			l_dir: DIRECTORY
			loop_end: BOOLEAN
			l_entry: STRING
			l_subfix: STRING
			l_list_item: EV_LIST_ITEM
			l_dlg: EV_INFORMATION_DIALOG
			l_file_name: FILE_NAME
		do
			if copyright_directory /= Void then
				l_dir := copyright_directory
			else
				l_dir := find_copyright_directory
			end
			if l_dir /= Void then
				copyright_directory := l_dir
				create l_file_name.make_from_string (l_dir.name)
				from
					l_dir.open_read
					l_dir.start
					loop_end := false
				until
					loop_end
				loop
					l_dir.readentry
					l_entry := l_dir.lastentry
					if l_entry /= Void then
						l_subfix := l_entry.substring (l_entry.count - subfix.count + 1, l_entry.count)
						if l_subfix.is_equal (subfix) then
							create l_list_item.make_with_text (l_entry.substring (l_entry.last_index_of (separator, l_entry.count) + 1, l_entry.count))
							create l_file_name.make_from_string (l_dir.name)
							l_file_name.extend (l_entry)
							l_entry := l_file_name.string
							l_list_item.set_data (l_entry)
							l_list_item.set_tooltip (l_entry)
							l_list_item.select_actions.extend (agent on_list_item_selected (l_list_item))
							copyright_list.extend (l_list_item)
						end
					else
						loop_end := true
						l_dir.close
					end
				end
			elseif a_show_dlg then
				create l_dlg.make_with_text_and_actions (warning_missing_copyright_directory, <<agent on_close>>)
				l_dlg.show_modal_to_window (Current)
			end
		end

	find_copyright_directory : DIRECTORY is
			-- Find copyrights directiory `copyright_text_directory'.
		local
			l_str: STRING
			l_directory: DIRECTORY
			l_env: EXECUTION_ENVIRONMENT
		do
			create l_env
			l_str := l_env.current_working_directory + separator.out + copyright_text_directory
			create l_directory.make (l_str)
			if l_directory.exists then
				Result := l_directory
			end
		end

	on_list_item_selected (a_item: EV_LIST_ITEM) is
			-- When list item selected.
		require
			a_item_attached: a_item /= Void
		do
			if last_selected_item /= Void implies not last_selected_item.data.is_equal (a_item.data) then
				if text_changed then
					save_and (agent load_item (a_item))
				else
					load_item (a_item)
				end
			end
		end

	load_item (a_item: EV_LIST_ITEM) is
			-- Load text of the selected file.
		require
			a_item_attached: a_item /= Void
		local
			l_str: STRING
			l_file: RAW_FILE
			l_cpr_text: STRING
		do
			l_str ?= a_item.data
			if l_str /= Void then
				create l_file.make_open_read (l_str)
				if l_file.exists then
					l_file.read_stream (l_file.count)
					l_cpr_text := l_file.last_string
				end
				l_file.close
				if l_cpr_text /= Void then
					load_copyright_text (l_cpr_text)
					last_selected_item := a_item
				end
			end
		end

	load_copyright_text (a_string: STRING) is
			-- Load a_string into `copyright_text'
		require
			a_string_attached: a_string /= Void
		do
			a_string.prune_all ('%R')
			copyright_text.set_text (a_string)
			text_changed := false
			toggle_save
		end

feature {NONE} -- Implementation

	on_text_changed is
			-- On text changed.
		do
			text_changed := true
			toggle_save
			if copyright_text.text_length /= 0 then
				save_as_button.enable_sensitive
			else
				save_as_button.disable_sensitive
			end
		end

	select_directory_dialog: EV_DIRECTORY_DIALOG

	on_select_and_start is
			-- Called by `select_actions' of `select_and_start'.
		do
			create select_directory_dialog.make_with_title (choose_dirs_dialog_title)
			select_directory_dialog.ok_actions.extend (agent select_and_start_attaching)
			if last_open_directory /= Void then
				select_directory_dialog.set_start_directory (last_open_directory)
			end
			select_directory_dialog.show_modal_to_window (Current)
		end

	on_save is
			-- Called by `select_actions' of `save_button'.
		local
			l_file_name: STRING
		do
			if last_selected_item /= Void then
				l_file_name ?= last_selected_item.data
				if l_file_name /= Void then
					save_file_with_name_and_text (l_file_name, copyright_text.text)
					text_changed := false
					toggle_save
				end
			end
		end

	save_dialog: EV_FILE_SAVE_DIALOG
			-- Dialog for saving

	on_save_as is
			-- Called by `select_actions' of `save_as_button'.
		local
			start_directory: STRING
		do
			create save_dialog.make_with_title (save_file_dialog_title)
			start_directory := find_copyright_directory.name
			if start_directory /= Void then
				save_dialog.set_start_directory (start_directory)
			end
			save_dialog.filters.extend (["*.cpr", "Copyright (.cpr)"])
			save_dialog.save_actions.extend (agent save_file_from_dialog)
			save_dialog.show_modal_to_window (Current)
		end

	on_focus is
			-- Gain keyboard focus.
		local
			l_item: EV_LIST_ITEM
		do
			copyright_list.wipe_out
			read_copyright_texts_list (false)
			if last_selected_item /= Void then
				l_item := copyright_list.retrieve_item_by_data (last_selected_item.data, true)
				if l_item = Void then
					last_selected_item := Void
				else
					l_item.enable_select
				end
			end
			toggle_save
		end

	on_close is
			-- Close requested.
		local
			app: EV_APPLICATION
		do
			destroy
			app := (create {EV_ENVIRONMENT}).application
			app.destroy
		end

feature {NONE} -- Save

	toggle_save is
			-- Toggle save button.
		do
			if last_selected_item /= Void and text_changed then
				save_button.enable_sensitive
			else
				save_button.disable_sensitive
			end
		end

	save_and (a_pro: PROCEDURE [ANY, TUPLE]) is
			-- Save and do.
		local
			l_warning_dlg: EV_CONFIRMATION_DIALOG
			actions: ARRAY [PROCEDURE [ANY, TUPLE]]
		do
			if text_changed then
				actions := <<agent on_save, a_pro>>
				create l_warning_dlg.make_with_text_and_actions (warning_text_unsaved, actions)
				l_warning_dlg.show_modal_to_window (Current)
			else
				on_save
				a_pro.call ([Void])
			end
		end

	save_file_from_dialog is
			-- Save file from dialog.
		local
			l_file_name: STRING
			l_subfix: STRING
		do
			l_file_name := save_dialog.file_name
			l_subfix := l_file_name.twin
			l_subfix.keep_tail (subfix.count)
			if not l_subfix.is_equal (subfix) then
				l_file_name.append (subfix.twin)
			end
			save_file_with_name_and_text (l_file_name, copyright_text.text)
			on_focus
		end

	save_file_with_name_and_text (a_name, a_text: STRING) is
			-- Save file to `a_name' with text `a_text'
		require
			a_name_attached: a_name /= Void
			a_text_attached: a_text /= Void
		local
			l_file : RAW_FILE
		do
			create l_file.make_open_write (a_name)
			l_file.put_string (a_text)
			l_file.close
		end

feature {NONE} -- File

	file_exists (a_name: STRING): BOOLEAN is
			-- If file with `a_name' exists.
		require
			a_name_attached: a_name /= Void
		local
			l_file: RAW_FILE
		do
			create l_file.make (a_name)
			Result := l_file.exists
		end

	copyright_directory: DIRECTORY

feature {NONE} -- Attaching copyrights

	stop_processing: BOOLEAN

	select_and_start_attaching is
			--
		do
			last_open_directory := select_directory_dialog.directory
			stop_processing := false
			total_processed := 0
			failed_count := 0
			parse_failed_count := 0
			succeed := 0
			output_text.set_text ("")
			attach_directory (last_open_directory, is_recursive)
			output_text.append_text (total_processed.out + " file(s) was(were) processed%N")
			output_text.append_text (succeed.out + " file(s) succeed(s).%N")
			if parse_failed_count > 0 then
				output_text.append_text (parse_failed_count.out + " file(s) is(are) not processed due to parsing failure.%N")
			end
			if failed_count > 0 then
				output_text.append_text ("Warning: " + failed_count.out + " file(s) can not be parsed after processing. Processing canceled.%N")
			end
			status_label.set_text (attaching_finished)
		end

	attach_directory (a_directory: STRING; a_is_recursive: BOOLEAN) is
			-- Attach directory recursively.
		local
			l_file: RAW_FILE
			l_directory: DIRECTORY
			l_entry: STRING
		do
			create l_directory.make (a_directory)
			if l_directory.exists then
				l_directory.open_read
				from
					l_directory.start
					l_directory.readentry
				until
					l_directory.lastentry = Void or stop_processing
				loop
					l_entry := l_directory.lastentry
					if not l_entry.is_equal (".") and then not l_entry.is_equal ("..") then
						l_entry := a_directory + separator.out + l_entry
						create l_file.make (l_entry)
						if l_file.exists then
							if l_file.is_directory then
								if a_is_recursive then
									attach_directory (l_entry, true)
								end
							else
								attach_file (l_entry)
							end
						end
					end
					l_directory.readentry
				end
			end
		end

	attach_file (a_file: STRING) is
			-- Attach a file.
		local
			copyright_assembler: COPYRIGHT_ASSEMBLER
		do
			create copyright_assembler.make (a_file, copyright_text.text.twin)
			copyright_assembler.file_assembled_actions.extend (agent send_output (copyright_assembler))
			copyright_assembler.assemble
		end

	send_output (a_assembler: COPYRIGHT_ASSEMBLER) is
			-- Send output from a assembler
		require
			a_assembler_attached: a_assembler /= Void
		do
			total_processed := total_processed + 1
			if a_assembler.init_error then
				output_text.append_text (a_assembler.file_path + " :%T")
				output_text.append_text (file_can_not_parse_string (a_assembler.file_path))
				output_text.append_text ("%N")
				parse_failed_count := parse_failed_count + 1
			elseif a_assembler.parse_failed then
				if stop_when_post_parsing_failed then
					stop_processing := true
				end
				failed_count := failed_count + 1
				output_text.append_text (a_assembler.file_path + " :%T")
				output_text.append_text (file_post_parsing_failed (a_assembler.file_path))
				output_text.append_text ("%N")
--				save_file_with_name_and_text (a_assembler.file_path + ".new", a_assembler.text)
--				save_file_with_name_and_text (a_assembler.file_path, a_assembler.text)
			else
--				save_file_with_name_and_text (a_assembler.file_path + ".new", a_assembler.text)
				save_file_with_name_and_text (a_assembler.file_path, a_assembler.text)
				if a_assembler.top_index_inserted then
					status_label.set_text (a_assembler.file_path + " :%T" + top_index_inserted_string (a_assembler.file_path))
				elseif a_assembler.top_index_modified then
					status_label.set_text (a_assembler.file_path + " :%T" + top_index_modified_string (a_assembler.file_path))
				end

				if a_assembler.bottom_index_inserted then
					status_label.set_text (a_assembler.file_path + " :%T" + bottom_index_inserted_string (a_assembler.file_path))
				elseif a_assembler.bottom_index_replaced then
					status_label.set_text (a_assembler.file_path + " :%T" + bottom_index_replaced_string (a_assembler.file_path))
				end

				if a_assembler.end_class_comments_removed then
					status_label.set_text (a_assembler.file_path + " :%T" + end_class_comments_removed_string (a_assembler.file_path))
				end
				succeed := succeed + 1
			end
			status_label.refresh_now
		end

	total_processed, failed_count, parse_failed_count,succeed: INTEGER

end -- class MAIN_WINDOW

