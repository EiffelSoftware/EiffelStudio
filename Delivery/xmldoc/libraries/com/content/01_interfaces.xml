<document output="studio" title="Interfaces">
	<meta_data/>
	<paragraph>
		<paragraph>
			COM interfaces have several facets. First, an interface is a deferred, or an abstract, class.
			This means that an interface is a specification of a type.
			Second, an interface pointer represents a COM object, which is callable by a client 
			application. An object can expose several interfaces, or represent several types.
		</paragraph>
		<heading>
			<size>2</size>ECOM_INTERFACE
		</heading>
		<paragraph>
			For each interface listed in a type library, the EiffelCOM wizard generates a deferred class 
			and two effective classes: a proxy of an interface pointer, or a client side class, and a stub 
			of an interface pointer, or a server side class. The deferred interface class inherits from 
			<class_name>
				<url>../reference/Interfaces/ecom_interface_chart.xml</url>
				<label>ECOM_INTERFACE</label>
			</class_name>
			and has a deferred feature per each interface function. Both effective classes, or implemented 
			interfaces, inherit from the deferred class and implement its functions. The functions of the 
			interface proxy calls an underlying C layer, which in turn calls the COM component while 
			the functions of the interface stub implement the component functionality.
		</paragraph>
		<paragraph>
			<link>
				<url>../reference/Interfaces/ecom_interface_chart.xml</url>
				<label>ECOM_INTERFACE</label>
			</link> 
			holds a pointer to the underlining COM interface.
		</paragraph>
		<heading>
			<size>2</size>ECOM_QUERIABLE
		</heading>
		<paragraph>
			Different languages handle type coercion in different ways. C uses type cast; C++ introduces 
			several type casting mechanisms; Eiffel uses assignment attempt, etc. Every COM interface exposes 
			the <feature_name>QueryInterface</feature_name> function which allows clients to query the COM 
			component for a pointer to another interface. Querying a component for an interface pointer is 
			similar to using an assignment attempt in Eiffel. The Eiffel implementation of the assignment 
			attempt relies on the runtime data. Since we could not change the Eiffel runtime and the 
			implementation of the assignment attempt, we have created a library class 
			<link>
					<label>ECOM_QUERIABLE</label>
					<url>../reference/Interfaces/ecom_queriable_chart.xml</url>					
			</link>
			, which has a creation routine
		</paragraph>
		<code_block>
			<feature_name>make_from_other</feature_name> <symbol>(</symbol>other<symbol>:</symbol> <class_name>ECOM_INTERFACE</class_name><symbol>)</symbol></code_block>
		<paragraph>
			that queries a COM component internally. Every interface proxy class inherits from 
			<link>
					<label>ECOM_QUERIABLE</label>
					<url>../reference/Interfaces/ecom_queriable_chart.xml</url>					
			</link>
		</paragraph>
		<heading>
			<size>2</size>ECOM_STUB
		</heading>
		<paragraph>
			<link>
				<url>../reference/Interfaces/ecom_stub_chart.xml</url>
				<label>ECOM_STUB</label>
			</link> 
			inherits from 
			<link>
				<url>../reference/Interfaces/ecom_interface_chart.xml</url>
				<label>ECOM_INTERFACE</label>
			</link>
			, and exposes the feature 
			<code>
				<link>
					<url>../reference/Interfaces/ecom_stub_chart.xml</url><anchor_name>f_create_item</anchor_name>
					<label>create_item</label>
				</link>
			</code> 
			which allows creating the underlying COM object.
		</paragraph>
	</paragraph>
</document>
