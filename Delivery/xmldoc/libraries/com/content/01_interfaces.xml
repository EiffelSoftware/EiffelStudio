<document output="studio" title="Interfaces">
	<meta_data/>
	<paragraph>
		<paragraph>COM interfaces have several facets. First, an interface is a deferred, or an abstract, class.    This means that an interface is a specification of a type.    Second, an interface pointer represents a COM object, which is callable    by a client application. An    object can expose several interfaces, or represent several types. </paragraph>
		<heading>
			<size>2</size>ECOM_INTERFACE
		</heading>
		<paragraph>For each interface referenced in a type    library, the EiffelCOM wizard generates a deferred class and two    effective classes: a proxy of an interface pointer, or a client side    class, and a stub of an interface pointer, or a server side class.     The deferred interface class inherits from 
			<code>
				<class_name>
					<url>../reference/interfaces/ecom_interface.html</url>
					<label>ECOM_INTERFACE</label>
				</class_name>
			</code>    and has a deferred feature per each interface function.     Both effective classes, or implemented interfaces, inherit from    the deferred class and implement its functions. The functions of the    interface proxy call underlying C layer, which calls a COM component.    The functions of the interface stub implement the component    functionality.
		</paragraph>
		<paragraph>
			<link>
				<url>../reference/interfaces/ecom_interface.html</url>
				<label>ECOM_INTERFACE</label>
			</link>    holds a pointer to the underlining COM interface.
		</paragraph>
		<heading>
			<size>2</size>ECOM_QUERIABLE
		</heading>
		<paragraph>Different languages handle the type    coercion in dissimilar ways. C    has a type cast; C++ introduces several type casting mechanisms; Eiffel    has an assignment attempt, etc. Every    COM interface exposes 
			<code>
				<feature_name>QueryInterface</feature_name>
			</code>    function that allows a client to query the COM component for the    interfaces it exposes and receive a pointer to another interface.    Querying a component for an interface is similar to using an    assignment attempt in Eiffel. The    Eiffel implementation of the assignment attempt relies on the runtime    data. Since we could not change the Eiffel runtime and the    implementation of the assignment attempt, we have created a library    class 
			<code>
				<class_name>
					<url>../reference/interfaces/ecom_queriable.html</url>
					<label>ECOM_QUERIABLE</label>
				</class_name>
			</code>, which has a creation routine
		</paragraph>
		<code_block>
	<feature_name>make_from_other</feature_name> <symbol>(</symbol>other<symbol>:</symbol> <class_name>ECOM_INTERFACE</class_name><symbol>)</symbol>
		</code_block>
		<paragraph>that queries a COM component internally.        Every interface proxy class inherits from 
			<code>
				<class_name>
					<url>../reference/interfaces/ecom_queriable.html</url>
					<label>ECOM_QUERIABLE</label>
				</class_name>.
			</code>
		</paragraph>
		<heading>
			<size>2</size>ECOM_STUB
		</heading>
		<paragraph>
			<link>
				<url>../reference/interfaces/ecom_stub.html</url>
				<label>ECOM_STUB</label>
			</link>    inherits from 
			<link>
				<url>../reference/interfaces/ecom_interface.html</url>
				<label>ECOM_INTERFACE</label>
			</link>,    and has feature 
			<code>
				<feature_name>
					<url>../reference/interfaces/ecom_stub.html#f_create_item</url>
					<label>create_item</label>
				</feature_name>
			</code>,    which allows to create a COM object corresponding to an Eiffel object.
		</paragraph>
	</paragraph></document>