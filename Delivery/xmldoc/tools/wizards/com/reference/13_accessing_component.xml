<document title="Accessing a COM Component" output="studio">
	<meta_data/>
	<paragraph>
		<paragraph>The wizard generates all the necessary code to access the existing component. The plumbing is already done, so instantiating an Eiffel coclass actually initializes COM internals.</paragraph>
		<heading>
			<size>2</size> Using the Generated Code
		</heading>
		<paragraph> To access the component, you need to call features of the coclass. The data types of function arguments are either Eiffel types defined in Eiffeldata structure libraries (EiffelBase), standard COM data types defined in the EiffelCOM library, or component COM data types specified in the definition file. For example, from the following IDL line</paragraph>
		<code_block>
HRESULT InterfaceFunction ([in] int a, [out, retval] MyStruct * b)
</code_block>
		<paragraph>The wizard generates the following feature in the Eiffel coclass:</paragraph>
		<code_block>
interface_function (a: INTEGER): MY_STRUCT_RECORD
</code_block>
		<paragraph>where 
			<code>
				<class_name>MY_STRUCT_RECORD</class_name>
			</code> is a generated Eiffel class wrapping 
			<italic>MyStruct</italic>.
		</paragraph>
		<paragraph>Here is a more difficult example:</paragraph>
		<code_block>
HRESULT a_function ([in] IsomeInterface * p_interface)
</code_block>
		<paragraph>The wizard generates the following Eiffelfeature:</paragraph>
		<code_block>
a_function (p_interface: ISOME_INTERFACE_INTERFACE)
</code_block>
		<paragraph>where 
			<code>
				<class_name>ISOME_INTERFACE_INTERFACE</class_name>
			</code>is a generated deferred class. Where can you obtain an instance of the class? First, you may receive from other function. Second, you can create an implemented server interface 
			<code>
				<class_name>ISOME_INTERFACE_IMPL_STUB</class_name>
			</code>. In the later case you should provide your own implementation.
		</paragraph>
		<heading>
			<size>2</size> Contracts
		</heading>
		<paragraph>The wizard cannot generate fully specified contracts. Indeed, the tool has no domain specific knowledge and can only generate contracts that are domain independent. Such contracts, although useful, are not enough to describe entirely the behavior of the component. Generated contracts include void Eiffel objects as well as C pointer validity (for wrappers) checking. There might be other conditions to allow calls to an Eiffel coclass feature. Invariants and postconditions can be enforced in an heir of the generated Eiffel coclass. Preconditions, however, cannot be strengthened. A workaround provided by the wizard is to generate a precondition function for each feature in the interface. The default implementation of these functions always returns 
			<italic>True</italic>. They should be redefined to implement the correct behavior:
		</paragraph>
		<code_block>
interface_function (a: INTEGER): MY_STRUCT is
                -- Example of a generated Eiffel coclass feature
        require
            interface_function_user_precondition: interface_function_user_precondition
        do
            ...
        ensure
            non_void_my_struct: Result /= Void
        end
</code_block>So the complete class hierarchy for an Eiffel client coclass is the following:
		<paragraph/>
		<heading>
			<size>3</size>EiffelCOM Client System
		</heading>
		<paragraph>
			<image>
				<url>../images/wizard-12.gif</url>
			</image>
		</paragraph>
		<paragraph>Another advantage of the previous hierarchy is that it adds incrementality to the EiffelCOM system. Indeed, should the definition file be modified and the wizard run once more against it, your code would not be changed. Only the generated Eiffel coclass would be, and it would suffice to adapt your heir accordingly.</paragraph>
		<heading>
			<size>2</size>  Exceptions
		</heading>
		<paragraph>COM standard requires that any interface function returns a status value (knownas a HRESULT). This corresponds to side effect features which the Eiffel methodology tends to avoid. The work around used in EiffelCOM systems is to map these return values into Eiffel exceptions. If the server returns an error code, the EiffelCOM runtime raises an Eiffel exception that your code should catch.</paragraph>
		<heading>
			<size>3</size>EiffelCOM Client System ExceptionRaising
		</heading>
		<paragraph>
			<image>
				<url>../images/wizard-13.gif</url>
			</image>
		</paragraph>
		<paragraph>As a result, any feature in the co class client making calls to the user defined Eiffel coclass should include a rescue clause. The processing donein this clause might depend on the nature of the exception. All the standard COM exceptions can be found in the library class 
			<code>
				<class_name>ECOM_EXCEPTION_CODES,</class_name>
			</code> which is inherited from by 
			<code>
				<class_name>ECOM_EXCEPTION</class_name>
			</code>. The later also inherits from the kernel class 
			<code>
				<class_name>EXCEPTIONS</class_name>
			</code> and can consequently be used by the coclass client to catch the exceptions.
		</paragraph>
		<paragraph>The following code snippet illustrates how a client can process exceptions raised in the Eiffel coclass:</paragraph>
		<code_block>
indexing
    description: "Eiffel coclass client example"

class
    COCLASS_CLIENT

inherit
    ECOM_EXCEPTION
        export
            {NONE} all
        end

create
    make

feature {NONE} -- Initialization

    make is
            -- Initialize Eiffel coclass.
        do
            create coclass.make
        end

feature -- Basic Operations

    coclass_feature_client is
            -- Example of a coclass feature caller
        local
            retried: BOOLEAN
            coclass: EIFFEL_COCLASS_PROXY
        do
            create coclass.make
            if not retried then
                coclass.coclass_feature -- Actual call
            end
        rescue
            if hresult = E_notimpl then
                -- Process non implemented function error.
                retried := True
                retry
            elseif hresult = E_invalidarg then
                -- Process invalid argument error.
                retried := True
                retry
            else
                -- Forward exception to caller.
            end
        end

end -- class COCLASS_CLIENT
</code_block>
		<heading>
			<size>2</size> Summary
		</heading>
		<paragraph>There are a few rules to follow when building an Eiffel coclass client, but they are straightforward and do not add any constraints. First,inherit from the generated Eiffel coclass to implement the preconditions. Second, any feature call to the Eiffel coclassshould include a rescue clause.</paragraph>
		<seealso>
			<bold>See Also</bold>
			<line_break/>
			<link>
				<url>01_introduction_d.xml</url>
				<label>Introduction Dialog and Main Window</label>
			</link>
			<line_break/>
			<link>
				<url>02_generated_code_type_d.xml</url>
				<label>Generated Code Type Dialog</label>
			</link>
			<line_break/>
			<link>
				<url>03_definition_file_d.xml</url>
				<label>Definition File Dialog</label>
			</link>
			<line_break/>
			<link>
				<url>04_eiffel_project_file_d.xml</url>
				<label>Eiffel Project File Dialog</label>
			</link>
			<line_break/>
			<link>
				<url>05_destination_folder_d.xml</url>
				<label>Destination Folder Dialog</label>
			</link>
			<line_break/>
			<link>
				<url>06_idl_marshalling_d.xml</url>
				<label>IDL Marshaling Definition Dialog</label>
			</link>
			<line_break/>
			<link>
				<url>07_type_lybrary_m_d.xml</url>
				<label>Type Library Marshaling Definition Dialog</label>
			</link>
			<line_break/>
			<link>
				<url>08_final_d.xml</url>
				<label>Final Dialog</label>
			</link>
			<line_break/>
			<link>
				<url>09_com_definition_file_processing.xml</url>
				<label>COM Definition File Processing</label>
			</link>
			<line_break/>
			<link>
				<url>10_eiffel_project_processing.xml</url>
				<label>Eiffel Project Processing</label>
			</link>
			<line_break/>
			<link>
				<url>11_generated_files.xml</url>
				<label>Generated Files</label>
			</link>
			<line_break/>
			<link>
				<url>12_class_hierarchy.xml</url>
				<label>Class Hierarchy</label>
			</link>
			<line_break/>
			<link>
				<url>13_accessing_component.xml</url>
				<label>Accessing a Component</label>
			</link>
			<line_break/>
			<link>
				<url>14_building_component.xml</url>
				<label>Building a Component</label>
			</link>
		</seealso>
	</paragraph></document>