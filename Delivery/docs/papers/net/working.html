<HTML>
<HEAD>
<TITLE>Introduction to the Examples</TITLE>
<LINK REV="made" HREF="mailto:ise@eiffel.com">
<link rel="stylesheet" type="text/css" href="../../styles/tech.css">
<meta name="Microsoft Border" content="t, default">
</HEAD>

<BODY><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><table border="0" cellspacing="0" cellpadding="0" width="100%">
  <tr>
    <td valign="top" bgcolor="#000063" width="291"><b><font face="Arial" size="4" color="#FFFFFF">Interactive<br>
      Software Engineering</font></b></td>
    <td valign="top" bgcolor="#000063" width="720"><b><font face="Arial" size="6" color="#FFFFCC">Introduction to the Examples</font></b></td>
  </tr>
  <tr>
    <td colspan="2" valign="top" width="100%">
<p align="center">[<a href="http://eiffel.com">ISE Home</a>] <nobr>[&nbsp;<a href="../../index.html">Home</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../../release_notes.html">Release&nbsp;Notes</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../index.html">Technology&nbsp;Papers</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../../install.html">Installation&nbsp;Notes</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../../Eiffel/index.html">About&nbsp;Eiffel</a>&nbsp;]</nobr>
<hr>

    </td>
  </tr>
</table></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><!--msnavigation--><td valign="top">
<P>
<A HREF="control.html#Title"><IMG SRC="next.gif" ALIGN=RIGHT ALT="Next" width="16" height="16"></A>
<A HREF="toc.html"><IMG SRC="toc.gif" ALIGN=RIGHT ALT="TOC" width="16" height="16"></A>
<A HREF="examples_introduction.html#Title"><IMG SRC="previous.gif"
ALT="Previous" ALIGN="RIGHT" width="16" height="16"></A>
<h1>The EiffelNet Library</h1>
<hr>

<H2><A NAME="Title">6 WORKING AT THE PREDEFINED LEVEL</A></H2>

<CENTER>
<TABLE BORDER=1 WIDTH=75%>
<TR><TD>
The example classes discussed in this section appear in the   
subdirectory <I>predef </I>of the example directory                  
</TD></TR>
</TABLE>
</CENTER>

<P>
The first example shows how to use the predefined level classes, covering many common client-server schemes. The work needed in this case is minimal: just effect or redefine a few routines describing the specific processing that your client and your server require.
</P>

<H3><A NAME="example">6.1 The example</A></H3>

<P>
The example describes a simple communication protocol. The client sends to the server a list of strings, which together form the message <I>"This is my test"</I>; the server receives the corresponding object structure, appends to it one more element - the string <I>"I'm back"</I> - and returns the result to the client, which will accept it and print it. The server increases a counter each time it closes a connection with a client, and will only accept three connections.
</P>

<H3><A NAME="Object Structures">6.2 Object structures</A></H3>

<P>
As noted above, it is possible with sockets, as any other <I>IO_MEDIUM</I>, to send and receive simple objects such as integers. But for this first example we are already more ambitious and want to exchange entire linked lists of strings. The structures that we will exchange are described by the following class:
<ul><DL>
	<I><DT><B>class</B> OUR_MESSAGE <B>inherit</B>
		<DT><DD>LINKED_LIST [STRING];
		<DT><DD>STORABLE
	<DT><B>creation</B>
		<DT><DD>make
	<DT><B>end</B>
</I></DL></ul>
<P>
Note that to make use of the storage and retrieval facilities the objects to be exchanged must be instances of a class which, as here, is a descendant of <I>STORABLE</I>.
</P>

<H3><A NAME="System Structure">6.3 Application classes and system structure</A></H3>

<P>
The client and server mechanisms will be described by instances of two classes that make up the example, called <I>OUR_CLIENT</I> and <I>OUR_SERVER</I>.
</P>
<P>
We want to have the two communicating systems be two different systems (compiled separately, with two separate Ace files). <I>OUR_CLIENT </I>will be part of one of these systems; <I>OUR_SERVER </I>will be part of the other.
</P>
<P>
There are four predefined classes, corresponding to the client and server sides with, in each case, the choice between the "Unix" (single-machine) and "network" (multi-machine) styles of communication. Note that all these classes support stream communication; for datagrams, see <A HREF="datagram_sockets.html#Title">chapter 8</A>. The server class should inherit from <I>UNIX</I>_<I>SERVER </I>or <I>NETWORK</I>_<I>SERVER</I>; the client class should inherit from <I>UNIX</I>_<I>CLIENT </I>or <I>NETWORK</I>_<I>CLIENT</I>. The choice between <I>UNIX</I>_ and <I>NETWORK_</I> classes must of course be the same on both sides.
</P>

<H3><A NAME="Client">6.4 The client</A></H3>

<P>
Here is the client class:
<ul><DL>
	<I><DT><B>class</B> OUR_CLIENT <B>inherit</B>
		<DT><DD>UNIX_CLIENT
			<DT><DL><DT><DD><B>redefine</B> received <B>end</B></DL>
	<DT><B>creation</B>
		<DT><DD>make_client
	<DT><B>feature</B>
		<DT><DD>our_list: OUR_MESSAGE;
<BR><BR>
		<DT><DD>received: OUR_MESSAGE; </I>-- Type redefinition<I>
<BR><BR>
		<DT><DD>make_client <B>is</B>
				<DT><DL><DT><DL><DT><DD></I>-- Build list, send it, receive modified list, and print it.<I></DL>
			<DT><DD><B>do</B>
				<DT><DL><DT><DD>make ("/tmp/here");
				<DT><DD>build_list;
				<DT><DD>send (our_list);
				<DT><DD>receive;
				<DT><DD>process_received;
				<DT><DD>cleanup</DL>
			<DT><DD><B>rescue</B>
				<DT><DL><DT><DD>cleanup</DL>
			<DT><DD><B>end</B>;</DL>
<BR><BR>
		<DT><DD>build_list <B>is</B>
				<DT><DL><DT><DL><DT><DD></I>-- Build list of strings our_list for transmission to server.<I></DL>
			<DT><DD><B>do</B>
				<DT><DL><DT><DD>!! our_list.make; our_list.extend ("This "); our_list.extend ("is ");
				<DT><DD>our_list.extend ("our "); our_list.extend ("test")</DL>
			<DT><DD><B>end</B></DL>
<BR><BR>
		<DT><DD>process_received <B>is</B>
				<DT><DL><DT><DL><DT><DD></I>-- Print the contents of received in sequence.<I></DL>
			<DT><DD><B>do</B>
				<DT><DL><DT><DD><B>if</B> received = Void <B>then</B>
					<DT><DL><DT><DD>io.putstring ("No list received")</DL>
				<DT><DD><B>else</B>
					<DT><DL><DT><DD><B>from</B> received.start <B>until</B> received.after <B>loop</B>
						<DT><DL><DT><DD>io.putstring (received.item);
						<DT><DD>received.forth</DL>
					<DT><DD><B>end</B></DL>
				<DT><DD><B>end</B>;
					<DT><DT><DD>io.new_line</DL>
			<DT><DD><B>end</B></DL>
</DL>
<DT><B>end</B>
</I></DL></ul>
<P>
</B></I>The scheme is very simple:
<ul>
<li>The inherited procedure <I>make</I> takes care of the many details of creating a socket and setting up the communication; the following sections will give some insight into what this involves. The argument to <I>make</I> is the path name that has been selected to enable communication with the server: <I>/tmp/here</I>.
<BR>
<li>The client has defined a procedure <I>build_list</I> to construct an object structure.
<BR>
<li>It then uses the inherited procedure <I>send</I> to send this object structure to the server; <I>send</I> expects an argument of a type conforming to <I>STORABLE</I>, so that it can use all the predefined storage and retrieval facilities.
<BR>
<li>The <I>receive</I> procedure, called next, obtains an object structure from the server; here, as will be seen from the server's text below, this is the original list to which the server has appended a new element. The result of procedure <I>receive</I> is available through feature <I>received</I>. To avoid the need for an assignment attempt (as with the result of a <I>retrieve</I> operation with <I>STORABLE</I>) the class redefines <I>received</I> to be of type <I>STORABLE</I>.
<BR>
<li>The client has defined a procedure <I>process_received</I> to print the received string. 
<BR>
<li>Finally, a call to <I>cleanup </I>is necessary to close the sockets that have been opened and free the corresponding resources.
</ul>
<P>
Of course, in a typical object-oriented design, the class and those which appear in the rest of this set of examples may "do" more than one thing and so may have more routines than the ones shown in this document.
</P>
<P>
This example shows how to write a client class in the most common cases: inherit from <I>UNIX_CLIENT </I>or <I>NETWORK_CLIENT</I>; use <I>make</I> to specify the socket address, <I>send</I> to send an object structure, <I>receive </I>to receive an object structure, <I>received</I> to access it, and <I>cleanup </I>to clean things up.
</P>
<P>
There would be one difference for a <I>NETWORK_CLIENT</I>: procedure <I>make</I> would need two arguments, the name of a host and a port on that host. For example, to connect to a server running on a machine of name <I>serverhost </I>and using port 2000, the call would be:
<ul><DL>
<DT><I>make </I>("serverhost", 2000)
</DL></ul>
<P>
As noted earlier, you may identify the machine by an Internet address such as <I>"127.0.0.1"</I> rather than by a host name.
</P>

<H3><A NAME="Server">6.5 The server</A></H3>

<P>
Now, the server class:
<ul><DL>
	<I><DT><B>class</B> OUR_SERVER <B>inherit</B>
		<DT><DD>UNIX_SERVER
			<DT><DL><DT><DD><B>redefine</B> received, respond <B>end</B></DL>
	<DT><B>creation</B>
		<DT><DD>make_server
	<DT><B>feature</B>
		<DT><DD>received: OUR_MESSAGE
<BR><BR>
		<DT><DD>make_server <B>is</B>
				<DT><DL><DL><DT><DD></I>-- Receive list, print it, extend it, and send the result back.<I></DL>
			<DT><DD><B>do</B>
				<DT><DL><DT><DD>make ("/tmp/here");
				<DT><DD>execute</DL>
			<DT><DD><B>rescue</B>
				<DT><DL><DT><DD>cleanup</DL>
			<DT><DD><B>end</B>;</DL>
<BR><BR>
		<DT><DD>process_message <B>is</B>
				<DT><DL><DL><DT><DD></I>-- Print received list.<I></DL>
			<DT><DD><B>do</B>
				<DT><DL><DT><DD><B>from</B> received.start <B>until</B> received.after <B>loop</B>
					<DT><DL><DT><DD>io.putstring (received.item);
					<DT><DD>received.forth</DL>
				<DT><DD><B>end</B>;
				<DT><DD>io.new_line</DL>
			<DT><DD><B>end</B>;</DL>
<BR><BR>
		<DT><DD>respond <B>is</B>
				<DT><DL><DL><DT><DD></I>-- Extend received list.<I></DL>
			<DT><DD><B>do</B>
				<DT><DL><DT><DD>received.extend ("%N I'm back.%N");
				<DT><DD>resend (received)</DL>
			<DT><DD><B>end</B></DL>
	<DT><B>end</B>
</I>
</DL></ul>
<P>
The developer's task is even easier here than on the client side. The last instruction in the creation procedure is <I>execute</I>, inherited from the chosen <I>_SERVER </I>class, which executes a loop that will repeatedly call <I>receive</I>, <I>process_message</I>, <I>respond</I> and <I>close</I>. This loop is actually an infinite one, which will only terminate if the server is killed (in which case a Rescue clause will execute procedure <I>cleanup</I>); indeed, a server is not expected to terminate under normal circumstances.
</P>
<P>
To define a server's behavior as desired for your particular application, all you are required to do is to effect the procedure <I>process_message</I>, inherited from the <I>_SERVER</I> class in deferred form. (Remember that to "effect" a deferred feature is to provide a non-deferred version, also called an effective version.) Here the effective version prints the list of strings received from the client.
</P>
<P>
In addition, you may also, as here, redefine procedure <I>respond</I>. In the <I>_SERVER</I> class this procedure is effective, but it does nothing; this means that you have nothing special to do for the common case in which the server does not respond when it has received a message. Here, however, we do want to respond; the redefined version of <I>respond</I> extends the <I>received</I> string and returns it. Procedure <I>resend</I> sends an object structure back to the last connected client. It is also possible to have more sophisticated versions of <I>respond</I>, for example to dispatch objects to all active clients; this will be shown in a later example
</P>
<P>As in the client case there is a cleanup procedure to free the sockets, but you do not need to call it explicitly; it is called by execute. You may redefine this procedure to free some additional resources of your own.
</P>

<P>
<A HREF="examples_introduction.html#Title"><IMG SRC="previous.gif" ALT="Previous" width="16" height="16">Previous
Chapter</A>
<A HREF="toc.html"><IMG SRC="toc.gif" ALT="TOC" width="16" height="16">Table of Contents</A>
<A HREF="control.html#Title"><IMG SRC="next.gif" ALT="Next" width="16" height="16">Next Chapter</A>
</P>

<!-- ICON BAR -->
<!--msnavigation--></td></tr><!--msnavigation--></table></BODY>
</HTML>
