<document title="Event Programming with Agents"><meta_data ><help ><toc ><envision_location >Eiffel, The Language\The Eiffel for .NET Language</envision_location><envision_pseudo_name>70</envision_pseudo_name><envision_title >Event Programming With Agents</envision_title><studio_location /><studio_title /></toc></help></meta_data><paragraph ><heading ><size >1</size>Event Programming with Agents</heading><paragraph >In Eiffel there is a facility referred to as agents.</paragraph><paragraph >The implementation of agents is an advanced topic, but you do not have to understand the details of the implementation of agents to put agents to work for you. That is what you will learn in this section.</paragraph><heading ><size >2</size>Objects that Represent Operations</heading><paragraph >Object technology is based on the idea that when we model real world objects, we model them based on the things that they have and what they can do ... their properties and their operations. The operations in Eiffel are the <link ><url /><label >routines</label></link>, i.e., the <link ><url /><label >functions</label></link> and <link ><url /><label >procedures</label></link>, of classes. Operations are not objects. </paragraph><paragraph >Having said that, it is sometimes desirable for us to model operations. We do this in the same fashion that we model other concepts: statically as classes, and as objects at runtime.</paragraph><paragraph >An object that represents an operation is called an agent.</paragraph><paragraph >If we can have a runtime object that represents an operation, then we can place the object in the structure of another object, where at some later time, a client can cause the associated operation to execute.</paragraph><paragraph >This is a very desirable model for event driven processing, like graphical user interfaces. The operations that are executed when a user take some action like clicking on a button, could be represented by agents. When the user interface element is initialized, agents that represent the action routines are stored within the interface element. Then at the time that an event, say a button click, occurs, the agents for that event are retrieved and their associated operations are executed.</paragraph><paragraph >Another area in which agents are commonly used is in traversing data structures. Many of the data structure classes in the Base Library include routines which take agents as there arguments. For example, the feature <code ><feature_name >do_all</feature_name></code> takes an agent which represents some procedure and will apply the procedure to every item in the structure.</paragraph><heading ><size >2</size>Classes to Model Operations</heading><paragraph >We know that there are two types of routines in Eiffel, functions and procedures.</paragraph><paragraph >Not surprisingly, the implementation of agents relies on three classes in the Base Library. Class <code ><class_name >ROUTINE</class_name></code>, and its heirs <code ><class_name >FUNCTION</class_name></code> and <code ><class_name >PROCEDURE</class_name></code>.</paragraph><paragraph >When you use an agent from a client routine, you will be building an instance of either <code ><class_name >FUNCTION</class_name></code> or <code ><class_name >ROUTINE</class_name></code>. This happens implicitly as you will see.</paragraph><heading ><size >2</size>Using Agents</heading><paragraph >Below is an instruction which passes an agent as an argument to a procedure. </paragraph>


<code_block >
	button.select_actions.extend (agent gauge.step_forward)
</code_block>

<paragraph >In this example, the producer wants to add the action of stepping the gauge forward in the event that a button is clicked. The keyword "<code ><keyword >agent</keyword></code>" is used to indicate that at runtime an object of type <code ><class_name >PROCEDURE</class_name></code> should be created which represents applying the feature <code ><feature_name >step_forward</feature_name></code> to the object attached to <code ><indexing_tag >gauge</indexing_tag></code>. It is the object of type <code ><class_name >PROCEDURE</class_name></code> that is passed as the argument.</paragraph><paragraph >It is important to understand that <code ><feature_name >step_forward</feature_name></code> does not get applied at the point that the instruction above is executed. Rather the procedure object that represents <code ><feature_name >step_forward</feature_name></code> is given to the button to hold in reserve. Then at the point that the button click event takes place, the button will go through its list of <code ><feature_name >select_actions</feature_name></code> executing their associated routines. Only then does <code ><feature_name >step_forward</feature_name></code>get applied to <code ><indexing_tag >gauge</indexing_tag></code>.</paragraph><heading ><size >3</size>Agents with Arguments</heading><paragraph >In this example, the routine "<code ><feature_name >step_forward</feature_name></code>" on which the agent is based takes no arguments. If you drilled down into the workings of this example you would find that class that implements the feature <code ><feature_name >extend</feature_name></code> is class <code ><class_name >EV_NOTIFY_ACTION_SEQUENCE</class_name></code>. You would also see that the signature for the feature <code ><feature_name >extend</feature_name></code>is as essentially as follows. </paragraph>


<code_block >
	extend (v: PROCEDURE [ANY, TUPLE])
</code_block>

<paragraph >We don't have to know too much about the workings of agents to see that "<code ><feature_name >extend</feature_name></code>" takes an argument <code ><indexing_tag >v</indexing_tag></code> which is of type <code ><class_name >PROCEDURE</class_name></code>. It turns out that the actual generic parameter <code ><class_name >TUPLE</class_name></code> represents the set of "open" arguments. In this case, extend is expecting an agent which has no open arguments. </paragraph><heading ><size >3</size>Open and Closed Arguments</heading><paragraph >It is this business of open and closed arguments which really makes agents remarkable. To get a feel for it, let's simplify the example some. Instead of considering an agent passed as an argument let's look at it as a simple assignment within a class.</paragraph><paragraph >Suppose a class has a feature declared as shown below.</paragraph>


<code_block >
	my_procedure: PROCEDURE [ANY, TUPLE]
</code_block>

<paragraph >Then what can be assigned to <code ><feature_name >my_procedure</feature_name></code>?. An agent, of course. Say the class has procedures as follows.</paragraph>


<code_block >
	no_argument_procedure is
            -- A procedure with no arguments
        do
            print ("No argument here!%N%N")
        end

    two_argument_procedure (an_int: INTEGER; another_int: INTEGER) is
            -- A procedure with two arguments
        do
            print ("My arguments are: " + an_int.out + " and " + another_int.out + "%N")
        end
</code_block>

<paragraph >Then the following assignment is valid.</paragraph>


<code_block >
	my_procedure := agent no_argument_procedure
</code_block>

<paragraph >What this means is that the agent created and associated with the procedure <code ><feature_name >no_argument_procedure</feature_name></code> must conform to the type <code ><class_name >PROCEDURE</class_name></code> [<code ><class_name >ANY</class_name></code>, <code ><class_name >TUPLE</class_name></code>]. The feature <code ><feature_name >my_procedure</feature_name></code> (which is of type <code ><class_name >PROCEDURE</class_name></code>) can be attached at runtime to an agent representing a procedure with no open arguments, which indeed is what <code ><feature_name >no_argument_procedure</feature_name></code> is.</paragraph><paragraph >Now let's turn our attention to the other procedure <code ><feature_name >two_argument_procedure</feature_name></code>. You might think that because it takes two arguments, that you would not be able to build an agent from it which could be assigned to the attribute <code ><feature_name >my_procedure</feature_name></code>. But you can do it by closing the two arguments at the time that the agent is created, as in the following.</paragraph>


<code_block >
	my_procedure := agent two_argument_procedure (1, 2)    -- Is Valid
</code_block>

<paragraph >What happens here is that  values are fixed for those arguments at the time that the agent, an object of type <code ><class_name >PROCEDURE</class_name></code> [<code ><class_name >ANY</class_name></code>, <code ><class_name >TUPLE</class_name></code>] is created. </paragraph><paragraph >So this is the wonderful thing about agents. A routine which will be represented as an agent does not have to be an exact fit for the expected signature. By closing some arguments at agent creation, you have effectively produced a new and conforming routine.</paragraph><paragraph >The advantange of this is that you can sometimes avoid building specialized routines for the sole purpose of having a routine which conforms to the agent signature.</paragraph><paragraph >To leave an argument open, you hold its place with a question mark. If you intend for all arguments to be open, then you may make them all question marks, or leave off the arguments entirely.</paragraph>


<code_block >
        my_procedure := agent two_argument_procedure (?, 2)    -- Argument 1 left open
        my_procedure := agent two_argument_procedure (?, ?)    -- Both arguments left open
        my_procedure := agent two_argument_procedure           -- Both arguments left open
</code_block>

<paragraph >If an argument is open, then it means that a value is not provided for that argument at the time that the agent is created. The implication is that the value must be provided at some time prior to the time that the agent's associated routine gets executed. A precondition to executing a routine associated with an agent is that the agent has a valid set of arguments (called operands within the <code ><class_name >ROUTINE</class_name></code> classes) for the call. If you were to leave one or both of the arguments to <code ><feature_name >two_argument_procedure</feature_name></code> open as in the examples above, the assignment would still work due to the rules governing <code ><keyword >TUPLE</keyword></code> conformance. But, at runtime unless the other arguments had been provided, the "<code ><indexing_tag >valid operands</indexing_tag></code>" precondition would be violated.</paragraph><paragraph >Let's see an example in which we leave a target open. Suppose we have a class that has a feature coded as below</paragraph>


<code_block >
	my_strings: LINKED_LIST [STRING]
</code_block>

<paragraph >and some code to put some strings in <code ><feature_name >my_strings</feature_name></code>:</paragraph>


<code_block >
	create my_things.make
	my_strings.extend ("Hello")
	my_strings.extend ("World!")
</code_block>

<paragraph >Our class also has a feature called <code ><feature_name >print_on_new_line</feature_name></code> which we created to print a string preceded by a new line character.</paragraph>


<code_block >
        print_on_new_line (s: STRING) is
            -- Print `s' preceded by a new line
        do
            print ("%N" + s)
        end
</code_block>

<paragraph >Now suppose we want to print the values of all the strings in <code ><feature_name >my_strings</feature_name></code> each on a separate line by invoking <code ><feature_name >print_on_new_line</feature_name></code>.  Traditionally, we would do it by traversing the <code ><class_name >LINKED_LIST</class_name></code> and printing each item. Like this:</paragraph>


<code_block >
            from
                my_list.start
            until
                my_list.exhausted
            loop
                print_on_new_line (my_list.item)
                my_list.forth
            end

</code_block>

<paragraph >The availability of agents gives us new options. <code ><class_name >LINKED_LIST</class_name></code> has a feature <code ><feature_name >do_all</feature_name></code> which comes to it from its ancestor <code ><class_name >LINEAR</class_name></code>. The <code ><feature_name >do_all</feature_name></code> feature's signature looks like this:</paragraph>


<code_block >
	do_all (action: PROCEDURE [ANY, TUPLE [G]])
</code_block>

<paragraph >As an argument <code ><feature_name >do_all</feature_name></code> takes an agent based on a procedure with one open argument which is the same type as the list items (in this class, <code ><generics >G</generics></code> is the formal generic parameter representing the type of the items being stored). Then it traverses the list executing the routine associated with that agent and roviding the current list item to satisfy the open argument.</paragraph><paragraph >Instead of coding the loop shown above, we can code this instruction:</paragraph>


<code_block >
	my_list.do_all (agent print_on_new_line (?))
</code_block>

<paragraph >we leave the argument to <code ><feature_name >print</feature_name></code> open, and <code ><feature_name >do_all</feature_name></code> will provide it as a reference to the current list item as it traverses the list.</paragraph><heading ><size >3</size>Targets for Agents' Routines</heading><paragraph >In Eiffel every routine must be applied against a target object. In our model for computation, <code ><indexing_tag >x</indexing_tag></code>.<code ><feature_name >f</feature_name></code> (<code ><indexing_tag >a</indexing_tag></code>, ...), <code ><indexing_tag >x</indexing_tag></code> is the target of the application of feature <code ><feature_name >f</feature_name></code>. In the case of an agent, the agent must account for objects for each of the arguments and an object for the target of the routine.</paragraph><paragraph >Let's identify the targets in the examples shown. First:</paragraph>


<code_block >
	button.select_actions.extend (agent gauge.step_forward)
</code_block>

<paragraph >Here the target is the object attached to the entity "gauge" which is (although you cannot determine it from this line taken out of context) an object of type <code ><class_name >EV_GAUGE</class_name></code>.</paragraph><paragraph >How about this:</paragraph>


<code_block >
	my_procedure := agent two_argument_procedure (1, 2)
</code_block>

        <paragraph >Here, since there was no qualification, then the target is the current instance. Same with this:</paragraph>


<code_block >
	my_list.do_all (agent print_on_new_line (?))
</code_block>

<paragraph >Again, consider the fact that the agent must account for objects for each of the arguments to a routine, and an object for the target. So, in the examples we've seen so far, the target is close, that is provided at the time of the creation of the agent.</paragraph><paragraph >But we can actually leave the target open as well. Now we cannot use the question mark notation to do that, because if we did, there would be no way to know of which class the routine is a feature. So instead, we mark an open target with the class name in braces.</paragraph><paragraph >Suppose in our list of strings example, we wanted to print the strings, then convert them to lower case, then print them again. Remember that "do_all" has one open argument, which will be provided as the current list item during the traversal.</paragraph>


<code_block >
            my_list.do_all (agent print_on_new_line (?))
            my_list.do_all (agent {STRING}.to_lower)
            my_list.do_all (agent print_on_new_line (?))
</code_block>

<paragraph >In between printing the list two times, we provide <code ><feature_name >do_all</feature_name></code> with an agent that representing the <code ><class_name >STRING</class_name></code> class's feature <code ><feature_name >to_lower</feature_name></code> which will convert each string in the list to lower case. Notice that <code ><feature_name >to_lower</feature_name></code> does not take an argument of type <code ><class_name >STRING</class_name></code> as <code ><feature_name >print_on_new_line</feature_name></code> did. Rather it gets applied to an instance of <code ><class_name >STRING</class_name></code>, so it is targeted to a string. So we leave its target open and <code ><feature_name >do_all</feature_name></code> provides the current list item as the target.</paragraph> <paragraph >Agents for Functions</paragraph><paragraph >So far all the agents that we have coded have created instances of <code ><class_name >PROCEDURE</class_name></code>. But functions are routines and can be represented as agents as well. The difference is that functions have a return value. </paragraph><paragraph >Let's extend the string example by using an agent that represents a function. Suppose we wanted to print only those strings which contain a particular character, say the exclamation point. </paragraph><paragraph >Here again we'll use a feature of the <code ><class_name >LINKED_LIST</class_name></code> class. There is a feature called <code ><feature_name >do_if</feature_name></code> which takes two agents as arguments. One is an action procedure like the argument that <code ><feature_name >do_all</feature_name></code> takes, and the other is a function which returns a boolean and used as a test. As each list item is current, the test is applied first. If the result is true, then the action is applied with the current item.</paragraph>


<code_block >
	my_list.do_if (agent print_on_new_line(?), agent {STRING}.has('!'))
</code_block>

<paragraph >The agent for the action is the same as we used earlier. We've added an agent for the test. It represents applying the <code ><feature_name >has</feature_name></code> feature of the <code ><class_name >STRING</class_name></code> class. Here the target is left open, because we want each of the strings in the list to be the target of <code ><feature_name >has</feature_name></code>.</paragraph></paragraph></document>