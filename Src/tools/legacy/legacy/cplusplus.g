/*
 * PUBLIC DOMAIN PCCTS-BASED C++ GRAMMAR (cplusplus.g, stat.g, expr.g)
 *
 * Authors: Sumana Srinivasan, NeXT Inc.;            sumana_srinivasan@next.com
 *          Terence Parr, Parr Research Corporation; parrt@parr-research.com
 *          Russell Quong, Purdue University;        quong@ecn.purdue.edu
 *
 * VERSION 1.2
 *
 * SOFTWARE RIGHTS
 *
 * This file is a part of the ANTLR-based C++ grammar and is free
 * software.  We do not reserve any LEGAL rights to its use or
 * distribution, but you may NOT claim ownership or authorship of this
 * grammar or support code.  An individual or company may otherwise do
 * whatever they wish with the grammar distributed herewith including the
 * incorporation of the grammar or the output generated by ANTLR into
 * commerical software.  You may redistribute in source or binary form
 * without payment of royalties to us as long as this header remains
 * in all source distributions.
 *
 * We encourage users to develop parsers/tools using this grammar.
 * In return, we ask that credit is given to us for developing this
 * grammar.  By "credit", we mean that if you incorporate our grammar or
 * the generated code into one of your programs (commercial product,
 * research project, or otherwise) that you acknowledge this fact in the
 * documentation, research report, etc....  In addition, you should say nice
 * things about us at every opportunity.
 *
 * As long as these guidelines are kept, we expect to continue enhancing
 * this grammar.  Feel free to send us enhancements, fixes, bug reports,
 * suggestions, or general words of encouragement at parrt@parr-research.com.
 * 
 * NeXT Computer Inc.
 * 900 Chesapeake Dr.
 * Redwood City, CA 94555
 * 12/02/1994
 * 
 * Restructured for public consumption by Terence Parr late February, 1995.
 *
 * Requires PCCTS 1.32b7 or higher to get past ANTLR. 
 * 
 * DISCLAIMER: we make no guarantees that this grammar works, makes sense,
 *             or can be used to do anything useful.
 */

#header <<
#include "CPPDictionary.h"
#include "AToken.h"
typedef ANTLRCommonToken ANTLRToken;
>>

/* These token names are unnecessary in that the regular expressions
 * could easily have been placed into the grammar rules themselves.
 * However, if SORCERER is to be used to do any sort of translation
 * labels must be assigned for each token type.  Hence, I've left
 * the token label definitions here.
 */
#token LCURLYBRACE "\{"
#token RCURLYBRACE "\}"
#token LSQUAREBRACKET "\["
#token RSQUAREBRACKET "\]"
#token LPARENTHESIS "\("
#token RPARENTHESIS "\)"
#token COLON ":"
#token SEMICOLON ";"
#token COMMA ","
#token QUESTIONMARK "?"
#token ELLIPSIS "..."
#token ASSIGNEQUAL "="
#token TIMESEQUAL "\*="
#token DIVIDEEQUAL "/="
#token MODEQUAL "%="
#token PLUSEQUAL "\+="
#token MINUSEQUAL "\-="
#token SHIFTLEFTEQUAL "\<\<="
#token SHIFTRIGHTEQUAL "\>\>="
#token BITWISEANDEQUAL "&="
#token BITWISEXOREQUAL "^="
#token BITWISEOREQUAL "\|="
#token OR "\|\|"
#token AND "&&"
#token BITWISEOR "\|"
#token BITWISEXOR "^"
#token AMPERSAND "&"
#token EQUAL "=="
#token NOTEQUAL "!="
#token LESSTHAN "<"
#token GREATERTHAN ">"
#token LESSTHANOREQUALTO "<="
#token GREATERTHANOREQUALTO ">="
#token SHIFTLEFT "\<\<"
#token SHIFTRIGHT "\>\>"
#token PLUS "\+"
#token MINUS "\-"
#token STAR "\*"
#token DIVIDE "/"
#token MOD "%"
#token PLUSPLUS "\+\+"
#token MINUSMINUS "\-\-"
#token TILDE "\~"
#token NOT "!"
#token DOT "."
#token POINTERTO "\->"

#token AUTO "auto"
#token BREAK "break"
#token CASE "case"
#token CHAR "char"

#tokclass CONST {"const" "__const" }

#token CONTINUE "continue"
#token DEFAULT "default"
#token DO "do"
#token DOUBLE "double"
#token ELSE "else"
#token ENUM "enum"
#token EXTERN "extern"
#token FLOAT "float"
#token FOR "for"
#token GOTO "goto"
#token IF "if"
#token INT "int"
#token LONG "long"
#token REGISTER "register"
#token RETURN "return"
#token SHORT "short"
#token SIGNED "signed"
#token SIZEOF "sizeof"
#token STATIC "static"
#token STRUCT "struct"
#token CLASS  "class"
#token SWITCH "switch"
#token TYPEDEF "typedef"
#token UNION "union"
#token UNSIGNED "unsigned"
#token VOID "void"
#token VOLATILE "volatile"
#token WHILE "while"
#token SCOPE "::"
#token OPERATOR "operator"
#token BOOL "bool" // ***
#token INT64 	"__int64" // ***
#token INT32 	"__int32" // ***
#token INT16 	"__int16" // ***
#token INT8 	"__int8" // ***
#token USING "using"
#token NAMESPACE "namespace"
#token EXPLICIT "explicit"
#token MUTABLE	"mutable"

#token DECLSPEC	"__declspec"

#tokclass CURLY_TOKCLASS { LCURLYBRACE RCURLYBRACE } 
#tokclass PARENTHESIS_TOKCLASS { LPARENTHESIS RPARENTHESIS } 
#tokclass INF_SUP_TOKCLASS { "<" ">" }
#tokclass THROW_TOK { "throw" "_THROW0" }
#tokclass TYPE_TOKCLASS { VOID CHAR SHORT INT LONG FLOAT DOUBLE SIGNED UNSIGNED INT64 INT32 INT16 INT8 }

#token "" << skip(); >> // ***
#token "__stdcall" << skip (); >> // ***
#token "__cdecl" << skip (); >>  // ***
#token "_cdecl" << skip (); >>  // ***
#token "__fastcall" << skip (); >>  // ***
#token "__inline" << skip (); >>  // ***
#token "_inline" << skip (); >>  // ***
#token "_STD_BEGIN" << skip (); >>  // ***
#token "_STD_END" << skip (); >>  // ***
#token "afx_msg" << skip (); >>  // ***


#token "/\*" << mode (COMMENT); skip (); >>

#token "[\t\ ]+"					<< skip (); >>
#token "[\n\r]"						<< newline(); skip(); >>
#token "// ~[\n]* \n"				<< newline(); skip(); >>
#token "#pragma ~[\n]* \n"			<< newline(); skip(); >>
// line number and file stuff from preprocessor
#token "#[\ \t]* [0-9]+ {[\ \t]* \"~[\"]+\" [\ \t]* [0-9]* [\ \t]* [0-9]*} \n"
									<< _line = atoi(begexpr()+1); skip(); >>

#token Eof "@"

#lexclass COMMENT

#token "[\n\r]"		<< skip(); newline(); >>
#token "\*/"		<< mode (START); skip (); >>
#token "\*~[/]"		<< skip (); >>
#token "~[\*\n\r]+"	<< skip (); >>

#lexclass STRINGS

#token STRING "\"" << mode (START); >>

#token "\\x" << replchar ((char) 0x0E); more (); >> //### 0x0E ... or another?

#token "\\n" << replchar ((char) 0x0A); more (); >>
#token "\\t" << replchar ((char) 0x09); more (); >>
#token "\\v" << replchar ((char) 0x0B); more (); >>
#token "\\b" << replchar ((char) 0x08); more (); >>
#token "\\r" << replchar ((char) 0x0D); more (); >>
#token "\\f" << replchar ((char) 0x0C); more (); >>
#token "\\a" << replchar ((char) 0x07); more (); >>
#token "\\\\" << replchar ((char) 0x5C); more (); >>
#token "\\?" << replchar ((char) 0x3F); more (); >>
#token "\\'" << replchar ((char) 0x27); more (); >>
#token "\\\"" << replchar ((char) 0x22); more (); >>
#token "\\0[0-7]*" << replchar ((char) strtol (begexpr(), NULL, 8)); more (); >>
#token "\\[1-9][0-9]*" << replchar ((char) strtol (begexpr(), NULL, 10)); more (); >>
#token "\\(0x|0X)[0-9a-fA-F]+" << replchar ((char) strtol (begexpr(), NULL, 16)); more (); >>
#token "[\n\r]" << newline(); more (); >>
#token "~[\"\n\r\\]+" << more (); >>

#lexclass CHARACTERS 

#token CHARACTER "'" << mode (START); >>
#token "\\n" << replchar ((char) 0x0A); more (); mode (DONE); >>
#token "\\t" << replchar ((char) 0x09); more (); mode (DONE); >>
#token "\\v" << replchar ((char) 0x0B); more (); mode (DONE); >>
#token "\\b" << replchar ((char) 0x08); more (); mode (DONE); >>
#token "\\r" << replchar ((char) 0x0D); more (); mode (DONE); >>
#token "\\f" << replchar ((char) 0x0C); more (); mode (DONE); >>
#token "\\a" << replchar ((char) 0x07); more (); mode (DONE); >>
#token "\\\\" << replchar ((char) 0x5C); more (); mode (DONE); >>
#token "\\?" << replchar ((char) 0x3F); more (); mode (DONE); >>
#token "\\'" << replchar ((char) 0x27); more (); mode (DONE); >>
#token "\\\"" << replchar ((char) 0x22); more (); mode (DONE); >>
#token "\\0[0-7]*" << replchar ((char) strtol (begexpr(), NULL, 8)); more (); mode (DONE); >>
#token "\\[1-9][0-9]*" << replchar ((char) strtol (begexpr(), NULL, 10)); more (); mode (DONE); >>
#token "\\(0x|0X)[0-9a-fA-F]+" << replchar ((char) strtol (begexpr(), NULL, 16)); more (); mode (DONE); >>
#token "[\n\r]" << newline(); more (); >>
#token "~['\n\r\\]" << more (); mode (DONE); >>

#lexclass DONE

#token CHARACTER "'" << mode (START); >>

#lexclass START

<<
//typedef ANTLRCommonToken ANTLRToken;
>>

class CPPParser {
<<
public:
#define CPPParser_MaxQualifiedItemSize	500

	// can't bitwise-OR enum elements together, this must be an int; damn!
	typedef unsigned long TypeSpecifier;	// note: must be > 16bits
#define	tsInvalid	0
#define tsVOID		0x1
#define tsCHAR		0x2
#define tsSHORT		0x4
#define tsINT		0x8
#define tsLONG		0x10
#define tsFLOAT		0x20
#define tsDOUBLE	0x40
#define tsSIGNED	0x80
#define tsUNSIGNED	0x100
#define tsTYPEID	0x200
#define tsSTRUCT	0x400
#define tsENUM		0x800
#define tsUNION		0x1000
#define tsCLASS		0x2000
#define tsEXPLICIT	0x3000		//###
#define tsBOOL		0x4000		//###


	enum TypeQualifier { tqInvalid=0, tqCONST=1, tqVOLATILE };

	enum StorageClass {
		scInvalid=0, scAUTO=1, scREGISTER,
		scSTATIC, scEXTERN, scTYPEDEF , scUSING, scNAMESPACE //###
	};

	enum DeclSpecifier {
		dsInvalid=0,
		dsVIRTUAL, dsINLINE, dsFRIEND, dsMUTABLE
	};

	enum QualifiedItem {
		qiInvalid=0,
		qiType=1,			// includes enum, class, typedefs
		qiDtor, qiCtor, qiOperator, qiPtrMember,
		qiID				// not a type, but could be a var, func...
	};

protected:
	// Symbol table management stuff
	CPPDictionary *symbols;
	StorageClass _sc;
	TypeQualifier _tq;
	TypeSpecifier _ts;
	unsigned char functionDefinition;
	int traceIndentLevel, doTracing;
	char qualifierPrefix[CPPParser_MaxQualifiedItemSize+1];
	int externalScope;	// global variables
	int templateParameterScope;
	char *enclosingClass;

	void tracein(char *r);
	void traceout(char *r);
	QualifiedItem qualifiedItemIs(int lookahead_offset=0);
	char *qualified(char *);
	int scopedItem(int k=1);
	int finalQualifier(int k=1);

public:
	void init()
	{
		ANTLRParser::init();
		symbols = new CPPDictionary(4001, 200, 800000);
		traceIndentLevel = 0;
		doTracing = 0;
		qualifierPrefix[0] = '\0';
		templateParameterScope = symbols->getCurrentScopeIndex();
		symbols->saveScope();
		externalScope = symbols->getCurrentScopeIndex();
		enclosingClass = "";
	}
	void traceOn()	{ doTracing=1; }

protected:
	virtual int isTypeName(char *s);
	virtual int isClassName(char *s);
	virtual void enterNewLocalScope();
	virtual void exitLocalScope();
	virtual void enterExternalScope();
	virtual void exitExternalScope();
	virtual void beginClassDefinition(TypeSpecifier, char *);
	virtual void endClassDefinition(TypeSpecifier);
	virtual void classForwardDeclaration(TypeSpecifier, DeclSpecifier, char *);
	virtual void beginDeclaration();
	virtual void endDeclaration();
	virtual void beginFunctionDefinition();
	virtual void endFunctionDefinition();
	virtual void functionParameterList();
	virtual void functionEndParameterList();
	virtual void beginConstructorDefinition(char *);
	virtual void endConstructorDefinition();
	virtual void beginConstructorDeclaration(char *);
	virtual void endConstructorDeclaration();
	virtual void beginDestructorDefinition(char *);
	virtual void endDestructorDefinition();
	virtual void beginDestructorDeclaration(char *);
	virtual void endDestructorDeclaration();
	virtual void beginParameterDeclaration();
	virtual void beginFieldDeclaration();
	virtual void endFieldDeclaration();
	virtual void declarationSpecifier(StorageClass, TypeQualifier, TypeSpecifier);
	virtual void beginEnumDefinition(char *);
	virtual void endEnumDefinition();
	virtual void enumElement(char *);
	virtual void declaratorPointerTo();
	virtual void declaratorID(char *);
	virtual void declaratorArrayTo();
	virtual void declaratorParameterList(int def);
	virtual void declaratorEndParameterList(int def);
	virtual void StoreQt(char*);
	virtual	void BaseClause(char *, int);
	virtual void PublicAccess();
	virtual void ProtectedAccess();
	virtual void PrivateAccess();
	virtual void templateTypeParameter(char *);
	virtual void beginTemplateDefinition();
	virtual void endTemplateDefinition();
	virtual void beginTemplateParameterList();
	virtual void endTemplateParameterList();
	virtual void exceptionBeginHandler();
	virtual void exceptionEndHandler();
	virtual void panic(char *);
	virtual void namespaceDeclaration(char *);
>>

translation_unit
	:	<<enterExternalScope();>>
		(external_declaration)+ Eof
		<<exitExternalScope();>>
	;

external_declaration
	:
		//template<..,..> A<..,..>::~A<..,..>() {..}
		( 
		template_head //{cv_qualifier_seq} 
		typeID  { "<" generic_bloc_templ ">" } SCOPE TILDE 
		typeID  { "<" generic_bloc_templ ">" }
		"\(" { parameter_list } "\)" {compound_statement}		
		)?

	|
		// typedef map< _KEY::TKey, CTIdentifierParent<_ENTITY>::CIdentifierTuple > TMap;
		(TYPEDEF ID "<" generic_bloc_templ ">" ID)? // ID or typeID.. to check
		declaration_specifiers { init_declarator_list } ";" 

	|
		(TYPEDEF typeID { "<" generic_bloc_templ ">" }  SCOPE ID)?
		decl_scope_specifiers  { init_declarator_list }  ";"

	|	(TYPEDEF (typeID|TYPE_TOKCLASS) ID )?
		declaration_specifiers  init_declarator_list 
		{ "__attribute__" generic_argument  } ";"

	|	// Class definition (templates too)
		// This is separated out otherwise the next alternative
		// would look for "class A { ... } f() {...}" which is
		// an acceptable level of backtracking.
		( {TYPEDEF | template_head } class_head  LCURLYBRACE )?
		{ template_head } declaration 

	|	// to handle  :  template<class _St> _St fpos<_St>::_Stz;
		(<<char *q;>> template_head	typeID qualified_id_scope >[q] <<declaratorID(q);>>  ";")?

	|	NAMESPACE
		id:ID
		<<namespaceDeclaration( id->getText() );>>
		"\{" (external_declaration)* "\}" #pragma approx {";"}

	|	// Enum definition (don't want to backtrack over this in other alts)
		( "enum" {ID} "\{" )?
		enum_specifier { init_declarator_list } ";"
		
		// Destructor DEFINITION (templated or non-templated)
	|	( {template_head} dtor_ctor_decl_spec dtor_declarator[1] "\{" )?
		dtor_definition

		// Constructor DEFINITION (non-templated)
	|	(ID)? => <<qualifiedItemIs()==qiCtor>>?
		( dtor_ctor_decl_spec ctor_declarator[1]
		  { ctor_initializer } "\{"
		)?
		ctor_definition

		// User-defined type cast
	|	( scope_override conversion_function_decl_or_def )?
	|	// Function definition
		( ID )? => <<1>>?
		<<;>>	// don't hoist preds from decl_specs as we will backtrack
		( {declaration_specifiers} function_declarator { (";"|"\{") } )?
		function_definition		 
		/* <<fprintf(stderr,"END Fct def\n");>> */

// templated stuff

	|	
		<<beginTemplateDefinition();>>
		( 
		template_head {cv_qualifier_seq} 
		typeID  ( {"<" generic_bloc_templ ">"} SCOPE ID )* {STAR | "&"}
		typeID {"<" generic_bloc_templ ">"} SCOPE ID  
		{ "=" ( template_id | ID |assignment_expression) } ";" 	
		)?
		<<endTemplateDefinition();>>

	|	// templated forward class decl, init/decl of static member in template
		<<beginTemplateDefinition();>>
		(template_head declaration_specifiers { init_declarator_list } ";")?
		<<endTemplateDefinition();>>

	|	(template_head "class")?
		template_head 
		declaration

	|	// Can only be templated function definition here; regular funcs
		// matched above. Templated CONSTRUCTORS also matched here
		<<beginTemplateDefinition();>>
		template_head
		(	( dtor_ctor_decl_spec ctor_declarator[1]
			  { ctor_initializer } "\{"
			)?
			ctor_definition
		|	{declaration_specifiers} function_declarator
		 	(   compound_statement	
		    |   ";"
		    )
		)
		<<endTemplateDefinition();>>

//
		// stupid, but must allow "a;"
	|	init_declarator_list ";"
//


		// everything else (except templates)

	|	declaration

		// believe it or not, this is a valid decl
	|	";"

	;


linkage_specification
	:	EXTERN
		STRING
		(	"\{" (external_declaration)* "\}" #pragma approx {";"}
		|	declaration
		)
	;

declaration
	:	<<;>>
		<<beginDeclaration();>>
		declaration_specifiers { init_declarator_list } ";" 
		<<endDeclaration();>>
	|	linkage_specification
	;


declaration_specifiers
	:	<<
		TypeSpecifier ts = tsInvalid, ts2;
		TypeQualifier tq = tqInvalid;
		StorageClass  sc = scInvalid;
		DeclSpecifier ds = dsInvalid;
		>>
		{DECLSPEC LPARENTHESIS ID RPARENTHESIS}
		#pragma approx
		(	storage_class_specifier>[sc]
		|	type_specifier[ds]>[ts2]		<<ts |= ts2;>>
		|	type_qualifier>[tq]
		|	"inline"						<<ds = dsINLINE;>>
		|	"virtual"						<<ds = dsVIRTUAL;>>
		|   "friend"						<<ds = dsFRIEND;>>
		|	"mutable"						<<ds = dsMUTABLE;>>
		)+
		<<declarationSpecifier(sc, tq, ts);>>
	;

type_specifier[DeclSpecifier ds] > [CPPParser::TypeSpecifier ts]
	:	simple_type_specifier > [$ts]
	|	class_specifier[$ds] > [$ts]
	|	enum_specifier	<<$ts=tsENUM;>>
	;

simple_type_specifier > [CPPParser::TypeSpecifier ts]
	:	<< char *qt_str; 
			static char qitem[CPPParser_MaxQualifiedItemSize+1];>>
		(
//			(ID "<" )? 
//			id:ID "<" generic_bloc_templ ">"   
//			<<StoreQt($id->getText()); $ts=tsTYPEID;>>
//		|	
			builtin_type_specifier > [$ts]
		|	qualified_type > [qt_str] <<StoreQt(qt_str); $ts=tsTYPEID;>>
		)
	;



/* Match the A::B::C:: or ::A::B:: nothing */
scope_override > [char *s]
	:	<<
		static char sitem[CPPParser_MaxQualifiedItemSize+1];
		sitem[0]='\0';
		>>
		{"::" <<strcat(sitem,"::");>> }
		#pragma approx
		(	<<scopedItem()>>?
			id:ID { "<" generic_bloc_templ ">" } "::"
			<<
			strcat(sitem,$id->getText());
			strcat(sitem,"::");
			>>
		)*
		<<$s = sitem;>>
	;

/* This matches a generic qualified identifier ::T::B::foo
 * (including "operator").
 * It might be a good idea to put T::~dtor in here
 * as well, but id_expression in expr.g puts it in manually.
 * Maybe not, 'cause many people use this assuming only A::B.
 * How about a 'qualified_complex_id'?
 */
qualified_id > [char *q]
	:	<<
		char *so;
		static char qitem[CPPParser_MaxQualifiedItemSize+1];
		>>
		scope_override > [so]
		<<strcpy(qitem, so);>>
		(	<<char *op;>>
			id2:ID { "<" generic_bloc_templ ">" }
			<<strcat(qitem,$id2->getText());>>
		|	"operator" optor > [op]
			<<strcat(qitem,"operator"); strcat(qitem,op);>>
		)
		<<$q = qitem;>>
	;


/* Match A::B::* */
ptr_to_member
	:	(ID)? => <<qualifiedItemIs()==qiPtrMember>>?
		scope_override "\*"
	;

qualified_type > [char *q]
	:	<<char *s; static char qitem[CPPParser_MaxQualifiedItemSize+1];>>
		<<qualifiedItemIs()==qiType || qualifiedItemIs()==qiCtor>>?
		scope_override > [s]
		id:ID #pragma approx {"<" generic_bloc_templ ">"}
		<<
		strcpy(qitem, s);
		strcat(qitem, $id->getText());
		$q = qitem;
		>>
	;

type_qualifier > [CPPParser::TypeQualifier tq]
	:	CONST		<<$tq = tqCONST;>>
	|	VOLATILE	<<$tq = tqVOLATILE;>>
	;

storage_class_specifier > [CPPParser::StorageClass sc]
	:	AUTO		<<$sc = scAUTO;>>
	|	REGISTER	<<$sc = scREGISTER;>>
	|	STATIC		<<$sc = scSTATIC;>>
	|	EXTERN		<<$sc = scEXTERN;>>
	|	TYPEDEF		<<$sc = scTYPEDEF;>>
	|	USING		<<$sc = scUSING;>>
	|	NAMESPACE	<<$sc = scEXTERN;>>
	;

builtin_type_specifier > [CPPParser::TypeSpecifier ts]
	:	VOID		<<$ts = tsVOID;>>
	|	CHAR		<<$ts = tsCHAR;>>
	|	SHORT		<<$ts = tsSHORT;>>
	|	INT			<<$ts = tsINT;>>
	|	LONG		<<$ts = tsLONG;>>
	|	FLOAT		<<$ts = tsFLOAT;>>
	|	DOUBLE		<<$ts = tsDOUBLE;>>
	|	SIGNED		<<$ts = tsSIGNED;>>
	|	UNSIGNED	<<$ts = tsUNSIGNED;>>
	|	BOOL		<<$ts = tsBOOL;>> // ***
	|	INT64		<<$ts = tsINT;>> // ***
	|	INT32		<<$ts = tsINT;>> // ***
	|	INT16		<<$ts = tsINT;>> // ***
	|	INT8		<<$ts = tsINT;>> // ***
	;

typeID
	:	<<isTypeName(LT(1)->getText())>>?
		ID
	;

init_declarator_list
	:	init_declarator (COMMA init_declarator)*
	;

init_declarator
	:	declarator 
		{	#pragma approx( "=" | ":" ) initializer //*** i need to verify for the correct use of ":"
		|	"\(" expression_list "\)"
		}
	;


class_head
	:	(	STRUCT
		|	UNION
		|	CLASS
		)
		{ID {"<" generic_bloc_templ ">"}  { base_clause } }
	;


class_specifier[DeclSpecifier ds] > [CPPParser::TypeSpecifier ts]
	:	<<char *saveClass;>>
//		<<;>>
		(	STRUCT	<<$ts=tsSTRUCT;>>
		|	UNION	<<$ts=tsUNION;>>
		|	CLASS	<<$ts=tsCLASS;>>
		)
		#pragma approx	// indicate that ambig between alts 1 and 3 is ok
		(	id:ID
			<<saveClass = enclosingClass;
			  enclosingClass = symbols->strdup($id->getText()); >>
			{"<" generic_bloc_templ ">"}

			<<beginClassDefinition($ts, $id->getText());>>	//###
			{ base_clause }
			LCURLYBRACE
				(member_declaration)*
				<<endClassDefinition($ts);>>
			RCURLYBRACE
			/*<<endClassDefinition($ts);>> */
			<<enclosingClass = saveClass;>>
		|	LCURLYBRACE
				<<saveClass = enclosingClass; enclosingClass = "__anonymous";>>
				<<beginClassDefinition($ts, "anonymous");>>
				(member_declaration)*
				<<endClassDefinition($ts);>>
			RCURLYBRACE
			<<enclosingClass = saveClass;>>

		|	tag:ID #pragma approx {"<" generic_bloc_templ ">"}
			<<classForwardDeclaration($ts, $ds, $tag->getText());>>
		)
	;



base_clause
	:	":" base_specifier ("," base_specifier)*
	;

base_specifier
	:	<<int _base_access = -1;>>
		(	"virtual" {access_specifier > [_base_access]} id_one:ID
			<<BaseClause($id_one->getText(),
				(_base_access == -1 ? 2 : _base_access));>>
		|	access_specifier > [_base_access] {"virtual"} id_two:ID
			<<BaseClause($id_two->getText(), _base_access);>>
		|	id_three:ID
			<<BaseClause($id_three->getText(), 2);>>
		)
		{"<" generic_bloc_templ ">"}
	;

access_specifier > [int _acc]
	:	"public"		<<$_acc = 0;>>
	|	"protected"		<<$_acc = 1;>>
	|	"private"		<<$_acc = 2;>>
	;

scope_specifiers  > [CPPParser::TypeSpecifier ts]
	:	<<char * qt_str;>>
		qualified_type_scope > [qt_str] <<StoreQt(qt_str); $ts=tsTYPEID;>>

	;


decl_scope_specifiers 
	:	<<
		TypeSpecifier ts = tsInvalid, ts2;
		TypeQualifier tq = tqInvalid;
		StorageClass  sc = scInvalid;
		DeclSpecifier ds = dsInvalid;
		>>
		#pragma approx
		(	storage_class_specifier>[sc]
		|	(typeID {"<" generic_bloc_templ ">"} SCOPE ID)? scope_specifiers > [ts2]	<<ts |= ts2;>>
//		|	(typeID  SCOPE ID)? scope_specifiers > [ts2]	<<ts |= ts2;>>
		|	type_qualifier>[tq]
		|	"inline"						<<ds = dsINLINE;>>
		|	"virtual"						<<ds = dsVIRTUAL;>>
		|   "friend"						<<ds = dsFRIEND;>>
		|	"mutable"						<<ds = dsMUTABLE;>>
		)+

		<<declarationSpecifier(sc, tq, ts);>>
	;

typedef_decl_scope_templ_specifiers 
	:	<<
		TypeSpecifier ts = tsInvalid, ts2;
		TypeQualifier tq = tqInvalid;
		StorageClass  sc = scInvalid;
		DeclSpecifier ds = dsInvalid;
		>>
		#pragma approx
		(	storage_class_specifier>[sc]
		|	typeID "<" generic_bloc_templ ">" 	<<ts =tsTYPEID;>>
		)+

		<<declarationSpecifier(sc, tq, ts);>>
	;

member_declaration
	:
		( "friend" "class" ID "<" generic_bloc_templ ">" ";")?

	|
		// typedef map< _KEY::TKey, CTIdentifierParent<_ENTITY>::CIdentifierTuple > TMap;

		( TYPEDEF typeID "<" generic_bloc_templ ">" ID)? 
		typedef_decl_scope_templ_specifiers {init_declarator_list} ";"

	|
		(TYPEDEF typeID { "<" generic_bloc_templ ">" }  SCOPE ID)?
		decl_scope_specifiers  { init_declarator_list }  ";"

	|	(TYPEDEF (typeID|TYPE_TOKCLASS) ID )?
		declaration_specifiers { init_declarator_list } ";"

	|	( 
		template_head {cv_qualifier_seq} 
		typeID {"<" generic_bloc_templ ">"} SCOPE ID
		typeID {"<" generic_bloc_templ ">"} SCOPE ID  
		{ "=" ( template_id | ID |assignment_expression) } ";" 
		)?

	|
	/*	// Class definition
		// This is separated out otherwise the next alternative
		// would look for "class A { ... } f() {...}" which is
		// an acceptable level of backtracking.
		( {TYPEDEF} class_head LCURLYBRACE )? declaration

	
	|*/	// Enum definition (don't want to backtrack over this in other alts)
		( "enum" {ID} "\{" )?
		enum_specifier {member_declarator_list} ";"
		
		// Destructor DEFINITION
	|	
		( dtor_ctor_decl_spec dtor_declarator[1] "\{" )?
		dtor_definition

	|	// Destructor DECLARATION (ambig with func def, but ok)
		( ("inline"|"virtual")* "\~" )?
		dtor_ctor_decl_spec
		<<beginDestructorDeclaration(LT(1)->getText());>>
		simple_dtor_declarator[0] ";"
		<<endDestructorDeclaration();>>

	|	// Constructor DEFINITION (must have same name as enclosing class)
		(ID)? => <<strcmp(enclosingClass,LT(1)->getText())==0>>?
		(   dtor_ctor_decl_spec ctor_declarator[1] { ctor_initializer } "\{" )?
		ctor_definition

	|	// Constructor DECLARATION (must have same name as enclosing class)
		(ID)? => <<strcmp(enclosingClass,LT(1)->getText())==0>>?
		(	<<;>>
			<<beginConstructorDeclaration(LT(1)->getText());>>
			dtor_ctor_decl_spec ctor_declarator[0] ";"
			<<endConstructorDeclaration();>>
		)?


	|	// Function definition
		( { declaration_specifiers } function_declarator  { (";"|"\{") } )? 
		function_definition

	|	// User-defined type cast
		conversion_function_decl_or_def
		
//	|	// Hack to handle decls like "superclass::member"
//		( qualified_id ";" )?


		// stupid, but must allow member "a;"
//	|	
//		member_declarator_list ";"


		// Member with a type or just a type def
		// A::T a(), ::T a, ::B a, void a, E a (where E is the enclosing class)
	|	
		(ID|SCOPE)? => <<qualifiedItemIs()==qiType||qualifiedItemIs()==qiCtor>>?
		declaration_specifiers {member_declarator_list} ";"

		// Member without a type (I guess it can only be a function decl)

	|	
		( ID )? => <<1>>?
		function_declarator ";"

	|	"public" ":" <<PublicAccess();>>
	|	"protected" ":" <<ProtectedAccess();>>
	|	"private" ":" <<PrivateAccess();>>
	|	";"
	;

member_declarator_list
	:	member_declarator { #pragma approx ("="|":") (constant |assignment_expression) } // The value must be 0 (pure virt.)
		( "," member_declarator { #pragma approx ("="|":") (constant |assignment_expression) } )*
	; 
	// i replaced OCTALINT with [assignment_expression] .. may be i sould add constant ... it is done =)
	// and i add the #pragma approx to include the ":" case.. it's temporary


member_declarator
	:	<<;>>
		<<beginFieldDeclaration();>> 
		declarator
		<<endFieldDeclaration();>>
	;

conversion_function_decl_or_def
	:	"operator" declaration_specifiers {"\*"|"&"}
		"\(" { parameter_list } "\)"
		{type_qualifier}
		(	compound_statement 
		|	";"
		)
	;

enum_specifier
	:	ENUM
		(	"\{" enumerator_list "\}"
		|	id:ID
			<<beginEnumDefinition($id->getText());>>
			{ "\{" enumerator_list "\}" }
			<<endEnumDefinition();>>
		)
	;

enumerator_list
	:	enumerator (COMMA enumerator)*
	;

enumerator
	:	id:ID { "=" constant_expression }
		<<enumElement($id->getText());>>
	|	
		declaration_specifiers function_declarator  { compound_statement }
		<<enumElement("A_function");>> 
		//We don't care about the name of this function.. for now.
	| /* empty */ // That seems very weird, but i found in a library file this case 
	;

/* I think something is weird with the context-guards for predicates;
 * as a result I manually hoist the appropriate pred from ptr_to_member
 */
ptr_operator
	:	"&" cv_qualifier_seq
	|  	"\*" cv_qualifier_seq
	|  	(ID)? => <<qualifiedItemIs()==qiPtrMember>>?
		<<;>> ptr_to_member cv_qualifier_seq
	;

/* Linear-approximate lookahead is sufficient to handle the {...}, but
 * ANTLR tries full LL(k) because is couldn't be sure.  The #pragma
 * forces ANTLR not to attempt this *expensive* operation.
 */
cv_qualifier_seq
	:	"const"
	|	"const" "volatile"
	|	"volatile"
	|	"volatile" "const"
	|	/* empty */
	;

declarator
	:	ptr_operator declarator <<declaratorPointerTo();>>
	|	( ID )? => <<1>>?	// counteract qiPtrMember pred in ptr_operator
		direct_declarator
	;

direct_declarator
	:	<<char *id;>>
		qualified_id > [id] <<declaratorID(id);>>
		declarator_suffixes

	|	"\~" dtor:ID <<declaratorID($dtor->getText());>>
		declarator_suffixes

	|	LPARENTHESIS declarator RPARENTHESIS declarator_suffixes
	;

declarator_suffixes
	:	( LSQUAREBRACKET { constant_expression } RSQUAREBRACKET )+
		<<declaratorArrayTo();>>
	|	("\(" ID)? => <<qualifiedItemIs(1)==qiType||qualifiedItemIs(1)==qiCtor>>?
		"\(" <<declaratorParameterList(0);>>
			{ parameter_list }
		"\)" <<declaratorEndParameterList(0);>>
		{ type_qualifier }
	|
	;

/* I think something is weird with the context-guards for predicates;
 * as a result I manually hoist the appropriate pred from ptr_to_member
 *
 * TER: warning: seems that "ID::" will always bypass and go to 2nd alt :(
 */

function_definition
	:	// don't want next action as an init-action due to (...)? caller
		<<beginFunctionDefinition();>>
		(	
			declaration_specifiers function_declarator  <<endFunctionDefinition();>> 		
			{ THROW_TOK "\(" { parameter_list } "\)" } //###
			{compound_statement}
		|	function_declarator <<endFunctionDefinition();>> 
			{ THROW_TOK "\(" { parameter_list } "\)" } //###
			{compound_statement }
		)
	;


function_declarator
	:	(ID)? => <<qualifiedItemIs()==qiPtrMember>>?
		<<;>> ptr_operator function_declarator <<declaratorPointerTo();>>
	|	function_direct_declarator
	;

function_direct_declarator
	:	<<char *q;>>
		/* predicate indicate that plain ID is ok here; this counteracts any
		 * other predicate that gets hoisted (along with this one) that
		 * indicates that an ID is a type or whatever.  E.g.,
		 * another rule testing isTypeName() alone, implies that the
		 * the ID *MUST* be a type name.  Combining isTypeName() and
		 * this predicate in an OR situation like this one:
		 * ( declaration_specifiers ... | function_declarator ... )
		 * would imply that ID can be a type name OR a plain ID.
		 */
		#pragma approx
		(
			( typeID "<" generic_bloc_templ ">"  "::" {STAR } ID )? //=> <<1>>?
			qualified_id_scope >[q]
			<<declaratorID(q);>>
		|
			( ID )? => <<1>>?
			qualified_id>[q]
			<<declaratorID(q);>>
		|
			"\("
			//declarator
			( ID )? => <<1>>?  qualified_id>[q] <<declaratorID(q);>>
			"\)"
		)	
		<<functionParameterList();>>
		"\(" { parameter_list } "\)"
		{ type_qualifier }
		{ "="  constant  }		// The value of the octal must be 0
		<<functionEndParameterList();>>
	;
	

dtor_ctor_decl_spec
	:	"inline"
	|	"virtual"
	|	"virtual" "inline"
	|	"inline" "virtual"
	|	EXPLICIT	//### ADDED
	|
	;

dtor_definition
	:	<<;>>
		<<beginDestructorDefinition(LT(2)->getText());>>
		{template_head}
		dtor_ctor_decl_spec dtor_declarator[1]
		compound_statement
		<<endDestructorDefinition();>>
	;

ctor_definition
	:	<<;>>
		<<beginConstructorDefinition(LT(1)->getText());>>
		dtor_ctor_decl_spec ctor_declarator[1] { ctor_initializer }
		<<endConstructorDefinition();>>	 //### This line was at the end.
		compound_statement
	;

dtor_declarator[int definition]
	:	scope_override simple_dtor_declarator[$definition]
	;

simple_dtor_declarator[int definition]
	:	"\~" ID
		<<declaratorParameterList($definition);>>
		"\(" { parameter_list } "\)"
		<<declaratorEndParameterList($definition);>>
		{ THROW_TOK "\(" { parameter_list } "\)" }
	;

ctor_declarator[int definition]
	:	
		qualified_id 
		<<declaratorParameterList($definition);>>
		"\(" { parameter_list } "\)"
		<<declaratorEndParameterList($definition);>>
	;

ctor_initializer
	:	
	{ THROW_TOK "\(" { parameter_list } "\)" } 
	":" superclass_init ("," superclass_init)*
	;

superclass_init
	:	qualified_id "\(" {expression_list} "\)"
	;

parameter_list
	:	parameter_declaration_list { {","} "..." }
	|	"..."
	;

parameter_declaration_list
	:	parameter_declaration ( COMMA parameter_declaration )*
	;

parameter_declaration
	:   <<;>>
		<<beginParameterDeclaration();>>
		( 
			( cv_qualifier_seq ID {"<" generic_bloc_templ ">" } "::" ID)?
			arg_scope_spec 
		|
			declaration_specifiers 
		)

		(	(declarator)?			// if arg name given
		|	abstract_declarator		// if arg name not given
		)
		{"=" assignment_expression}
	;


initializer
	:	assignment_expression
	|	LCURLYBRACE initializer (COMMA initializer)* RCURLYBRACE
	;

type_name
	:	declaration_specifiers abstract_declarator
	;


/* This rule looks a bit weird because (...) can happen in two
 * places within the declaration such as "void (*)()" (ptr to
 * function returning nothing).  However, the () of a function
 * can only occur after having seen either a (abstract_declarator)
 * and not after a [..] or simple '*'.  These are the only two
 * valid () func-groups:
 *		int (*)();		// ptr to func
 *		int (*[])();	// array of ptr to func
 */
abstract_declarator
	:	<<;>> ptr_operator abstract_declarator <<declaratorPointerTo();>> 
	|	LPARENTHESIS abstract_declarator RPARENTHESIS
		(abstract_declarator_suffix)+
	|	(	LSQUAREBRACKET { constant_expression } RSQUAREBRACKET
			<<declaratorArrayTo();>>
		)+
	|	/* empty */
	;

abstract_declarator_suffix
	:	LSQUAREBRACKET { expression } RSQUAREBRACKET  //*** expression instead of constant_expression 
		<<declaratorArrayTo();>>
	|	"\("
			<<declaratorParameterList(0);>>
			{ parameter_list }
		"\)"
		<<declaratorEndParameterList(0);>>
	;

template_head
	:  	"template"
		<<beginTemplateParameterList();>>
		"<" { template_parameter_list} ">" 
		<<endTemplateParameterList();>>
	;

/*
template_declaration
	:	<<;>>
		<<beginTemplateDefinition();>>
		template_head declaration
		<<endTemplateDefinition();>>
	;
*/

template_parameter_list
	:  template_parameter ( "," template_parameter )*
	;

/* Rule requires >2 lookahead tokens. The ambiguity is resolved 
 * correctly, however. According to the manual ''...A template argument
 * that can be interpreted either as a parameter-declaration or a
 * type-argument (because its identifier is the name of an
 * already exisitng class) is taken as type-argument.''
 * Therefore, any "class ID" that is seen on the input, should
 * match the first alternative here (it should be a type-argument).
 */
template_parameter
	:	#pragma approx	// make ANTLR shut up about this ambiguity
		(	"class" id:ID	<<templateTypeParameter($id->getText());>> 
			{"=" ( ID { "<" generic_bloc_templ ">" } | TYPE_TOKCLASS |assignment_expression) {STAR|"&"} }
		|	( cv_qualifier_seq typeID ( { "<" generic_bloc_templ ">" } SCOPE ID)+ {init_declarator}  )?
		|	parameter_declaration
		)
	;

/* This rule refers to an instance of a template class or function */
template_id
	:	ID "<" generic_bloc_templ ">"
	;



template_argument_list
	:	template_argument ( "," template_argument )*
	;




/* Here assignment_expression was changed to shift_expression to rule out
 *  x< 1<2 > which causes ambiguities. As a result, these can be used only
 *  by enclosing parentheses x<(1<2)>. This is true for x<1+2> ==> bad,
 *  x<(1+2)>==>ok.
 */


//template_argument
//	:	arg_scope_spec abstract_declarator 
//	|	type_name
//	|	shift_expression
//	;

arg_scope_spec 
	:	<<
		char * qt_str;
		TypeSpecifier ts = tsInvalid;
		TypeQualifier tq = tqInvalid;
		StorageClass  sc = scInvalid;
		>>
		
		( cv_qualifier_seq ID {"<" template_argument_list ">" } "::" ID)?
		cv_qualifier_seq qualified_type > [qt_str] <<StoreQt(qt_str); ts=tsTYPEID;>>
		<<declarationSpecifier(sc, tq, ts);>>

	;


template_argument
	:	decl_scope_specifiers abstract_declarator 
	|	declaration_specifiers abstract_declarator //type_name
	|	shift_expression
	;


qualified_id_scope > [char *q]
	:	<<
		char *so;
		static char qitem[CPPParser_MaxQualifiedItemSize+1];
		>>

		full_scope_override > [so]
		<<strcpy(qitem, so);>>
		{ "<" generic_bloc_templ ">" }
		<<$q = qitem;>>
	;



qualified_type_scope > [char *q]
	:	<<char *s; static char qitem[CPPParser_MaxQualifiedItemSize+1];>>
		<<qualifiedItemIs()==qiType || qualifiedItemIs()==qiCtor>>?

		full_scope_override > [s]
		#pragma approx {"<" generic_bloc_templ ">"}

		<<strcpy(qitem, s);	$q = qitem;>>
	;

full_scope_override > [char *s]
	:	//<<;>> 
		//<<;>>
		<<
		static char sitem[CPPParser_MaxQualifiedItemSize+1];
		sitem[0]='\0';
		>>

		<<scopedItem()>>?
		id1:ID {"<" generic_bloc_templ ">"} "::" {STAR }
		<<
		strcat(sitem,$id1->getText());
		strcat(sitem,"::");
		>>
		
		#pragma approx
		(	<<scopedItem()>>?
			id2:ID {"<" generic_bloc_templ ">"} "::"
			<<
			strcat(sitem,$id2->getText());
			strcat(sitem,"::");
			>>
		)*

		id3:ID	<<strcat(sitem,$id3->getText());>>
		<<$s = sitem;>>
	;

}
