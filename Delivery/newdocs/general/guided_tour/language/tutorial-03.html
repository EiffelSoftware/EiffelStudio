<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML XMLNS:MSHelp="http://msdn.microsoft.com/mshelp">
	<XML>
		<MSHelp:Keyword Index="K" Term="Eiffel Tutorial, General Properties" />
		<MSHelp:Attr Name="Product" Value="Eiffel"/>
		<MSHelp:Attr Name="Locale" Value="kbEnglish"/>
	</XML>
	<HEAD>
		<TITLE>An Eiffel Tutorial, General Properties</TITLE>
		<LINK HREF="../../../default.css" TYPE="text/css" REL="STYLESHEET">
	</HEAD>
	<BODY>
		<TABLE CLASS="HEADER">
			<TR>
				<TD CLASS="HEADER">Eiffel ENViSioN!</TD>
			</TR>
			<TR>
				<TD CLASS="SUBHEADER">An Eiffel Tutorial, General Properties</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FRAME">
			<TR>
				<TD>
					<A NAME="pgfId-513899"></A>
					
					<P>Here is an overview of the facilities supported by Eiffel:</P>
					<UL>
						<LI>Completely <SPAN CLASS="italics">object-oriented</SPAN> approach. Eiffel is a 
        full-fledged application of object technology, not a "hybrid" of O-O and 
        traditional concepts. 
        
						<LI><SPAN CLASS="italics">External interfaces</SPAN>. Eiffel is a software composition tool and is easily 
        interfaced with software written in such languages as C, C++, Java and 
        C#. 
        
						<LI><SPAN CLASS="italics">Full lifecycle support</SPAN>. Eiffel is applicable throughout the 
        development process, including analysis, design, implementation and 
        maintenance. 
        
						<LI><SPAN CLASS="italics">Classes</SPAN> as the basic structuring tool. A 
        class is the description of a set of run-time objects, specified through 
        the applicable operations and abstract properties. An Eiffel system is 
        made entirely of classes, serving as the only module mechanism. 
        
						<LI><SPAN CLASS="italics">Consistent type system</SPAN>. Every type is based 
        on a class, including basic types such as integer, boolean, real, 
        character, string, array. 
        
						<LI><SPAN CLASS="italics">Design by Contract™.</SPAN> Every system component can be accompanied by a 
        precise specification of its abstract properties, governing its internal 
        operation and its interaction with other components. 
        
						<LI><SPAN CLASS="italics">Assertions</SPAN>. The method and notation support 
        writing the logical properties of object states, to express the terms of 
        the contracts. These properties, known as assertions, can be monitored 
        at run-time for testing and quality assurance. They also serve as 
        documentation mechanism. Assertions include preconditions, 
        postconditions, class invariants, loop invariants, and also appear in 
        "check" instructions. 
        
						<LI><SPAN CLASS="italics">Exception handling</SPAN>. You can set up your 
        software to detect abnormal conditions, such as unexpected operating 
        system signals and contract violations, correct them, and recover 
        
						<LI><SPAN CLASS="italics">Information hiding</SPAN>. Each class author 
        decides, for each feature, whether it is available to all client 
        classes, to specific clients only, or just for internal purposes. 
        
						<LI><SPAN CLASS="italics">Self-documentation</SPAN>. The notation is designed 
        to enable environment tools to produce abstract views of classes and 
        systems, textual or graphical, and suitable for reusers, maintainers and 
        client authors. 
        
						<LI><SPAN CLASS="italics">Inheritance</SPAN>. You can define a class as 
        extension or specialization of others. 
        
						<LI><SPAN CLASS="italics">Redefinition</SPAN>. An inherited feature 
        (operation) can be given a different implementation or signature. 
        
						<LI><SPAN CLASS="italics">Explicit redefinition</SPAN>. Any feature redefinition must be explicitly stated. 

        
						<LI><SPAN CLASS="italics">Subcontracting</SPAN>. Redefinition rules require 
        new assertions to be compatible with inherited ones. 
        
						<LI><SPAN CLASS="italics">Deferred features and classes</SPAN>. It is possible for a feature, and the 
        enclosing class, to be specified -- including with assertions -- but not 
        implemented. Deferred classes are also known as abstract classes. 
        
						<LI><SPAN CLASS="italics">Polymorphism</SPAN>. An entity (variable, argument 
        etc.) can become attached to objects of many different types. 
        
						<LI><SPAN CLASS="italics">Dynamic binding</SPAN>. Calling a feature on an object always triggers the 
        version of the feature specifically adapted to that object, even in the 
        presence of polymorphism and redefinition. 
        
						<LI><SPAN CLASS="italics">Static typing</SPAN>. A compiler can check statically that all type 
        combinations will be valid, so that no run-time situation will occur in 
        which an attempt will be made to apply an inexistent feature to an 
        object. 
        
						<LI><SPAN CLASS="italics">Assignment attempt </SPAN>("type narrowing"). It is 
        possible to check at run time whether the type of an object conforms to 
        a certain expectation, for example if the object comes from a database 
        or a network. 
        
						<LI><SPAN CLASS="italics">Multiple inheritance</SPAN>. A class can inherit from any number of others. 
        
						<LI><SPAN CLASS="italics">Feature renaming</SPAN>. To remove name clashes under multiple inheritance, or 
        to give locally better names, a class can give a new name to an 
        inherited feature. 
        
						<LI><SPAN CLASS="italics">Repeated inheritance</SPAN>:<SPAN CLASS="italics">
						sharing and replication</SPAN>. If, as a result of multiple inheritance, a class 
        inherits from another through two or more paths, the class author can 
        specify, for each repeatedly inherited feature, that it yields either 
        one feature (sharing) or two (replication). 
        
						<LI><SPAN CLASS="italics">No ambiguity under repeated inheritance</SPAN>. Conflicting redefinitions 
        under repeated inheritance are resolved through a "selection" mechanism. 

        
						<LI><SPAN CLASS="italics">Unconstrained genericity</SPAN>. A class can be 
        parameterized, or "generic", to describe containers of objects of an 
        arbitrary type. 
        
						<LI><SPAN CLASS="italics">Constrained genericity</SPAN>. A generic class can 
        be declared with a generic constraint, to indicate that the 
        corresponding types must satisfy some properties, such as the presence 
        of a particular operation. 
        
						<LI><SPAN CLASS="italics">Garbage collection</SPAN>. The dynamic model is designed so that memory 
        reclamation, in a supporting environment, can be automatic rather than 
        programmer-controlled. 
        
						<LI><SPAN CLASS="italics">No-leak modular structure</SPAN>. All software is built out of classes, with 
        only two inter-class relations, client and inheritance. 
        
						<LI><SPAN CLASS="italics">Once routines</SPAN>. A feature can be declared as "once", so that it is 
        executed only for its first call, subsequently returning always the same 
        result (if required). This serves as a convenient initialization 
        mechanism, and for shared objects. 
        
						<LI><SPAN CLASS="italics">Standardized library</SPAN>. The Kernel Library, 
        providing essential abstractions, is standardized across 
        implementations. 
        
						<LI><SPAN CLASS="italics">Other libraries</SPAN>. Eiffel development is largely 
						based on high-quality libraries covering many common needs of software development,
						from general algorithms and data structures to networking and databases.</LI>
					</UL>
					<P>It is also useful, as in any design, to list some of what is <SPAN CLASS="bold">
					not</SPAN> present in Eiffel. The approach is indeed based on a small number of
					coherent concepts so as to remain easy to master. Eiffel typically takes a few hours
					to a few days to learn, and users seldom need to return to the reference manual once
					they have understood the basic concepts. Part of this simplicity results from the explicit
					decision to exclude a number of possible facilities:</P>
					<UL>
						<LI><SPAN CLASS="italics">No global variables</SPAN>, which would break the modularity of systems and 
        hamper extendibility, reusability and reliability. 
        
						<LI><SPAN CLASS="italics">No union types</SPAN> (or record type with variants), which force the explicit 
        enumeration of all variants; in contrast, inheritance is an open 
        mechanism which permits the addition of variants at any time without 
        changing existing code. 
        
						<LI><SPAN CLASS="italics">No in-class overloading</SPAN> which, by assigning the same name to 
        different features within a single context, causes confusions, errors, 
        and conflicts with object-oriented mechanisms such as dynamic binding. 
        (Dynamic binding itself is a powerful form of inter-class overloading, 
        without any of these dangers.) 
        
						<LI><SPAN CLASS="italics">No goto instructions</SPAN> or similar control structures (break, exit, 
        multiple-exit loops) which break the simplicity of the control flow and 
        make it harder or impossible to reason about the software (in particular 
        through loop invariants and variants). 
        
						<LI><SPAN CLASS="italics">No exceptions to the type rules</SPAN>. To be credible, a type system must 
        not allow unchecked "casts" converting from a type to another. (Safe 
        cast-like operations are available through assignment attempt.) 
        
						<LI><SPAN CLASS="italics">No side-effect expression operators</SPAN> confusing computation and 
        modification. 
        
						<LI><SPAN CLASS="italics">No low-level pointers, no pointer arithmetic</SPAN>,
						a well-known source of bugs. (There is however a type <SPAN CLASS="italics">
						POINTER</SPAN>, used for interfacing Eiffel with C 
        and other languages.)</LI>
					</UL>
					<P CLASS="seealso"><B>See also</B><BR />
						<A HREF="tutorial-04.html">The Software Process In Eiffel</A>
					</P>
				</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FOOTER">
			<TR>
				<TD>© 2003-2004 Eiffel Software. All rights reserved.<TD></TD>
			</TR>
		</TABLE>
	</BODY>
</HTML>
