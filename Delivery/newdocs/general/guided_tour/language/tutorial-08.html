<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML XMLNS:MSHelp="http://msdn.microsoft.com/mshelp">
	<XML>
		<MSHelp:Keyword Index="K" Term="Eiffel Tutorial, Genericity And Arrays" />
		<MSHelp:Attr Name="Product" Value="Eiffel"/>
		<MSHelp:Attr Name="Locale" Value="kbEnglish"/>
	</XML>
	<HEAD>
		<TITLE>An Eiffel Tutorial, Genericity And Arrays</TITLE>
		<LINK HREF="../../../default.css" TYPE="text/css" REL="STYLESHEET">
	</HEAD>
	<BODY>
		<TABLE CLASS="HEADER">
			<TR>
				<TD CLASS="HEADER">Eiffel ENViSioN!</TD>
			</TR>
			<TR>
				<TD CLASS="SUBHEADER">An Eiffel Tutorial, Genericity And Arrays</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FRAME">
			<TR>
				<TD>
					<A NAME="pgfId-514722"></A>

					<P>Some of the classes that we will need, particularly in libraries, are
					<SPAN CLASS="bold">container</SPAN> classes, describing data structures made
					of a number of objects of the same or similar types. Examples of containers
					include arrays, stacks and lists. The class
					<SPAN CLASS="eclass">DEPOSIT_LIST</SPAN> posted in earlier examples describes
					such a container.</P>

					<P>It is not hard, with the mechanisms seen so far, to write the class
					<SPAN CLASS="eclass">DEPOSIT_LIST</SPAN>, which would include such features as
					<SPAN CLASS="efeature">count</SPAN> (query returning the number of deposit
					objects in the list) and <SPAN CLASS="efeature">put</SPAN> (command to insert a
					new deposit object).</P>

					<P>Most of the operations, however, would be the same for lists of objects
					other than deposits. To avoid undue replication of efforts and promote reuse,
					we need a way to describe <SPAN CLASS="bold">generic</SPAN> container classes,
					which we can use to describe containers containing elements of many different
					types.</P>

					<H2>Making a class generic</H2>

					<P>The notation</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">class</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">C</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="egeneric">G</SPAN><SPAN CLASS="esymbol">]</SPAN></P>

						<P>&#8230; <SPAN CLASS="ecomment">The rest as for any other class declaration</SPAN>
						&#8230;</P>
					</CODE>

					<P>introduces a generic class. A name such as <SPAN CLASS="egeneric">G</SPAN>
					appearing in brackets after the class name is known as a
					<SPAN CLASS="bold">formal generic parameter</SPAN>; it represents an arbitrary
					type.</P>

					<P>Within the class text, feature declarations can freely use
					<SPAN CLASS="egeneric">G</SPAN> even though it is not known what type
					<SPAN CLASS="egeneric">G</SPAN> stands for. Class <SPAN CLASS="eclass">LIST</SPAN>
					of EiffelBase, for example, includes features</P>

					<CODE>
						<P><SPAN CLASS="efeature">first</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="egeneric">G</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ecomment">-- Value of first list item</SPAN>

						<P><SPAN CLASS="efeature">extend</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">val</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="egeneric">G</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ecomment">-- Add a new item of value
						<SPAN CLASS="elocal">val</SPAN> at end of list</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&#8230;</P>
					</CODE>

					<P>The operations available on an entity such as
					<SPAN CLASS="efeature">first</SPAN> and <SPAN CLASS="elocal">val</SPAN>, whose
					type is a formal generic parameter, are the operations available on all types:
					use as source <SPAN CLASS="elocal">y</SPAN> of an assignment
					<SPAN CLASS="elocal">x</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
					<SPAN CLASS="elocal">y</SPAN>, use as target <SPAN CLASS="elocal">x</SPAN>
					of such an assignment (although not for <SPAN CLASS="elocal">val</SPAN>, which
					as a formal routine argument is not writable), use in equality comparisons
					<SPAN CLASS="elocal">x</SPAN> <SPAN CLASS="esymbol">=</SPAN>
					<SPAN CLASS="elocal">y</SPAN> or <SPAN CLASS="elocal">x</SPAN>
					<SPAN CLASS="esymbol">/=</SPAN> <SPAN CLASS="elocal">y</SPAN>, and application of
					universal features from <SPAN CLASS="eclass">ANY</SPAN> such as
					<SPAN CLASS="efeature">clone</SPAN>, <SPAN CLASS="efeature">equal</SPAN> and
					<SPAN CLASS="efeature">copy</SPAN>.</P>

					<P>To use a generic class such as list, a client will provide a type name as
					<SPAN CLASS="bold">actual generic parameter</SPAN>. So instead of relying on
					a special purpose class <SPAN CLASS="eclass">DEPOSIT_LIST</SPAN>, the class
					<SPAN CLASS="eclass">ACCOUNT</SPAN> could include the declaration</P>

					<CODE>
						<P><SPAN CLASS="efeature">all_deposits</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">LIST</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">DEPOSIT</SPAN><SPAN CLASS="esymbol">]</SPAN></P>
					</CODE>

					<P>using <SPAN CLASS="eclass">LIST</SPAN> as a generic class and
					<SPAN CLASS="eclass">DEPOSIT</SPAN> as the actual generic parameter.
					Then all features declared in <SPAN CLASS="eclass">LIST</SPAN> as
					working on values of type <SPAN CLASS="egeneric">G</SPAN> will work,
					when called on the target <SPAN CLASS="efeature">all_deposits</SPAN>,
					on values of type <SPAN CLASS="eclass">DEPOSIT</SPAN>. With the target</P>

					<CODE>
						<P><SPAN CLASS="efeature">all_accounts</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">LIST</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">ACCOUNT</SPAN><SPAN CLASS="esymbol">]</SPAN>
					</CODE>

					<P>these features would work on values of type
					<SPAN CLASS="eclass">ACCOUNT</SPAN>.</P>

					<P CLASS=note>A note of terminology: to avoid confusion, Eiffel
					always uses the word <SPAN CLASS="bold">argument</SPAN> for
					routine arguments, reserving <SPAN CLASS="bold">parameter</SPAN>
					for the generic parameters of classes.</P>

					<P>Genericity reconciles extendibility and reusability with the
					static type checking demanded by reliability. A typical error,
					such as confusing an account and a deposit, will be detected
					immediately at compile time, since the call
					<SPAN CLASS="efeature">all_accounts</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">extend</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">dep</SPAN><SPAN CLASS="esymbol">)</SPAN>
					is invalid for <SPAN CLASS="elocal">dep</SPAN> declared of type
					<SPAN CLASS="eclass">DEPOSIT</SPAN>. What is valid is something
					like <SPAN CLASS="efeature">all_accounts</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">extend</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">acc</SPAN><SPAN CLASS="esymbol">)</SPAN>
					for <SPAN CLASS="elocal">acc</SPAN> of type <SPAN CLASS="eclass">ACCOUNT</SPAN>.
					In other approaches, the same effect might require costly
					run-time checks (as in Java, C# or Smalltalk), with the risk of
					run-time errors.</P>

					<P CLASS=note>This form of genericity is known as
					<SPAN CLASS="bold">unconstrained</SPAN> because the formal
					generic parameter, <SPAN CLASS="egeneric">G</SPAN> in the example,
					represents an arbitrary type. You may also want to use types
					that are guaranteed to have certain operations available. This
					is known as <SPAN CLASS="bold">constrained</SPAN> genericity
					and will be studied with inheritance.</P>

					<H2>Arrays</H2>

					<P>An example of generic class from the Kernel Library is
					<SPAN CLASS="eclass">ARRAY</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="egeneric">G</SPAN><SPAN CLASS="esymbol">]</SPAN>,
					which describes direct-access arrays. Features include:</P>

					<UL>
						<LI><SPAN CLASS="efeature">put</SPAN> to replace an element's
						value, as in
						<SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">put</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">val</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS=enumber>25</SPAN><SPAN CLASS="esymbol">)</SPAN>
						which replaces by <SPAN CLASS="elocal">val</SPAN> the value
						of the array entry at index 25.</LI>

						<LI><SPAN CLASS="efeature">item</SPAN> to access an entry, as
						in <SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">item</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS=enumber>25</SPAN><SPAN CLASS="esymbol">)</SPAN>
						yielding the entry at index 25. A synonym is
						<SPAN CLASS="ekeyword">infix</SPAN>
						<SPAN CLASS="esymbol">&quot;</SPAN><SPAN CLASS="efeature">@</SPAN><SPAN CLASS="esymbol">&quot;</SPAN>,
						so that you may also write more tersely, for the same
						result, <SPAN CLASS="elocal">my_array</SPAN>
						<SPAN CLASS="efeature">@</SPAN> <SPAN CLASS=enumber>25</SPAN>.</LI>

						<LI><SPAN CLASS="efeature">lower</SPAN>,
						<SPAN CLASS="efeature">upper</SPAN> and
						<SPAN CLASS="efeature">count</SPAN>: queries yielding the
						bounds and the number of entries.</LI>

						<LI>The creation procedure <SPAN CLASS="efeature">make</SPAN>,
						as in <SPAN CLASS="ekeyword">create</SPAN>
						<SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">make</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS=enumber>1</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS=enumber>50</SPAN><SPAN CLASS="esymbol">)</SPAN>
						which creates an array with the given index bounds. It is
						also possible to resize an array through
						<SPAN CLASS="efeature">resize</SPAN>, retaining the old
						elements. In general, the Eiffel method abhors built-in
						limits, favoring instead structures that resize themselves
						when needed, either from explicit client request or
						automatically.</LI>
					</UL>

					<P>The comment made about <SPAN CLASS="eclass">INTEGER</SPAN> and
					other basic classes applies to <SPAN CLASS="eclass">ARRAY</SPAN>
					too: Eiffel compilers know about this class, and will be able
					to process expressions of the form
					<SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">put</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">val</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS=enumber>25</SPAN><SPAN CLASS="esymbol">)</SPAN> and
					<SPAN CLASS="elocal">my_array</SPAN> <SPAN CLASS="efeature">@</SPAN>
					<SPAN CLASS=enumber>25</SPAN> in essentially the same way as a
					C or Fortran array access -- <SPAN CLASS="elocal">my_array</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS=enumber>25</SPAN><SPAN CLASS="esymbol">]</SPAN>
					in C. But it is consistent and practical to let developers
					treat <SPAN CLASS="eclass">ARRAY</SPAN> as a class and arrays as
					objects; many library classes in EiffelBase, for example,
					inherit from <SPAN CLASS="eclass">ARRAY</SPAN>. Once again the
					idea is to get the best of both worlds: the convenience and
					uniformity of the object-oriented way of thinking; and the
					efficiency of traditional approaches.</P>

					<P CLASS=note>A similar technique applies to another Kernel
					Library class, that one not generic:
					<SPAN CLASS="eclass">STRING</SPAN>, describing character strings
					with a rich set of string manipulation features.</P>

					<H2>Generic derivation</H2>

					<P>The introduction of genericity brings up a small difference
					between classes and types. A generic class
					<SPAN CLASS="eclass">C</SPAN> is not directly a type since you
					cannot declare an entity as being of type
					<SPAN CLASS="eclass">C</SPAN>: you must use some actual generic
					parameter <SPAN CLASS="eclass">T</SPAN> -- itself a type.
					<SPAN CLASS="eclass">C</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">T</SPAN><SPAN CLASS="esymbol">]</SPAN>
					is indeed a type, but class <SPAN CLASS="eclass">C</SPAN> by
					itself is only a type template.</P>

					<P>The process of obtaining a type <SPAN CLASS="eclass">C</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">T</SPAN><SPAN CLASS="esymbol">]</SPAN>
					from a general class <SPAN CLASS="eclass">C</SPAN> is known as a
					<SPAN CLASS="bold">generic derivation</SPAN>;
					<SPAN CLASS="eclass">C</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">T</SPAN><SPAN CLASS="esymbol">]</SPAN>
					is a <SPAN CLASS="bold">generically derived type</SPAN>. Type
					<SPAN CLASS="eclass">T</SPAN> itself is, recursively, either a
					non-generic class or again a generically derived type
					<SPAN CLASS="eclass">D</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">U</SPAN><SPAN CLASS="esymbol">]</SPAN>
					for some <SPAN CLASS="eclass">D</SPAN> and <SPAN CLASS="eclass">U</SPAN>,
					as in <SPAN CLASS="eclass">LIST</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">ARRAY</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">]]</SPAN>.
					</P>

					<P>It remains true, however, that every type is based on a
					class. The base class of a generically derived type
					<SPAN CLASS="eclass">C</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">T</SPAN><SPAN CLASS="esymbol">]</SPAN>
					is <SPAN CLASS="eclass">C</SPAN>.</P>

					<P CLASS="seealso"><B>See also</B><BR />
							<A HREF="tutorial-09.html">Design by Contract&#153</A>
					</P>
				</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FOOTER">
			<TR>
				<TD>© 2003-2004 Eiffel Software. All rights reserved.</TD>
			</TR>
		</TABLE>
	</BODY>
</HTML>