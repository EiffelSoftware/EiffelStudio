<document title="General Target Options" output="studio">
	<meta_data/>
	<paragraph>
		<paragraph>This is where you can configure most general aspects of your target.</paragraph>
		<paragraph>Here is what you will see when you switch to the target section in the project settings of the calculator example:</paragraph>
		<paragraph>
			<image>
				<url/>
				<alt_text>General target properties</alt_text>
			</image>
		</paragraph>
		<paragraph>On the top you can easily switch between the different targets of the current system.</paragraph>
		<paragraph>You can change the name of the target and give it a description. A target can be marked as abstract if it should not appear in the list of targets when opening a configuration.</paragraph>
		<paragraph>Targets can inherit from each other, which means they take certain settings from a base target if the don't specify it themself. In the projects settings values that are inherited 
		are displayed with a light grey blackground. Values that are overriden are displayed with a light red background. Overriden values can be reset to their inherited value, 
		by right clicking on them and choosing <italic>Use inherited value</italic> from the context menu.</paragraph>
		<paragraph>An important setting that affects other settings is the compilation type. Here you can specify if you want to generate normal C/byte code (classic application) or if you want to generate .NET code.</paragraph>
		<paragraph>With the output name option you can change the name of the generated executable if you want this to be different than the name of the system.</paragraph>
		<paragraph>If you want to change the root of your system, you will see a dialog like this:</paragraph>
		<paragraph>
			<image>
				<url/>
				<alt_text>Root dialog</alt_text>
			</image>
		</paragraph>
		<paragraph>You can specify a root class, root cluster and root feature. Both root cluster and root feature are optional. Instead of specifying a root class it is also possible to choose 
			<italic>Compile all classes</italic> which doesn't generate a binary but checks all classes in the target. This can be used for making sure that a library doesn't have any compiler errors.
		</paragraph>
		<paragraph>The version dialog looks similar to this one:</paragraph>
		<paragraph>
			<image>
				<url/>
				<alt_text>Version dialog</alt_text>
			</image>
		</paragraph>
		<paragraph>It allows to set a version number and some copyright informations. On .NET this information will be put into the generated assembly.</paragraph>
		<anchor>file_pattern</anchor>
		<paragraph>The File pattern setting allows to set rules to exclude certain files from every cluster. This can be used to exclude CVS or SVN directories globally instead of excluding them on each cluster. The dialog looks like this:</paragraph>
		<paragraph>
			<image>
				<url/>
				<alt_text>File pattern dialog</alt_text>
			</image>
		</paragraph>
		<paragraph>
			File patterns are regular expression which are matched against directories and file names. The basic semantic is that everything is included that does either not match an exclude pattern or does match an include pattern.
			 Matching is done against the path relative to the location of the cluster and / is used as a directory sepearator.
		</paragraph>
		<sample>
			We have a recursive cluster in c:\projects\calculator\cluster and in there we have a file c:\projects\calculator\cluster\interface\ignore_me.e<line_break></line_break>
			Matching would now be first done against <italic>/interface</italic> and then against <italic>/interface/ignore_me.e</italic><line_break></line_break>
			A rule like <italic>^/interface$</italic> would exclude the whole subdirectory, a rule like <italic>^/interface/ignore_me\.e$</italic> would only exclude the ignore_me.e class.
		</sample>
		<anchor>condition</anchor>
		<paragraph>It is also possible to condition a file rule (set of include and exclude file patterns). Conditioning allows to have a certain file rule only active under certain conditions. The conditioning dialog looks like this:</paragraph>
		<paragraph>
			<image>
				<url/>
				<alt_text>Condition dialog</alt_text>
			</image>
		</paragraph>
		<paragraph>Conditioning possibilities are platform (e.g. only Windows or everything but windows), kind of build, .NET generation, dynamic runtime, multithreaded, version of compiler and 
		version of msil clr. It is also possible to specify custom conditions where a user defined variable has to have a certain value.</paragraph>
		<paragraph>Further options are</paragraph>
		<list ordered="false">
			<item>Profiling: turn on the Eiffel profiler during the application execution (C code generation mode only). The results can be seen at the end of the execution in the profiler window.</item>
			<item>Trace: display on the console all the features that are called during the system execution (C generation mode only).</item>
			<item>.NET Namespace: specify the namespace for this target (.NET code generation mode only)</item>
			<item>Line generation: generate some extra information that will enable a .NET debugger or a C debugger to step through the Eiffel code rather than MSIL code or C code.</item>
		</list>
	</paragraph>
</document>
