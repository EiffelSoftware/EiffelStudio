<document output="studio" title="Differences between ETL 2nd printing and ISE implementation">
	<meta_data/>
	<paragraph>
		<heading><size>2</size>Added classes</heading>
		<list ordered="false">
			<item>New basic classes have been added: <code><class_name>INTEGER_8</class_name></code>, <code><class_name>INTEGER_16</class_name></code>, <code><class_name>INTEGER_64</class_name></code> and <code><class_name>WIDE_CHARACTER</class_name></code>. <code><class_name>INTEGER</class_name></code> is now specified as having a 32 bits representation</item>
			<item>New <code><class_name>TUPLE</class_name></code>, <code><class_name>ROUTIN</class_name></code>E, <code><class_name>PROCEDURE</class_name></code> and <code><class_name>FUNCTION</class_name></code> classes required by the agent mechanism.</item>
		</list>
		<heading><size>2</size>Added keywords</heading>
		<list ordered="false">
			<item><code><keyword>Precursor</keyword></code></item>
			<item><code><keyword>reference</keyword></code>: new keyword to specify that a type is used as a reference type.</item>
			<item> <code> <keyword>agent</keyword></code>: new keyword used by the agent mechanism.</item>
			<item><code><keyword>create</keyword></code>: Instead of using the famous exclamation mark to create an instance of a class, you can use the keyword <code><keyword>create</keyword></code>. Below you will find a correspondence table between the old and the new syntaxes. The old syntax is still valid, but at some points ISE will remove it from its implementation:
				<table>
					<row> <cell>Old syntax</cell> <cell>New syntax</cell> </row>
					<row> <cell>!! a</cell> <cell><code><keyword>create</keyword></code> a</cell> </row>
					<row> <cell>!! a.make</cell> <cell><code><keyword>create</keyword></code> a.make</cell> </row>
					<row> <cell>!<code><class_name>B</class_name></code>! a</cell> <cell><code><keyword>create</keyword></code> {<code><class_name>B</class_name></code>} a</cell> </row>
					<row> <cell>!<code><class_name>B</class_name></code>! a.make</cell> <cell><code><keyword>create</keyword></code> {<code><class_name>B</class_name></code>} a.make</cell> </row>
				</table>
			</item>
		</list>
		<heading><size>2</size>Added semantics</heading>
		<list ordered="false">
			<item>
				<link>
					<url>/general/guided_tour/language/tutorial-08.html</url>
					<label>Generic            creation</label>
				</link>
			</item>
			<item>Expression creation: you can now create an object within an expression. For example, you want to create an object and pass it as an argument to a function. Whereas you had to create a local variable, create the object and pass it to the function, you now simply need to pass to the function the creation expression. Here is a small example:
				<table>
					<row> <cell>Old method</cell> <cell>New method</cell> </row>
					<row><cell>
<code_block>
<keyword>local</keyword>
	a: <class_name>STRING</class_name>
<keyword>do</keyword>
	!! a.<feature_name>make</feature_name> (10)
	<feature_name>f</feature_name> (a)
<keyword>end</keyword>
</code_block>
						</cell>
						<cell>
<code_block>
<keyword>do</keyword>
	<feature_name>f</feature_name> (<keyword>create</keyword> {<class_name>STRING</class_name>}.<feature_name>make</feature_name> (10))
<keyword>end</keyword>
</code_block>
						</cell>
					</row>
				</table>
				This is also very useful since it can improve the power of assertions.
			</item>
			<item>Mutually recursive constraints: one can now write class A [H, G-&gt;H] or class B [H -&gt; C, G -&gt; ARRAY [H]]. As a result, the declaration A [D, E] is valid only if E is a descendant of D. Similarly, the declaration B [E, ARRAY [D]] is not valid, if E is a descendant of D.</item>
			<item>
				<link>
					<url>/general/guided_tour/language/tutorial-11.html</url>
					<label>Tuples</label>
				</link>
			</item>
			<item>
				<link>
					<url>/general/guided_tour/language/tutorial-12.html</url>
					<label>Agents</label>
				</link>
			</item>
			<item>Feature access:
				<line_break/>
<code_block>
<keyword>local</keyword>
	value: <class_name>INTEGER</class_name>
<keyword>do</keyword>
	value := <keyword>feature</keyword> {<class_name>MY_CLASS</class_name>}.<feature_name>value</feature_name>
<keyword>end</keyword>
</code_block>
				<line_break/>The previous call is valid, if and only if:
				<list ordered="false">
					<item>
						<code><feature_name>value</feature_name></code> is a feature representing a constant of a basic type (<code><class_name>INTEGER</class_name></code>, <code><class_name>DOUBLE</class_name></code> or <code><class_name>CHARACTER</class_name></code>)</item>
					<item>
						<code><feature_name>value</feature_name></code> is a C/C++/DLL external feature
					</item>
					<item>
						<code><feature_name>value</feature_name></code> is an IL static external feature
					</item>
				</list>
			</item>
		</list>
		<heading><size>2</size>Added external support</heading>
		<paragraph>Look at the page for 
			<link>
				<url>../30_external_features/10_c_externals.html</url>
				<label>C</label>
			</link>
			 and 
			<link>
				<url>../30_external_features/20_cpp_externals.html</url>
				<label>C++</label>
			</link>
			 with the introduction of `struct' and C++ external features encapsulation.</paragraph>
	</paragraph>
</document>
