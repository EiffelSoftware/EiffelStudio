<document title="9 Inheritance">
	<meta_data>
		<help>
			<toc>
				<envision_location>EiffelEnvision\A Guide to Eiffel for .NET\An Eiffel Tutorial</envision_location>
				<envision_pseudo_name>90</envision_pseudo_name>
				<envision_title>Inheritance</envision_title>
				<studio_location/>
				<studio_title/>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph>Inheritance is a powerful and attractive technique. A look at either the practice or literature shows, however, that it is not always well applied. Eiffel has made a particular effort to tame inheritance for the benefit of modelers and software developers. Many of the techniques are original with Eiffel. Paul Dubois has written (comp.lang.python Usenet newsgroup, 23 March 1997): there are two things that [Eiffel] got right that nobody else got right anywhere else: support for design by contract, and multiple inheritance. Everyone should understand these "correct answers" if only to understand how to work around the limitations in other languages.</paragraph>
		<heading>
			<size>2</size>
			<content>Basic inheritance structure</content>
		</heading>
		<paragraph>To make a class inherit from another, simply use an 
			<code>
				<keyword>inherit</keyword>
			</code> clause:
		</paragraph>
<code_block>
<keyword>indexing</keyword> ...

<keyword>class</keyword> 
	<class_name>D</class_name>

<keyword>inherit</keyword>
	<class_name>A</class_name>
	<class_name>B</class_name>
	...

<keyword>feature</keyword>
	...
</code_block>
		<paragraph>This makes 
			<code>
				<class_name>D</class_name>
			</code> an heir of 
			<code>
				<class_name>A</class_name>
			</code>, 
			<code>
				<class_name>B</class_name>
			</code> and any other class listed. Eiffel supports 
			<bold>multiple</bold> inheritance: a class may have as many parents as it needs. Later sections (
			<link>
				<url>tutorial-10.xml</url><anchor_name>21906</anchor_name>
				<label>"Multiple inheritance and renaming", page 64</label>
			</link> and 
			<link>
				<url>tutorial-10.xml</url><anchor_name>69912</anchor_name>
				<label>"Repeated inheritance and selection", page 73</label>
			</link>) will explain how to handle possible conflicts between parent features.
		</paragraph>
		<note>This discussion will rely on the terminology introduced on page 
			<link>
				<url>tutorial-06.xml</url><anchor_name>INHERITANCE AND CLIENT TERMS</anchor_name>
				<label>14</label>
			</link>: 
			descendants of a class are the class itself, its heirs, the heirs of its heirs and so on. Proper descendants exclude the class itself. The reverse notions are ancestors and proper ancestors.
		</note>
		<paragraph>By default 
			<code>
				<class_name>D</class_name>
			</code> will simply include all the original features of 
			<code>
				<class_name>A</class_name>
			</code>, 
			<code>
				<class_name>B</class_name>
			</code>, ..., to which it may add its own through its 
			<code>
				<keyword>feature</keyword>
			</code> clauses if any. But the inheritance mechanism is more flexible, allowing 
			<code>
				<class_name>D</class_name>
			</code> to adapt the inherited features in many ways. Each parent name -- 
			<code>
				<class_name>A</class_name>
			</code>, 
			<code>
				<class_name>B</class_name>
			</code>, ... in the example -- can be followed by a Feature Adaptation clause, with subclauses, all optional, introduced by keywords 
			<code>
				<keyword>rename</keyword>
			</code>, 
			<code>
				<keyword>export</keyword>
			</code>, 
			<code>
				<keyword>undefine</keyword>
			</code>, 
			<code>
				<keyword>redefine</keyword>
			</code> and 
			<code>
				<keyword>select</keyword>
			</code>, enabling the author of 
			<code>
				<class_name>A</class_name>
			</code> to make the best use of the inheritance mechanism by tuning the inherited features to the precise needs of 
			<code>
				<class_name>D</class_name>
			</code>. This makes inheritance a principal tool in the Eiffel process, mentioned earlier, of carefully crafting each individual class, like a machine, for the benefit of its clients. The next sections review the various Feature Adaptation subclauses.
		</paragraph>
		<heading>
			<size>2</size>
			<content>Redefinition</content>
		</heading>
		<paragraph>The first form of feature adaptation is the ability to change the implementation of an inherited feature. </paragraph>
		<paragraph>Assume a class 
			<code>
				<class_name>SAVINGS_ACCOUNT</class_name>
			</code> that specializes the notion of account. It is probably appropriate to define it as an heir to class 
			<code>
				<class_name>ACCOUNT</class_name>
			</code>, to benefit from all the features of 
			<code>
				<class_name>ACCOUNT</class_name>
			</code> still applicable to savings accounts, and to reflect the conceptual relationship between the two types: every savings account, apart from its own specific properties, also "is" an account. But we may need to produce a different effect for procedure 
			<code>
				<feature_name>deposit</feature_name>
			</code> which, besides recording the deposit and updating the balance, may also need, for example, to update the interest.
		</paragraph>
		<paragraph>This example is typical of the form of reuse promoted by inheritance and crucial to effective reusability in software: the case of 
			reuse with adaptation. Traditional forms of reuse are all-or-nothing: either you take a component exactly as it is, or you build your own. Inheritance will get us out of this "reuse or redo" dilemma by allowing us to reuse 
			and redo. The mechanism is feature redefinition:
		</paragraph>
		<code_block>
<keyword>indexing</keyword>
	description<symbol>:</symbol> <string>"Savings accounts"</string>

<keyword>class</keyword>
	<class_name>SAVINGS_ACCOUNT</class_name>

<keyword>inherit</keyword>
	<class_name>ACCOUNT</class_name>
		<keyword>redefine</keyword> 
			<feature_name>deposit</feature_name>
	<keyword>end</keyword>

<keyword>feature</keyword> <comment>-- Element change</comment>

	<feature_name>deposit</feature_name> <symbol>(</symbol>sum<symbol>:</symbol> <class_name>INTEGER</class_name><symbol>)</symbol> <keyword>is</keyword>
			<comment>-- Add sum to account.</comment>
		<keyword>do</keyword>
			<comment>... New implementation (see below) ...</comment>
		<keyword>end</keyword>

	<comment>... Other features ...</comment>

<keyword>end</keyword> <comment>-- class SAVINGS_ACCOUNT</comment>
</code_block>
		<paragraph>Without the 
			<code>
				<keyword>redefine</keyword>
			</code> subclause, the declaration of 
			<code>
				<feature_name>deposit</feature_name>
			</code> would be invalid, yielding two features of the same name, the inherited one and the new one. The subclause makes this valid by specifying that the new declaration will override the old one.
		</paragraph>
		<paragraph>In a redefinition, the original version -- such as the 
			<code>
				<class_name>ACCOUNT</class_name>
			</code> implementation of 
			<code>
				<feature_name>deposit</feature_name>
			</code> in this example -- is called the 
			<code>
				<keyword>precursor</keyword>
			</code> of the new version. It is common for a redefinition to rely on the precursor's algorithm and add some other actions; the reserved word 
			<code>
				<keyword>Precursor</keyword>
			</code> helps achieve this goal simply. Permitted only in a routine redefinition, it denotes the parent routine being redefined. So here he body of the new 
			<code>
				<feature_name>deposit</feature_name>
			</code> (called "implementation New" above) could be of the form
		</paragraph>
<code_block>
<keyword>Precursor</keyword> <symbol>(</symbol><local_variable>sum</local_variable><symbol>)</symbol>
	<comment>-- Apply ACCOUNT's version of deposit</comment>
<comment>... Instructions to update the interest ...</comment>
</code_block>
		<paragraph>Besides changing the implementation of a routine, a redefinition can turn an argument-less function into an attribute; for example a proper descendant of 
			<code>
				<class_name>ACCOUNT</class_name>
			</code> could redefine 
			<code>
				<feature_name>deposits_count</feature_name>
			</code>, originally a function, as an attribute. The Uniform Access Principle (page 
			<link>
				<url>tutorial-07.xml</url><anchor_name>UNIFORM ACCESS</anchor_name>
				<label>19</label>
			</link>) guarantees that the redefinition makes no change for clients, which will continue to use the feature under the form 
			<code>
				<local_variable>acc</local_variable>.<feature_name>deposits_count</feature_name>
			</code>.
		</paragraph>
		<heading>
			<size>2</size>
			<content>Polymorphism</content>
		</heading>
		<paragraph>The inheritance mechanism is relevant to both roles of classes: module and type. Its application as a mechanism to reuse, adapt and extend features from one class to another, as just seen, covers its role as a 
			<bold>module extension</bold> mechanism. But it's also a 
			<bold>subtyping</bold> mechanism. To say that 
			<code>
				<class_name>D</class_name>
			</code> is an heir of 
			<code>
				<class_name>A</class_name>
			</code>, or more generally a descendant of 
			<code>
				<class_name>A</class_name>
			</code>, is to expresses that instances of 
			<code>
				<class_name>D</class_name>
			</code> can be viewed as instances of 
			<code>
				<class_name>A</class_name>
			</code>.
		</paragraph>
		<paragraph>
			<bold>Polymorphic assignment</bold> supports this second role. In an assignment 
			<code>
				<local_variable>x</local_variable> <symbol>:=</symbol> <local_variable>y</local_variable>
			</code>, the types of 
			<code>
				<local_variable>x</local_variable>
			</code> and 
			<code>
				<local_variable>y</local_variable>
			</code> do not have, with inheritance, to be identical; the rule is that the type of 
			<code>
				<local_variable>y</local_variable>
			</code> must simply 
			<bold>conform</bold> to the type of 
			<code>
				<local_variable>x</local_variable>
			</code>. A class 
			<code>
				<class_name>D</class_name>
			</code> conforms to a class 
			<code>
				<class_name>A</class_name>
			</code> if and only if it is a descendant of 
			<code>
				<class_name>A</class_name>
			</code> (which includes the case in which 
			<code>
				<class_name>A</class_name>
			</code> and 
			<code>
				<class_name>D</class_name>
			</code> are the same class); if these classes are generic, conformance of 
			<code>
				<class_name>D</class_name>
			</code>
			<code>
				<symbol>[</symbol>
			</code>
			<code>
				<class_name>U</class_name>
			</code>
			<code>
				<symbol>]</symbol>
			</code> to 
			<code>
				<class_name>C</class_name>
			</code>
			<code>
				<symbol>[</symbol>
			</code>
			<code>
				<class_name>T</class_name>
			</code>
			<code>
				<symbol>]</symbol>
			</code> requires in addition that type 
			<code>
				<class_name>U</class_name>
			</code> conform to type 
			<code>
				<class_name>T</class_name>
			</code> (through the recursive application of the same rules).
		</paragraph>
		<note>In addition, it follows from the earlier discussion of tuples (
			<link>
				<url>tutorial-11.xml</url><anchor_name>36752</anchor_name>
				<label>"Tuple types", page 90</label>
			</link>), that 
			<code>
				<class_name>TUPLE</class_name> <symbol>[</symbol><class_name>X</class_name><symbol>]</symbol>
			</code> conforms to 
			<code>
				<class_name>TUPLE</class_name>
			</code>, 
			<code>
				<class_name>TUPLE</class_name> <symbol>[</symbol><class_name>X</class_name>, <class_name>Y</class_name><symbol>]</symbol>
			</code> to 
			<code>
				<class_name>TUPLE</class_name> <symbol>[</symbol><class_name>X</class_name><symbol>]</symbol>
			</code> and so on.
		</note>
		<paragraph>So with the inheritance structure that we have seen, the declarations</paragraph>
<code_block>
<local_variable>acc</local_variable><symbol>:</symbol> <class_name>ACCOUNT</class_name>
<local_variable>sav</local_variable><symbol>:</symbol> <class_name>SAVINGS_ACCOUNT</class_name>
</code_block>
		<paragraph>make it valid to write the assignment</paragraph>
<code_block>
<local_variable>acc</local_variable> <symbol>:=</symbol> <local_variable>sav</local_variable>
</code_block>
		<paragraph>which will assign to 
			<code>
				<local_variable>acc</local_variable>
			</code> a reference attached (if not void) to a direct instance of type 
			<code>
				<class_name>SAVINGS_ACCOUNT</class_name>
			</code>, not 
			<code>
				<class_name>ACCOUNT</class_name>
			</code>.
		</paragraph>
		<paragraph>Such an assignment, where the source and target types are different, is said to be polymorphic. An entity such as 
			<code>
				<local_variable>acc</local_variable>
			</code>, which as a result of such assignments may become attached at run time to objects of types other than the one declared for it, is itself called a polymorphic entity.
		</paragraph>
		<paragraph>For polymorphism to respect the reliability requirements of Eiffel, it must be controlled by the type system and enable static type checking. We certainly do not want an entity of type 
			<code>
				<class_name>ACCOUNT</class_name>
			</code> to become attached to an object of type 
			<code>
				<class_name>DEPOSIT</class_name>
			</code>. Hence the second typing rule:
		</paragraph>
		<note>
			<bold>Type Conformance rule </bold>An assignment <code><local_variable>x</local_variable> <symbol>:=</symbol> <local_variable>y</local_variable></code>, or the use of y as actual argument corresponding to the formal argument x in a routine call, is only valid if the type of y conforms to the the type of x .
		</note>
		<paragraph>The second case listed in the rule is a call such as 
			<code>
				<feature_name>target</feature_name>.<feature_name>routine</feature_name><symbol>(</symbol>..., <local_variable>y</local_variable>, ...<symbol>)</symbol>
			</code> where the routine declaration is of the form 
			<code>
				<feature_name>routine</feature_name> <symbol>(</symbol>..., <local_variable>x</local_variable><symbol>:</symbol> <class_name>SOME_TYPE</class_name><symbol>)</symbol>
			</code>. The relationship  between 
			<code>
				<local_variable>y</local_variable>
			</code>, the actual argument in the call, and the corresponding formal argument 
			<code>
				<local_variable>x</local_variable>
			</code>, is exactly the same as in an assignment 
			<code>
				<local_variable>x</local_variable> <symbol>:=</symbol> <local_variable>y</local_variable>
			</code>: not just the type rule, as expressed by Type Conformance (the type of 
			<code>
				<local_variable>y</local_variable>
			</code> must conform to 
			<code>
				<class_name>SOME_TYPE</class_name>
			</code>), but also the actual run-time effect which, as for assignments, will be either a reference attachment or, for expanded types, a copy.
		</paragraph>
		<paragraph>The ability to accept the assignment 
			<code>
				<local_variable>x</local_variable> <symbol>:=</symbol> <keyword>Void</keyword>
			</code> for 
			<code>
				<local_variable>x</local_variable>
			</code> of any reference type (
			<link>
				<url>tutorial-07.xml</url><anchor_name>12485</anchor_name>
				<label>"Basic operations", page 28</label>
			</link>) is a consequence of the Type Conformance rule, since 
			<code>
				<keyword>Void</keyword>
			</code> is of type 
			<code>
				<class_name>NONE</class_name>
			</code> which by construction (
			<link>
				<url>tutorial-06.xml</url><anchor_name>82680</anchor_name>
				<label>"The global inheritance structure", page 15</label>
			</link>) conforms to all types.
		</paragraph>
		<paragraph>Polymorphism also yields a more precise definition of "instance". A 
			<bold>direct instance</bold> of a type 
			<code>
				<class_name>A</class_name>
			</code> is an object created from the exact pattern defined by the declaration of 
			<code>
				<class_name>A</class_name>
			</code> 's base class, with one field for each of the class attributes; you will obtain it through a creation instruction of the form 
			<code>
				<keyword>create</keyword> <local_variable>x</local_variable>
			</code> ..., for 
			<code>
				<local_variable>x</local_variable>
			</code> of type 
			<code>
				<class_name>A</class_name>
			</code>, or by cloning an existing direct instance. An 
			<bold>instance</bold> of 
			<code>
				<class_name>A</class_name>
			</code> is a direct instance of any type conforming to 
			<code>
				<class_name>A</class_name>
			</code>: 
			<code>
				<class_name>A</class_name>
			</code> itself, but also any type based on descendant classes. So an instance of 
			<code>
				<class_name>SAVINGS_ACCOUNT</class_name>
			</code> is also an instance, although not a direct instance, of 
			<code>
				<class_name>ACCOUNT</class_name>
			</code>.
		</paragraph>
		<paragraph>A consequence of polymorphism is the ability to define 
			<bold>polymorphic data structures</bold>. With a declaration such as
		</paragraph>
<code_block>
<feature_name>accounts</feature_name><symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>ACCOUNT</class_name><symbol>]</symbol>
</code_block>
		<paragraph>the procedure call 
			<code>
				<feature_name>accounts</feature_name>.<feature_name>extend</feature_name>
			</code> (
			<code>
				<local_variable>acc</local_variable>
			</code>), because it uses a procedure 
			<code>
				<feature_name>extend</feature_name>
			</code>which in this case expects an argument of any type conforming to 
			<code>
				<class_name>ACCOUNT</class_name>
			</code>, will be valid not only if 
			<code>
				<local_variable>acc</local_variable>
			</code> is of type 
			<code>
				<class_name>ACCOUNT</class_name>
			</code> but also if it is of a descendant type such as 
			<code>
				<class_name>SAVINGS_ACCOUNT</class_name>
			</code>. Successive calls of this kind make it possible to construct a data structure that, at run-time, might contain objects of several types, all conforming to 
			<code>
				<class_name>ACCOUNT</class_name>
			</code>:
		</paragraph>
		<image>
			<url>tutorial-10.png</url>
		</image>
		<image>
			<url>tutorial-11.png</url>
		</image>
		<paragraph>Such polymorphic data structures combine the flexibility and safety of genericity and inheritance. You can make them more or less general by choosing for the actual generic parameter, here 
			<code>
				<class_name>ACCOUNT</class_name>
			</code>, a type higher or lower in the inheritance hierarchy. Static typing is again essential here, prohibiting for example a mistaken insertion of the form 
			<code>
				<feature_name>accounts</feature_name>.<feature_name>extend</feature_name> <symbol>(</symbol><local_variable>dep</local_variable><symbol>)</symbol>
			</code> where 
			<code>
				<local_variable>dep</local_variable>
			</code>is of type 
			<code>
				<class_name>DEPOSIT</class_name>
			</code>, which does not conform to 
			<code>
				<class_name>ACCOUNT</class_name>
			</code>.
		</paragraph>
		<paragraph>At the higher (most abstract) end of the spectrum, you can produce an unrestrictedly polymorphic data structure 
			<code>
				<feature_name>general_list</feature_name><symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>ANY</class_name><symbol>]</symbol>
			</code> which makes the call 
			<code>
				<feature_name>general_list</feature_name>.<feature_name>extend</feature_name> <symbol>(</symbol><local_variable>x</local_variable><symbol>)</symbol>
			</code> valid for any 
			<code>
				<local_variable>x</local_variable>
			</code>. The price to pay is that retrieving an element from such a structure will yield an object on which the only known applicable operations are the most general ones, valid for all types: assignment, copy, clone, equality comparison and others from 
			<code>
				<class_name>ANY</class_name>
			</code>. Assignment attempt, studied below, will make it possible to apply more specific operations after checking dynamically that a retrieved object is of the appropriate type.
		</paragraph>
		<heading>
			<size>2</size>
			<content>Dynamic binding</content>
		</heading>
		<paragraph>The complement of polymorphism is dynamic binding, the answer to the question "What version of a feature will be applied in a call whose target is polymorphic?". </paragraph>
		<paragraph>Consider 
			<code>
				<local_variable>acc</local_variable>
			</code> is of type 
			<code>
				<class_name>ACCOUNT</class_name>
			</code>. Thanks to polymorphism, an object attached to 
			<code>
				<local_variable>acc</local_variable>
			</code> may be a direct instance not just of 
			<code>
				<class_name>ACCOUNT</class_name>
			</code> but also of 
			<code>
				<class_name>SAVINGS_ACCOUNT</class_name>
			</code> or other descendants. Some of these descendants, indeed 
			<code>
				<class_name>SAVINGS_ACCOUNT</class_name>
			</code> among them, redefine features such as 
			<code>
				<feature_name>deposit</feature_name>
			</code>. Then we have to ask what the effect will be for a call of the form
		</paragraph>
<code_block>
<local_variable>acc</local_variable>.<feature_name>deposit</feature_name> <symbol>(</symbol><local_variable>some_value</local_variable><symbol>)</symbol>
</code_block>
		<paragraph>Dynamic binding is the clearly correct answer: the call will execute the version of 
			<code>
				<feature_name>deposit</feature_name>
			</code> from the generating class of the object attached to 
			<code>
				<local_variable>acc</local_variable>
			</code> at run time. If 
			<code>
				<local_variable>acc</local_variable>
			</code> is attached to a direct instance of 
			<code>
				<class_name>ACCOUNT</class_name>
			</code>, execution will use the original 
			<code>
				<class_name>ACCOUNT</class_name>
			</code> version; if 
			<code>
				<local_variable>acc</local_variable>
			</code> is attached to a direct instance of 
			<code>
				<class_name>SAVINGS_ACCOUNT</class_name>
			</code>, the call will execute the version redefined in that class.
		</paragraph>
		<paragraph>This is a clear correctness requirement. A policy of 
			static binding (as available for example in C++ or Delphi, for non-virtual functions) would take the declaration of 
			<code>
				<local_variable>acc</local_variable>
			</code> as an 
			<code>
				<class_name>ACCOUNT</class_name>
			</code> literally. But that declaration is only meant to ensure generality, to enable the use of a single entity 
			<code>
				<local_variable>acc</local_variable>
			</code> in many different cases: what counts at execution time is the object that 
			<code>
				<local_variable>acc</local_variable>
			</code> represents. Applying the 
			<code>
				<class_name>ACCOUNT</class_name>
			</code> version to a 
			<code>
				<class_name>SAVINGS_ACCOUNT</class_name>
			</code> object would be wrong, possibly leading in particular to objects that violate the invariant of their own generating class (since there is no reason a routine of 
			<code>
				<class_name>ACCOUNT</class_name>
			</code> will preserve the specific invariant of a proper descendant such as 
			<code>
				<class_name>SAVINGS_ACCOUNT</class_name>
			</code>, which it does not even know about).
		</paragraph>
		<paragraph>In some cases, the choice between static and dynamic binding does not matter: this is the case for example if a call's target is not polymorphic, or if the feature of the call is redefined nowhere in the system. In such cases the use of static binding permits slightly faster calls (since the feature is known at compile time). This application of static binding should, however, be treated as a 
			<bold>compiler optimization</bold>. The EiffelStudio compiler, under its "finalization" mode, which performs extensive optimization, will detect some of these cases and process them accordingly -- unlike approaches that make developers responsible for specifying what should be static and what dynamic (a tedious and error-prone task, especially delicate because a minute change in the software can make a static call, in a far-away module of a large system, suddenly become dynamic). Eiffel programmers don't need to worry about such aspects; they can rely on the semantics of dynamic binding in all cases, with the knowledge that the compiler will apply static binding when safe and desirable.
		</paragraph>
		<paragraph>Even in cases that require dynamic binding, the design of Eiffel, in particular the typing rules, enable compilers to make the penalty over the static-binding calls of traditional approaches very small and, most importantly, 
			<bold>constant-bounded</bold> : it does not grow with the depth or complexity of the inheritance structure. The discovery in 1985 of a technique for constant-time dynamic binding calls, even in the presence of multiple and repeated inheritance, was the event that gave the green light to the development of Eiffel.
		</paragraph>
		<paragraph>Dynamic binding is particularly interesting for polymorphic data structures. If you iterate over the list of accounts of various kinds, 
			<code>
				<feature_name>accounts</feature_name><symbol>:</symbol>	<class_name>LIST</class_name> <symbol>[</symbol><class_name>ACCOUNT</class_name><symbol>]</symbol>
			</code>, illustrated in the last figure, and at each step let 
			<code>
				<local_variable>acc</local_variable>
			</code> represent the current list element, you can repeatedly apply
		</paragraph>
<code_block>
<feature_name>acc</feature_name>.<feature_name>deposit</feature_name> <symbol>(</symbol>...<symbol>)</symbol>
</code_block>
		<paragraph>to have the appropriate variant of the 
			<code>
				<feature_name>deposit</feature_name>
			</code> operation triggered for each element.
		</paragraph>
		<paragraph>The benefit of such techniques appears clearly if we compare them with the traditional way to address such needs: using multi-branch discriminating instructions of the form 
			<code>
				<keyword>if</keyword> 
				<comment>"Account is a savings account "</comment> 
				<keyword>then</keyword> ... 
				<keyword>elseif</keyword> 
				<comment>"It is a money market account"</comment> 
				<keyword>then</keyword> ... 
			</code> and so on, or the corresponding 
			<code>
				<keyword>case</keyword> ... 
				<keyword>of</keyword> ...,
				<keyword>switch</keyword>
			</code> or 
			<code>
				<keyword>inspect</keyword>
			</code> instructions. Apart from their heaviness and complexity, such solutions cause many components of a software system to rely on the knowledge of the exact set of variants available for a certain notion, such as bank account. Then any addition, change or removal of variants can cause a ripple of changes throughout the architecture. This is one of the majors obstacles to extendibility and reusability in traditional approaches. In contrast, using the combination of inheritance, redefinition, polymorphism and dynamic binding makes it possible to have a 
			<bold>point of single choice</bold> -- a unique location in the system which knows the exhaustive list of variants. Every client then manipulates entities of the most general type, 
			<code>
				<class_name>ACCOUNT</class_name>
			</code>, through dynamically bound calls of the form 
			<code>
				<local_variable>acc</local_variable>.<feature_name>some_account_feature</feature_name> <symbol>(</symbol>...<symbol>)</symbol>
			</code>.
		</paragraph>
		<paragraph>These observations make dynamic binding appear for what it is: not an implementation mechanism, but an 
			<bold>architectural technique</bold> that plays a key role (along with information hiding, which it extends, and Design by Contract, to which it is linked through the assertion redefinition rules seen below) in providing the modular system architectures of Eiffel, the basis for the method's approach to reusability and extendibility. These properties apply as early as analysis and modeling, and continue to be useful throughout the subsequent steps.
		</paragraph>
		<heading>
			<size>2</size>
			<content>Deferred features and classes</content>
		</heading>
		<paragraph>The examples of dynamic binding seen so far assumed that all classes were fully implemented, and dynamically bound features had a version in every relevant class, including the most general ones such as 
			<code>
				<class_name>ACCOUNT</class_name>
			</code>.
		</paragraph>
		<paragraph>It is also useful to define classes that leave the implementation of some of their features entirely to proper descendants. Such an abstract class is known as 
			<code>
				<keyword>deferred</keyword>
			</code>; so are its unimplemented features. The reverse of deferred is effective, meaning fully implemented.
		</paragraph>
		<paragraph>
			<code>
				<class_name>LIST</class_name>
			</code> is a typical example of deferred class. As it describes the general notion of list, it should not favor any particular implementation; that will be the task of its effective descendants, such as 
			<code>
				<class_name>LINKED_LIST</class_name>
			</code> (linked implementation), 
			<code>
				<class_name>TWO_WAY_LIST</class_name>
			</code> (linked both ways) 
			<code>
				<string>ARRAYED_LIST, </string>
			</code> (implementation by an array), all effective, and all indeed to be found in EiffelBase.
		</paragraph>
		<paragraph>At the level of the deferred class 
			<code>
				<class_name>LIST</class_name>
			</code>, some features such as 
			<code>
				<feature_name>extend</feature_name>
			</code> (add an item at the end of the list) will have no implementation and hence will be declared as deferred. Here is the corresponding form, illustrating the syntax for both deferred classes and their deferred features:
		</paragraph>
<code_block>
<keyword>indexing</keyword>
	description<symbol>:</symbol> <string>"[</string>
		<string>Sequential finite lists, without a commitment</string>
		<string>to a representation."</string>

<keyword>deferred</keyword> <keyword>class</keyword>
	<class_name>LIST</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol>

<keyword>feature</keyword> <comment>-- Access</comment>

	count<symbol>:</symbol> <class_name>INTEGER</class_name> <keyword>is</keyword>
			<comment>-- Number of items in list</comment>
		<keyword>do</keyword>
			<comment>... See below; this feature can be effective ...</comment>
		<keyword>end</keyword>

<keyword>feature</keyword> <comment>-- Element change</comment>

	<feature_name>extend</feature_name> <symbol>(</symbol><local_variable>x</local_variable><symbol>:</symbol> <generics>G</generics><symbol>)</symbol> <keyword>is</keyword>
			<comment>-- Add `x' at end of list.</comment>
		<keyword>require</keyword>
			space_available<symbol>:</symbol> <keyword>not</keyword> <feature_name>full</feature_name>
		<keyword>deferred</keyword>
		<keyword>ensure</keyword>
			one_more<symbol>:</symbol> <feature_name>count</feature_name> <symbol>=</symbol> <keyword>old</keyword> <feature_name>count</feature_name> <symbol>+</symbol> <number>1</number>
		<keyword>end</keyword>

	<comment>... Other feature declarations and invariants ...</comment>

<keyword>end</keyword><comment> -- class LIST</comment>
</code_block>
		<paragraph>A deferred feature (considered to be a routine, although it can yield an attribute in a proper descendant) has the single keyword 
			<code>
				<keyword>deferred</keyword>
			</code> in lieu of the 
			<code>
				<keyword>do</keyword>
			</code> <italic>Instructions</italic> clause of an effective routine. A deferred class -- defined as a class that has at least one deferred feature -- must be introduced by 
			<code>
				<keyword>class deferred</keyword>
			</code> instead of just 
			<code>
				<keyword>class</keyword>
			</code>.
		</paragraph>
		<paragraph>As the example of 
			<code>
				<feature_name>extend</feature_name>
			</code> shows, a deferred feature, although it has no implementation, can be equipped with assertions. They will be binding on implementations in descendants, in a way to be explained below.
		</paragraph>
		<paragraph>Deferred classes do not have to be 
			fully deferred. They may contain some effective features along with their deferred ones. Here, for example, we may express 
			<code>
				<feature_name>count</feature_name>
			</code> as a function:
		</paragraph>
<code_block>
<feature_name>count</feature_name><symbol>:</symbol> <class_name>INTEGER</class_name> <keyword>is</keyword>
		<comment>-- Number of items in list</comment>
	<keyword>do</keyword>
		<keyword>from</keyword> 
			<feature_name>start</feature_name>
		<keyword>until</keyword>
			<feature_name>after</feature_name>
		<keyword>loop</keyword>
			<keyword>Result</keyword> <symbol>:=</symbol> <keyword>Result</keyword> <symbol>+</symbol> <number>1</number>
			<feature_name>forth</feature_name>
		<keyword>end</keyword>
	<keyword>end</keyword>
</code_block>
		<paragraph>This implementation relies on the loop construct described below (
			<code>
				<keyword>from</keyword>
			</code> introduces the loop initialization) and on a set of deferred features of the class which allow traversal of a list based on moving a fictitious cursor: 
			<code>
				<feature_name>start</feature_name>
			</code> to bring the cursor to the first element if any, 
			<code>
				<feature_name>after</feature_name>
			</code> to find out whether all relevant elements have been seen, and 
			<code>
				<keyword>forth</keyword>
			</code> (with precondition 
			<code>
				<keyword>not</keyword>
			</code> 
			<code>
				<feature_name>after</feature_name>
			</code>) to advance the cursor to the next element. Procedure 
			<code>
				<feature_name>forth</feature_name>
			</code> itself appears as
		</paragraph>
<code_block>
<feature_name>forth</feature_name> <keyword>is</keyword>
		<comment>-- Advance cursor by one position</comment>
	<keyword>require</keyword>
		not_after<symbol>:</symbol> <keyword>not</keyword> <feature_name>after</feature_name>
	<keyword>deferred</keyword>
	<keyword>ensure</keyword>
		moved_right<symbol>:</symbol> <feature_name>index</feature_name> <symbol>=</symbol> <keyword>old</keyword> <feature_name>index</feature_name> <symbol>+</symbol> <number>1</number>
	<keyword>end</keyword>
</code_block>
		<paragraph>where 
			<code>
				<feature_name>index</feature_name>
			</code> -- another deferred feature -- is the integer position of the cursor.
		</paragraph>
		<paragraph>Although the above version of feature 
			<code>
				<feature_name>count</feature_name>
			</code> is time-consuming -- it implies a whole traversal just for the purpose of determining the number of elements -- it has the advantage of being applicable to all variants, without any commitment to a choice of implementation, as would follow for example if we decided to treat 
			<code>
				<feature_name>count</feature_name>
			</code> as an attribute. Proper descendants can always redefine 
			<code>
				<feature_name>count</feature_name>
			</code> for more efficiency.
		</paragraph>
		<paragraph>Function 
			<code>
				<feature_name>count</feature_name>
			</code> illustrates one of the most important contributions of the method to reusability: the ability to define 
			<bold>behavior classes</bold> that capture common behaviors (such as count) while leaving the details of the behaviors (such as 
			<code>
				<feature_name>start</feature_name>
			</code>, 
			<code>
				<feature_name>after</feature_name>
			</code>, 
			<code>
				<feature_name>forth</feature_name>
			</code>) open to many variants. As noted earlier, traditional approaches to reusability provide closed reusable components. A component such as 
			<code>
				<class_name>LIST</class_name>
			</code>, although equipped with directly usable behaviors such as count, is open to many variations, to be provided by proper descendants.
		</paragraph>
		<note>Some O-O languages support only the two extremes: fully effective classes, and fully deferred "interfaces", but not classes with a mix of effective and deferred features. This is an unacceptable limitation, negating the object-oriented method's support for a seamless, continuous spectrum from the most abstract to the most concrete. </note>
		<paragraph>A class 
			<code>
				<class_name>B</class_name>
			</code> inheriting from a deferred class 
			<code>
				<class_name>A</class_name>
			</code> may provide implementations -- effective declarations -- for the features inherited in deferred form. In this case there is no need for a 
			<code>
				<keyword>redefine</keyword>
			</code> subclause; the effective versions simply replace the inherited versions. The class is said to <bold>effect</bold> the corresponding features. If after this process there remain any deferred features,  B is still considered deferred, even if it introduces no deferred features of its own, and must be declared as 
			<code>
				<keyword>class deferred</keyword>
			</code>.
		</paragraph>
		<paragraph>In the example, classes such as 
			<code>
				<class_name>LINKED_LIST</class_name>
			</code> and 
			<code>
				<class_name>ARRAYED_LIST</class_name>
			</code> will effect all the deferred features they inherit from 
			<code>
				<class_name>LIST</class_name>
			</code> -- 
			<code>
				<feature_name>extend</feature_name>
			</code>, 
			<code>
				<feature_name>start</feature_name>
			</code> etc. -- and hence will be effective.
		</paragraph>
		<paragraph>Except in some applications restricted to pure system modeling -- as discussed next -- the main benefit of deferred classes and features comes from polymorphism and dynamic binding. Because 
			<code>
				<feature_name>extend</feature_name>
			</code> has no implementation in class 
			<code>
				<class_name>LIST</class_name>
			</code>, a call of the form 
			<code>
				<feature_name>my_list</feature_name>.<feature_name>extend</feature_name><symbol>(</symbol>...<symbol>)</symbol>
			</code> with my_list of type 
			<code>
				<class_name>LIST</class_name> <symbol>[</symbol><generics>T</generics><symbol>]</symbol>
			</code> for some 
			<code>
				<class_name>T</class_name>
			</code> can only be executed if 
			<code>
				<feature_name>my_list</feature_name>
			</code> is attached to a direct instance of an effective proper descendant of 
			<code>
				<class_name>LIST</class_name>
			</code>, such as 
			<code>
				<class_name>LINKED_LIST</class_name>
			</code>; then it will use the corresponding version of 
			<code>
				<feature_name>extend</feature_name>
			</code>. Static binding would not even make sense here.
		</paragraph>
		<paragraph>Even an effective feature of 
			<code>
				<class_name>LIST</class_name>
			</code> such as count may depend on deferred features (start and so on), so that a call of the form
			<code>
				<feature_name>my_list</feature_name>.<feature_name>count</feature_name>
			</code> can only be executed in the context of an effective descendant.
		</paragraph>
		<paragraph>All this indicates that a deferred class must have 
			<bold>no direct instance</bold>. (It will have instances, the direct instances of its effective descendants.) If it had any, we could call deferred features on them, leading to execution-time impossibility. The rule that achieves this goal is simple: if the base type of 
			<code>
				<local_variable>x</local_variable>
			</code> is a deferred class, no creation instruction of target 
			<code>
				<local_variable>x</local_variable>
			</code>, of the form 
			<code>
				<keyword>create</keyword> <local_variable>x</local_variable>...
			</code>, is permitted.
		</paragraph>
		<heading>
			<size>2</size>
			<content>Applications of deferred classes</content>
		</heading>
		<paragraph>Deferred classes cover abstract notions with many possible variants. They are widely used in Eiffel where they cover various needs:
		<line_break/>
		<list ordered="false">
			<item>Capturing high-level classes, with common behaviors. </item>
			<item>Defining the higher levels of a general taxonomy, especially in the inheritance structure of a library. </item>
			<item>Defining the components of an architecture during system design, without commitment to a final implementation. </item>
			<item>Describing domain-specific concepts in analysis and modeling. </item>
		</list>
		</paragraph>
		<paragraph>These applications make deferred classes a central tool of the Eiffel method's support for seamlessness and reversibility. The last one in particular uses deferred classes and features to model objects from an application domain, without any commitment to implementation, design, or even software (and computers). Deferred classes are the ideal tool here: they express the properties of the domain's abstractions, without any temptation of implementation bias, yet with the precision afforded by type declarations, inheritance structures (to record classifications of the domain concepts), and contracts to express the abstract properties of the objects being described. </paragraph>
		<paragraph>Rather than using a separate method and notation for analysis and design, this apprroach integrates seamlessly with the subsequent phases (assuming the decision is indeed taken to develop a software system): it suffices to refine the deferred classes progressively by introducing effective elements, either by modifying the classes themselves, or by introducing design- and implementation-oriented descendants. In the resulting system, the classes that played an important role for analysis, and are the most meaningful for customers, will remain important; as we have seen (
			<link>
				<url>tutorial-04.xml</url><anchor_name>24218</anchor_name>
				<label>"Seamlessness and reversibility", page 9</label>
			</link>) this 
			direct mapping property is a great help for extendibility.
		</paragraph>
		<paragraph>The following sketch (from the book 
			<link>
				<url>http://eiffel.com/doc/oosc/</url>
				<label>Object-Oriented Software Construction</label>
			</link>) illustrates these ideas on theexample of scheduling the programs of a TV station. This is pure modeling of an application domain; no computers or software are involved yet. The class describes the notion of program segment.
		</paragraph>
		<paragraph>Note the use of assertions to define semantic properties of the class, its instances and its features. Although often presented as high-level, most object-oriented analysis methods (with the exception of Waldn's and Nerson's Business Object Notation) have no support for the expression of such properties, limiting themselves instead to the description of broad structural relationships. </paragraph>
<code_block>
<keyword>indexing</keyword>
	description<symbol>:</symbol> <string>"Individual fragments of a broadcasting schedule"</string>

<keyword>deferred</keyword> <keyword>class</keyword>
	<class_name>SEGMENT</class_name>

<keyword>feature</keyword> <comment>-- Access</comment>

	<feature_name>schedule</feature_name><symbol>:</symbol> <class_name>SCHEDULE</class_name> <keyword>is</keyword> <keyword>deferred</keyword> <keyword>end</keyword>
			<comment>-- Schedule to which segment belongs</comment>

	<feature_name>index</feature_name><symbol>:</symbol> <class_name>INTEGER</class_name> <keyword>is</keyword> <keyword>deferred</keyword> <keyword>end</keyword>
			<comment>-- Position of segment in its schedule</comment>

	<feature_name>starting_time</feature_name>, <feature_name>ending_time</feature_name><symbol>:</symbol> <class_name>INTEGER</class_name> <keyword>is</keyword> <keyword>deferred</keyword> <keyword>end</keyword>
			<comment>-- Beginning and end of scheduled air time</comment>

	<feature_name>next</feature_name><symbol>:</symbol> <class_name>SEGMENT</class_name> <keyword>is</keyword> <keyword>deferred</keyword> <keyword>end</keyword>
			<comment>-- Segment to be played next, if any</comment>

	<feature_name>sponsor</feature_name><symbol>:</symbol> <class_name>COMPANY</class_name> <keyword>is</keyword> <keyword>deferred</keyword> <keyword>end</keyword>
			<comment>-- Segment's principal sponsor</comment>

	<feature_name>rating</feature_name><symbol>:</symbol> <class_name>INTEGER</class_name> <keyword>is</keyword> <keyword>deferred</keyword> <keyword>end</keyword>
			<comment>-- Segment's rating (for children's viewing etc.)</comment>

	<feature_name>Minimum_duration</feature_name><symbol>:</symbol> <class_name>INTEGER</class_name> <keyword>is</keyword> 30
			<comment>-- Minimum length of segments, in seconds</comment>

	<feature_name>Maximum_interval</feature_name><symbol>:</symbol> <class_name>INTEGER</class_name> <keyword>is</keyword> 2
			<comment>-- Maximum time (seconds) between successive segments</comment>

<keyword>feature</keyword> <comment>-- Element change</comment>

	<feature_name>set_spons</feature_name><keyword>or</keyword> <symbol>(</symbol><local_variable>s</local_variable><symbol>:</symbol> <class_name>SPONSOR</class_name><symbol>)</symbol> <keyword>is</keyword>
		<keyword>require</keyword>
			not_void<symbol>:</symbol> <local_variable>s</local_variable> <symbol>/=</symbol> <keyword>Void</keyword>
		<keyword>deferred</keyword>
		<keyword>ensure</keyword>
			sponsor_set<symbol>:</symbol> sponsor <symbol>=</symbol> <local_variable>s</local_variable>
		<keyword>end</keyword>

	<comment>... change_next, set_rating omitted ...</comment>

<keyword>invariant</keyword>
	in_list<symbol>:</symbol> <symbol>(</symbol><number>1</number> <symbol>&lt;=</symbol> <feature_name>index</feature_name><symbol>)</symbol> <keyword>and</keyword> <symbol>(</symbol><feature_name>index</feature_name> <symbol>&lt;=</symbol> <feature_name>schedule</feature_name>.<feature_name>segments</feature_name>.<feature_name>count</feature_name><symbol>)</symbol>
	in_schedule<symbol>:</symbol> <feature_name>schedule</feature_name>.<feature_name>segments</feature_name>.<feature_name>item</feature_name> <symbol>(</symbol><feature_name>index</feature_name><symbol>)</symbol> <symbol>=</symbol> <keyword>Current</keyword>
	next_in_list<symbol>:</symbol> <symbol>(</symbol><feature_name>next</feature_name> <symbol>/=</symbol> <keyword>Void</keyword><symbol>)</symbol> <keyword>implies</keyword> <symbol>(</symbol><feature_name>schedule</feature_name>.<feature_name>segments</feature_name>.<feature_name>item</feature_name> <symbol>(</symbol>index <symbol>+</symbol> 1<symbol>)</symbol> <symbol>=</symbol> <feature_name>next</feature_name><symbol>)</symbol>
	no_next_if_last<symbol>:</symbol> <symbol>(</symbol><feature_name>next</feature_name> <symbol>=</symbol> <keyword>Void</keyword><symbol>)</symbol> <symbol>=</symbol> <symbol>(</symbol><feature_name>index</feature_name> <symbol>=</symbol> <feature_name>schedule</feature_name>.<feature_name>segments</feature_name>.<feature_name>count</feature_name><symbol>)</symbol>
	non_negative_rating<symbol>:</symbol> rating &gt;<symbol>=</symbol> <number>0</number>
	positive times<symbol>:</symbol> <symbol>(</symbol><feature_name>starting_time</feature_name> <symbol>&gt;</symbol> <number>0</number><symbol>)</symbol> <keyword>and</keyword> <symbol>(</symbol><feature_name>ending_time</feature_name> <symbol>&gt;</symbol> <number>0</number><symbol>)</symbol>
	sufficient_duration<symbol>:</symbol> <feature_name>ending_time</feature_name> <symbol>-</symbol> <feature_name>starting_time</feature_name> <symbol>&gt;=</symbol> <feature_name>Minimum_duration</feature_name>
	decent_interval<symbol>:</symbol> <symbol>(</symbol><feature_name>next</feature_name><feature_name/>.<feature_name/><feature_name>starting_time</feature_name><symbol>)</symbol> <symbol>-</symbol> <feature_name>ending_time</feature_name> <symbol>&lt;=</symbol> <feature_name>Maximum_interval</feature_name>

<keyword>end</keyword>
</code_block>
		<heading>
			<size>2</size>
			<content>Structural property classes</content>
		</heading>
		<paragraph>Some deferred classes describe a structural property, useful to the description of many other classes. Typical examples are classes of the Kernel Library in EiffelBase:</paragraph>
		<paragraph>
			<code>
				<class_name>NUMERIC</class_name>
			</code> describes objects on which arithmetic operations 
			<code>
				<symbol>+</symbol>, <symbol>-</symbol>, <symbol>*</symbol>, <symbol>/</symbol>
			</code> are available, with the properties of a ring (associativity, distributivity, zero elements etc.). Kernel Library classes such as 
			<code>
				<class_name>INTEGER</class_name>
			</code> and 
			<code>
				<class_name>REAL</class_name>
			</code> -- but not, for example, 
			<code>
				<class_name>STRING</class_name>
			</code> -- are descendants of 
			<code>
				<class_name>NUMERIC</class_name>
			</code>. An application that defines a class 
			<code>
				<class_name>MATRIX</class_name>
			</code> may also make it a descendant of 
			<code>
				<class_name>NUMERIC</class_name>
			</code>.
		</paragraph>
		<paragraph>
			<code>
				<class_name>COMPARABLE</class_name>
			</code> describes objects on which comparison operations 
			<code>
				<symbol>&lt;</symbol>, <symbol>&lt;=</symbol>, <symbol>&gt;</symbol>, <symbol>&gt;=</symbol>
			</code> are available, with the properties of a total preorder (transitivity, irreflexivity). Kernel Library classes such as 
			<code>
				<class_name>CHARACTER</class_name>
			</code>, 
			<code>
				<class_name>STRING</class_name>
			</code> and 
			<code>
				<class_name>INTEGER</class_name>
			</code> -- but not out 
			<code>
				<class_name>MATRIX</class_name>
			</code> example -- are descendants of 
			<code>
				<class_name>NUMERIC</class_name>
			</code>.
		</paragraph>
		<paragraph>For such classes it is again essential to permit effective features in a deferred class, and to include assertions. For example class 
			<code>
				<class_name>COMPARABLE</class_name>
			</code> declares 
			<code>
				<keyword>infix</keyword> <string>"&lt;"</string>
			</code> as deferred, and expresses 
			<code>
				<symbol>&gt;</symbol>, 
				<symbol>&gt;=</symbol>
			</code> and 
			<code>
				<symbol>&lt;</symbol>
			</code> effectively in terms of it.
		</paragraph>
		<note>The type 
			<code>
				<keyword>like</keyword> 
				<keyword>Current</keyword>
			</code> will be explained in 
			<link>
				<url>tutorial-10.xml</url><anchor_name>46019</anchor_name>
				<label>"Covariance and anchored declarations", page 79</label>
			</link>; you may understand it, in the following class, as equivalent to 
			<code>
				<class_name>COMPARABLE</class_name>
			</code>.
		</note>
<code_block>
<keyword>indexing</keyword>
	description<symbol>:</symbol> <string>"Objects that can be compared according to a total preorder relation"</string>

<keyword>deferred</keyword> <keyword>class</keyword>
	<class_name>COMPARABLE</class_name>

<keyword>feature</keyword> <comment>-- Comparison</comment>

	<keyword>infix</keyword> <string>"&lt;"</string> <symbol>(</symbol><local_variable>other</local_variable><symbol>:</symbol> <keyword>like</keyword> <keyword>Current</keyword><symbol>)</symbol><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
			<comment>-- Is current object less than `other'?</comment>
		<keyword>require</keyword>
			other_exists<symbol>:</symbol> <local_variable>other</local_variable> <symbol>/=</symbol> <keyword>Void</keyword>
		<keyword>deferred</keyword>
		<keyword>ensure</keyword>
			asymmetric<symbol>:</symbol> <keyword>Result</keyword> <keyword>implies</keyword> <keyword>not</keyword> <symbol>(</symbol><local_variable>other</local_variable> <symbol>&lt;</symbol> <keyword>Current</keyword><symbol>)</symbol>
		<keyword>end</keyword>

	<keyword>infix</keyword> <string>"&lt;="</string> <symbol>(</symbol><local_variable>other</local_variable><symbol>:</symbol> <keyword>like</keyword> <keyword>Current</keyword><symbol>)</symbol><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
			<comment>-- Is current object less than or equal to `other'?</comment>
		<keyword>require</keyword>
			other_exists<symbol>:</symbol> <local_variable>other</local_variable> <symbol>/=</symbol> <keyword>Void</keyword>
		<keyword>do</keyword>
			<keyword>Result</keyword> <symbol>:=</symbol> <symbol>(</symbol><keyword>Current</keyword> <symbol>&lt;</symbol> <local_variable>other</local_variable><symbol>)</symbol> <keyword>or</keyword> <feature_name>is_equal</feature_name> <symbol>(</symbol><local_variable>other</local_variable><symbol>)</symbol>
		<keyword>ensure</keyword>
			definition<symbol>:</symbol> <keyword>Result</keyword> <symbol>=</symbol> <symbol>(</symbol><keyword>Current</keyword> <symbol>&lt;</symbol> <local_variable>other</local_variable><symbol>)</symbol> <keyword>or</keyword> <feature_name>is_equal</feature_name> <symbol>(</symbol><local_variable>other</local_variable><symbol>)</symbol>
		<keyword>end</keyword>

	<comment>... Other features: infix "&gt;", min, max, ...</comment>

<keyword>invariant</keyword>
	irreflexive<symbol>:</symbol> <keyword>not</keyword> <symbol>(</symbol><keyword>Current</keyword> <symbol>&lt;</symbol> <keyword>Current</keyword><symbol>)</symbol>

<keyword>end</keyword> -- class COMPARABLE
</code_block>
		<heading>
			<size>2</size>
			<content>Multiple inheritance and renaming</content>
		</heading>
		<paragraph>It is often necessary to define a new class in terms of several existing ones. For example:</paragraph>
		<paragraph>The Kernel Library classes 
			<code>
				<class_name>INTEGER</class_name>
			</code> and 
			<code>
				<class_name>REAL</class_name>
			</code> must inherit from both 
			<code>
				<class_name>NUMERIC</class_name>
			</code> and 
			<code>
				<class_name>COMPARABLE</class_name>
			</code>.
		</paragraph>
		<paragraph>A class 
			<code>
				<class_name>TENNIS_PLAYER</class_name>
			</code>, in a system for keeping track of player ranking, will inherit from 
			<code>
				<class_name>COMPARABLE</class_name>
			</code>, as well as from other domain-specific classes.
		</paragraph>
		<paragraph>A class 
			<code>
				<class_name>COMPANY_PLANE</class_name>
			</code> may inherit from both 
			<code>
				<class_name>PLANE</class_name>
			</code> and 
			<code>
				<class_name>ASSET</class_name>
			</code>.
		</paragraph>
		<paragraph>Class 
			<code>
				<class_name>ARRAYED_LIST</class_name>
			</code>, describing an implementation of lists through arrays, may inherit from both 
			<code>
				<class_name>LIST</class_name>
			</code> and 
			<code>
				<class_name>ARRAY</class_name>
			</code>.
		</paragraph>
		<paragraph>In all such cases multiple inheritance provides the answer. </paragraph>
		<paragraph>Multiple inheritance can cause 
			<bold>name clashes</bold> : two parents may include a feature with the same name. This would conflict with the ban on name overloading within a class -- the rule that no two features of a class may have the same name. Eiffel provides a simple way to remove the name clash at the point of inheritance through the 
			<code>
				<keyword>rename</keyword>
			</code> subclause, as in
		</paragraph>
<code_block>
<keyword>indexing</keyword>
	description<symbol>:</symbol> <string>"Sequential finite lists implemented as arrays"</string>

<keyword>class</keyword>
	<class_name>ARRAYED_LIST</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol>

<keyword>inherit</keyword>
	<class_name>LIST</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol>

	<class_name>ARRAY</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol>
		<keyword>rename</keyword>
			<feature_name>count</feature_name> <keyword>as</keyword> <feature_name>capacity</feature_name>, 
			<feature_name>item</feature_name> <keyword>as</keyword> <feature_name>array_item</feature_name>
		<keyword>end</keyword>

<keyword>feature</keyword>

	...

<keyword>end</keyword> -- class ARRAYED_LIST
</code_block>
		<paragraph>Here both 
			<code>
				<class_name>LIST</class_name>
			</code> and 
			<code>
				<class_name>ARRAY</class_name>
			</code> have features called 
			<code>
				<feature_name>count</feature_name>
			</code> and 
			<code>
				<feature_name>item</feature_name>
			</code>. To make the new class valid, we give new names to the features inherited from 
			<code>
				<class_name>ARRAY</class_name>
			</code>, which will be known within 
			<code>
				<class_name>ARRAYED_LIST</class_name>
			</code> as 
			<code>
				<feature_name>capacity</feature_name>
			</code> and 
			<code>
				<feature_name>array_item</feature_name>
			</code>. Of course we could have renamed the 
			<code>
				<class_name>LIST</class_name>
			</code> versions instead, or renamed along both inheritance branches.
		</paragraph>
		<paragraph>Every feature of a class has a 
			<bold>final name</bold> : for a feature introduced in the class itself ("immediate" feature) it is the name appearing in the declaration; for an inherited feature that is not renamed, it is the feature's name in the parent; for a renamed feature, it is the name resulting from the renaming. This definition yields a precise statement of the rule against in-class overloading:
		</paragraph>
		<note>
			<bold>Final Name rule</bold>: Two different features of a class may not have the same final name.
		</note>
		<paragraph>It is interesting to compare renaming and redefinition. The principal distinction is between features and feature names. Renaming keeps a feature, but changes its name. Redefinition keeps the name, but changes the feature. In some cases, it is of course appropriate to do both. </paragraph>
		<paragraph>Renaming is interesting even in the absence of name clashes. A class may inherit from a parent a feature which it finds useful for its purposes, but whose name, appropriate for the context of the parent, is not consistent with the context of the heir. This is the case with 
			<code>
				<class_name>ARRAY</class_name>
			</code>'s feature 
			<code>
				<feature_name>count</feature_name>
			</code> in the last example: the feature that defines the number of items in an array -- the total number of available entries -- becomes, for an arrayed list, the 
			maximum number of list items; the truly interesting indication of the number of items is the count of how many items have been inserted in the list, as given by feature 
			<code>
				<feature_name>count</feature_name>
			</code> from 
			<code>
				<class_name>LIST</class_name>
			</code>. But even if we did not have a name clash because of the two inherited 
			<code>
				<feature_name>count</feature_name>
			</code> features we should rename 
			<code>
				<class_name>ARRAY</class_name>
			</code> 's 
			<code>
				<feature_name>count</feature_name>
			</code> as 
			<code>
				<feature_name>capacity</feature_name>
			</code> to maintain the consistency of the local feature terminology.
		</paragraph>
		<paragraph>The 
			<code>
				<keyword>rename</keyword>
			</code> subclause appears before all the other feature adaptation subclauses -- 
			<code>
				<keyword>redefine</keyword>
			</code> already seen, and the remaining ones 
			<code>
				<keyword>export</keyword>
			</code>, 
			<code>
				<keyword>undefine</keyword>
			</code> and 
			<code>
				<keyword>select</keyword>
			</code> -- since an inherited feature that has been renamed sheds its earlier identity once and for all: within the class, and to its own clients and descendants, it will be known solely through the new name. The original name has simply disappeared from the name space. This is essential to the view of classes presented earlier: self-contained, consistent abstractions prepared carefully for the greatest enjoyment of clients and descendants.
		</paragraph>
		<heading>
			<size>2</size>
			<content>Inheritance and contracts</content>
		</heading>
		<paragraph>A proper understanding of inheritance requires looking at the mechanism in the framework of Design by Contract, where it will appear as a form of 
			subcontracting.
		</paragraph>
		<paragraph>The first rule is that invariants accumulate down an inheritance structure:</paragraph>
		<note>
				<bold>Invariant Accumulation rule</bold>: The invariants of all the parents of a class apply to the class itself.
		</note>
		<paragraph>The invariant of a class is automatically considered to include -- in the sense of logical "and" -- the invariants of all its parents. This is a consequence of the view of inheritance as an "is" relation: if we may consider every instance of 
			<code>
				<class_name>B</class_name>
			</code> as an instance of 
			<code>
				<class_name>A</class_name>
			</code>, then every consistency constraint on instances of 
			<code>
				<class_name>A</class_name>
			</code> must also apply to instances of 
			<code>
				<class_name>B</class_name>
			</code>.
		</paragraph>
		<paragraph>Next we consider routine preconditions and postconditions. The rule here will follow from an examination of what contracts mean in the presence of polymorphism and dynamic binding. </paragraph>
		<paragraph>Consider a parent 
			<code>
				<class_name>A</class_name>
			</code> and a proper descendant 
			<code>
				<class_name>B</class_name>
			</code> (a direct heir on the following figure), which redefines a routine 
			<code>
				<local_variable>r</local_variable>
			</code> inherited from 
			<code>
				<class_name>A</class_name>
			</code>.
		</paragraph>
		<image>
			<url>tutorial-12.png</url>
		</image>
		<paragraph>As a result of dynamic binding, a call 
			<code>
				<local_variable>a1</local_variable>
			</code>
			. 
			<code>
				<feature_name>r</feature_name>
			</code> from a client 
			<code>
				<class_name>C</class_name>
			</code> may be serviced not by 
			<code>
				<class_name>A</class_name>
			</code> 's version of 
			<code>
				<feature_name>r</feature_name>
			</code> but by 
			<code>
				<class_name>B</class_name>
			</code> 's version if 
			<code>
				<local_variable>a1</local_variable>
			</code>, although declared of type 
			<code>
				<class_name>A</class_name>
			</code>, becomes at run time attached to an instance of 
			<code>
				<class_name>B</class_name>
			</code>. This shows the combination of inheritance, redefinition, polymorphism and dynamic binding as providing a form of subcontracting; 
			<code>
				<class_name>A</class_name>
			</code> subcontracts certain calls to 
			<code>
				<class_name>B</class_name>
			</code>.
		</paragraph>
		<paragraph>The problem is to keep subcontractors honest. Assuming preconditions and postconditions as shown on the last figure, a call in 
			<code>
				<class_name>C</class_name>
			</code> of the form
		</paragraph>
<code_block>
<keyword>if</keyword> <local_variable>a1</local_variable>.<feature_name>pre</feature_name> <keyword>then</keyword> <local_variable>a1</local_variable>.<feature_name>r</feature_name> <keyword>end</keyword>
</code_block>
		<paragraph>or just 
			<code>
				<local_variable>a1</local_variable>.<feature_name>q</feature_name>
			</code>; 
			<code>
				<local_variable>a1</local_variable>.<feature_name>r</feature_name>
			</code> where the postcondition of 
			<code>
				<feature_name>q</feature_name>
			</code> implies the precondition 
			<code>
				<local_variable>pre</local_variable>
			</code> of 
			<code>
				<local_variable>r</local_variable>
			</code>, satisfies the terms of the contract and hence is entitled to being handled correctly -- to terminate in a state satisfying 
			<code>
				<local_variable>a1</local_variable>
			</code>
			. 
			<code>
				<string>post</string>
			</code>. But if we let the subcontractor 
			<code>
				<class_name>B</class_name>
			</code> redefine the assertions to arbitrary <italic>pre</italic>
			<code>
				<comment>'</comment>
			</code> and <italic>post</italic>', this is not necessarily the case: <italic>pre'</italic> could be stronger than <italic>pre</italic>, enabling 
			<code>
				<class_name>B</class_name>
			</code> not to process correctly certain calls that are correct from 
			<code>
				<class_name>A</class_name>
			</code>'s perspective; and <italic>post</italic>' could be weaker than <italic>post</italic>, enabling 
			<code>
				<class_name>B</class_name>
			</code> to do less of a job than advertized for 
			<code>
				<local_variable>r</local_variable>
			</code> in the Contract Form of 
			<code>
				<class_name>A</class_name>
			</code>, the only official reference for authors of client classes such as 
			<code>
				<class_name>C</class_name>
			</code>. (An assertion 
			<code>
				<local_variable>p</local_variable>
			</code> is stronger than or equal to an assertion 
			<code>
				<local_variable>q</local_variable>
			</code> if 
			<code>
				<local_variable>p</local_variable>
			</code> implies 
			<code>
				<local_variable>q</local_variable>
			</code> in the sense of boolean implication.)
		</paragraph>
		<paragraph>The rule, then, is that for the redefinition to be correct the new precondition <italic>pre</italic>' must be weaker than or equal to the original <italic>pre</italic>, and the new postcondition <italic>post'</italic> must be stronger than or equal to the original <italic>post'</italic>.
		</paragraph>
		<paragraph>Because it is impossible to check simply that an assertion is weaker or stronger than another, the language rule relies on different forms of the assertion constructs, 
			<code>
				<keyword>else require</keyword>
			</code> and 
			<code>
				<keyword>then ensure</keyword>
			</code>, for redeclared routines. They rely on the mathematical property that, for any assertions 
			<code>
				<local_variable>p</local_variable>
			</code> and 
			<code>
				<local_variable>q</local_variable>, 
			</code>
			<code>
				<local_variable>p</local_variable> 
				<keyword>implies</keyword> 
				<symbol>(</symbol>
				<local_variable>p</local_variable> 
				<keyword>or</keyword> 
				<local_variable>q</local_variable>
				<symbol>)</symbol>
			</code>, and 
			<code>
				<symbol>(</symbol><local_variable>p</local_variable> <keyword>and</keyword> <local_variable>q</local_variable><symbol>)</symbol> <keyword>implies</keyword> <local_variable>p</local_variable>
			</code>. For a precondition, using 
			<code>
				<keyword>else require</keyword>
			</code> with a new assertion will perform an 
			<code>
				<keyword>or</keyword>
			</code>, which can only weaken the original; for a postcondition, 
			<code>
				<keyword>then ensure</keyword>
			</code> will perform an 
			<code>
				<keyword>and</keyword>
			</code>, which can only strengthen the original. Hence the rule:
		</paragraph>
		<note>
			<bold>Assertion Redeclaration rule</bold>: In the redeclared version of a routine, it is not permitted to use a require or ensure clause. Instead you may:  Introduce a new condition with require else, for or-ing with the original precondition.  Introduce a new condition with ensure then, for and-ing with the original postcondition. In the absence of such a clause, the original assertions are retained.
		</note>
		<paragraph>The last case -- retaining the original -- is frequent but by no means universal. </paragraph>
		<paragraph>The Assertion Redeclaration rule applies to 
			<bold>redeclarations</bold>. This terms covers not just redefinition but also effecting (the implementation, by a class, of a feature that it inherits deferred). The rules -- not just for assertions but also, as reviewed below, for typing -- are indeed the same in both cases. Without the Assertion Redeclaration rule, assertions on deferred features, such as those on 
			<code>
				<feature_name>extend</feature_name>
			</code>, 
			<code>
				<feature_name>count</feature_name>
			</code> and 
			<code>
				<string>forth</string>
			</code> in 
			<link>
				<url>tutorial-10.xml</url><anchor_name>41757</anchor_name>
				<label>"Deferred features and classes", page 57</label>
			</link>, would be almost useless -- wishful thinking; the rule makes them binding on all effectings in descendants.
		</paragraph>
		<paragraph>From the Assertion Redeclaration rule follows an interesting technique: 
			<bold>abstract preconditions</bold>. What needs to be weakened for a precondition (or strengthened for a postcondition) is not the assertion's concrete semantics but its abstract specification as seen by the client. A descendant can change the 
			implementation of that specification as it pleases, even to the effect of strengthening the concrete precondition, as long as the abstract form is kept or weakened. The precondition of procedure 
			<code>
				<feature_name>extend</feature_name>
			</code> in the deferred class 
			<code>
				<class_name>LIST</class_name>
			</code> provided an example. We wrote the routine (page 
			<link>
				<url>tutorial-10.xml</url><anchor_name>17380</anchor_name>
				<label>58</label>
			</link>) as
		</paragraph>
<code_block>
<feature_name>extend</feature_name> <symbol>(</symbol><local_variable>x</local_variable><symbol>:</symbol> <generics>G</generics><symbol>)</symbol> <keyword>is</keyword>
		<comment>-- Add `x' at end of list.</comment>
	<keyword>require</keyword>
		space_available<symbol>:</symbol> <keyword>not</keyword> <feature_name>full</feature_name>
	<keyword>deferred</keyword>
	<keyword>ensure</keyword>
		one_more<symbol>:</symbol> <feature_name>count</feature_name> <symbol>=</symbol> <keyword>old</keyword> <feature_name>count</feature_name> <symbol>+</symbol> <number>1</number>
	<keyword>end</keyword>
</code_block>
		<paragraph>The precondition expresses that it is only possible to add an item to a list if the representation is not full. We may well consider -- in line with the Eiffel principle that whenever possible structures should be of unbounded capacity -- that 
			<code>
				<class_name>LIST</class_name>
			</code> should by default make 
			<code>
				<feature_name>full</feature_name>
			</code> always return false:
		</paragraph>
<code_block>
<feature_name>full</feature_name><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
		<comment>-- Is representation full?</comment>
		<comment>-- (Default: no)</comment>
	do
		<keyword>Result</keyword> <symbol>:=</symbol> <keyword>False</keyword>
	end
</code_block>
		<paragraph>Now a class 
			<code>
				<class_name>BOUNDED_LIST</class_name>
			</code> that implements bounded-size lists (inheriting, like the earlier 
			<code>
				<class_name>ARRAYED_LIST</class_name>
			</code>, from both 
			<code>
				<class_name>LIST</class_name>
			</code> and 
			<code>
				<class_name>ARRAY</class_name>
			</code>) may redefine 
			<code>
				<feature_name>full</feature_name>
			</code>:
		</paragraph>
<code_block>
<feature_name>full</feature_name><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
	<comment>-- Is representation full?</comment>
	<comment>-- (Answer: if and only if number of items is capacity)</comment>
	do
		<keyword>Result</keyword> <symbol>:=</symbol> <symbol>(</symbol><feature_name>count</feature_name> <symbol>=</symbol> <feature_name>capacity</feature_name><symbol>)</symbol>
	end
</code_block>
		<paragraph>Procedure 
			<code>
				<feature_name>extend</feature_name>
			</code> remains applicable as before; any client that used it properly with 
			<code>
				<class_name>LIST</class_name>
			</code> can rely polymorphically on the 
			<code>
				<class_name>FIXED_LIST</class_name>
			</code> implementation. The abstract precondition of 
			<code>
				<feature_name>extend</feature_name>
			</code> has not changed, even though the concrete implementation of that precondition has in fact been strengthened.
		</paragraph>
		<paragraph>Note that a class such as 
			<code>
				<class_name>BOUNDED_LIST</class_name>
			</code>, the likes of which indeed appear in EiffelBase, is not a violation of the Eiffel advice to stay away from fixed-size structures. The corresponding structures are bounded, but the bounds are changeable. Although 
			<code>
				<feature_name>extend</feature_name>
			</code> requires 
			<code>
				<keyword>not</keyword> 
				<string>full</string>
			</code>, another feature, called 
			<code>
				<feature_name>force</feature_name>
			</code> in all applicable classes, will add an element at the appropriate position by resizing and reallocating the structure if necessary. Even arrays in Eiffel are not fixed-size, and have a procedure 
			<code>
				<feature_name>force</feature_name>
			</code> with no precondition, accepting any index position.
		</paragraph>
		<paragraph>The Assertion Redeclaration rule, together with the Invariant Accumulation rule, provides the right methodological perspective for understanding inheritance and the associated mechanisms. Defining a class as inheriting from another is a strong commitment; it means inheriting not only the features but the logical constraints. Redeclaring a routine is bound by a similar committment: to provide a new implementation (or, for an effecting, a first implementation) of a previously defined semantics, as expressed by the original contract. Usually you have a wide margin for choosing your implementation, since the contract only defines a range of possible behaviors (rather than just one behavior), but you 
			<bold>must</bold> remain within that range. Otherwise you would be perverting the goals of redeclaration, using this mechanism as a sort of late-stage hacking to override bugs in ancestor classes.
		</paragraph>
		<heading>
			<size>2</size>
			<content>Join and uneffecting</content>
		</heading>
		<paragraph>It is not an error to inherit two deferred features from different parents under the same name, provided they have the same signature (number and types of arguments and result). In that case a process of 
			<bold>feature join</bold> takes place: the features are merged into just one -- with their preconditions and postconditions, if any, respectively or-ed and and-ed.
		</paragraph>
		<paragraph>More generally, it is permitted to have any number of deferred features and at most 
			one effective feature that share the same name: the effective version, if present will effect all the others.
		</paragraph>
		<paragraph>All this is not a violation of the Final Name rule (page 
			<link>
				<url>tutorial-10.xml</url><anchor_name>25265</anchor_name>
				<label>65</label>
			</link>), since the name clashes prohibited by the rule involve two 
			different features having the same final name; here the result is just 
			one feature, resulting from the join of all the inherited versions.
		</paragraph>
		<paragraph>Sometimes we may want to join 
			<italic>effective</italic> features inherited from different parents, assuming again the features have compatible signatures. One way is to redefine them all into a new version; then they again become one feature, with no name clash in the sense of the Final Name rule. But in other cases we may simply want one of the inherited implementations to take over the others. The solution is to revert to the preceding case by 
			<bold>uneffecting</bold> the other features; uneffecting an inherited effective feature makes it deferred (this is the reverse of effecting, which turns an inherited deferred feature into an effective one). The syntax uses the 
			<code>
				<keyword>undefine</keyword>
			</code> subclause:
		</paragraph>
<code_block>
<keyword>class</keyword> <class_name>D</class_name>

<keyword>inherit</keyword>
	<class_name>A</class_name>
		<keyword>rename</keyword>
			<feature_name>g</feature_name> <keyword>as</keyword> <feature_name>f</feature_name>
				<comment>-- g was effective in A</comment>
		<keyword>undefine</keyword>
			<feature_name>f</feature_name>
		<keyword>end</keyword>

	<class_name>B</class_name>
		<keyword>undefine</keyword>
			<feature_name>f</feature_name>
				<comment>-- f was effective in B</comment>
		<keyword>end</keyword>

	<class_name>C</class_name>
		<comment>-- C also has an effective feature f , which will serve as</comment>
		<comment>-- implementation for the result of the join.</comment>

<keyword>feature</keyword>
	...
	
</code_block>
		<paragraph>Again what counts, to determine if there is an invalid name clash, is the final name of the features. In this example to of the joined features were originally called 
			<code>
				<feature_name>f</feature_name>
			</code>; the one from 
			<code>
				<class_name>A</class_name>
			</code> was called 
			<code>
				<feature_name>g</feature_name>
			</code>, but in 
			<code>
				<class_name>D</class_name>
			</code> it is renamed as 
			<code>
				<feature_name>f</feature_name>
			</code>, so without the undefinition it would cause an invalid name clash.
		</paragraph>
		<paragraph>Feature joining is the most common application of uneffecting. In some non-joining cases, however, it may be useful to forget the original implementation of a feature and let it start a new life devoid of any burden from the past. </paragraph>
		<heading>
			<size>2</size>
			<content>Changing the export status</content>
		</heading>
		<paragraph>Another Feature Adaptation subclause, 
			<code>
				<keyword>export</keyword>
			</code>, makes it possible to change the export status of an inherited feature. By default -- covering the behavior desired in the vast majority of practical cases -- an inherited feature keeps its original export status (exported, secret, selectively exported). In some cases, however, this is not appropriate:
		</paragraph>
		<paragraph>A feature may have played a purely implementation-oriented role in the parent, but become interesting to clients of the heir. Its status will change from secret to exported. </paragraph>
		<paragraph>In implementation inheritance (for example 
			<code>
				<class_name>ARRAYED_LIST</class_name>
			</code> inheriting from 
			<code>
				<class_name>ARRAY</class_name>
			</code>) an exported feature of the parent may not be suitable for direct use by clients of the heir. The change of status in this case is from exported to secret.
		</paragraph>
		<paragraph>You can achieve either of these goals by writing</paragraph>
<code_block>
<keyword>class</keyword> <class_name>D</class_name> <keyword>inherit</keyword>
	<class_name>A</class_name>
		<keyword>export</keyword> <symbol>{</symbol><class_name>X</class_name>, <class_name>Y</class_name>, ...<symbol>}</symbol> <feature_name>feature1</feature_name>, <feature_name>feature2</feature_name>, ... <keyword>end</keyword>
		
	...
</code_block>
		<paragraph>This gives a new export status to the features listed (under their final names since, as noted, 
			<code>
				<keyword>export</keyword>
			</code> like all other subclauses comes after 
			<code>
				<keyword>rename</keyword>
			</code> if present): they become exported to the classes listed. In most cases this list of classes, 
			<code>
				<class_name>X</class_name>
			</code>, 
			<code>
				<class_name>Y</class_name>
			</code>, ..., consists of just 
			<code>
				<class_name>ANY</class_name>
			</code>, to re-export a previously secret feature, or 
			<code>
				<class_name>NONE</class_name>
			</code>, to hide a previously exported feature. It is also possible, in lieu of the feature list, to use the keyword 
			<code>
				<keyword>all</keyword>
			</code> to apply the new status to all features inherited from the listed parent. Then there can be more than one class-feature list, as in
		</paragraph>
<code_block>
<keyword>class</keyword> <class_name>ARRAYED_LIST</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol> <keyword>inherit</keyword>

	<class_name>ARRAY</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol>
		<keyword>rename</keyword>
			<feature_name>count</feature_name> <keyword>as</keyword> <feature_name>capacity</feature_name>, <feature_name>item</feature_name> <keyword>as</keyword> <feature_name>array_item</feature_name>, <feature_name>put</feature_name> <keyword>as</keyword> <feature_name>array_put</feature_name>
		<keyword>export</keyword>
			<symbol>{</symbol><class_name>NONE</class_name><symbol>}</symbol> <keyword>all</keyword>
			<symbol>{</symbol><class_name>ANY</class_name><symbol>}</symbol> <feature_name>capacity</feature_name>
		<keyword>end</keyword>

	...
</code_block>
		<paragraph>where any explicit listing of a feature, such as 
			<code>
				<feature_name>capacity</feature_name>
			</code>, takes precedence over the export status specified for 
			<code>
				<keyword>all</keyword>
			</code>. Here most features of 
			<code>
				<class_name>ARRAY</class_name>
			</code> are secret in 
			<code>
				<class_name>ARRAYED_LIST</class_name>
			</code>, because the clients should not permitted to manipulate array entries directly: they will manipulate them indirectly through list features such as 
			<code>
				<feature_name>extend</feature_name>
			</code> and 
			<code>
				<feature_name>item</feature_name>
			</code>, whose implementation relies on 
			<code>
				<feature_name>array_item</feature_name>
			</code> and 
			<code>
				<feature_name>array_put</feature_name>
			</code>. But 
			<code>
				<class_name>ARRAY</class_name>
			</code>'s feature 
			<code>
				<feature_name>count</feature_name>
			</code> remains useful, under the name 
			<code>
				<feature_name>capacity</feature_name>
			</code>, to the clients of 
			<code>
				<class_name>ARRAYED_LIST</class_name>
			</code>.
		</paragraph>
		<heading>
			<size>2</size>
			<content>Flat and Flat-Contract Forms</content>
		</heading>
		<paragraph>Thanks to inheritance, a concise class text may achieve a lot, relying on all the features inherited from direct and indirect ancestors. </paragraph>
		<paragraph>This is part of the power of the object-oriented form of reuse, but can create a comprehension and documentation problem when the inheritance structures become deep: how does one understand such a class, either as client author or as maintainer? For clients, the Contract Form, entirely deduced from the class text, does not tell the full story about available features; and maintainers must look to proper ancestors for much of the relevant information. </paragraph>
		<paragraph>These observations suggest ways to produce, from a class text, a version that is equivalent feature-wise and assertion-wise, but has no inheritance dependency. This is called the 
			<bold>Flat Form</bold> of the class. It is a class text that has no inheritance clause and includes all the features of the class, immediate (declared in the class itself) as well as inherited. For the inherited features, the flat form must of course take account of all the feature adaptation mechanisms: renaming (each feature must appear under its final name), redefinition, effecting, uneffecting and export status change. For redeclared features, 
			<code>
				<keyword>else require</keyword>
			</code> clauses are or-ed with the precursors' preconditions, and 
			<code>
				<keyword>then ensure</keyword>
			</code> clauses are and-ed with precursors' postconditions. For invariants, all the ancestors' clauses are concatenated. As a result, the flat form yields a view of the class, its features and its assertions that conforms exactly to the view offered to clients and (except for polymorphic uses) heirs.
		</paragraph>
		<paragraph>As with the Contract Form (
			<link>
				<url>tutorial-09.xml</url><anchor_name>78482</anchor_name>
				<label>"The contract form of a class", page 44</label>
			</link>), producing the Flat Form is the responsibility of tools in the development environment. In EiffelStudio, you will just click the "Flat" icon.
		</paragraph>
		<paragraph>The Contract Form of the Flat Form of a class is known as its <bold>Flat-Contract Form</bold>. It gives the complete interface specification, documenting all exported features and assertions -- immediate or inherited -- and hiding implementation aspects. It is the appropriate documentation for a class.</paragraph>
		<heading>
			<size>2</size>
			<content>Repeated inheritance and selection</content>
		</heading>
		<paragraph>An inheritance mechanism, following from multiple inheritance, remains to be seen. Through multiple inheritance, a class can be a proper descendant of another through more than one path. This is called repeated inheritance and can be indirect, as in the following figure, or even direct, when a class 
			<code>
				<class_name>D</class_name>
			</code> lists a class 
			<code>
				<class_name>A</class_name>
			</code> twice in its 
			<code>
				<keyword>inherit</keyword>
			</code> clause.
		</paragraph>
		<image>
			<url>tutorial-13.png</url>
		</image>
		<paragraph>The figure's particular example is in fact often used by introductory presentations of 
			multiple inheritance, which is a pedagogical mistake: simple multiple inheritance examples (such as 
			<code>
				<class_name>INTEGER</class_name>
			</code> inheriting from 
			<code>
				<class_name>NUMERIC</class_name>
			</code> and 
			<code>
				<class_name>COMPARABLE</class_name>
			</code>, or 
			<code>
				<class_name>COMPANY_PLANE</class_name>
			</code> from 
			<code>
				<class_name>ASSET</class_name>
			</code> and 
			<code>
				<class_name>PLANE</class_name>
			</code>) should involve the combination of <bold>separate abstractions</bold>. Repeated inheritance is an advanced technique; although invaluable, it does not arise in elementary uses and requires a little more care.
		</paragraph>
		<paragraph>In fact there is only one non-trivial issue in repeated inheritance: what does a feature of the repeated ancestor, such as 
			<code>
				<feature_name>change_address</feature_name>
			</code> and 
			<code>
				<feature_name>computer_account</feature_name>
			</code>, mean for the repeated descendant, here 
			<code>
				<class_name>TEACHING_ASSISTANT</class_name>
			</code>? (The example features chosen involve a routine and an attribute; the basic rules will be the same.)
		</paragraph>
		<paragraph>There are two possibilities: sharing (the repeatedly inherited feature yields just one feature in the repeated descendant) and duplication (it yields two). Examination of various cases shows quickly that a fixed policy, or one that would apply to all the features of a class, would be inappropriate. </paragraph>
		<paragraph>Feature 
			<code>
				<feature_name>change_address</feature_name>
			</code> calls for sharing: as a teaching assistant, you may be both teacher and student, but you are just one person, with just one official domicile.
		</paragraph>
		<paragraph>If there are separate accounts for students' course work and for faculty, you may need one of each kind, suggesting that 
			<code>
				<feature_name>computer_account</feature_name>
			</code> calls for duplication.
		</paragraph>
		<paragraph>The Eiffel rule enables, once again, the software developer to craft the resulting class so as to tune it to the exact requirements. Not surprisingly, it is based on names, in accordance with the Final Name rule (no in-class overloading):</paragraph>
		<note>
			<bold>Repeated Inheritance rule</bold>
			<line_break/>
			<list ordered="false">
				<item>A feature inherited multiply under one name will be shared: it is considered to be just one feature in the repeated descendant. </item>
				<item>A feature inherited multiply under different names will be replicated, yielding as many variants as names. </item>
			</list>
		</note>
		<paragraph>So to tune the repeated descendant, feature by feature, for sharing and replication it suffices to use renaming. </paragraph>
		<paragraph>Doing nothing will cause sharing, which is indeedthe desired policy in most cases (especially those cases of 
			unintended repeated inheritance: making 
			<code>
				<class_name>D</class_name>
			</code> inherit from 
			<code>
				<class_name>A</class_name>
			</code> even though it also inherits from 
			<code>
				<class_name>B</class_name>
			</code>, which you forgot is already a descendant of 
			<code>
				<class_name>A</class_name>
			</code>).
		</paragraph>
		<paragraph>If you use renaming somewhere along the way, so that the final names are different, you will obtain two separate features. It does not matter where the renaming occurs; all that counts is whether in the common descendant, 
			<code>
				<class_name>TEACHING_ASSISTANT</class_name>
			</code> in the last figure, the names are the same or different. So you can use renaming at that last stage to cause replication; but if the features have been renamed higher you can also use last-minute renaming to 
			avoid replication, by bringing them back to a single name.
		</paragraph>
		<paragraph>The Repeated Inheritance rule gives the desired flexibility to disambiguate the meaning of repeatedly inherited features. There remains a problem in case of redeclaration and polymorphism. Assume that somewhere along the inheritance paths one or both of two replicated versions of a feature 
			<code>
				<feature_name>f</feature_name>
			</code>, such as 
			<code>
				<feature_name>computer_account</feature_name>
			</code> in the example, has been redeclared; we need to define the effect of a call 
			<code>
				<local_variable>a</local_variable>.<feature_name>f</feature_name>
			</code> (
			<code>
				<local_variable>a</local_variable>.<feature_name>computer_account</feature_name>
			</code> in the example) if 
			<code>
				<local_variable>a</local_variable>
			</code> is of the repeated ancestor type, here 
			<code>
				<class_name>UNIVERSITY_PERSON</class_name>
			</code>, and has become attached as a result of polymorphism to an instance of the repeated descendant, here 
			<code>
				<class_name>TEACHING_ASSISTANT</class_name>
			</code>. If one or more of the intermediate ancestors has redefined its version of the feature, the dynamically-bound call has two or moreversions to choose from.
		</paragraph>
		<paragraph>A 
			<code>
				<keyword>select</keyword>
			</code> clause will resolve the ambiguity, as in
		</paragraph>
		<code_block>
<keyword>class</keyword> <class_name>TEACHING_ASSISTANT</class_name>

<keyword>inherit</keyword>
	<class_name>TEACHER</class_name>
		<keyword>rename</keyword>
			<feature_name>computer_account</feature_name> <keyword>as</keyword> <feature_name>faculty_account</feature_name>
		<keyword>select</keyword>
			<feature_name>faculty_account</feature_name>
		<keyword>end</keyword>

	<class_name>STUDENT</class_name>
		<keyword>rename</keyword>
			<feature_name>computer_account</feature_name> <keyword>as</keyword> <feature_name>student_account</feature_name>
		<keyword>end</keyword>

	...
</code_block>
		<paragraph>We assume here that that no other renaming has occurred -- 
			<code>
				<class_name>TEACHING_ASSISTANT</class_name>
			</code> takes care of the renaming to ensure replication -- but that one of the two parents has redefined 
			<code>
				<string>computer_account</string>
			</code>, for example 
			<code>
				<class_name>TEACHER</class_name>
			</code> to express the special privileges of faculty accounts. In such a case the rule is that one (and exactly one) of the two parent clauses in 
			<code>
				<class_name>TEACHING_ASSISTANT</class_name>
			</code> <bold>must</bold> select the corresponding version. Note that no problem arises for an entity declared as
		</paragraph>
<code_block>
<local_variable>ta</local_variable><symbol>:</symbol> <class_name>TEACHING_ASSISTANT</class_name>
</code_block>
		<paragraph>since the valid calls are of the form 
			<code>
				<local_variable>ta</local_variable>.<feature_name>faculty_account</feature_name>
			</code> and 
			<code>
				<local_variable>ta</local_variable>.<feature_name>student_account</feature_name>
			</code>, neither of them ambiguous; the call 
			<code>
				<local_variable>ta</local_variable>.<feature_name>computer_account</feature_name>
			</code> would be invalid, since after the renamings class 
			<code>
				<class_name>TEACHING_ASSISTANT</class_name>
			</code> has no feature of that name. The 
			<code>
				<keyword>select</keyword>
			</code> only applies to a call
		</paragraph>
<code_block>
<local_variable>up</local_variable>.<feature_name>computer_account</feature_name>
</code_block>
		<paragraph>with 
			<code>
				<local_variable>up</local_variable>
			</code> of type 
			<code>
				<class_name>UNIVERSITY_PERSON</class_name>
			</code>, dynamically attached to an instance of 
			<code>
				<class_name>TEACHING_ASSISTANT</class_name>
			</code>; then the 
			<code>
				<keyword>select</keyword>
			</code> resolves the ambiguity by causing the call to use the version from 
			<code>
				<class_name>TEACHER</class_name>
			</code>.
		</paragraph>
		<paragraph>So if you traverse a list 
			<code>
				<feature_name>computer_users</feature_name><symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>UNIVERSITY_PERSON</class_name><symbol>]</symbol>
			</code> to print some information about the computer account of each list element, the account used for a teaching assistant is the faculty account, not the student account.
		</paragraph>
		<paragraph>You may, if desired, redefine 
			<code>
				<feature_name>faculty_account</feature_name>
			</code> in class 
			<code>
				<class_name>TEACHING_ASSISTANT</class_name>
			</code>, using 
			<code>
				<feature_name>student_account</feature_name>
			</code> if necessary, to take into consideration the existence of another account. But in all cases we need a precise disambiguation of what 
			<code>
				<feature_name>computer_account</feature_name>
			</code> means for a 
			<code>
				<class_name>TEACHING_ASSISTANT</class_name>
			</code> object known only through a 
			<code>
				<class_name>UNIVERSITY_PERSON</class_name>
			</code> entity.
		</paragraph>
		<paragraph>The 
			<code>
				<keyword>select</keyword>
			</code> is only needed in case of replication. If the Repeated Inheritance rule would imply sharing, as with change_address, and one or both of the shared versions has been redeclared, the Final Name rule makes the class invalid, since it now has 
			<bold>two different features</bold> with the same name. (This is only a problem if both versions are effective; if one or both are deferred there is no conflict but a mere case of feature joining as explained in 
			<link>
				<url>tutorial-10.xml</url><anchor_name>61102</anchor_name>
				<label>"Join and uneffecting", page 70</label>
			</link>.) The two possible solutions follow from the previous discussions:
		</paragraph>
		<paragraph>If you do want sharing, one of the two versions must take precedence over the other. It suffices to 
			<bold>undefine</bold> the other, and everything gets back to order. Alternatively, you can redefine both into a new version, which takes precedence over both.
		</paragraph>
		<paragraph>If you want to keep both versions, switch from sharing to replication: rename one or both of the features so that they will have different names; then you must 
			<code>
				<keyword>select</keyword>
			</code> one of them.
		</paragraph>
		<heading>
			<size>2</size>
			<content>Constrained genericity</content>
		</heading>
		<paragraph>Eiffel's inheritance mechanism has an important application to extending the flexibility of the 
			<bold>genericity</bold> mechanism. In a class 
			<code>
				<class_name>SOME_CONTAINER</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol>
			</code>, as noted (section 
			<link>
				<url>tutorial-08.xml</url>
				<label>7</label>
			</link>), the only operations available on entities of type 
			<code>
				<generics>G</generics>
			</code>, the formal generic parameter, are those applicable to entities of all types. A generic class may, however, need to assume more about the generic parameter, as with a class 
			<code>
				<class_name>SORTABLE_ARRAY</class_name> <symbol>[</symbol><generics>G</generics> ...<symbol>]</symbol>
			</code> which will have a procedure 
			<code>
				<feature_name>sort</feature_name>
			</code> that needs, at some stage, to perform tests of the form
		</paragraph>
<code_block>
<keyword>if</keyword> <feature_name>item</feature_name> <symbol>(</symbol><local_variable>i</local_variable><symbol>)</symbol> <symbol>&lt;</symbol> <feature_name>item</feature_name> <symbol>(</symbol><local_variable>j</local_variable><symbol>)</symbol> <keyword>then</keyword> ...
</code_block>
		<paragraph>where 
			<code>
				<feature_name>item</feature_name> <symbol>(</symbol><local_variable>i</local_variable><symbol>)</symbol>
			</code> and 
			<code>
				<feature_name>item</feature_name> <symbol>(</symbol><local_variable>j</local_variable><symbol>)</symbol>
			</code> are of type 
			<code>
				<generics>G</generics>
			</code>. But this requires the availability of a feature 
			<code>
				<keyword>infix</keyword> <string>"&lt;"</string>
			</code> in all types that may serve as actual generic parameters corresponding to 
			<code>
				<generics>G</generics>
			</code>. Using the type 
			<code>
				<class_name>SORTABLE_ARRAY</class_name> <symbol>[</symbol><class_name>INTEGER</class_name><symbol>]</symbol>
			</code> should be permitted, because 
			<code>
				<class_name>INTEGER</class_name>
			</code> has such a feature; but not 
			<code>
				<class_name>SORTABLE_ARRAY</class_name> <symbol>[</symbol><class_name>COMPLEX</class_name><symbol>]</symbol>
			</code> if there is no total order relation on 
			<code>
				<class_name>COMPLEX</class_name>
			</code>.
		</paragraph>
		<paragraph>To cover such cases, declare the class as</paragraph>
<code_block>
<keyword>class</keyword> <class_name>SORTABLE_ARRAY</class_name> <symbol>[</symbol><generics>G</generics> <symbol>-&gt;</symbol> <class_name>COMPARABLE</class_name><symbol>]</symbol>
</code_block>
		<paragraph>making it 
			<bold>constrained generic</bold>. The symbol 
			<code>
				<symbol>-&gt;</symbol>
			</code> recalls the arrow of inheritance diagrams; what follows it is a type, known as the generic constraint. Such a declaration means that:
		</paragraph>
		<paragraph>Within the class, you may apply the features of the generic constraint -- here the features of 
			<code>
				<class_name>COMPARABLE</class_name>
			</code>: 
			<code>
				<keyword>infix</keyword> <string>"&lt;"</string>
			</code>, 
			<code>
				<keyword>infix</keyword> <string>"&lt;"</string>
			</code> etc. -- to expressions of type 
			<code>
				<generics>G</generics>
			</code>.
		</paragraph>
		<paragraph>A generic derivation is only valid if the chosen actual generic parameter conforms to the constraint. Here you can use 
			<code>
				<class_name>SORTABLE_ARRAY</class_name> <symbol>[</symbol><class_name>INTEGER</class_name><symbol>]</symbol>
			</code> since 
			<code>
				<class_name>INTEGER</class_name>
			</code> inherits from 
			<code>
				<class_name>COMPARABLE</class_name>
			</code>, but not 
			<code>
				<class_name>SORTABLE_ARRAY</class_name> <symbol>[</symbol><class_name>COMPLEX</class_name><symbol>]</symbol>
			</code> if 
			<code>
				<class_name>COMPLEX</class_name>
			</code> is not a descendant of 
			<code>
				<class_name>COMPARABLE</class_name>
			</code>.
		</paragraph>
		<paragraph>A class can have a mix of constrained and unconstrained generic parameters, as in the EiffelBase class 
			<code>
				<class_name>HASH_TABLE</class_name> <symbol>[</symbol><generics>G</generics>, <generics>H</generics> <symbol>-&gt;</symbol> <class_name>HASHABLE</class_name><symbol>]</symbol>
			</code> whose first parameter represents the types of objects stored in a hash table, the second representing the types of the keys used to store them, which must be 
			<code>
				<class_name>HASHABLE</class_name>
			</code>. As these examples suggest, structural property classes such as 
			<code>
				<class_name>COMPARABLE</class_name>
			</code>, 
			<code>
				<class_name>NUMERIC</class_name>
			</code> and 
			<code>
				<class_name>HASHABLE</class_name>
			</code> are the most common choice for generic constraints.
		</paragraph>
		<paragraph>Unconstrained genericity, as in 
			<code>
				<class_name>C</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol>
			</code>, is defined as equivalent to 
			<code>
				<class_name>C</class_name> <symbol>[</symbol><generics>G</generics> <symbol>-&gt;</symbol> <class_name>ANY</class_name><symbol>]</symbol>
			</code>.
		</paragraph>
		<heading>
			<size>2</size>
			<content>Assignment attempt</content>
		</heading>
		<paragraph>The Type Conformance rule (
			<link>
				<url>tutorial-10.xml</url><anchor_name>65123</anchor_name>
				<label>"Polymorphism", page 53</label>
			</link>) ensures type safety by requiring all assignments to be from a more specific source to a more general target.
		</paragraph>
		<paragraph>Sometimes you can't be sure of the source object's type. This happens for example when the object comes from the outside -- a file, a database, a network. The persistence storage mechanism(
			<link>
				<url>tutorial-07.xml</url><anchor_name>35815</anchor_name>
				<label>"Deep operations and persistence", page 30</label>
			</link>) includes, along with the procedure 
			<code>
				<feature_name>store</feature_name>
			</code> seen there, the reverse operation, a function 
			<code>
				<feature_name>retrieved</feature_name>
			</code> which yields an object structure retrieved from a file or network, to which it was sent using 
			<code>
				<feature_name>store</feature_name>
			</code>. But 
			<code>
				<feature_name>retrieved</feature_name>
			</code> as declared in the corresponding class 
			<code>
				<class_name>STORABLE</class_name>
			</code> of EiffelBase can only return the most general type, 
			<code>
				<class_name>ANY</class_name>
			</code>; it is not possible to know its exact type until execution time, since the corresponding objects are not under the control of the retrieving system, and might even have been corrupted by some external agent.
		</paragraph>
		<paragraph>In such cases you cannot trust the declared type but must check it against the type of an actual run-time object. Eiffel introduces for this purpose the 
			<bold>assignment attempt</bold> operation, written
		</paragraph>
<code_block>
<local_variable>x</local_variable> <symbol>?=</symbol> <local_variable>y</local_variable>
</code_block>
		<paragraph>with the following effect (only applicable if 
			<code>
				<local_variable>x</local_variable>
			</code> is a writable entity of reference type):
		</paragraph>
		<paragraph>If 
			<code>
				<local_variable>y</local_variable>
			</code> is attached, at the time of the instruction's execution to an object whose type conforms to the type of 
			<code>
				<local_variable>x</local_variable>
			</code>, perform a normal reference assignment.
		</paragraph>
		<paragraph>Otherwise (if 
			<code>
				<local_variable>y</local_variable>
			</code> is void, or attached to a non-conforming object), make 
			<code>
				<local_variable>x</local_variable>
			</code> void.
		</paragraph>
		<paragraph>Using this mechanism, a typical object structure retrieval will be of the form</paragraph>
<code_block>
<local_variable>x</local_variable> <symbol>?=</symbol> <feature_name>retrieved</feature_name>

<keyword>if</keyword> <local_variable>x</local_variable> <symbol>=</symbol> <keyword>Void</keyword> <keyword>then</keyword>
	<comment>"We did not get what we expected"</comment>
<keyword>else</keyword>
	<comment>"Proceed with normal computation, which will typically involve calls of the form x.some_feature "</comment>
<keyword>end</keyword>
</code_block>
		<paragraph>As another application, assume we have a 
			<code>
				<class_name>LIST</class_name> <symbol>[</symbol><class_name>ACCOUNT</class_name><symbol>]</symbol>
			</code> and class 
			<code>
				<class_name>SAVINGS_ACCOUNT</class_name>
			</code>, a descendant of 
			<code>
				<class_name>ACCOUNT</class_name>
			</code>, has a feature 
			<code>
				<feature_name>interest_rate</feature_name>
			</code> which was not in 
			<code>
				<class_name>ACCOUNT</class_name>
			</code>. We want to find the maximum interest rate for savings accounts in the list. Assignment attempt easily solves the problem:
		</paragraph>
<code_block>
<keyword>local</keyword>
	<local_variable>s</local_variable><symbol>:</symbol> <class_name>SAVINGS_ACCOUNT</class_name>
<keyword>do</keyword>
	<keyword>from</keyword> <feature_name>account_list</feature_name>.<feature_name>start</feature_name> <keyword>until</keyword> <feature_name>account_list</feature_name>.<feature_name>after</feature_name> <keyword>loop</keyword>
		<local_variable>s</local_variable> <symbol>?=</symbol> <feature_name>acc_list</feature_name>.<feature_name>item</feature_name>
			<comment>-- item from LIST yields the element at</comment>
			<comment>-- cursor position</comment>
		<keyword>if</keyword> <local_variable>s</local_variable> <symbol>/=</symbol> <keyword>Void and then</keyword> <local_variable>s</local_variable>.<feature_name>interest_rate</feature_name> <symbol>&gt;</symbol> <keyword>Result then</keyword>
			<comment>-- Using and then (rather than and) guarantees</comment>
			<comment>-- that s.interest_rate is not evaluated</comment>
			<comment>-- if s = Void is true.</comment>
			<keyword>Result</keyword> <symbol>:=</symbol> <local_variable>s</local_variable>.<feature_name>interest_rate</feature_name>
		<keyword>end</keyword>
		<feature_name>account_list</feature_name>.<feature_name>forth</feature_name>
	<keyword>end</keyword>
<keyword>end</keyword>
</code_block>
		<paragraph>Note that if there is no savings account at all in the list the assignment attempt will always yield void, so that the result of the function will be 0, the default initialization. </paragraph>
		<paragraph>Assignment attempt is useful in the cases cited -- access to external objects beyond the software's own control, and access to specific properties in a polymorphic data structure. The form of the instruction precisely serves these purposes; not being a general type comparison, but only a verification of a specific expected type, it does not carry the risk of encouraging developers to revert to multi-branch instruction structures, for which Eiffel provides the far preferable alternative of polymorphic, dynamically-bound feature calls. </paragraph>
		<heading>
			<size>2</size>
			<content>Covariance and anchored declarations</content>
		</heading>
		<paragraph>The final property of Eiffel inheritance involves the rules for adapting not only the implementation of inherited features (through redeclaration of either kind, redeclaration and redefinition, as seen so far) and their contracts (through the Assertion Redeclaration rule), but also their types. More general than type is the notion of a feature's 
			<bold>signature</bold>, defined by the number of its arguments, their types, the indication of whether it has a result (that is to say, is a function or attribute rather than a procedure) and, if so, the type of the result.
		</paragraph>
		<paragraph>In many cases the signature of a redeclared feature remains the same as the original's. But in some cases you may want to adapt it to the new class. Assume for example that class 
			<code>
				<class_name>ACCOUNT</class_name>
			</code> has features
		</paragraph>
<code_block>
<feature_name>owner</feature_name><symbol>:</symbol> <class_name>HOLDER</class_name>

<feature_name>set_owner</feature_name> <symbol>(</symbol><local_variable>h</local_variable><symbol>:</symbol> <class_name>HOLDER</class_name><symbol>)</symbol> <keyword>is</keyword>
		<comment>-- Make `h' the account owner.</comment>
	<keyword>require</keyword>
		not_void<symbol>:</symbol> <local_variable>h</local_variable> <symbol>/=</symbol> <keyword>Void</keyword>
	<keyword>do</keyword>
		<feature_name>owner</feature_name> <symbol>:=</symbol> <local_variable>h</local_variable>
	<keyword>end</keyword>
</code_block>
		<paragraph>We introduce an heir 
			<code>
				<class_name>BUSINESS_ACCOUNT</class_name>
			</code> of 
			<code>
				<class_name>ACCOUNT</class_name>
			</code> to represent special business accounts, corresponding to class 
			<code>
				<class_name>BUSINESS</class_name>
			</code> inheriting from 
			<code>
				<class_name>HOLDER</class_name>
			</code>:
		</paragraph>
		<image>
			<url>tutorial-14.png</url>
		</image>
		<paragraph>Clearly, we must redefine 
			<code>
				<feature_name>owner</feature_name>
			</code> in class 
			<code>
				<class_name>BUSINESS_ACCOUNT</class_name>
			</code> to yield a result of type 
			<code>
				<class_name>BUSINESS</class_name>
			</code>; the same signature redefinition must be applied to the argument of 
			<code>
				<feature_name>set_owner</feature_name>
			</code>. This case is typical of the general scheme of signature redefinition: in a descendant, you may need to redefine both results and arguments to types conforming to the originals. This is reflected by a language rule:
		</paragraph>
		<note>
			<bold>Covariance rule</bold>: In a feature redeclaration, both the result type if the feature is a query (attribute or function) and the type of any argument if it is a routine (procedure or function) must conform to the original type as declared in the precursor version.
		</note>
		<paragraph>The term "covariance" reflects the property that all types -- those of arguments and those of results -- vary together in the same direction as the inheritance structure. </paragraph>
		<paragraph>If a feature such as 
			<code>
				<feature_name>set_owner</feature_name>
			</code> has to be redefined for more than its signature -- to update its implementation or assertions -- the signature redefinition will be explicit. For example 
			<code>
				<feature_name>set_owner</feature_name>
			</code> could do more for business owners than it does for ordinary owners. Then the redefinition will be of the form
		</paragraph>
<code_block>
<feature_name>set_owner</feature_name> <symbol>(</symbol>b<symbol>:</symbol> BUSINESS<symbol>)</symbol> <keyword>is</keyword>
		<comment>-- Make b the account owner.</comment>
	<keyword>do</keyword>
		... New routine body ...
	<keyword>end</keyword>
</code_block>
		<paragraph>In other cases, however, the body will be exactly the same as in the precursor. Then explicit redefinition would be tedious, implying much text duplication. The mechanism of 
			<bold>anchored redeclaration</bold> solves this problem. The original declaration of 
			<code>
				<feature_name>set_owner</feature_name>
			</code> in 
			<code>
				<class_name>ACCOUNT</class_name>
			</code> should be of the form
		</paragraph>
<code_block>
<feature_name>set_owner</feature_name> <symbol>(</symbol><local_variable>h</local_variable><symbol>:</symbol> <keyword>like</keyword> <feature_name>owner</feature_name><symbol>)</symbol> <keyword>is</keyword>
		<comment>-- Make h the account owner.</comment>
		<comment>-- The rest as before:</comment>
	<keyword>require</keyword>
		not_void<symbol>:</symbol> <local_variable>h</local_variable> <symbol>/=</symbol> <keyword>Void</keyword>
	<keyword>do</keyword>
		<feature_name>owner</feature_name> <symbol>:=</symbol> <local_variable>h</local_variable>
	<keyword>end</keyword>
</code_block>
		<paragraph>A 
			<code>
				<keyword>like</keyword>
			</code> <italic>anchor</italic> type, known as an anchored type, may appear in any context in which <italic>anchor</italic> has a well-defined type; <italic>anchor</italic> can be an attribute or function of the enclosing class, or an argument of the enclosing routine. Then, assuming 
			<code>
				<class_name>T</class_name>
			</code> is the type of <italic>anchor</italic>, the type 
			<code>
				<keyword>like</keyword>
			</code> <italic>anchor</italic> means the following:
		</paragraph>
		<paragraph>In the class in which it appears, 
			<code>
				<keyword>like</keyword>
			</code> <italic>anchor</italic> means the same as 
			<code>
				<class_name>T</class_name>
			</code>. For example, in 
			<code>
				<feature_name>set_owner</feature_name>
			</code> above, the declaration of 
			<code>
				<local_variable>h</local_variable>
			</code> has the same effect as if 
			<code>
				<local_variable>h</local_variable>
			</code> had been declared of type 
			<code>
				<class_name>HOLDER</class_name>
			</code>, the type of the anchor 
			<code>
				<feature_name>owner</feature_name>
			</code> in class 
			<code>
				<class_name>ACCOUNT</class_name>
			</code>.
		</paragraph>
		<paragraph>The difference comes in proper descendants: if a type redefinition changes the type of <italic>anchor</italic>, any entity declared 
			<code>
				<keyword>like</keyword>
			</code> <italic>anchor</italic> will be considered to have been redefined too.
		</paragraph>
		<paragraph>This means that anchored declaration are a form of of implicit covariant redeclaration. </paragraph>
		<paragraph>In the example, class 
			<code>
				<class_name>BUSINESS_ACCOUNT</class_name>
			</code> only needs to redefine the type of 
			<code>
				<feature_name>owner</feature_name>
			</code> (to 
			<code>
				<class_name>BUSINESS</class_name>
			</code>). It doesn't have to redefine 
			<code>
				<feature_name>set_owner</feature_name>
			</code> except if it needs to change its implementation or assertions.
		</paragraph>
		<paragraph>It is possible to use 
			<code>
				<keyword>Current</keyword>
			</code> as anchor; the declaration 
			<code>
				<keyword>like</keyword> <keyword>Current</keyword>
			</code> denotes a type based on the current class (with the same generic parameters if any). This is in fact a common case; we saw in 
			<link>
				<url>tutorial-10.xml</url>
				<label>"Structural property classes", page 62</label>
			</link>, that it applies in class 
			<code>
				<class_name>COMPARABLE</class_name>
			</code> to features such as
		</paragraph>
<code_block>
<keyword>infix</keyword> <string>"&lt;"</string> <symbol>(</symbol><feature_name>other</feature_name><symbol>:</symbol> <keyword>like Current</keyword><symbol>):</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword> ...
</code_block>
		<paragraph>since we only want to compare two comparable elements of compatible types -- but not, for example, integer and strings, even if both types conform to 
			<code>
				<class_name>COMPARABLE</class_name>
			</code>. (A "balancing rule" makes it possible, however, to mix the various arithmetic types, consistently with mathematical traditions, in arithmetic expressions such as 
			<code>
				<number>3</number> <symbol>+</symbol> <number>45.82</number>
			</code> or boolean expressions such as 
			<code>
				<number>3</number> <symbol>&lt;</symbol> <string>45. 82</string>
			</code>.)
		</paragraph>
		<paragraph>Similarly, class 
			<code>
				<class_name>ANY</class_name>
			</code> declares procedure 
			<code>
				<feature_name>copy</feature_name>
			</code> as
		</paragraph>
<code_block>
<feature_name>copy</feature_name> <symbol>(</symbol><local_variable>other</local_variable><symbol>:</symbol> <keyword>like Current</keyword><symbol>)</symbol> <keyword>is</keyword> ...
</code_block>
		<paragraph>with the argument anchored to the current object. Function 
			<code>
				<feature_name>clone</feature_name>
			</code>, for its part, has signature 
			<code>
				<feature_name>clone</feature_name> <symbol>(</symbol><local_variable>other</local_variable><symbol>:</symbol> <class_name>ANY</class_name><symbol>):</symbol> <keyword>like</keyword> <local_variable>other</local_variable>
			</code>, with both argument and result anchored to the argument, so that for any 
			<code>
				<local_variable>x</local_variable>
			</code> the type of 
			<code>
				<feature_name>clone</feature_name> <symbol>(</symbol><local_variable>x</local_variable><symbol>)</symbol>
			</code> is the same as the type of 
			<code>
				<local_variable>x</local_variable>
			</code>.
		</paragraph>
		<paragraph>A final, more application-oriented example of anchoring to 
			<code>
				<keyword>Current</keyword>
			</code> is the feature 
			<code>
				<feature_name>merge</feature_name>
			</code> posited in an earlier example (page 
			<link>
				<url>tutorial-07.xml</url>
				<label>13</label>
			</link>) with the signature 
			<code>
				<feature_name>merge</feature_name> <symbol>(</symbol><local_variable>other</local_variable><symbol>:</symbol> <class_name>ACCOUNT</class_name><symbol>)</symbol>
			</code>. By using instead 
			<code>
				<feature_name>merge</feature_name> <symbol>(</symbol><local_variable>other</local_variable><symbol>:</symbol> <keyword>like Current</keyword><symbol>)</symbol>
			</code> we can ensure that in any descendant class -- 
			<code>
				<class_name>BUSINESS_ACCOUNT</class_name>
			</code>, 
			<code>
				<class_name>SAVINGS_ACCOUNT</class_name>
			</code>, 
			<code>
				<class_name>MINOR_ACCOUNT</class_name>
			</code> ... -- an account will only be mergeable with another of a compatible type.
		</paragraph>
		<paragraph>Covariance makes static type checking more delicate; mechanisms of "system validity" and "catcalls" address the problem, discussed in detail in the book 
			<link>
				<url>http://eiffel.com/doc/oosc/</url>
				<label>Object-Oriented Software Construction</label>
			</link> (see the bibliography).
		</paragraph>
	</paragraph></document>
