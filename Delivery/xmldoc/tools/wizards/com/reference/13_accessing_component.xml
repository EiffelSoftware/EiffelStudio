<document title="Accessing a COM Component" output="studio">
	<meta_data/>
	<paragraph>
		<paragraph>The wizard generates all the necessary code to access the existing component. The plumbing is already done, so instantiating an Eiffel coclass actually initializes COM internals.</paragraph>
		<heading>
			<size>2</size> Using the Generated Code
		</heading>
		<paragraph> To access the component, you need to call features of the coclass. The data types of function arguments are either Eiffel types defined in Eiffel data structure libraries (EiffelBase), standard COM data types defined in the EiffelCOM library, or component COM data types specified in the definition file. For example, from the following IDL line</paragraph>
<code_block>
HRESULT InterfaceFunction ([in] int a, [out, retval] MyStruct * b)
</code_block>
		<paragraph>The wizard generates the following feature in the Eiffel coclass:</paragraph>
<code_block>
<feature_name>interface_function</feature_name> <symbol>(</symbol><feature_name>a</feature_name><symbol>:</symbol> <class_name>INTEGER</class_name><symbol>)</symbol><symbol>:</symbol> <class_name>MY_STRUCT_RECORD</class_name>
</code_block>
		<paragraph>where 
			<code>
				<class_name>MY_STRUCT_RECORD</class_name>
			</code> is a generated Eiffel class wrapping 
			<italic>MyStruct</italic>.
		</paragraph>
		<paragraph>Here is a more difficult example:</paragraph>
<code_block>
HRESULT a_function ([in] IsomeInterface * p_interface)
</code_block>
		<paragraph>The wizard generates the following Eiffel feature:</paragraph>
<code_block>
<feature_name>a_function</feature_name> <symbol>(</symbol><local_variable>p_interface</local_variable><symbol>:</symbol> <class_name>ISOME_INTERFACE_INTERFACE</class_name><symbol>)</symbol>
</code_block>
		<paragraph>where 
			<code>
				<class_name>ISOME_INTERFACE_INTERFACE</class_name>
			</code>is a generated deferred class. Where can you obtain an instance of the class? First, you may receive from other function. Second, you can create an implemented server interface 
			<code>
				<class_name>ISOME_INTERFACE_IMPL_STUB</class_name>
			</code>. In the later case you should provide your own implementation.
		</paragraph>
		<heading>
			<size>2</size> Contracts
		</heading>
		<paragraph>The wizard cannot generate fully specified contracts. Indeed, the tool has no domain specific knowledge and can only generate contracts that are domain independent. Such contracts, although useful, are not enough to describe entirely the behavior of the component. Generated contracts include void Eiffel objects as well as C pointer validity (for wrappers) checking. There might be other conditions to allow calls to an Eiffel coclass feature. Invariants and postconditions can be enforced in an heir of the generated Eiffel coclass. Preconditions, however, cannot be strengthened. A workaround provided by the wizard is to generate a precondition function for each feature in the interface. The default implementation of these functions always returns 
			<italic>True</italic>. They should be redefined to implement the correct behavior:
		</paragraph>
<code_block>
<feature_name>interface_function</feature_name> <symbol>(</symbol><local_variable>a</local_variable><symbol>:</symbol> <class_name>INTEGER</class_name><symbol>)</symbol><symbol>:</symbol> <class_name>MY_STRUCT</class_name> <keyword>is</keyword>
		<comment>-- Example of a generated Eiffel coclass feature</comment>
	<keyword>require</keyword>
		interface_function_user_precondition: <feature_name>interface_function_user_precondition</feature_name>
	<keyword>do</keyword>
		...
	<keyword>ensure</keyword>
		non_void_my_struct: <keyword>Result</keyword> <keyword>/=</keyword> <keyword>Void</keyword>
	<keyword>end</keyword>
</code_block>So the complete class hierarchy for an Eiffel client coclass is the following:
		<paragraph/>
		<heading>
			<size>3</size>EiffelCOM Client System
		</heading>
		<paragraph>
			<image>
				<url>../images/wizard-12.gif</url>
			</image>
		</paragraph>
		<paragraph>Another advantage of the previous hierarchy is that it adds incrementality to the EiffelCOM system. Indeed, should the definition file be modified and the wizard run once more against it, your code would not be changed. Only the generated Eiffel coclass would be, and it would suffice to adapt your heir accordingly.</paragraph>
		<heading>
			<size>2</size>  Exceptions
		</heading>
		<paragraph>COM standard requires that any interface function returns a status value (known as a HRESULT). This corresponds to side effect features which the Eiffel methodology tends to avoid. The work around used in EiffelCOM systems is to map these return values into Eiffel exceptions. If the server returns an error code, the EiffelCOM runtime raises an Eiffel exception that your code should catch.</paragraph>
		<heading>
			<size>3</size>EiffelCOM Client System Exception Raising
		</heading>
		<paragraph>
			<image>
				<url>../images/wizard-13.gif</url>
			</image>
		</paragraph>
		<paragraph>As a result, any feature in the co class client making calls to the user defined Eiffel coclass should include a rescue clause. The processing done in this clause might depend on the nature of the exception. All the standard COM exceptions can be found in the library class 
			<code>
				<class_name>ECOM_EXCEPTION_CODES,</class_name>
			</code> which is inherited from by 
			<code>
				<class_name>ECOM_EXCEPTION</class_name>
			</code>. The later also inherits from the kernel class 
			<code>
				<class_name>EXCEPTIONS</class_name>
			</code> and can consequently be used by the coclass client to catch the exceptions.
		</paragraph>
		<paragraph>The following code snippet illustrates how a client can process exceptions raised in the Eiffel coclass:</paragraph>
<code_block>
<keyword>indexing</keyword>
	description<keyword>:</keyword> <string>"Eiffel coclass client example"</string>

<keyword>class</keyword>
	<class_name>COCLASS_CLIENT</class_name>

<keyword>inherit</keyword>
	<class_name>ECOM_EXCEPTION</class_name>
		<keyword>export</keyword>
			<symbol>{</symbol><class_name>NONE</class_name><symbol>}</symbol> <keyword>all</keyword>
		<keyword>end</keyword>

<keyword>create</keyword>
	<feature_name>make</feature_name>

<keyword>feature</keyword> <symbol>{</symbol><class_name>NONE</class_name><symbol>}</symbol> <comment>-- Initialization</comment>

	<feature_name>make</feature_name> <keyword>is</keyword>
			<comment>-- Initialize Eiffel coclass.</comment>
		<keyword>do</keyword>
			<keyword>create</keyword> <feature_name>coclass</feature_name><symbol>.</symbol><feature_name>make</feature_name>
		<keyword>end</keyword>

<keyword>feature</keyword> <comment>-- Basic Operations</comment>

	<feature_name>coclass_feature_client</feature_name> <keyword>is</keyword>
			<comment>-- Example of a coclass feature caller</comment>
		<keyword>local</keyword>
			<local_variable>retried</local_variable><symbol>:</symbol> <class_name>BOOLEAN</class_name>
			<local_variable>coclass</local_variable><symbol>:</symbol> <class_name>EIFFEL_COCLASS_PROXY</class_name>
		<keyword>do</keyword>
			<keyword>create</keyword> <feature_name>coclass</feature_name><symbol>.</symbol><feature_name>make</feature_name>
			<keyword>if</keyword> <keyword>not</keyword> <local_variable>retried</local_variable> <keyword>then</keyword>
				<feature_name>coclass</feature_name><symbol>.</symbol><feature_name>coclass_feature</feature_name> <comment>-- Actual call</comment>
			<keyword>end</keyword>
		<keyword>rescue</keyword>
			<keyword>if</keyword> <feature_name>hresult</feature_name> <symbol>=</symbol> <feature_name>E_notimpl</feature_name> <keyword>then</keyword>
					<comment>-- Process non implemented function error.</comment>
				<local_variable>retried</local_variable> <symbol>:=</symbol> <keyword>True</keyword>
				<keyword>retry</keyword>
			<keyword>elseif</keyword> <feature_name>hresult</feature_name> <symbol>=</symbol> <feature_name>E_invalidarg</feature_name> <keyword>then</keyword>
					<comment>-- Process invalid argument error.</comment>
				<local_variable>retried</local_variable> <symbol>:=</symbol> <keyword>True</keyword>
				<keyword>retry</keyword>
			<keyword>else</keyword>
				<comment>-- Forward exception to caller.</comment>
			<keyword>end</keyword>
		<keyword>end</keyword>

<keyword>end</keyword> <comment>-- class COCLASS_CLIENT</comment>
</code_block>
		<heading>
			<size>2</size> Summary
		</heading>
		<paragraph>There are a few rules to follow when building an Eiffel coclass client, but they are straightforward and do not add any constraints. First,inherit from the generated Eiffel coclass to implement the preconditions. Second, any feature call to the Eiffel coclass should include a rescue clause.</paragraph>
		<seealso>
			<bold>See Also</bold>
			<line_break/>
			<link>
				<url>01_introduction_d.xml</url>
				<label>Introduction Dialog and Main Window</label>
			</link>
			<line_break/>
			<link>
				<url>02_generated_code_type_d.xml</url>
				<label>Generated Code Type Dialog</label>
			</link>
			<line_break/>
			<link>
				<url>03_definition_file_d.xml</url>
				<label>Definition File Dialog</label>
			</link>
			<line_break/>
			<link>
				<url>04_eiffel_project_file_d.xml</url>
				<label>Eiffel Project File Dialog</label>
			</link>
			<line_break/>
			<link>
				<url>05_destination_folder_d.xml</url>
				<label>Destination Folder Dialog</label>
			</link>
			<line_break/>
			<link>
				<url>06_idl_marshalling_d.xml</url>
				<label>IDL Marshaling Definition Dialog</label>
			</link>
			<line_break/>
			<link>
				<url>07_type_lybrary_m_d.xml</url>
				<label>Type Library Marshaling Definition Dialog</label>
			</link>
			<line_break/>
			<link>
				<url>08_final_d.xml</url>
				<label>Final Dialog</label>
			</link>
			<line_break/>
			<link>
				<url>09_com_definition_file_processing.xml</url>
				<label>COM Definition File Processing</label>
			</link>
			<line_break/>
			<link>
				<url>10_eiffel_project_processing.xml</url>
				<label>Eiffel Project Processing</label>
			</link>
			<line_break/>
			<link>
				<url>11_generated_files.xml</url>
				<label>Generated Files</label>
			</link>
			<line_break/>
			<link>
				<url>12_class_hierarchy.xml</url>
				<label>Class Hierarchy</label>
			</link>
			<line_break/>
			<link>
				<url>13_accessing_component.xml</url>
				<label>Accessing a Component</label>
			</link>
			<line_break/>
			<link>
				<url>14_building_component.xml</url>
				<label>Building a Component</label>
			</link>
		</seealso>
	</paragraph></document>
