indexing
	description: "Objects that represent an EV_TITLED_WINDOW.%
		%The original version of this class was generated by EiffelBuild."
	date: "$Date$"
	revision: "$Revision$"

class
	TESTER_MAIN_WINDOW

inherit
	TESTER_MAIN_WINDOW_IMP
	
	TESTER_SAVED_SETTINGS
		export
			{NONE} all
		undefine
			default_create,
			copy
		end

	TESTER_SHARED_EVENT_MANAGER
		export
			{NONE} all
		undefine
			default_create,
			copy
		end

	TESTER_CODEDOM_TYPES
		export
			{NONE} all
		undefine
			default_create,
			copy
		end

feature {NONE} -- Initialization

	user_initialization is
			-- called by `initialize'.
			-- Any custom user initialization that
			-- could not be performed in `initialize',
			-- (due to regeneration of implementation class)
			-- can be added here.
		local
			l_config: CODE_MACHINE_CONFIGURATION
			l_languages: LIST [STRING]
		do
			Event_manager.set_output_displayer (agent display_output)
			make
			close_request_actions.extend (agent on_close)
			create l_config.make
			l_languages := l_config.languages
			from
				l_languages.start
			until
				l_languages.after
			loop
				provider_combo_box.extend (create {EV_LIST_ITEM}.make_with_text (l_languages.item))
				l_languages.forth
			end
			provider_combo_box.set_text (saved_codedom_provider)
			set_x_position (saved_x)
			set_y_position (saved_y)
			set_width (saved_width)
			set_height (saved_height)
			generate_label.set_text ("Select codedom tree")
			indent_string_text_field.set_text ("%T%T%T")
			referenced_assemblies_list.enable_multiple_selection
			create store.load
			update_tree
		end

feature {NONE} -- Events

	on_provider_update is
			-- Update provider file extension and case sensitivity status.
		local
			l_analyzer: TESTER_CODEDOM_ANALYZER
		do
			create l_analyzer
			l_analyzer.analyze (provider_combo_box.text)
			if l_analyzer.analysis_successful then
				file_extension_label.set_text (l_analyzer.language_extension)
				case_sensitive_check_button.show
				if l_analyzer.is_case_sensitive then
					case_sensitive_check_button.enable_select
				else
					case_sensitive_check_button.disable_select
				end
				codedom_provider := l_analyzer.codedom_provider
				update_properties
			else
				file_extension_label.remove_text
				case_sensitive_check_button.hide
				codedom_provider := Void
				generate_button.disable_sensitive
				compile_from_dom_button.disable_sensitive
				compile_from_file_button.disable_sensitive
				compile_from_source_button.disable_sensitive
				parse_button.disable_sensitive
			end
		end
		
	on_generate_source is
			-- Called by `select_actions' of `generate_button'.
		local
			l_type: INTEGER
			l_generator: SYSTEM_DLL_ICODE_GENERATOR
			l_compile_unit: SYSTEM_DLL_CODE_COMPILE_UNIT
			l_namespace: SYSTEM_DLL_CODE_NAMESPACE
			l_type_type: SYSTEM_DLL_CODE_TYPE_DECLARATION
			l_expression: SYSTEM_DLL_CODE_EXPRESSION
			l_statement: SYSTEM_DLL_CODE_STATEMENT
			l_text_writer: STREAM_WRITER
			l_options: SYSTEM_DLL_CODE_GENERATOR_OPTIONS
			l_retried: BOOLEAN
		do
			if not l_retried then
				l_type := selected_tree_item_type
				l_generator := codedom_provider.create_generator
				create l_options.make
				l_options.set_blank_lines_between_members (blank_lines_check_button.is_selected)
				l_options.set_indent_string (indent_string_text_field.text)
				l_options.set_else_on_closing (else_on_closing_check_button.is_selected)
				create l_text_writer.make_from_path (generation_path_text_field.text + (create {OPERATING_ENVIRONMENT}).Directory_separator.out + generated_filename_text_field.text + codedom_provider.file_extension)
				inspect
					l_type
				when codedom_compile_unit_type then
					l_compile_unit ?= codedoms_tree.selected_item.data
					check
						has_data: l_compile_unit /= Void
					end
					l_generator.generate_code_from_compile_unit (l_compile_unit, l_text_writer, l_options)
				when codedom_namespace_type then
					l_namespace ?= codedoms_tree.selected_item.data
					check
						has_data: l_namespace /= Void
					end
					l_generator.generate_code_from_namespace (l_namespace, l_text_writer, l_options)
				when codedom_type_type then
					l_type_type ?= codedoms_tree.selected_item.data
					check
						has_data: l_type_type /= Void
					end
					l_generator.generate_code_from_type (l_type_type, l_text_writer, l_options)
				when codedom_expression_type then
					l_expression ?= codedoms_tree.selected_item.data
					check
						has_data: l_expression /= Void
					end
					l_generator.generate_code_from_expression (l_expression, l_text_writer, l_options)
				when codedom_statement_type then
					l_statement ?= codedoms_tree.selected_item.data
					check
						has_data: l_statement /= Void
					end
					l_generator.generate_code_from_statement (l_statement, l_text_writer, l_options)
				else
					Event_manager.raise_event (create {TESTER_EVENT}.make ("Cannot generate: Invalid codedom tree.", True))
				end
			end
		rescue
			l_retried := True
			Event_manager.raise_event (create {TESTER_EVENT}.make ("Error while generating source code: " + (create {EXCEPTIONS}).exception_trace, True))
			retry
		end
	
	on_compile_from_dom is
			-- Called by `select_actions' of `compile_from_dom_button'.
		local
			l_compiler: SYSTEM_DLL_ICODE_COMPILER
			l_compilation_unit: SYSTEM_DLL_CODE_COMPILE_UNIT
			l_results: SYSTEM_DLL_COMPILER_RESULTS
		do
			check
				non_void_codedom_provider: codedom_provider /= Void
				valid_codedom_type: selected_tree_item_type = Codedom_compile_unit_type
			end
			l_compilation_unit ?= codedoms_tree.selected_item.data
			check
				has_data: l_compilation_unit /= Void
			end
			l_compiler := codedom_provider.create_compiler
			l_results := l_compiler.compile_assembly_from_dom (compiler_options, l_compilation_unit)
			display_compilation_results (l_results)
		end
	
	on_compile_from_file is
			-- Called by `select_actions' of `compile_from_file_button'.
		local
			l_compiler: SYSTEM_DLL_ICODE_COMPILER
			l_results: SYSTEM_DLL_COMPILER_RESULTS
		do
			check
				non_void_codedom_provider: codedom_provider /= Void
			end
			l_compiler := codedom_provider.create_compiler
			l_results := l_compiler.compile_assembly_from_file (compiler_options, source_filename_text_field.text)
			display_compilation_results (l_results)
		end
	
	on_compile_from_source is
			-- Called by `select_actions' of `compile_from_source_button'.
		local
			l_compiler: SYSTEM_DLL_ICODE_COMPILER
			l_results: SYSTEM_DLL_COMPILER_RESULTS
		do
			check
				non_void_codedom_provider: codedom_provider /= Void
			end
			l_compiler := codedom_provider.create_compiler
			l_results := l_compiler.compile_assembly_from_source (compiler_options, source_text.text)
			display_compilation_results (l_results)
		end
	
	on_parse is
			-- Called by `select_actions' of `parse_button'.
		local
			l_parser: SYSTEM_DLL_ICODE_PARSER
			l_text_reader: STREAM_READER
			l_compile_unit: SYSTEM_DLL_CODE_COMPILE_UNIT
			l_formatter: BINARY_FORMATTER
			l_stream: FILE_STREAM
			l_retried: BOOLEAN
		do
			if not l_retried then
				check
					non_void_codedom_provider: codedom_provider /= Void
				end
				l_parser := codedom_provider.create_parser
				create l_text_reader.make_from_path (parse_file_text_field.text)
				l_compile_unit := l_parser.parse (l_text_reader)
				create l_stream.make (serialized_folder_text_field.text + (create {OPERATING_ENVIRONMENT}).Directory_separator.out + serialized_filename_text_field.text + serialized_file_extension, feature {FILE_MODE}.Create_)
				create l_formatter.make
				l_formatter.serialize (l_stream, l_compile_unit)
				l_stream.close
			end
		rescue
			l_retried := True
			if l_stream /= Void then
				l_stream.close
			end
			Event_manager.raise_event (create {TESTER_EVENT}.make ("Could not parse file", True))
			retry
		end

	on_output_type_update is
			-- Update `Output Type' text field content.
		local
			l_generator: SYSTEM_DLL_ICODE_GENERATOR
			l_type: SYSTEM_DLL_CODE_TYPE_REFERENCE
		do
			if codedom_provider /= Void and not type_text_field.text.is_empty then
				l_generator := codedom_provider.create_generator
				create l_type.make_from_type_name (type_text_field.text)
				output_type_text_field.set_text (l_generator.get_type_output (l_type))
			else
				output_type_text_field.remove_text
			end
		end
	
	on_identifier_change is
			-- Update identifier test text fields.
		local
			l_generator: SYSTEM_DLL_ICODE_GENERATOR
			l_text: STRING
			l_retried: BOOLEAN
		do
			if not l_retried then
				if codedom_provider /= Void and not identifier_text_field.text.is_empty then
					l_generator := codedom_provider.create_generator
					l_text := l_generator.create_escaped_identifier (identifier_text_field.text)
					if l_text = Void then
						Event_manager.raise_event (create {TESTER_EVENT}.make ("CreateEscapedIdentifier returned Void!", False))
						escaped_identifier_text_field.remove_text
					else
						escaped_identifier_text_field.set_text (l_text)
					end
					l_text := l_generator.create_valid_identifier (identifier_text_field.text)
					if l_text = Void then
						Event_manager.raise_event (create {TESTER_EVENT}.make ("CreateValidIdentifier returned Void!", False))
						valid_identifier_text_field.remove_text
					else
						valid_identifier_text_field.set_text (l_text)
					end
					is_valid_identifier_text_field.set_text (l_generator.is_valid_identifier (identifier_text_field.text).out)
				end
			end
		rescue
			Event_manager.raise_event (create {TESTER_EVENT}.make ("The following exception occured:%N" + (create {EXCEPTIONS}).exception_trace, True))
			l_retried := True
			retry
		end
	
	on_add_codedom_tree is
			-- Add codedom tree to codedoms tree
		do
			browse_for_file ("Browse for serialized CodeDom tree...", Void, agent add_codedom_tree)
		end
	
	on_remove_codedom_tree is
			-- Add codedom tree to codedoms tree
		do
			store.remove (codedoms_tree.selected_item.tooltip)
			update_tree
		end

	on_codedom_tree_select is
			-- Called by `select_actions' of `codedom_trees'.
			-- Check kind of tree.
		local
			l_type: INTEGER
		do
			l_type := selected_tree_item_type
			inspect
				l_type
			when Codedom_compile_unit_type then
				generate_label.set_text (generate_compile_unit_label)
				compile_from_dom_button.enable_sensitive
				remove_button.enable_sensitive
			when Codedom_namespace_type then
				generate_label.set_text (generate_namespace_label)
				remove_button.enable_sensitive
				compile_from_dom_button.disable_sensitive
			when Codedom_type_type then
				generate_label.set_text (generate_type_label)
				remove_button.enable_sensitive
				compile_from_dom_button.disable_sensitive
			when Codedom_expression_type then
				generate_label.set_text (generate_expression_label)
				remove_button.enable_sensitive
				compile_from_dom_button.disable_sensitive
			when Codedom_statement_type then
				generate_label.set_text (generate_statement_label)
				remove_button.enable_sensitive
				compile_from_dom_button.disable_sensitive
			else
				generate_label.set_text (select_codedom_tree_label)
				remove_button.disable_sensitive
				compile_from_dom_button.disable_sensitive
			end
		end
	
	on_codedom_tree_deselect is
			-- Called by `deselect_actions' of `codedoms_tree'.
		do
			if codedoms_tree.selected_item = Void then
				generate_label.set_text (select_codedom_tree_label)
				remove_button.disable_sensitive
			end
		end

	on_browse_generated_file_folder is
			-- Called by `select_actions' of `browse_button'.
		do
			browse_for_directory ("Browse for destination folder...", Generated_file_folder_key, agent generation_path_text_field.set_text)
		end

	on_browse_source is
			-- Called by `select_actions' of `browse_source_button'.
			-- Show browse dialog, put result in text field.
		do
			browse_for_file ("Browse for Eiffel Source file...", "*.es", agent source_filename_text_field.set_text)
		end

	on_source_file_name_change is
			-- Called by `change_actions' of `source_filename_text_field'.
			-- Check text field entry and enable `Compile' button if OK.
		do
			if feature {SYSTEM_FILE}.exists (source_filename_text_field.text) then
				source_filename_text_field.set_foreground_color (Black)
				if not compile_from_file_button.is_sensitive then
					compile_from_file_button.enable_sensitive
				end
			else
				source_filename_text_field.set_foreground_color (Red)
				if compile_from_file_button.is_sensitive then
					compile_from_file_button.disable_sensitive
				end
			end
		end

	on_source_change is
			-- Called by `change_actions' of `source_text'.
			-- Check source text and enable `Compile' button if OK.
		do
			if source_text.text.is_empty then
				compile_from_source_button.disable_sensitive
			else
				compile_from_source_button.enable_sensitive
			end
		end

	on_referenced_assembly_select is
			-- Enable `Remove' button if necessary.
		do
			if not remove_button.is_sensitive then
				remove_button.enable_sensitive
				new_reference_text_field.set_text (referenced_assemblies_list.selected_item.text)
			end
		end
		
	on_referenced_assembly_deselect is
			-- Disable `Remove' button if necessary.
		do
			if referenced_assemblies_list.selected_items.count = 0 then
				remove_button.disable_sensitive
				new_reference_text_field.remove_text
			else
				new_reference_text_field.set_text (referenced_assemblies_list.selected_item.text)
			end
		end
	
	on_browse_new_reference is
			-- Called by `select_actions' of `new_reference_browse_button'.
			-- Popup file browse dialog and update `ew_reference_text_field' accordingly.
		do
			browse_for_file ("Browse for assembly...", "*.dll", agent new_reference_text_field.set_text)
		end
		
	on_new_reference_change is
			-- Enable `Add' reference button if text field not empty.
		do
			if new_reference_text_field.text.is_empty then
				if add_button.is_sensitive then
					add_button.disable_sensitive
				end
			else
				if not add_button.is_sensitive then
					add_button.enable_sensitive
				end
			end
		end
		
	on_add_referenced_assembly is
			-- Called by `select_actions' of `referenced_assemblies_add_button'.
		do
			referenced_assemblies_list.extend (create {EV_LIST_ITEM}.make_with_text (new_reference_text_field.text))
			new_reference_text_field.remove_text
		end
	
	on_remove_referenced_assembly is
			-- Called by `select_actions' of `referenced_assemblies_remove_button'.
		local
			l_selected_items: LIST [EV_LIST_ITEM]
		do
			l_selected_items := referenced_assemblies_list.selected_items
			from
				l_selected_items.start
			until
				l_selected_items.after
			loop
				referenced_assemblies_list.prune (l_selected_items.item)
				l_selected_items.forth
			end
		end
	
	on_browse_for_resource is
			-- Called by `select_actions' of `resource_browse_button'.
		do
			browse_for_file ("Browse for resource...", "*.res", agent resource_text_field.set_text)
		end
	
	on_browse_parse_file is
			-- Called by `select_actions' of `parse_file_browse_button'.
		do
			browse_for_file ("Browse for file to parse...", "*.es", agent parse_file_text_field.set_text)
		end
	
	on_browse_serialized_folder is
			-- Called by `select_actions' of `serialized_folder_browse_button'.
		do
			browse_for_directory ("Browse for destination folder...", Saved_serialized_folder_key, agent parse_file_text_field.set_text)
		end

	on_serialized_filename_change is
			-- Called by `change_actions' of `serialized_filename_text_field'.
			-- Check if `Parse' button should be enabled.
		do
			check_can_parse
		end

	on_serialized_folder_change is
			-- Called by `change_actions' of `serialized_folder_text_field'.
			-- Check if `Parse' button should be enabled.
		do
			check_can_parse
		end

	on_parse_file_change is
			-- Called by `change_actions' of `parse_file_text_field'.
			-- Check if `Parse' button should be enabled.
		do
			check_can_parse
		end

	on_provider_browse is
			-- Called by `select_actions' of `provider_browse_button'.
			-- Show file browse dialog.
		do
			browse_for_file ("Browse for CodeDom Provider dll...", "*.dll", agent provider_combo_box.set_text)
		end

	on_change_notebook_tab is
			-- Called by `selection_actions' of `tests_notebook'.
			-- Enable codedom trees frame only for `Generator' tab.
		do
			if tests_notebook.item_text (tests_notebook.selected_item).is_equal (Generator_tab_title) then
				if not codedom_trees_frame.is_sensitive then
					codedom_trees_frame.enable_sensitive
				end
			else
				if codedom_trees_frame.is_sensitive then
					codedom_trees_frame.disable_sensitive
				end
			end
		end

	on_change_generation_path is
			-- Called by `change_actions' of `generation_path_text_field'.
		do
			check_can_generate
		end

	on_change_generated_filename is
			-- Called by `change_actions' of `generated_filename_text_field'.
		do
			check_can_generate
		end

	on_close is
			-- Save all settings then quit.
		do
			set_saved_height (height)
			set_saved_width (width)
			set_saved_x (x_position)
			set_saved_y (y_position)
			set_saved_codedom_provider (provider_combo_box.text)
			(create {EV_ENVIRONMENT}).application.destroy
		end
	
feature {NONE} -- Implementation

	check_can_generate is
			-- Check if `Generate' button should be enabled.
		do
			if feature {SYSTEM_DIRECTORY}.exists (generation_path_text_field.text) then
				generation_path_text_field.set_foreground_color (Black)
			else
				generation_path_text_field.set_foreground_color (Red)
			end
			if codedom_provider /= Void and codedoms_tree.selected_item /= Void then
				if feature {SYSTEM_DIRECTORY}.exists (generation_path_text_field.text) then
					if not generated_filename_text_field.text.is_empty then
						if not generate_button.is_sensitive then
							generate_button.enable_sensitive
						end
					else
						if generate_button.is_sensitive then
							generate_button.disable_sensitive
						end
					end
				else
					if generate_button.is_sensitive then
						generate_button.disable_sensitive
					end
				end
			end
		end
	
	check_can_parse is
			-- Check if `Parse' button should be enabled.
		do
			if feature {SYSTEM_DIRECTORY}.exists (serialized_folder_text_field.text) then
				serialized_folder_text_field.set_foreground_color (Black)
			else
				serialized_folder_text_field.set_foreground_color (Red)
			end
			if feature {SYSTEM_FILE}.exists (parse_file_text_field.text) then
				parse_file_text_field.set_foreground_color (Black)
			else
				parse_file_text_field.set_foreground_color (Red)
			end
			if feature {SYSTEM_FILE}.exists (serialized_folder_text_field.text + (create {OPERATING_ENVIRONMENT}).Directory_separator.out +
					serialized_filename_text_field.text + Serialized_file_extension) then
				serialized_filename_text_field.set_foreground_color (Red)
			else
				serialized_filename_text_field.set_foreground_color (Black)
			end
			if codedom_provider /= Void and not serialized_filename_text_field.text.is_empty and
				feature {SYSTEM_DIRECTORY}.exists (serialized_folder_text_field.text) and feature {SYSTEM_FILE}.exists (parse_file_text_field.text) then
					parse_button.enable_sensitive
			else
				parse_button.disable_sensitive
			end
		end
	
	update_tree is
			-- Update codedoms tree.
		local
			l_node: EV_TREE_ITEM
			l_namespace: SYSTEM_DLL_CODE_NAMESPACE
			i: INTEGER
		do
			codedoms_tree.wipe_out
			Compile_units_node.wipe_out
			Namespaces_node.wipe_out
			Types_node.wipe_out
			Expressions_node.wipe_out
			Statements_node.wipe_out
			if store.compile_units /= Void then
				from
					i := 1
					store.compile_units.start
					store.compile_units_paths.start
				until
					store.compile_units.after
				loop
					l_namespace := store.compile_units.item.namespaces.item (0)
					if l_namespace /= Void then
						create l_node.make_with_text (l_namespace.name)
					else
						create l_node.make_with_text ("Compile unit " + i.out)
					end
					l_node.set_pixmap (Compile_units_node.pixmap)
					l_node.set_tooltip (store.compile_units_paths.item)
					l_node.set_data (store.compile_units.item)
					Compile_units_node.extend (l_node)
					store.compile_units.forth
					store.compile_units_paths.forth
					i := i + 1
				end
				codedoms_tree.extend (Compile_units_node)
				Compile_units_node.expand
			end
			if store.namespaces /= Void then
				from
					store.namespaces.start
					store.namespaces_paths.start
				until
					store.namespaces.after
				loop
					create l_node.make_with_text (store.namespaces.item.name)
					l_node.set_pixmap (Namespaces_node.pixmap)
					l_node.set_tooltip (store.namespaces_paths.item)
					l_node.set_data (store.namespaces.item)
					Namespaces_node.extend (l_node)
					store.namespaces.forth
					store.namespaces_paths.forth
				end
				codedoms_tree.extend (Namespaces_node)
				Namespaces_node.expand
			end
			if store.types /= Void then
				from
					store.types.start
					store.types_paths.start
				until
					store.types.after
				loop
					create l_node.make_with_text (store.types.item.name)
					l_node.set_pixmap (Types_node.pixmap)
					l_node.set_tooltip (store.types_paths.item)
					l_node.set_data (store.types.item)
					Types_node.extend (l_node)
					store.types.forth
					store.types_paths.forth
				end
				codedoms_tree.extend (Types_node)
				Types_node.expand
			end
			if store.expressions /= Void then
				from
					store.expressions.start
					store.expressions_paths.start
				until
					store.expressions.after
				loop
					create l_node.make_with_text ("Expression " + store.expressions.index.out)
					l_node.set_pixmap (Expressions_node.pixmap)
					l_node.set_tooltip (store.expressions_paths.item)
					l_node.set_data (store.expressions.item)
					Expressions_node.extend (l_node)
					store.expressions.forth
					store.expressions_paths.forth
				end
				codedoms_tree.extend (Expressions_node)
				Expressions_node.expand
			end
			if store.statements /= Void then
				from
					store.statements.start
					store.statements_paths.start
				until
					store.statements.after
				loop
					create l_node.make_with_text ("Statement " + store.expressions.index.out)
					l_node.set_pixmap (Statements_node.pixmap)
					l_node.set_tooltip (store.statements_paths.item)
					l_node.set_data (store.statements.item)
					Statements_node.extend (l_node)
					store.statements.forth
					store.statements_paths.forth
				end
				codedoms_tree.extend (Statements_node)
				Statements_node.expand
			end
		end
		
	display_output (a_output: STRING) is
			-- Display output `a_output'.
		require
			non_void_output: a_output /= Void
		do
			output_text.append_text (a_output)
			tests_notebook.select_item (output_text)
		end
		
	selected_tree_item_type: INTEGER is
			-- Selected tree item type if any
			-- 0 otherwise
			-- See class TESTER_CODEDOM_TYPES for possible values
		do
			if codedoms_tree.selected_item /= Void then
				Result := (create {TESTER_TREE_DESERIALIZER}).codedom_type_from_file (codedoms_tree.selected_item.tooltip)
			end
		ensure
			valid_type: Result = 0 or else is_valid_codedom_type (Result)
		end
		
	update_properties is
			-- Update code generator, parser and compiler properties with `codedom_provider'.
		local
			l_generator: SYSTEM_DLL_ICODE_GENERATOR
		do
			supports_list.wipe_out
			non_supports_list.wipe_out
			l_generator := codedom_provider.create_generator
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.Arrays_of_arrays) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Arrays of arrays"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Arrays of arrays"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.assembly_attributes) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Assembly attributes"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Assembly attributes"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.chained_constructor_arguments) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Chained constructor arguments"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Chained constructor arguments"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.complex_expressions) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Complex expressions"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Complex expressions"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.declare_delegates) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare delegates"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare delegates"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.declare_enums) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare enums"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare enums"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.declare_events) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare events"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare events"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.declare_interfaces) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare interfaces"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare interfaces"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.declare_value_types) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare value types"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare value types"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.entry_point_method) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Entry point method"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Entry point method"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.goto_statements) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Goto statements"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Goto statements"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.multidimensional_arrays) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Multidimensional arrays"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Multidimensional arrays"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.multiple_interface_members) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Multiple interface members"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Multiple interface members"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.nested_types) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Nested types"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Nested types"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.parameter_attributes) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Parameter attributes"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Parameter attributes"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.public_static_members) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Public static members"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Public static members"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.reference_parameters) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Reference parameters"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Reference parameters"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.return_type_attributes) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Return type attributes"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Return type attributes"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.static_constructors) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Static constructors"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Static constructors"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.try_catch_statements) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Try catch statements"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Try catch statements"))
			end
			if l_generator.supports (feature {SYSTEM_DLL_GENERATOR_SUPPORT}.win_32_resources) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Win32 resources"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Win32 resources"))
			end
		end
	
	add_codedom_tree (a_path: STRING) is
			-- Add tree located at `a_path' to codedoms tree.
		require
			non_void_path: a_path /= Void
			non_empty_path: not a_path.is_empty
		do
			store.add (a_path)
			update_tree
		end

	compiler_options: SYSTEM_DLL_COMPILER_PARAMETERS is
			-- Compiler options from gui values
		local
			l_names: NATIVE_ARRAY [SYSTEM_STRING]
			i: INTEGER
		do
			create l_names.make (referenced_assemblies_list.count)
			from
				referenced_assemblies_list.start
			until
				referenced_assemblies_list.after
			loop
				l_names.put (i, referenced_assemblies_list.item.text)
				referenced_assemblies_list.forth
				i := i + 1
			end
			create Result.make_from_assembly_names (l_names)
			if not resource_text_field.text.is_empty then
				Result.set_win_32_resource (resource_text_field.text)
			end
			Result.set_generate_executable (generate_executable_check_button.is_selected)
			Result.set_generate_in_memory (generate_executable_check_button.is_selected)
			Result.set_include_debug_information (include_debug_check_button.is_selected)
			if not compiler_options_text_field.text.is_empty then
				Result.set_compiler_options (compiler_options_text_field.text)
			end
			if not main_class_text_field.text.is_empty then
				Result.set_main_class (main_class_text_field.text)
			end
			if not output_assembly_text_field.text.is_empty then
				Result.set_output_assembly (output_assembly_text_field.text)
			end
		end
		
	display_compilation_results (a_results: SYSTEM_DLL_COMPILER_RESULTS) is
			-- Display `a_results' in output pane.
		require
			non_void_results: a_results /= Void
		local
			l_message: STRING
			i: INTEGER
			l_collection: SYSTEM_DLL_STRING_COLLECTION
			l_errors: SYSTEM_DLL_COMPILER_ERROR_COLLECTION
			l_path: STRING
		do
			l_message := "-- Compilation Terminated --%N* Compiler output:%N"
			l_collection := a_results.output
			if l_collection /= Void then
				from
				until
					i = l_collection.count
				loop
					l_message.append (l_collection.item (i))
					l_message.append_character ('%N')
					i := i + 1
				end
			else
				l_message.append ("(None)%N")
			end
			l_errors := a_results.errors
			if l_errors /= Void and then l_errors.count > 0 then
				l_message.append ("%N* Compiler errors:%N")
				from
					i := 0
				until
					i = l_errors.count
				loop
					l_message.append (l_errors.item (i).to_string)
					l_message.append_character ('%N')
					i := i + 1				
				end
			end
			l_path := a_results.path_to_assembly
			if l_path /= Void and then not l_path.is_empty then
				l_message.append ("%N* Path to assembly:%N" + l_path)
			end
			Event_manager.raise_event (create {TESTER_EVENT}.make (l_message, False))
		end

	browse_for_file (a_title, a_filter: STRING; a_processor: ROUTINE [ANY, TUPLE [STRING]]) is
			-- Browse for file and give title `a_title' to browse dialog and filter `a_filter'.
			-- Call `a_processor' with resulting file name if not empty.
		require
			non_void_title: a_title /= Void
			non_void_processor: a_processor /= Void
		local
			l_dialog: EV_FILE_OPEN_DIALOG
		do
			create l_dialog.make_with_title (a_title)
			if a_filter /= Void then
				l_dialog.set_filter (a_filter)
			end
			l_dialog.show_modal_to_window (Current)
			if not l_dialog.file_name.is_empty then
				a_processor.call ([l_dialog.file_name])
			end
		end
		
	browse_for_directory (a_title, a_key: STRING; a_processor: ROUTINE [ANY, TUPLE [STRING]]) is
			-- Browse for directory and give title `a_title' to browse dialog.
			-- Store/retrieve last used folder in `a_key'.
			-- Call `a_processor' with resulting file name if not empty.
		require
			non_void_title: a_title /= Void
			non_void_key: a_key /= Void
			non_void_processor: a_processor /= Void
		local
			l_dialog: EV_DIRECTORY_DIALOG
			l_start_dir, l_dir: STRING
		do
			create l_dialog.make_with_title (a_title)
			l_start_dir := text_setting (a_key)
			if l_start_dir /= Void then
				l_dialog.set_start_directory (text_setting (a_key))
			end
			l_dialog.show_modal_to_window (Current)
			l_dir := l_dialog.directory
			if not l_dir.is_empty then
				set_text_setting (a_key, l_dir)
				a_processor.call ([l_dir])
			end
		end
		
feature {NONE} -- Private Access

	codedom_provider: SYSTEM_DLL_CODE_DOM_PROVIDER
			-- Associated codedom provider
		
	store: TESTER_TREE_STORE
			-- Associated codedom tree store

	Serialized_file_extension: STRING is ".ecds"
			-- Serialized file extension

	Black: EV_COLOR is
			-- Black
		once
			Result := (create {EV_STOCK_COLORS}).Black
		end
		
	Red: EV_COLOR is
			-- Black
		once
			Result := (create {EV_STOCK_COLORS}).Red
		end

	Compile_units_node: EV_TREE_NODE is
			-- Compile units tree node
		once
			create {EV_TREE_ITEM} Result.make_with_text ("Compile units")
			Result.set_pixmap (Compile_unit_png)
		end

	Namespaces_node: EV_TREE_NODE is
			-- Namespaces tree node
		once
			create {EV_TREE_ITEM} Result.make_with_text ("Namespaces")
			Result.set_pixmap (Namespace_png)
		end

	Types_node: EV_TREE_NODE is
			-- Types tree node
		once
			create {EV_TREE_ITEM} Result.make_with_text ("Types")
			Result.set_pixmap (Type_png)
		end

	Expressions_node: EV_TREE_NODE is
			-- Expressions tree node
		once
			create {EV_TREE_ITEM} Result.make_with_text ("Expressions")
			Result.set_pixmap (Expression_png)
		end

	Statements_node: EV_TREE_NODE is
			-- Statements tree node
		once
			create {EV_TREE_ITEM} Result.make_with_text ("Statements")
			Result.set_pixmap (Statement_png)
		end

invariant
	generate_button_disabled_if_no_provider: codedom_provider = Void implies not generate_button.is_sensitive
	compile_from_dom_button_disabled_if_no_provider: codedom_provider = Void implies not compile_from_dom_button.is_sensitive
	compile_from_file_button_disabled_if_no_provider: codedom_provider = Void implies not compile_from_file_button.is_sensitive
	compile_from_source_button_disabled_if_no_provider: codedom_provider = Void implies not compile_from_source_button.is_sensitive
	parse_button_disabled_if_no_provider: codedom_provider = Void implies not parse_button.is_sensitive

end -- class TESTER_TESTER_MAIN_WINDOW

--+--------------------------------------------------------------------
--| Eiffel CodeDOM Provider Tester
--| Copyright (C) 2001-2004 Eiffel Software
--| Eiffel Software Confidential
--| All rights reserved. Duplication and distribution prohibited.
--|
--| Eiffel Software
--| 356 Storke Road, Goleta, CA 93117 USA
--| http://www.eiffel.com
--+--------------------------------------------------------------------