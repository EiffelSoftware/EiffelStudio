<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<TITLE>EiffelStore DataView Cluster</TITLE>
<LINK REL=StyleSheet HREF="../../../../default.css">
<style>
<!--
.warning     {  }
.Note        {  }
.figuretitle {  }
.tip         {  }
-->
</style>
</head>

<body>

<h1 align="center">EiffelStore DataView Cluster</h1>
<h2>1. Introduction</h2>
<p><i>DataView</i> cluster helps the programmer creating a GUI for a RDBMS. It
gives a basic solution for a RDBMS GUI and enable the developer to customize his
GUI from this basic interface.</p>
<p>This cluster is client of EiffelStore to interface with a RDBMS and
EiffelVision2 to create a GUI. However, the use of EiffelStore and EiffelVision2
is sufficiently encapsulated to enable the programmer to use other
database/graphic libraries.</p>
<p>Notice finally that <i>DataView</i> is based on some common O-O <i>design
patterns</i>. Knowing these patterns will help you understand how the library
works. It can also give an example of patterns use.</p>
<h2>2. Specifications</h2>
<p>This part draws the main capabilities that can be expected from the <i>DataView</i>
cluster. These capabilities are not exhaustive since the cluster architecture
enables to add easily new capabilities to it.</p>
<h3>2.1. Database structure</h3>
<p>The cluster has been designed to work well with relational databases on 3rd
Normal Form. Database tables must also have an unique numeric ID.</p>
<ul>
  <li>The cluster automatically performs associations between related tables.
    This is required to work fine with 3rd NF architectures.</li>
  <li>The unique ID enable to update the database content. If you only intend to
    display database table content, unique IDs are not required.</li>
  <li>The numeric ID enable to directly give IDs to new table rows. If you don't
    intend to create table rows, this is not necessary. Notice that with only a
    couple of redefinitions, the numeric ID requirement problem can be overcome.</li>
</ul>
<h3>2.2. Database content display</h3>
<p>The cluster provides facilities to:</p>
<ul>
  <li>display a set of table rows.</li>
  <li>select a (current) table row in the set.</li>
  <li>display the current table row so that it can be edited.</li>
</ul>
<p>For instance, an interface can display a multi-column list of table rows. A
given row can be selected in the list and its information can be then edited
through a set of text fields and combo-boxes.</p>
<p>The standard cluster usage is to define a GUI that will associate a given
frame/window to a given database table, that is, the information that is
displayed in a GUI area will be determined at compile-time. This enables to
adapt the GUI display to the type of information displayed, which is recommended
when creating a GUI for non-developer users (or any people that should not be
aware of the database structure and functioning). Nevertheless, determining the
type of information displayed by a frame/window at runtime is still possible as
not hard-coded in the DV_TABLE_COMPONENT class.</p>
<p>Abstracting database in the GUI might not be as easy as only changing
database attribute fields names. Information to display may not match the
database tables structure. However, for consistency reasons, we can assume that
the information to display within a GUI area belongs to a set of associated
tables. The easiest solution is to create database views that directly contain
the information to display on the GUI area. This implies though that the
database has to be modified for the GUI needs.</p>
<p><i>DataView </i>cluster affords a second solution:</p>
<ul>
  <li>Model-View separation enables to merge graphically information that is
    separated in the process part (i.e. that is from a different table).</li>
  <li>Table associations facilities enable to specify to display automatically
    content of table rows associated to a given table row. For instance, with a
    CONTACTS table associated to a COMPANIES table, the cluster can retrieve
    automatically a COMPANIES table row associated to a selected CONTACTS table
    row.</li>
</ul>
<h3>2.3. Actions performed on the database</h3>
<p>The cluster provides facilities for the following actions:</p>
<ul>
  <li>Creating a table row</li>
  <li>Deleting a table row</li>
  <li>Updating the content of a table row</li>
  <li>Selecting a set of table rows</li>
</ul>
<p>Other capabilities can be added to these ones. For instance, a descendant of
DV_TABLE_COMPONENT can be written, that would handle more database operations.</p>
<p>Operations relative to the database structure modification may be more
difficult to add since the database structure is hard-coded. But these advanced
capabilities might not be necessary in a GUI for non-developer users.</p>
<h2>3. General description</h2>
<h3>3.1. Global architecture</h3>
<p>The <i>DataView</i> cluster is based on 1 class called DV_TABLE_COMPONENT
that represents the interface for 1 relational database table. An architecture
using <i>DataView</i> is centered on database table structure rather than the
GUI structure. The basic idea is to have:</p>
<ul>
  <li>1 database relational table</li>
  <li>1 GUI window or frame</li>
  <li>1 DV_TABLE_COMPONENT object</li>
</ul>
<p>This is then possible to adapt the code to have a GUI meeting the
specifications, database structure can be totally abstracted in the interface,
which might be more convenient for non-developer GUI users.</p>
<h3>3.2. Library structure</h3>
<p>The cluster can be separated into 3 main parts:</p>
<ul>
  <li>The <b>model</b>: processes the information and interfaces with an
    abstract graphic interface (<i>see handle below</i>) and an abstract
    database interface.</li>
  <li>The <b>handle</b>: defines an abstract graphic interface for the model.</li>
  <li>The <b>view</b>: implements the handle interface with EiffelVision2
    widgets.</li>
</ul>
<p>The abstract database interface used is actually part of EiffelStore (<i>see
eiffelstore.generation cluster</i>). This cluster can indeed been used
independently from the <i>DataView</i> cluster.</p>
<h3>3.3. Model cluster structure</h3>
<p>The <b>model</b> cluster processes the information retrieved from the GUI and
the database and update then both GUI and database.</p>
<p>The cluster is based on the DV_TABLE_COMPONENT class which objects represents
a database relational table (or view).</p>
<p>DV_TABLE_COMPONENT objects can be interconnected to match the table
associations. The DV_TABLE_COMPONENT class has been designed to work with 3rd
Normal Form relational databases. DV_TABLE_COMPONENT achieves most of the work
to retrieve associated table rows for a 3NF database. For instance, when
deleting a table row, the component ensures that every associated table row is
also deleted.</p>
<p>DV_TABLE_COMPONENT objects can be customized by adding some subcomponents to
it. Subcomponents enable to display table rows content on screen, to navigate
among table rows and to perform different database queries.</p>
<p><img border="1" src="sub-component_objects.png" width="383" height="339"></p>
<p class="figuretitle">Process objects structure for a GUI</p>
<h3>3.4. Design patterns</h3>
<p>This cluster adapts several well-known O-O design patterns.</p>
<h4>3.4.1. <a name="model-view_sep"></a> Model-View separation pattern</h4>
<p>The GUI appearance is totally abstracted in the GUI processing part, this
enables to change the GUI display without changing any part of the model part.
This is implemented with 2 sets of classes:</p>
<ul>
  <li>A set of interfaces that corresponds to each type of abstract widgets
    needed by the model.</li>
  <li>A set of classes that implements these interfaces. Notice that an
    implementation class can implement several interfaces and several classes
    can implement the same interface.</li>
</ul>
<p>Let's see an example through a BON diagram:</p>
<p align="left"><img border="0" src="model_view_relationship.png" width="573" height="269"></p>
<p align="left" class="figuretitle">Model-View separation pattern implementation in <i>DataView</i></p>
<ul>
  <li>
    <p align="left">Light blue classes represents the model cluster.</li>
  <li>
    <p align="left">Orange class represents the handle.</li>
  <li>
    <p align="left">Yellow and green classes represents the view cluster.</li>
  <li>
    <p align="left">Pink classes represents the EiffelVision2 library.</li>
</ul>
<h4 align="left">3.4.2. Strategy pattern</h4>
<p align="left"><i>DataView</i> cluster provides the developer with a basic GUI
implementation AND enables them to customize their application. This is possible
with a strategy pattern:</p>
<p align="left">The developer assign different subcomponents to a
DV_TABLE_COMPONENT object to define its behavior. The component object only uses
the interface of each subcomponent. For each interface, the developer can then
select which implementation object assigning to the table component.</p>
<p align="left">A default implementation is written for each interface to let
the user use the cluster as quick as possible. To adapt components behavior to
their needs, the developer can then create a new subcomponent class inheriting
from the abstract interface.</p>
<p align="left">This BON diagram illustrates this for DV_CREATOR and DV_SEARCHER
subcomponents:</p>
<p align="left"><img border="0" src="DV_TABLE_COMPONENT_strategy.png" width="585" height="192"></p>
<p align="left" class="figuretitle">Strategy pattern used in <i>DataView</i> model cluster</p>
<!--<h4 align="left">3.4.3. Manager-Observer pattern (remove?_?)</h4>
<p align="left">This pattern is used to ensure consistency between a
DV_TABLE_COMPONENT object and its related component objects.</p>
<p align="left">When a component object is updated, it then updates every
associated component objects. The associated objects are updated through a
DV_TYPED_SEARCHER object.</p>
<p align="left">Let's see how <i>DataView</i> implements this:</p>
<p align="left"><img border="0" src="DV_TABLE_COMPONENT_observer.png" width="516" height="164"></p>
<p class="figuretitle">Observer pattern used in <i>DataView</i> model cluster</p>
<p align="left"><img border="0" src="DV_T_C_observer_objects.png" width="384" height="335"></p>
<p align="left" class="figuretitle">Corresponding observer pattern objects
(example)</p>-->
<h2 align="left">4. Cluster interface</h2>
<p align="left">This part describes how to use the table component class and its
subcomponents classes:</p>
<ul>
  <li>
    <p align="left">The DV_SEARCHER class to <a href="#dv_searcher">select table
    rows from the database</a>.</li>
  <li>
    <p align="left">The DV_TABLEROW_NAVIGATOR class to <a href="#dv_tablerow_navigator">navigate
    among selected table rows</a>.</li>
  <li>
    <p align="left">The DV_CREATOR class to <a href="#dv_creator">create new
    table rows in the database</a>.</li>
  <li>
    <p align="left">The DV_TABLEROW_FIELDS class to <a href="#dv_tablerow_fields">edit
    a table row content</a>.</li>
</ul>
<h3 align="left">4.1. DV_TABLE_COMPONENT class</h3>
<p align="left">This class is responsible for the management of a database
table. Its behavior is determined by its assigned subcomponents.</p>
<p>To create a valid and functional DV_TABLE_COMPONENT object, follow these
steps:</p>
<ol>
  <li>Call `set_tablecode' to specify which table the component will deal with.</li>
  <li>Specify <a href="#output_handler">handlers to output messages</a>.</li>
  <li>Set the <a href="#database_handler">database handler</a>.</li>
  <li>Add different <a href="#controllers">controllers corresponding to actions
    to perform</a>.</li>
  <li>Set <a href="#subcomponents">subcomponents</a>.</li>
  <li>Set <a href="#associated_components">associated components</a>.</li>
  <li>Call `activate' to let the component work. This will basically set
    different default values for non required information not set during the
    creation process.</li>
</ol>
<p>The component can then be used on an interface:</p>
<ul>
  <li>Input interactions are done via component and subcomponents controllers
    (4).</li>
  <li>Output interactions are done via output handlers (2).</li>
</ul>
<h4>4.1.1. <a name="output_handler"></a>Output handlers</h4>

<p>Output handlers are specific to the DV_TABLE_COMPONENT object, that is, you
can output messages in a different way within your GUI. However, the same
handlers will be used for subcomponents.</p>

<p>3 handlers can be set:</p>
<ul>
  <li>`status_handler' to display status information</li>
  <li>`warning_handler' to display warning information. Warnings usually
    correspond to database errors, they are called warnings because the database
    error is &quot;caught&quot; and the message should enable the user to round
    the problem.</li>
  <li>`confirmation_handler' to ask for confirmation before an action.</li>
</ul>
<p>These handlers have default values, which are:</p>
<ul>
  <li>For `status_handler' and `warning_handler', messages are displayed on
    standard output (with {ANY}.io.pustring)</li>
  <li>For `confirmation_handler', action is executed without confirmation.</li>
</ul>
<h4>4.1.2. <a name="database_handler"></a>Database handler</h4>
<p>This handler is specific to the application. It must inherit from
ABSTRACT_DB_TABLE_MANAGER. Since it is specific to the program, it can be set
before creating any DV_TABLE_COMPONENT object through {DV_DATABASE_HANDLER}.set_database_handler.
The DB_TABLE_MANAGER class is the default database handler for EiffelStore.</p>
<h4>4.1.3. <a name="controllers"></a>Action controllers</h4>
<p>No subcomponent is associated to 'write', 'refresh' and 'delete' actions
since these actions does not require specific behavioral choices.</p>
<p>To perform 'write', 'refresh' and 'delete' at runtime, a controller is
associated to each of these actions. This controller triggers the action when a
determined user event is grabbed, for instance, when the user click on a button.</p>
<p><a href="#dv_s_control">Controllers</a> are implemented by the abstract class DV_SENSITIVE_CONTROL of
cluster user_interactions (handle).</p>
<h4>4.1.4. <a name="subcomponents"></a>Subcomponents</h4>
<p>Subcomponents can be assigned to a table component to specify its behavior to
create table rows, select table rows from the database and navigate among
selected table rows. A special subcomponent enable to display the <i>current</i>
table row, i.e. the table row that can be edited to update the database. The
default behavior for these subcomponents is that the functionality is not
available, that is, subcomponents are not mandatory.</p>
<p>These components share the table component output handlers. They are
automatically activated when table component is activated.</p>
<h4>4.1.5. <a name="associated_components"></a>Associated components</h4>
<p>Table components can be associated to reflect relation of database tables
represented. Associated table components are organized:</p>
<ul>
  <li>1 master component enables to manually select database table rows.</li>
  <li>Slave components automatically select table rows that are associated to
    the current table row of the master component.</li>
</ul>
<p class="Note"><b>Note</b>: Notice that table associations can be <b>nested</b>.</p>
<p>2 types of associations are possible to reflect table relations:</p>
<ul>
  <li>The slave table is dependent on the master table (1:N relationship)</li>
  <li>The slave table is necessary for the master table (N:1 relationship)</li>
</ul>
<p>Let us see an example with 3 relational tables:</p>
<p align="left"><img border="0" src="table-objects_associations.png" width="687" height="350"></p>
<p class="figuretitle">Tables architecture and corresponding component objects</p>
<p>The object architecture leads to a GUI where the user can select a company
and see the company country information and contacts in this company.</p>
<p>Finally, notice that by default slave components have the same output
handlers as their master and slave components are activated when the master
component is.</p>
<h3>4.2. <a name="dv_searcher"></a> DV_SEARCHER class</h3>
<h4>4.2.1. Overview</h4>
<p>DV_SEARCHER is responsible for retrieving table rows from the database. Let
us see how it interacts with a table component:</p>
<p align="left"><img border="0" src="component-search_relation.png" width="421" height="148"></p>
<p align="left" class="figuretitle">Basic relationship between table component
class and search class</p>
<ul>
  <li>`display' assigns a set of table rows to the table component.</li>
  <li>`refresh' asks to refresh the table rows from the same database query.</li>
</ul>
<p>DV_SEARCHER component does not afford an extended interface. This interface
is defined in its descendants. The implemented DV_SEARCHER descendants are:</p>
<ul>
  <li>DV_TYPED_SEARCHER performs different <a href="#dv_typed_searcher">basic
    searches</a> used by the cluster.</li>
  <li>DV_INTERACTIVE_SEARCHER enables to create a graphic interface to <a href="#dv_interactive_searcher">let
    user set search parameters</a>.</li>
</ul>
<h4>4.2.2. <a name="dv_typed_searcher"></a>DV_TYPED_SEARCHER class</h4>
<p>This class provides 3 types of searches:</p>
<ul>
  <li>&quot;Every row&quot; search: every rows of a table are fetched.</li>
  <li>&quot;ID selection&quot; search: the selection is qualified by an ID.</li>
  <li>&quot;Qualified selection&quot; search: the selection is qualified.</li>
</ul>
<h5>4.2.2.1. &quot;Every row&quot; search</h5>
<p>Call `read' to set table rows on the associated table component.</p>
<h5>4.2.2.2. &quot;ID selection&quot; search</h5>
<p>Call `read_from_tablerow' to set table rows on the associated table
component. Qualification ID is the ID of the table row in parameter. Table of
row in parameter must be the table of rows to select.</p>
<p>This capability is used by <i>DataView</i> cluster in DV_CHOICE_CREATOR to
select a just-created table row and display it on the table component.</p>
<h5>4.2.2.3. &quot;Qualified selection&quot; search</h5>
<p>Call `read_from_tablerow' to set table rows on the associated table
component. Table of row in parameter may not be the table of rows to select.</p>
<p>To extract the qualifier, the search component needs additional information:</p>
<ul>
  <li>The location of the qualifying value in the table row passed in parameter
    (`set_row_attribute_code')</li>
  <li>The qualifying attribute location in the table rows to select (`set_criterion')</li>
</ul>
<p>This capability is used in DV_TABLE_COMPONENT when a table row is selected to
set associated table rows to slave components. Take a look at `add_necessary_table'
and `add_dependent_table'.</p>
<h4>4.2.3. <a name="dv_interactive_searcher"></a>DV_INTERACTIVE_SEARCHER class</h4>
<p>This class enables to create a graphic interface to let user perform basic
searches. These searches are qualified by one table attribute. This interface
has 5 parts:</p>
<ul>
  <li>A <a href="#dv_s_control"> controller</a> that enables to launch the search</li>
  <li>A <a href="#dv_s_string"> text input field</a> to set qualifying attribute</li>
  <li>A <a href="#dv_s_string"> text input field</a> to set qualifying value</li>
  <li>A <a href="#dv_s_integer"> typed input field</a> to set qualification type</li>
  <li>A <a href="#dv_s_check"> Boolean input field</a> to set case sensitivity</li>
</ul>
<p>Text input fields correspond to handle class DV_SENSITIVE_STRING, typed input
fields corresponds to handle class DV_SENSITIVE_INTEGER and Boolean input fields
corresponds to handle class DV_SENSITIVE_CHECK.</p>
<h3>4.3. <a name="dv_tablerow_navigator"></a> DV_TABLEROW_NAVIGATOR class</h3>
<h4>4.3.1. Overview</h4>
<p>Table component class contains a set of table rows. This class lets table
component class know which of these rows is the current one.</p>
<p align="left"><img border="0" src="component_navigate_relation.png" width="471" height="167"></p>
<p class="figuretitle">Basic relationship between table component class and
navigation class</p>
<p>DV_CHOICE_CREATOR also uses the class to enable to select associated table rows
when creating a new table row (for instance, when creating a company, an
existing country should be selected). Let us see how this is designed:</p>
<p align="left"><img border="0" src="DV_TABLEROWS_NAVIGATOR_clients.png" width="598" height="240"></p>
<p class="figuretitle">DV_TABLEROWS_NAVIGATOR clients</p>
<p class="Note"><b>Note</b>: DV_TABLEROWS_COMPONENT class merely carries a set of table rows and enables
to select one table row.</p>
<p>DV_CONTROL_NAVIGATOR affords a way to navigate among searched table rows.</p>
<h4>4.3.2. <a name="dv_control_navigator"></a> DV_CONTROL_NAVIGATOR class</h4>
<p>This class enables 2 navigation systems:</p>
<ul>
  <li>Navigating among table rows with &quot;previous&quot; and &quot;next&quot;
    controllers.</li>
  <li>Navigating among table rows through a display list.</li>
</ul>
<p class="tip"><b>Tip</b>: Notice that both systems can be used.</p>
<p>You can directly set <a href="#dv_s_control"> controllers</a> for &quot;previous&quot; and
&quot;next&quot; actions. A 3rd controller, &quot;edit list&quot;, enables to
show or raise the display list.</p>
<p class="warning"><b>Caution</b>: Notice that DV_CONTROL_NAVIGATOR only manages
this controller sensitivity.</p>
<p>You can assign a <a href="#dv_tablerow_list"> display list</a> to the navigator with a DV_TABLEROW_LIST
component.</p>
<h3>4.4. <a name="dv_creator"></a> DV_CREATOR class</h3>
<h4>&nbsp;4.4.1. Overview</h4>
<p>This class enables to create database table rows.</p>
<p align="left"><img border="0" src="component-create_relation.png" width="454" height="167"></p>
<p class="figuretitle">Basic relationship between table component class and
navigation class</p>
<p>DV_CREATOR class contains minimum information to interact with
DV_TABLE_COMPONENT: when a table row is created, a creator component may display
it on the table component. In this case, when the table component needs to
refresh the table rows set, this refreshing action need to be managed by the
creator component:</p>
<ul>
  <li>`set_just_created' informs a table component that displayed table row set
    comes from the creator component.</li>
  <li>`refresh' lets the creation component refresh table component display.</li>
</ul>
<p>Much of the work, that is row creation, is totally abstracted in DV_CREATOR.
DV_CHOICE_CREATOR implements DV_CREATOR and thus affords a creation procedure.</p>
<h4>4.4.2. DV_CHOICE_CREATOR class</h4>
<h5>4.4.2.1. Overview</h5>
<p>This class creates a new table row and sets its key values:</p>
<ul>
  <li>Database handle gives the primary key value (ID) .</li>
  <li>The class asks the user for foreign key values (for table associations) by
    displaying available values in a list.</li>
</ul>
<p>DV_TABLEROW_NAVIGATOR is used to select a foreign key value, let us see how
this is implemented:</p>
<p align="left"><img border="0" src="DV_CHOICE_CREATOR_fkeys_selection.png" width="594" height="170"></p>
<p class="figuretitle">DV_CHOICE_CREATOR suppliers for foreign keys selection</p>
<p>DV_TABLEROW_ID_PROVIDER inherits from DV_TABLEROWS_COMPONENT to interface
with DV_TABLEROWS_NAVIGATOR.&nbsp;</p>
<p>Relation between DV_CHOICE_CREATOR and DV_TABLEROW_ID_PROVIDER is basically:</p>
<p align="left"><img border="0" src="creator-provider_relation.png" width="502" height="171"></p>
<p class="figuretitle">DV_CHOICE_CREATOR/DV_TABLEROW_ID_PROVIDER basic
interactions</p>
<p>Creation process and DV_CHOICE_CREATOR objects creation
procedure can help you use this class.</p>
<h5>4.4.2.2. Creation process</h5>
<p>Table row creation process is:</p>
<ol>
  <li>Table row creation is triggered by a <a href="#dv_s_control"> controller</a> (&quot;create&quot;)</li>
  <li>DV_CHOICE_CREATOR creates a table row object</li>
  <li>DV_CHOICE_CREATOR requests a first foreign key value to
    DV_TABLEROW_ID_PROVIDER (through `select_from_table')</li>
  <li>DV_TABLEROW_ID_PROVIDER loads the available table rows that can be
    referenced</li>
  <li>DV_TABLEROW_ID_PROVIDER assign the table rows to DV_TABLEROW_NAVIGATOR and
    pops up the interface with the table rows</li>
  <li>Table row selection is triggered by a <a href="#dv_s_control"> controller</a> (&quot;ok&quot;)</li>
  <li>DV_TABLEROW_ID_PROVIDER retrieves the selected table row ID and gives it
    back to DV_CHOICE_CREATOR (through `add_foreign_key_value')</li>
  <li>DV_CHOICE_CREATOR requests other foreign key values to
    DV_TABLEROW_ID_PROVIDER</li>
  <li>DV_CHOICE_CREATOR creates the database row with a new ID through the
    database handle</li>
</ol>
<h5>&nbsp;4.4.2.3. Objects creation procedure</h5>
<p>To create a DV_CHOICE_CREATOR, follow these steps:</p>
<ol>
  <li>Create an object conforming to DV_TABLEROWS_NAVIGATOR</li>
  <li>Create a DV_TABLEROW_ID_PROVIDER object and assign the
    DV_TABLEROWS_NAVIGATOR object to it</li>
  <li>Set a <a href="#dv_s_control"> controller</a> to trigger foreign key selection</li>
  <li>Set the action to perform to pop up the interface to select the foreign
    key</li>
  <li>Create a DV_CHOICE_CREATOR object and assign the DV_TABLEROW_ID_PROVIDER
    object to it</li>
  <li>Set a <a href="#dv_s_control"> controller</a> to trigger table row creation</li>
</ol>
<h3>4.5. <a name="dv_tablerow_fields"></a> DV_TABLEROW_FIELDS class</h3>
<h4>4.5.1. Overview</h4>
<p>This class enable to display and edit the current table row of a table
component. Let us see first how it interacts with the table component:</p>
<p align="left"><img border="0" src="component-fields_relation.png" width="478" height="145"></p>
<p class="figuretitle">DV_TABLE_COMPONENT/DV_TABLEROW_FIELDS basic interactions</p>
<ul>
  <li>
    <p>`refresh_tablerow' refreshes display with a new table
    row</li>
  <li>
    <p>`update_tablerow' requests an updated table row for
    database update. Unchanged values are kept from a default table row</li>
  <li>
    <p>`updated_tablerow' is the last updated table row</li>
</ul>
<p>The class contains a list of fields that represent editable table attributes.
The design is simple:</p>
<p align="left"><img border="0" src="DV_TABLEROW_FIELDS_design.png" width="432" height="86"></p>
<p class="figuretitle">Table row edition capability design</p>
<h4>4.5.2. DV_TABLEROW_FIELD class</h4>
<p>This class enables to edit a table row attribute value. The view is
abstracted using the handle cluster DV_SENSITIVE_STRING class that <a href="#dv_s_string">represents
the editable text value</a>.</p>
<p>This class manages a field value but can also provide field name and type if <a href="#dv_s_string">
graphic fields</a> are provided. Notice that standard DV_TABLEROW_FIELD objects can
be generated through the DV_FACTORY class, which is a component factory.</p>
<h2>5. Handle cluster </h2>

<p>This cluster provides the model with an interface to input or output data on
the GUI. This enables to remove any link to a graphic implementation in the
model, following the <a href="#model-view_sep">Model-View separation</a> design
pattern. The cluster contains a set of interface classes to design this: </p>

<ul>
  <li>The DV_SENSITIVE_CONTROL class to <a href="#dv_s_control">let the user
    trigger an action</a>.</li>
  <li>The DV_SENSITIVE_STRING class to <a href="#dv_s_string">input or output a
    text value</a>.</li>
  <li>The DV_SENSITIVE_INTEGER class to <a href="#dv_s_integer">input or output
    a quantity value</a>.</li>
  <li>The DV_SENSITIVE_CHECK class to <a href="#dv_s_check">input or output a
    tag value</a>.</li>
  <li>The DV_TABLEROW_LIST class to <a href="#dv_tablerow_list">display a set of
    table rows and grab events on it</a>.</li>
</ul>
<h3>5.1. <a name="dv_s_control"></a>DV_SENSITIVE_CONTROL class</h3>
<p>The DV_SENSITIVE_CONTROL class lets a model class trigger a specific action
on a determined user event. Furthermore, the model class lets the user know when
its state enables to trigger the action, by setting the controller sensitivity
(i.e. if the controller is insensitive, the action cannot be triggered).</p>
<p class="Note"><b>Note</b>: sensitivity excepted, these controllers could have
been implemented by Eiffel <i>agents</i>.</p>
<p class="Note"><b>Note</b>: sensitivity enables to let the user know <i>before</i>
triggering an action if this is possible or not. The other possibility is to let
the user know <i>after</i> trying to trigger the action that it was not possible
(with a warning for instance): this is often less convenient.</p>
<p>The standard controllers are buttons or menu items: the specific action is
triggered when button is clicked or menu item selected.</p>
<p>DV_SENSITIVE_CONTROL is inherited by DV_BUTTON that implements
an EiffelVision2 button. Other implementations can be added, such as a menu item.</p>
<h3>5.2. <a name="dv_s_string"></a>DV_SENSITIVE_STRING class</h3>
<p>The DV_SENSITIVE_STRING class lets a model class input or output a text
graphically. As for controllers, the model class lets the user know when a text
value can be input by setting the widget sensitivity.</p>
<p>The standard graphical widgets to perform this are text fields, but several
other widgets can be used:</p>
<ul>
  <li>A combo-box so that the interface can suggest different values.</li>
  <li>A label if the text only need to be output.</li>
</ul>
<p class="Note"><b>Note</b>: customized, specific widgets can be defined, you
can for instance take a look at the DV_STRING_LIST class.</p>
<h3>5.3. <a name="dv_s_integer"></a>DV_SENSITIVE_INTEGER class</h3>
<p>This class lets a model class input or output an INTEGER value graphically.
As for controllers, the model class lets the user know when an integer value can
be input by setting the widget sensitivity.</p>
<p>Different widgets can be used to implement this:</p>
<ul>
  <li>A text field. Notice that the value entered should be checked to ensure it
    is an INTEGER value.</li>
  <li>A combo-box. Each combo-box option is associated to an integer.</li>
  <li>A scroll button.</li>
</ul>
<h3>5.4. <a name="dv_s_check"></a>DV_SENSITIVE_CHECK class</h3>
<p>This class lets a model class input or output a BOOLEAN value graphically. As
for controllers, the model class lets the user know when a Boolean value can be
input by setting the widget sensitivity.</p>
<p>The standard widget to implement this is a check box.</p>
<h3>5.5. <a name="dv_tablerow_list"></a>DV_TABLEROW_LIST class</h3>
<p>The DV_TABLEROW_LIST class provides an interface to display a set of table
rows so that the user can select a particular row.</p>
<ul>
  <li>The model can be informed of a row selection or deselection: the class
    accepts actions (implemented by <i>agents</i>) that are triggered when a row
    is selected or deselected.</li>
  <li>The model can retrieve the currently selected row: the class yields the
    current index position in the list.</li>
</ul>
<p>
DV_TABLEROW_MULTILIST implements DV_TABLEROW_LIST with an EiffelVision2
multi-column list.</p>
<p class="Note"><b>Note</b>: This class is used for the <a href="#dv_control_navigator">standard
implementation</a> of DV_TABLEROW_NAVIGATOR to <a href="#dv_tablerow_navigator">navigate
among table rows</a> selected from the database.</p>
<h2>6. Improvements</h2>

<p>This part is unfortunately not available yet.</p>

</body>

</html>
