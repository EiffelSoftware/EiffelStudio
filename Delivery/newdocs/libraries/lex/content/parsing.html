<!DOCTYPE HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">

<HTML>
	<HEAD>
		<TITLE>Parsing: The Parse Library</TITLE>
		<LINK REL=StyleSheet HREF="../../../default.css">
		<META NAME="MS-HKWD" CONTENT="Parsing">
	</HEAD>
	</HEAD>

	<BODY>
		<H1>Parsing: The Parse Library</H1>

		<H2>OVERVIEW</H2>

		<P>Parsing is the task of analyzing the structure of documents such as programs, specifications or other structured texts.</P>

		<P>Many systems need to parse documents. The best-known examples are compilers, interpreters and other software development tools; but as soon as a system provides its users with a command language, or processes input data with a non-trivial structure, it will need parsing facilities.</P>

		<P>This chapter describes the Parse library, which you can use to process documents of many different types. It provides a simple and flexible parsing scheme, resulting from the full application of object-oriented principles.</P>

		<P>Because it concentrates on the higher-level structure, the Parse library requires auxiliary mechanisms for identifying a document’s lexical components: words, numbers and other such elementary units. To address this need it is recommended, although not required, to complement Parse with the Lex library studied in the previous chapter.</P>

		<P>Figure 1 shows the inheritance structure of the classes discussed in this chapter.</P>

		<IMG SRC=figure2.png>
		<P CLASS="figuretitle">Figure 1: Parse class structure</P>

		<H2>WHY USE THE PARSE LIBRARY</H2>

		<P>Let us fist look at the circumstances under which you may want - or not want - to use the Parse library.</P>

		<H3>The Parse library vs. parser generators</H3>

		<P>Parsing is a heavily researched area of computing science and many tools are available to generate parsers. In particular, the popular Yacc tool, originally developed for Unix, is widely used to produce parsers.</P>

		<P>In some cases Yacc or similar tools are perfectly adequate. It is also sometimes desirable to write a special-purpose parser for a language, not relying on any parser generator. Several circumstances may, however, make the Parse library attractive:</P>

		<UL>
			<LI>The need to interface the parsing tasks with the rest of an object-oriented system (such as a compiler or more generally a "document processor" as defined below) in the simplest and most convenient way.</LI>
			<LI>The desire to apply object-oriented principles as fully as possible to all aspects of a system, including parsing, so as to gain the method’s many benefits, in particular reliability, reusability and extendibility.</LI>
			<LI>The need to tackle languages whose structure is not easily reconciled with the demands of common parser generator, which usually require the grammar to be LALR (1). (The Parse library uses a more tolerant LL scheme, whose only significant constraint is absence of left-recursivity; the library provides mechanisms to detect this condition, which is easy to correct.)</LI>
			<LI>The need to define several possible semantic treatments on the same syntactic structure.</LI>
		</UL>

		<P>The last reason may be the most significant practical argument in favor of using Parse. Particularly relevant is the frequent case of a software development environment in which a variety of tools all work on the same basic syntactic structure. For example an environment supporting a programming language such as Pascal or Eiffel may include a compiler, an interpreter, a pretty-printer, software documentation tools (such as Eiffel’s short and flat-short facilities), browsing tools and several other mechanisms that all need to perform semantic actions on software texts that have the same syntactic structure. With common parser generators such as Yacc, the descriptions of syntactic structure and semantic processing are inextricably mixed, so that you normally need one new specification for each tool. This makes design, evolution and reuse of specifications difficult and error-prone.</P>

		<P>In contrast, the Parse library promotes a specification style whereby syntax and semantics are kept separate, and uses inheritance to allow many different semantic descriptions to rely on the same syntactic stem. This will make Parse particularly appropriate in such cases.</P>

		<H3>A word of caution</H3>

		<P>At the time of publication the Parse library has not reached the same degree of maturity as the other libraries presented in this book. It should thus be used with some care. You will find at the end of this chapter a few comments about the work needed to bring the library to its full realization.</P>

		<H2>AIMS AND SCOPE OF THE PARSE LIBRARY</H2>

		<P>To understand the Parse library it is necessary to appreciate the role of parsing and its place in the more general task of processing documents of various kinds.</P>

		<H3>Basic terminology</H3>

		<P>First, some elementary conventions. The word <B>document</B> will denote the texts to be parsed. The software systems which perform parsing as part of their processing will be called <B>document processors</B>.</P>

		<P>Typical document processors are compilers, interpreters, program checkers, specification analyzers and documentation tools. For example the [BENCH] environment contains a number of document processors, used for compiling, documentation and browsing; the language to which they apply is either Eiffel itself or the Lace control language.</P>

		<H3>Parsing, grammars and semantics</H3>

		<P>Parsing is seldom an end in itself; rather, it serves as an intermediate step for document processors which perform various other actions.</P>

		<P>Parsing takes care of one of the basic tasks of a document processor: reconstructing the logical organization of a document, which must conform to a certain <B>syntax</B> (or structure), defined by a <B>grammar</B>.</P>

		<P CLASS="note"><B>Note</B>: the more complete name <B>syntactic grammar</B> avoids any confusion with the <I>lexical</I> grammars discussed in the <A HREF="lexical.html">previous chapter</A>. By default, "grammar" with no further qualification will always denote a syntactic grammar. A syntactic grammar normally relies on a lexical grammar, which gives the form of the most elementary components - the tokens - appearing in the syntactic structure.</P>

		<P>Once parsing has reconstructed the structure of a document, the document processor will perform various operations on the basis of that structure. For example a compiler will generate target code corresponding to the original text; a command language interpreter will execute the operations requested in the commands; and a documentation tool such as the short and flat-short commands for Eiffel will produce some information on the parsed document. Such operations are called <B>semantic actions</B>. One of the principal requirements on a good parsing mechanism is that it should make it easy to graft semantics onto syntax, by adding semantic actions of many possible kinds to the grammar.</P>

		<P>The Parse library provides predefined classes which handle the parsing aspect automatically and provide the hooks for adding semantic actions in a straightforward way. This enables developers to write full document processors - handling both syntax and semantics - simply and efficiently.</P>

		<P>As noted at the beginning of this chapter, it is possible to build a single syntactic base and use it for several processors (such as a compiler and a documentation tool) with semantically different goals, such as compilation and documentation. In the Parse library the semantic hooks take the form of deferred routines, or of routines with default implementations which you may redefine in descendants.</P>

		<H2>LIBRARY CLASSES</H2>

		<P>The Parse library contains a small number of classes which cover common document processing applications. The classes, whose inheritance structure was shown at the beginning of this chapter, are:</P>

		<UL>
			<LI>CONSTRUCT, describing the general notion of syntactical construct.</LI>
			<LI>AGGREGATE, describing constructs of the "aggregate" form.</LI>
			<LI>CHOICE, describing constructs of the "choice" form.</LI>
			<LI>REPETITION, describing constructs of the "repetition" form.</LI>
			<LI>TERMINAL, describing "terminal" constructs with no further structure.</LI>
			<LI>KEYWORD, describing how to handle keywords.</LI>
			<LI>L_INTERFACE, providing a simple interface with the lexical analysis process and the Lex library.</LI>
			<LI>INPUT, describing how to handle the input document.</LI>
		</UL>

		<H2>EXAMPLES</H2>

		The [BENCH] delivery includes (in the examples/library/parse subdirectory) a simple example using the Parse Library  classes. The example is a processor for "documents" which describe computations involving polynomials with variables. The corresponding processor is a system which obtains polynomial specifications and variable values from
		a user, and computes the corresponding polynomials.</P>

		<P>This example illustrates the most important mechanisms of the Parsing Library and provides a guide for using the facilities described in this chapter. The components of its grammar appear as illustrations in the next sections.</P>

		<H2>CONSTRUCTS AND PRODUCTIONS</H2>

		<P>A set of documents possessing common properties, such as the set of all valid Eiffel classes or the set of all valid polynomial descriptions, is called a <B>language</B>.</P>

		<P>In addition to its lexical aspects, the description of a language includes both syntactic and semantic properties. The grammar - the syntactic specification - describes the structure of the language (for example how an Eiffel class is organized into a number of clauses); the semantic specification defines the meaning of documents
		written in the language (for example the run-time properties of instances of the class, and the effect of feature calls).</P>

		<P>To discuss the Parse library, it is simpler to consider "language' as a purely syntactic notion; in other words, a language is simply the set of documents conforming to a certain syntactic grammar (taken here to include the supporting lexical grammar). Any semantic aspect will be considered to belong to the province of a specific document processor for the language, although the technique used for specifying the grammar will
		make it easy to add the specification of the semantics, or several alternative semantic specifications if desired.</P>

		<P>This section explains how you may define the syntactic base - the grammar.</P>

		<H3>Constructs</H3>

		<P>A grammar consists of a number of <B>constructs</B>, each representing the structure of documents, or document components, called the <B>specimens</B> of the construct. For example, a grammar for Eiffel will contain constructs such as Class, Feature_clause and Instruction. A particular class text is a specimen of construct Class.</P>

		<P>Each construct will be defined by a <B>production</B>, which gives the structure of the construct’s specimens. For example, a production for Class in an Eiffel grammar should express that a class (a specimen of the Class construct) is made of an optional Indexing part, a Class_header, an optional Formal_generics part and so on. The production for Indexing will indicate that any specimen of this construct - any Indexing part - consists of the keyword <I><B>indexing</I></B> followed by zero or more specimens of Index_clause.

		<P>Although some notations for syntax descriptions such as BNF allow more than one production per construct, the Parse library relies on the convention that every construct is defined by <B>at most one</B> production. Depending on whether there is indeed such a production, the construct is either <B>non-terminal</B> or <B>terminal</B>:

		<UL>
			<LI>A non-terminal construct (so called because it is defined in terms of others) is specified by a production, which may be of one of three types: aggregate, choice and repetition. The construct will accordingly be called an aggregate, choice or repetition construct.</LI>
			<LI>A terminal construct has no defining production. This means that it must be defined outside of the syntactical grammar. Terminals indeed come from the <B>lexical grammar</B>. Every terminal construct corresponds to a token type (regular expression or keyword) of the lexical grammar, for which the parsing duty will be delegated to lexical mechanisms, assumed in the rest of this chapter to be provided by the Lex library although others may be substituted if appropriate.</LI>
		</UL>

		<P>All specimens of terminal constructs are instances of class TERMINAL. A special case is that of keyword constructs, which have a single specimen corresponding to a keyword of the language. For example, <SPAN CLASS="ekeyword">if</SPAN> is a keyword of Eiffel. Keywords are described by class KEYWORD, an heir of TERMINAL.</P>

		<P>The rest of this section concentrates on the parsing-specific part: non-terminal constructs and productions. Terminals will be studied in the discussion of how to interface parsing with lexical analysis.</P>

		<H3>Varieties of non-terminal constructs and productions</H3>

		<P>An aggregate production defines a construct whose specimens are obtained by concatenating ("aggregating") specimens of a list of specified constructs, some of which may be optional. For example, the production for construct Conditional in an Eiffel grammar may read:</P>

		<CODE>Conditional [=] if Then_part_list [Else_part] end</CODE>

		<P>This means that a specimen of Conditional (a conditional instruction) is made of the keyword <SPAN CLASS="ekeyword">if</SPAN>, followed by a specimen of Then_part_list, followed by zero or one specimen of Else_part (the square brackets represent an optional component), followed by the keyword <SPAN CLASS="ekeyword">end</SPAN>.</P>

		<P CLASS="note"><B>Note</B>: this notation for productions uses conventions similar to those of the book <A HREF="http://eiffel.com/doc/documentation.html#etl">Eiffel: The Language</A>. Keywords are written in <I><B>boldface italics</B></I> and stand for themselves. Special symbols, such as the semicolon, are written in double quotes, as in ";". The [=] symbol means "is defined as" and is more accurate mathematically than plain =, which, however, is often used for this purpose (see <A HREF="http://eiffel.com/doc/documentation.html#itpl">Introduction to the Theory of Programming Languages, Prentice Hall, 1991</A>, for a more complete discussion of this issue).</P>

		<P>A choice production defines a construct whose specimens are specimens of one among a number of specified constructs. For example, the production for construct Type 	in an Eiffel grammar may read:</P>

		<CODE>Type [=] Class_type | Class_type_expanded | Formal_generic_name | Anchored | Bit_type</CODE>

		<P>This means that a specimen of Type is either a specimen of Class_type, or a specimen of Class_type_expanded etc.</P>

		<P>Finally, a repetition production defines a construct whose specimens are sequences of zero or more specimens of a given construct (called the <B>base</B> of the repetition construct), separated from each other by a <B>separator</B>. For example, the production for construct Compound in an Eiffel grammar may read</P>

		<CODE>Compound [=] {Instruction ";" ...}</CODE>

		<P>This means that a specimen of Compound is made of zero or more specimens of Instruction, each separated from the next (if any) by a semicolon.</P>

		<P>These three mechanisms - aggregate, choice and repetition - suffice to describe the structure of a wide array of practical languages. Properties which cannot be handled by them should be dealt with through <B>semantic actions</B>, as explained below.</P>

		<H3>An example grammar</H3>

		<P>The example directory included in the delivery implements a processor for a grammar describing a simple language for expressing polynomials. A typical "document" in this language is the line</P>

		<P>x; y: x * (y + 8 - (2 * x))</P>

		<P>The beginning of the line, separated from the rest by a colon, is the list of variables used in the polynomial, separated by semicolons. The rest of the line is the expression defining the polynomial.</P>

		<P>Using the conventions defined above, the grammar may be written as:</P>

		<CODE><PRE>Line       [=] Variables ":" Sum
Variables  [=] {Identifier ";" ...}
Sum        [=] {Diff "+" ...}
Diff       [=] {Product "-" ...}
Product    [=] {Term " * " ...}
Term       [=] Simple_var Int_constant Nested
Nested     [=] "(" Sum ")"</PRE></CODE>

		<P>This grammar assumes a terminal Identifier, which must be defined as a token type in the lexical grammar. The other terminals are keywords, shown as strings appearing in double quotes, for example "+".</P>

		<H2>PARSING CONCEPTS</H2>

		<P>The Parse library supports a parsing mechanism based on the concepts of object-oriented software construction.</P>

		<H3>Class CONSTRUCT</H3>

		<P>The deferred class CONSTRUCT describes the general notion of construct; instances of this class and its descendants are specimens of the constructs of a grammar.</P>

		<P>Deferred though it may be, CONSTRUCT defines some useful general patterns; for example, its procedure <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_process">process</A> appears as:<BR>

		<CODE>
		<A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_parse">parse</A><BR>
		<SPAN CLASS="ekeyword">if</SPAN> <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_parsed">parsed</A> <SPAN CLASS="ekeyword">then</SPAN><BR>
		&nbsp; &nbsp; &nbsp;<A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_semantics">semantics</A><BR>
		<SPAN CLASS="ekeyword">end</SPAN><BR>
		</CODE><BR>

		where procedures <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_parse">parse</A> and <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_semantics">semantics</A> are expressed in terms of some more specific procedures, which are deferred. This defines a general scheme while leaving the details to descendants of the class.</P>

		<P>Such descendants, given in the library, are classes AGGREGATE, CHOICE, REPETITION and TERMINAL. They describe the corresponding types of construct, with features providing the operations for parsing their specimens and applying the associated semantic actions.</P>

		<H3>Building a processor</H3>

		<P>To build a processor for a given grammar, you write a class, called a <B>construct class</B>, for every construct of the grammar, terminal or non-terminal. The class should inherit from AGGREGATE, CHOICE, REPETITION or TERMINAL depending on the nature of the construct. It describes the production for the construct and any associated semantic actions.</P>

		<P>To complete the processor, you must choose a "top construct" for that particular processor, and write a root class. In accordance with the object-oriented method, which implies that "roots" and "tops" should be chosen last, these steps are explained at the end of this chapter.</P>

		<P>The next sections explain how to write construct classes, how to handle semantics, and how to interface parsing with the lexical analysis process. All these tasks rely on a fundamental data abstraction, the notion of <B>abstract syntax tree</B>.</P>

		<H3>Abstract syntax trees</H3>

		<P>The effect of processing a document with a processor built from a combination of
		construct classes is to build an abstract syntax tree for that document, and to apply any
		requested semantic actions to that tree.</P>

		<P>The syntax tree is said to be abstract because it only includes important structural information and does not retain the concrete information such as keywords and separators. Such concrete information, sometimes called "syntactic sugar", serves only external purposes but is of no use for semantic processing.</P>

		<P>The combination of Eiffel techniques and libraries yields a very simple approach to building and processing abstract syntax trees. Class CONSTRUCT is a descendant of the Data Structure Library class <A CLASS="eclass" HREF="/libraries/base/reference/structures/tree/two_way_tree_chart.html">TWO_WAY_TREE</A>, describing a versatile implementation of trees; so, as a consequence, are CONSTRUCT’s own descendants. The effect of parsing any specimen of a construct is therefore to create an instance of the corresponding construct class. This instance is (among other things) a tree node, and is automatically inserted at its right place in the abstract syntax tree.</P>

		<P>As noted in the discussion of trees, class <A CLASS="eclass" HREF="/libraries/base/reference/structures/tree/two_way_tree_chart.html">TWO_WAY_TREE</A> makes no formal distinction between the notions of tree and tree node. So you may identify the abstract syntax tree with the object (instance of CONSTRUCT) representing the topmost construct specimen in the structure of the document being analyzed.</P>

		<H3>The production function</H3>

		<P>A construct class describes the syntax of a given construct through a function called
		<A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_production">production</A>, which is a direct representation of the corresponding production. This function is declared in CONSTRUCT as</P>

		<CODE>
		<A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_production">production</A><SPAN CLASS="esymbol">:</SPAN> <A CLASS="eclass" HREF="/libraries/base/reference/structures/list/linked_list_chart.html">LINKED_LIST</A> <SPAN CLASS="esymbol">[</SPAN><A CLASS="eclass" HREF="/libraries/lex/reference/parse/construct_chart.html">CONSTRUCT</A><SPAN CLASS="esymbol">]</SPAN> <SPAN CLASS="ekeyword">is</SPAN><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<SPAN CLASS="ecomment">-- Right-hand side of the production for the construct</SPAN><BR>
		&nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">deferred</SPAN><BR>
		&nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">end</SPAN></A><BR>
		</CODE>

		<P>Function <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_production">production</A> remains deferred in classes AGGREGATE, CHOICE and REPETITION. Every effective construct class that you write must provide an effecting of that function. It is important for the efficiency of the parsing process that every effective version of <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_production">production</A> be a Once function. Several examples of such effectings are given below.</P>

		<P>Classes AGGREGATE, CHOICE, REPETITION and TERMINAL also have a deferred function <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_construct_name">construct_name</A> of type STRING, useful for tracing and debugging. This function should be effected in every construct class to return the string name of the construct, such as "INSTRUCTION" or "CLASS" for construct classes in a grammar of
		Eiffel. For efficiency reasons, the <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_construct_name">construct_name</A> function should also be a Once function. The form of such a function will always be the same, as illustrated by the following example which may appear in the construct class INSTRUCTION in a processor for Eiffel:</P>

		<CODE>
		<A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_construct_name">construct_name</A><SPAN CLASS="esymbol">:</SPAN> <A CLASS="eclass" HREF="/libraries/base/reference/kernel/string_chart.html">STRING</A> <SPAN CLASS="ekeyword">is</SPAN><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="ecomment">-- Symbolic name of the construct</SPAN><BR>
		&nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">once</SPAN><BR>

		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="ereserved">Result</SPAN> <SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="estring">"INSTRUCTION"</SPAN><BR>

		&nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">end</SPAN><BR>
		</CODE>

		<P>The examples of the next few sections, which explain how to write construct classes, are borrowed from the small "Polynomial" language mentioned above, which may be found in the examples directory in the ISE Eiffel delivery.

		<H2>PREPARING GRAMMARS</H2>

		<P>Having studied the Parse library principles, let us see how to write grammar productions for various kinds of construct. The main task is to write the <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_production">production</A> function for each construct class.</P>

		<P>The <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_production">production</A> function for a descendant of AGGREGATE will describe how to build a 	specimen of the corresponding function from a sequence of specimens of each of the constituent constructs. Writing this function from the corresponding production is straightforward.</P>

		<P>As an example, consider the production function of class LINE for the Polynomial example language. The corresponding production is<BR>

		<CODE>Line [=] Variables ":" Sum</CODE><BR>

		where Variables and Sum are other constructs, and the colon ":" is a terminal. This means that every specimen of Line consists of a specimen of Variables, followed by a colon, followed by a specimen of Sum.</P>

		<P>Here is the corresponding production function as it appears in class LINE:</P>

		<CODE>
		<A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_production">production</A><SPAN CLASS="esymbol">:</SPAN> <A CLASS="eclass" HREF="/libraries/base/reference/structures/list/linked_list_chart.html">LINKED_LIST</A> <SPAN CLASS="esymbol">[</SPAN><A CLASS="eclass" HREF="/libraries/lex/reference/parse/construct_chart.html">CONSTRUCT</A><SPAN CLASS="esymbol">]</SPAN> <SPAN CLASS="ekeyword">is</SPAN><BR>
		&nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">local</SPAN><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="elocal">var</SPAN><SPAN CLASS="esymbol">:</SPAN> <SPAN CLASS="eclass">VARIABLES</SPAN><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="elocal">sum</SPAN><SPAN CLASS="esymbol">:</SPAN> <SPAN CLASS="eclass">SUM</SPAN><BR>
		&nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">once</SPAN><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="ereserved">Result</SPAN><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">var</SPAN><SPAN CLASS="esymbol">;</SPAN> <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_put">put</A> <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">var</SPAN><SPAN CLASS="esymbol">)</SPAN><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_keyword">keyword</A> <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="estring">":"</SPAN><SPAN CLASS="esymbol">)</SPAN><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">sum</SPAN><SPAN CLASS="esymbol">;</SPAN> <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_put">put</A> <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">sum</SPAN><SPAN CLASS="esymbol">)</SPAN><BR>
		&nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">end</SPAN></A><BR>
		</CODE>

		<P>As shown by this example, the <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_production">production</A> function for an aggregate construct class should declare a local entity (here <SPAN CLASS="elocal">var</SPAN> and <SPAN CLASS="elocal">sum</SPAN>) for each non-keyword component of the right-hand side, the type of each entity being the corresponding construct class (here <SPAN CLASS="eclass">VARIABLES</SPAN> and <SPAN CLASS="eclass">SUM</SPAN>).</P>

		<P>The body of the function should begin with<BR>

		<CODE>
		<SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="ereserved">Result</SPAN>
		</CODE><BR>

		to create the object containing the result. Then for each non-keyword component, represented by the local entity <SPAN CLASS="elocal">component</SPAN> (this applies to <SPAN CLASS="elocal">var</SPAN> and <SPAN CLASS="elocal">sum</SPAN> in the example), there should be a sequence of two instructions, of the form</P>

		<CODE>
		<SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">component</SPAN><SPAN CLASS="esymbol">;</SPAN> <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_put">put</A> <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">component</SPAN><SPAN CLASS="esymbol">)</SPAN>
		</CODE>

		<P>For any keyword of associated string <I>symbol</I>, such as the colon ":" in the example,
		there should be a call to

		<CODE>
		<A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_keyword">keyword</A> <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">symbol</SPAN><SPAN CLASS="esymbol">)</SPAN>
		</CODE>

		<P>The order of the various calls to <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_put">put</A> (for non-keywords) and <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_keyword">keyword</A> (for keywords) must be the order of the components in the production. Also, every
		<SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">component</SPAN> instruction must occur before the corresponding call to <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_put">put</A> <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">symbol</SPAN><SPAN CLASS="esymbol">)</SPAN>.</P>

		<P>All components in the above example are required. In the general case an aggregate production may have optional components. To signal that a component component of the right-hand side is optional, include a call of the form</P>

		<CODE><SPAN CLASS="elocal">component</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_set_optional">set_optional</A>
		</CODE>

		<P>This call may appear anywhere after the corresponding <SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">component</SPAN> instruction. The recommended place is just after the call to put and on the same line, as in</P>

		<CODE>
		<SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">component</SPAN><SPAN CLASS="esymbol">;</SPAN>
		<A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_put">put</A> <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">symbol</SPAN><SPAN CLASS="esymbol">)</SPAN><SPAN CLASS="esymbol">;</SPAN>
		<SPAN CLASS="elocal">component</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_set_optional">set_optional</A>
		</CODE>

		<H3>Choices</H3>

		<P>The <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_production">production</A> function for a descendant of CHOICE will describe how to build a specimen of the corresponding function as a specimen of one of the alternative constructs.</P>

		<P>As an example, consider the production function of class <A CLASS="eclass" HREF="/libraries/lex/samples/process/term_chart.html">TERM</A> for the Polynomial example language. The corresponding production is<BR>

		<CODE>Term [=] Simple_var Poly_integer Nested</CODE><BR>

		where Simple_var, Poly_integer and Nested are other constructs. This means that every specimen of Term consists of one specimen of any one of these three constructs. Here is the corresponding production function as it appears in class TERM:

		<CODE>
		<A CLASS="efeature" HREF="/libraries/lex/samples/process/term.html#f_production">production</A><SPAN CLASS="esymbol">:</SPAN> <A CLASS="eclass" HREF="/libraries/base/reference/structures/list/linked_list_chart.html">LINKED_LIST</A> <SPAN CLASS="esymbol">[</SPAN><A CLASS="eclass" HREF="/libraries/lex/reference/parse/construct_chart.html">CONSTRUCT</A><SPAN CLASS="esymbol">]</SPAN> <SPAN CLASS="ekeyword">is</SPAN><BR>
		&nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">local</SPAN><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="elocal">id</SPAN><SPAN CLASS="esymbol">:</SPAN> <A CLASS="eclass" HREF="/libraries/lex/samples/process/simple_var_chart.html">SIMPLE_VAR</A><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="elocal">val</SPAN><SPAN CLASS="esymbol">:</SPAN> <A CLASS="eclass" HREF="/libraries/lex/samples/process/poly_integer_chart.html">POLY_INTEGER</A><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="elocal">nest</SPAN><SPAN CLASS="esymbol">:</SPAN> <A CLASS="eclass" HREF="/libraries/lex/samples/process/nested_chart.html">NESTED</A><BR>
		&nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">once</SPAN><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="ereserved">Result</SPAN><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">id</SPAN><SPAN CLASS="esymbol">;</SPAN> <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_put">put</A> <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">id</SPAN><SPAN CLASS="esymbol">)</SPAN><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">val</SPAN><SPAN CLASS="esymbol">;</SPAN> <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_put">put</A> <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">val</SPAN><SPAN CLASS="esymbol">)</SPAN><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">nest</SPAN><SPAN CLASS="esymbol">;</SPAN> <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_put">put</A> <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">nest</SPAN><SPAN CLASS="esymbol">)</SPAN><BR>
		&nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">end</SPAN></A><BR>
		</CODE>

		<P>As shown by this example, the production function for a choice construct class must declare a local entity - here <SPAN CLASS="elocal">id</SPAN>, <SPAN CLASS="elocal">val</SPAN> and <SPAN CLASS="elocal">nest</SPAN> - for each alternative component of the right-hand side. The type of each entity is the corresponding construct class - here <A CLASS="eclass" HREF="/libraries/lex/samples/process/simple_var_chart.html">SIMPLE_VAR</A>, <A CLASS="eclass" HREF="/libraries/lex/samples/process/poly_integer_chart.html">POLY_INTEGER</A> and <A CLASS="eclass" HREF="/libraries/lex/samples/process/nested_chart.html">NESTED</A>.</P>

		<P>The body of the function must begin by</P>

		<CODE>
		<SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="ereserved">Result</SPAN>
		</CODE>

		<P>Then for each alternative component represented by a local entity component (in the example this applies to <SPAN CLASS="elocal">id</SPAN>, <SPAN CLASS="elocal">val</SPAN> and <SPAN CLASS="elocal">nest</SPAN>) there should be two instructions of the form</P>


		<CODE>
		<SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">component</SPAN><SPAN CLASS="esymbol">;</SPAN> <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_put">put</A> <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">component</SPAN><SPAN CLASS="esymbol">)</SPAN>
		</CODE>

		<P CLASS="note"><B>Caution</B>: the order of the various calls to <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_put">put</A> is irrelevant in principle. When a document is parsed, however, the choices will be tried in the order given; so if you know that certain
		choices occur more frequently than others it is preferable to list them first to speed up the parsing process.</P>

		<H3>Repetitions</H3>

		<P>The <A CLASS="efeature" HREF="/libraries/lex/samples/process/term.html#f_production">production</A> function for a descendant of REPETITION will describe how to build a specimen of the corresponding function as a sequence or zero or more (or, depending on the grammar, one or more) specimens of the base construct. The class must also effect a feature <A CLASS="efeature" HREF="/libraries/lex/samples/process/variables.html#f_separator">separator</A> of type <A CLASS="eclass" HREF="/libraries/base/reference/kernel/string_chart.html">STRING</A>, usually as a constant attribute. (This feature is introduced as deferred in class REPETITION.)</P>

		<P>As an example, consider the construct Variables in the Polynomial example language. The right-hand side of the corresponding production is<BR>

		<CODE>Variables [=] {Identifier ";" ...}</CODE><BR>

		where Identifier is another construct, and the semicolon ";" is a terminal. This means that every specimen of Variables consists of zero or more specimens of Identifier, separated from each other (if more than one) by semicolons.</P>

		<P>Here are the corresponding <A CLASS="efeature" HREF="/libraries/lex/samples/process/variables.html#f_production">production</A> function and <A CLASS="efeature" HREF="/libraries/lex/samples/process/variables.html#f_separator">separator</A> attribute as they appear in class <A CLASS="eclass" HREF="/libraries/lex/samples/process/variables_chart.html">VARIABLES</A>:</P>

		<CODE>
		<A CLASS="efeature" HREF="/libraries/lex/samples/process/variables.html#f_production">production</A><SPAN CLASS="esymbol">:</SPAN> <A CLASS="eclass" HREF="/libraries/base/reference/structures/list/linked_list_chart.html">LINKED_LIST</A> <SPAN CLASS="esymbol">[</SPAN><A CLASS="eclass" HREF="/libraries/lex/reference/parse/construct_chart.html">CONSTRUCT</A><SPAN CLASS="esymbol">]</SPAN> <SPAN CLASS="ekeyword">is</SPAN><BR>
		&nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">local</SPAN><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="elocal">base</SPAN><SPAN CLASS="esymbol">:</SPAN> <A CLASS="eclass" HREF="/libraries/lex/samples/process/var_chart.html">IDENTIFIER</A><BR>
		&nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">once</SPAN><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="ereserved">Result</SPAN><BR>
		&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">base</SPAN><SPAN CLASS="esymbol">;</SPAN> <A CLASS="efeature" HREF="/libraries/lex/reference/parse/construct.html#f_put">put</A> <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">base</SPAN><SPAN CLASS="esymbol">)</SPAN><BR>
		&nbsp; &nbsp; &nbsp; <SPAN CLASS="ekeyword">end</SPAN></A><BR>
		<BR>
		<A CLASS="efeature" HREF="/libraries/lex/samples/process/variables.html#f_separator">separator</A><SPAN CLASS="esymbol">:</SPAN> <A CLASS="eclass" HREF="/libraries/base/reference/kernel/string_chart.html">STRING</A> <SPAN CLASS="ekeyword">is</SPAN> <SPAN CLASS="estring">";"</SPAN>
		</CODE>

		<P>As shown by this example, function <A CLASS="efeature" HREF="/libraries/lex/samples/process/variables.html#f_production">production</A> is built along the same ideas as for aggregates and choices, except that here only one component, <SPAN CLASS="elocal">base</SPAN>, is required; its type must be the class corresponding to the construct serving as the base of the repetition, <A CLASS="eclass" HREF="/libraries/lex/samples/process/var_chart.html">IDENTIFIER</A> in the example.</P>

		<H2>INTERFACE TO LEXICAL ANALYSIS</H2>

		<P>One more type of construct class remains to be discussed: terminal construct classes. Since terminal constructs serve to elevate lexical tokens (regular expressions and keywords) to the dignity of syntactical construct, we must first take a look at how the Parse library classes collaborate with their counterparts in the Lex library.</P>

		<H3>The notion of lexical interface class</H3>

		<P>To parse a document, you need to get tokens from a lexical analyzer. This is achieved by making some construct classes, in particular those describing terminals, descendants of one of the lexical classes.</P>

		<P>The best technique is usually to write a class covering the lexical needs of the language at hand, from which all construct classes that have some lexical business will inherit. Such a class is called a lexical interface class.</P>

		<P>Lexical interface classes usually follow a common pattern. To take advantage of this uniformity, the Parse library includes a deferred class L_INTERFACE which describes that pattern. Specific lexical interface classes may be written as descendants of L_INTERFACE.</P>

		<P>L_INTERFACE is a simple deferred class, with a deferred procedure <A CLASS="efeature" HREF="/libraries/lex/reference/parse/l_interface.html#f_obtain_analyzer">obtain_analyzer</A>. It is an heir of <A CLASS="eclass" HREF="/libraries/lex/reference/lex/metalex_chart.html">METALEX</A>.

		<H3>Obtaining a lexical analyzer</H3>

		<P>An effective descendant of L_INTERFACE must define procedure obtain_analyzer so that it records into the lexical analyzer the regular expressions and keywords of the language at hand. In writing <A CLASS="efeature" HREF="/libraries/lex/reference/parse/l_interface.html#f_obtain_analyzer">obtain_analyzer</A> you may use any one of three different techniques, each of which may be the most convenient depending on the precise context, to obtain the required lexical analyzer:

		<UL>
			<LI>You may build the lexical analyzer by defining its regular expressions one by one, using the procedures described in the presentation of <A CLASS="eclass" HREF="/libraries/lex/reference/lex/metalex_chart.html">METALEX</A>, in particular <A CLASS="efeature" HREF="/libraries/lex/reference/lex/metalex.html#f_put_expression">put_expression</A> and <A CLASS="efeature" HREF="/libraries/lex/reference/lex/lex_builder.html#f_put_keyword">put_keyword</A>.</LI>
			<LI>You may use use procedure <A CLASS="efeature" HREF="/libraries/lex/reference/lex/lex_builder.html#f_retrieve_analyzer">retrieve_analyzer</A> from <A CLASS="eclass" HREF="/libraries/lex/reference/lex/metalex_chart.html">METALEX</A> to retrieve an analyzer which a previous session saved into a file.</LI>
			<LI>Finally, you may write a lexical grammar file (or reuse an existing one) and process it on the spot by using procedure <A CLASS="efeature" HREF="/libraries/lex/reference/lex/metalex.html#f_read_grammar">read_grammar</A> from <A CLASS="eclass" HREF="/libraries/lex/reference/lex/metalex_chart.html">METALEX</A>.</LI>
		</UL></P>

		<H3>A lexical interface class</H3>

		<P>An example of lexical interface class is POLY_LEX for the Polynomial example language. Here is the complete text of that class:
	</BODY>
</HTML>
