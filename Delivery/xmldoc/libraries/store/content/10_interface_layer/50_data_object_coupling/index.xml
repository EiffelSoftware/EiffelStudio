<document output="studio" title="Data Object Coupling">
	<meta_data></meta_data>
	<paragraph>
		<paragraph>A smart way to work with relational databases is to have Eiffel objects directly mapping relational tables. Three EiffelStore classes enable this coupling:</paragraph>
		<list ordered="false">
			<item><link><url>/libraries/store/reference/interface/db_repository_flatshort.xml</url><label>DB_REPOSITORY</label></link> objects 
				<link>
					<anchor_name>describe</anchor_name>
					<label>describe a relational table</label>
				</link> and allow Eiffel to create objects mapping database tables.
			</item>
			<item><link><url>/libraries/store/reference/interface/db_store_flatshort.xml</url><label>DB_STORE</label></link> works directly with <link><url>/libraries/store/reference/interface/db_repository_flatshort.xml</url><label>DB_REPOSITORY</label></link> objects to <link>
					<anchor_name>insert</anchor_name>
					<label>insert data into relational tables</label>
				</link>.
			</item>
			<item><link><url>/libraries/store/reference/interface/db_selection_flatshort.xml</url><label>DB_SELECTION</label></link> can 
				<link>
					<anchor_name>map</anchor_name>
					<label>map a database query result into Eiffel objects</label>
				</link>. 
			</item>
		</list>
		<heading>
			<size>2</size>Describing relational tables with DB_REPOSITORY
		</heading>
		<paragraph>A <link><url>/libraries/store/reference/interface/db_repository_flatshort.xml</url><label>DB_REPOSITORY</label></link> object stores available information about a table. To access this information, you mainly have to give the table name and load the table description:</paragraph>
<code_block>
	<feature_name>repository</feature_name><symbol>:</symbol> <class_name>DB_REPOSITORY</class_name>
	...
	<keyword>create</keyword> <feature_name>repository</feature_name>.<feature_name>make</feature_name> <symbol>(</symbol>"<class_name>CONTACTS</class_name>"<symbol>)</symbol>
	<feature_name>repository</feature_name>.<feature_name>load</feature_name>
	<keyword>if</keyword> <feature_name>repository</feature_name>.<feature_name>exists</feature_name> <keyword>then</keyword>
		...
	<keyword>end</keyword>
</code_block>
		<tip>
			<bold>Tip</bold>: Loading a table description is often a costly operation: table has to be fetched among existing tables then every table column description must be loaded. Hence it is better to store and reuse a repository (maybe with a HASH_TABLE) once it has been loaded.
		</tip>
		<paragraph>Using the table information, <link><url>/libraries/store/reference/interface/db_repository_flatshort.xml</url><label>DB_REPOSITORY</label></link> then helps generating Eiffel classes mapping relational tables: </paragraph>
		<list ordered="false">
			<item>You can directly use {<link><url>/libraries/store/reference/interface/db_repository_flatshort.xml</url><label>DB_REPOSITORY</label></link>}.generate_class. Generated class may look like:
<code_block>
	<keyword>class</keyword> <class_name>CONTACTS</class_name>

	<keyword>feature</keyword><string> -- Access</string>

	<feature_name>id</feature_name><symbol>:</symbol> <class_name>INTEGER</class_name>
	...
	<keyword>feature</keyword><string> -- Settings</string>

	<feature_name>set_id</feature_name> <symbol>(</symbol><local_variable>an_id</local_variable><symbol>:</symbol> <class_name>INTEGER</class_name><symbol>)</symbol> <keyword>is</keyword>
			<comment>-- Set an_id to id.</comment>
		<keyword>do</keyword>
			<feature_name>id</feature_name> <symbol>:</symbol><symbol>=</symbol> <local_variable>an_id</local_variable>
		<keyword>end</keyword>
	...
</code_block>
				<note>
					<bold>Note</bold>: The EiffelStore Wizard uses the generation.generator cluster to generate the classes mapped to your database.
				</note>
			</item>
		</list>
		<heading>
			<size>2</size>Inserting data in the database
		</heading>
		<paragraph><link><url>/libraries/store/reference/interface/db_store_flatshort.xml</url><label>DB_STORE</label></link> lets you easily insert rows into a table using: 
			<list ordered="false">
				<item>the table description provided by <link><url>/libraries/store/reference/interface/db_repository_flatshort.xml</url><label>DB_REPOSITORY</label></link>.</item>
				<item>a class mapping the relational table. </item>
			</list> This is straight-forward since you only have to give <link><url>/libraries/store/reference/interface/db_store_flatshort.xml</url><label>DB_STORE</label></link> the object filled with the table values. Suppose you want to add a contact into your database:
		</paragraph>
<code_block>
	<feature_name>storage</feature_name><symbol>:</symbol> <class_name>DB_STORE</class_name>
	<feature_name>contacts_rep</feature_name><symbol>:</symbol> <class_name>DB_REPOSITORY</class_name>
	<feature_name>a_contact</feature_name><symbol>:</symbol> <class_name>CONTACTS</class_name>
	...
	<keyword>create</keyword> <feature_name>storage</feature_name>.<feature_name>make</feature_name>
		<comment>-- contacts_rep is loaded and exists.</comment>
	<feature_name>storage</feature_name>.<feature_name>set_repository</feature_name> <symbol>(</symbol><feature_name>contacts_rep</feature_name><symbol>)</symbol>
		<comment>-- a_contact carries values to insert into the database.</comment>
	<feature_name>storage</feature_name>.<feature_name>put</feature_name> <symbol>(</symbol><feature_name>a_contact</feature_name><symbol>)</symbol>
</code_block>
		<heading>
			<size>2</size>Accessing database content with Eiffel objects
		</heading>
		<paragraph><link><url>/libraries/store/reference/interface/db_selection_flatshort.xml</url><label>DB_SELECTION</label></link> lets you map data retrieved from the database into Eiffel objects: Result column names must match object attributes names so you can use for instance classes created by <link><url>/libraries/store/reference/interface/db_repository_flatshort.xml</url><label>DB_REPOSITORY</label></link>. Class <code><class_name>DB_ACTION</class_name></code> redefines ACTION and can be used to retrieve Eiffel objects directly into an ARRAYED_LIST:</paragraph>
<code_block>
	<feature_name>selection</feature_name><symbol>:</symbol> <class_name>DB_SELECTION</class_name>
	<feature_name>list_filling</feature_name><symbol>:</symbol> <class_name>DB_ACTION</class_name> <symbol>[</symbol><class_name>CONTACTS</class_name><symbol>]</symbol>
	<feature_name>contact</feature_name><symbol>:</symbol> <class_name>CONTACTS</class_name>
	...
	<feature_name>selection</feature_name>.<feature_name>object_convert</feature_name> <symbol>(</symbol><feature_name>contact</feature_name><symbol>)</symbol>
	<keyword>create</keyword> <feature_name>list_filling</feature_name>.<feature_name>make</feature_name> <symbol>(</symbol><feature_name>selection, contact</feature_name><symbol>)</symbol>
	<feature_name>selection</feature_name>.<feature_name>set_action</feature_name> <symbol>(</symbol><feature_name>list_filling</feature_name><symbol>)</symbol>
	...
	<feature_name>selection</feature_name>.<feature_name>load_result</feature_name>
	<keyword>if</keyword> <feature_name>selection</feature_name>.<feature_name>is_ok</feature_name> <keyword>then</keyword>
		<keyword>Result</keyword> <symbol>:</symbol><symbol>=</symbol> <feature_name>list_filling</feature_name>.<feature_name>list</feature_name>
	<keyword>end</keyword>
</code_block>
		<note>
			<bold>Note</bold>: You can see how actions are used in <link><url>/libraries/store/reference/interface/db_selection_flatshort.xml</url><label>DB_SELECTION</label></link>.
		</note>
		<line_break></line_break>
		<seealso>
			<bold>See Also</bold>
			<line_break></line_break>
			<link>
				<url>../30_database_selection/index.xml</url>
				<label>Performing a database selection.</label>
			</link>
			<line_break></line_break>
			<link>
				<url>../../30_data_structures_generation/10_data_structures_use/index.xml</url>
				<label>Database-specific structures use.</label>
			</link>
			<line_break></line_break>
		</seealso>
	</paragraph></document>
