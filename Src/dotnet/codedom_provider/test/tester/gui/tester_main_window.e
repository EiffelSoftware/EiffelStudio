indexing
	description: "Objects that represent an EV_TITLED_WINDOW.%
		%The original version of this class was generated by EiffelBuild."
	legal: "See notice at end of class."
	status: "See notice at end of class."
	date: "$Date$"
	revision: "$Revision$"

class
	TESTER_MAIN_WINDOW

inherit
	TESTER_MAIN_WINDOW_IMP
	
	TESTER_SAVED_SETTINGS
		export
			{NONE} all
		undefine
			default_create,
			copy
		end

	TESTER_SHARED_EVENT_MANAGER
		export
			{NONE} all
		undefine
			default_create,
			copy
		end

	TESTER_CODEDOM_TYPES
		export
			{NONE} all
		undefine
			default_create,
			copy
		end

	TESTER_SHARED_TREE_STORE
		export
			{NONE} all
		undefine
			default_create,
			copy
		end

	TESTER_CODE_OBJECT_ANALYZER
		export
			{NONE} all
		undefine
			default_create,
			copy
		end

feature {NONE} -- Initialization

	user_initialization is
			-- called by `initialize'.
			-- Any custom user initialization that
			-- could not be performed in `initialize',
			-- (due to regeneration of implementation class)
			-- can be added here.
		local
			l_config: CODE_MACHINE_CONFIGURATION
			l_string_list: LIST [STRING]
			l_assemblies: STRING
		do
			create codedoms_tree.make
			codedoms_tree.select_actions.extend (agent on_codedom_tree_select)
			codedoms_tree.deselect_actions.extend (agent on_codedom_tree_deselect)
			tree_bottom_split_area.set_first (codedoms_tree)
			tree_bottom_split_area.set_split_position (3000)
			Event_manager.set_output_displayer (agent display_output)
			make
			close_request_actions.extend (agent on_close)
			create l_config.make
			l_string_list := l_config.languages
			from
				l_string_list.start
			until
				l_string_list.after
			loop
				provider_combo_box.extend (create {EV_LIST_ITEM}.make_with_text (l_string_list.item))
				l_string_list.forth
			end
			provider_combo_box.set_text (text_setting (Codedom_provider_key))
			set_x_position (setting (X_key))
			set_y_position (setting (Y_key))
			set_width (setting (Width_key))
			set_height (setting (Height_key))
			generate_label.set_text (select_codedom_tree_label)
			referenced_assemblies_list.enable_multiple_selection
			indent_string_text_field.set_text (text_setting (Indent_string_Key))
			if saved_blank_lines then
				blank_lines_check_button.enable_select
			end
			if saved_else_at_closing then
				else_at_closing_check_button.enable_select
			end
			indent_string_text_field.set_text (text_setting (Indent_string_key))
			generation_path_text_field.set_text (text_setting (Generated_file_folder_key))
			generated_filename_text_field.set_text (text_setting (Generated_filename_key))
			identifier_text_field.set_text (text_setting (Identifier_key))
			type_text_field.set_text (text_setting (Type_key))
			source_filename_text_field.set_text (text_setting (Source_filename_key))
			source_text.set_text (text_setting (Source_key))
			if saved_generate_executable then
				generate_executable_check_button.enable_select
			end
			if saved_generate_in_memory then
				generate_in_memory_check_button.enable_select
			end
			if saved_include_debug then
				include_debug_check_button.enable_select
			end
			compiler_options_text_field.set_text (text_setting (Compiler_options_key))
			main_class_text_field.set_text (text_setting (Main_class_key))
			output_assembly_text_field.set_text (text_setting (Output_assembly_key))
			resource_text_field.set_text (text_setting (Resource_key))
			l_assemblies := text_setting (Referenced_assemblies_key)
			l_string_list := l_assemblies.split (';')
			from
				l_string_list.start
			until
				l_string_list.after
			loop
				if not l_string_list.item.is_empty then
					referenced_assemblies_list.extend (create {EV_LIST_ITEM}.make_with_text (l_string_list.item))
				end
				l_string_list.forth
			end
			parse_file_text_field.set_text (text_setting (Parsed_file_key))
			serialized_folder_text_field.set_text (text_setting (Saved_serialized_folder_key))
			output_text.append_text ("%N%N----------------------------------------------------------%N")
			output_text.append_text ("Tool started " + {SYSTEM_DATE_TIME}.now.to_string)
		end

feature -- Access

	codedoms_tree: TESTER_CODEDOM_TREE
			-- Codedoms tree

feature {NONE} -- Events

	on_provider_update is
			-- Update provider file extension and case sensitivity status.
		local
			l_analyzer: TESTER_CODEDOM_ANALYZER
		do
			create l_analyzer
			l_analyzer.analyze (provider_combo_box.text)
			if l_analyzer.analysis_successful then
				file_extension_label.set_text (l_analyzer.language_extension)
				case_sensitive_check_button.show
				if l_analyzer.is_case_sensitive then
					case_sensitive_check_button.enable_select
				else
					case_sensitive_check_button.disable_select
				end
				codedom_provider := l_analyzer.codedom_provider
				update_properties
			else
				file_extension_label.remove_text
				case_sensitive_check_button.hide
				codedom_provider := Void
				generate_button.disable_sensitive
				compile_from_dom_button.disable_sensitive
				compile_from_file_button.disable_sensitive
				compile_from_source_button.disable_sensitive
				parse_button.disable_sensitive
			end
		end
		
	on_generate_source is
			-- Called by `select_actions' of `generate_button'.
		local
			l_type: INTEGER
			l_generator: SYSTEM_DLL_ICODE_GENERATOR
			l_compile_unit: SYSTEM_DLL_CODE_COMPILE_UNIT
			l_namespace: SYSTEM_DLL_CODE_NAMESPACE
			l_type_type: SYSTEM_DLL_CODE_TYPE_DECLARATION
			l_expression: SYSTEM_DLL_CODE_EXPRESSION
			l_statement: SYSTEM_DLL_CODE_STATEMENT
			l_text_writer: STREAM_WRITER
			l_options: SYSTEM_DLL_CODE_GENERATOR_OPTIONS
			l_retried: BOOLEAN
			l_path: STRING
		do
			if not l_retried then
				analyze (codedoms_tree.selected_item.data)
				l_type := object_type
				l_generator := codedom_provider.create_generator
				create l_options.make
				l_options.set_blank_lines_between_members (blank_lines_check_button.is_selected)
				l_options.set_indent_string (indent_string_text_field.text)
				l_options.set_else_on_closing (else_at_closing_check_button.is_selected)
				create l_path.make (240)
				l_path.append (generation_path_text_field.text)
				if l_path.item (l_path.count) /= '\' then
					l_path.append_character ('\')
				end
				l_path.append (generated_filename_text_field.text)
				l_path.append (language_extension)
				create l_text_writer.make_from_path (l_path)
				inspect
					l_type
				when codedom_compile_unit_type then
					l_compile_unit ?= codedoms_tree.selected_item.data
					check
						has_data: l_compile_unit /= Void
					end
					l_generator.generate_code_from_compile_unit (l_compile_unit, l_text_writer, l_options)
				when codedom_namespace_type then
					l_namespace ?= codedoms_tree.selected_item.data
					check
						has_data: l_namespace /= Void
					end
					l_generator.generate_code_from_namespace (l_namespace, l_text_writer, l_options)
				when codedom_type_type then
					l_type_type ?= codedoms_tree.selected_item.data
					check
						has_data: l_type_type /= Void
					end
					l_generator.generate_code_from_type (l_type_type, l_text_writer, l_options)
				when codedom_expression_type then
					l_expression ?= codedoms_tree.selected_item.data
					check
						has_data: l_expression /= Void
					end
					l_generator.generate_code_from_expression (l_expression, l_text_writer, l_options)
				when codedom_statement_type then
					l_statement ?= codedoms_tree.selected_item.data
					check
						has_data: l_statement /= Void
					end
					l_generator.generate_code_from_statement (l_statement, l_text_writer, l_options)
				else
					Event_manager.raise_event (create {TESTER_EVENT}.make ("Cannot generate: Invalid codedom tree node.", True))
				end
				l_text_writer.flush
				l_text_writer.close
				Event_manager.raise_event (create {TESTER_EVENT}.make ("Code successfully generated in: " + l_path, False))
			end
		rescue
			l_retried := True
			Event_manager.raise_event (create {TESTER_EVENT}.make ("Error while generating source code: " + (create {EXCEPTIONS}).exception_trace, True))
			retry
		end
	
	on_compile_from_dom is
			-- Called by `select_actions' of `compile_from_dom_button'.
		local
			l_compiler: SYSTEM_DLL_ICODE_COMPILER
			l_compilation_unit: SYSTEM_DLL_CODE_COMPILE_UNIT
			l_results: SYSTEM_DLL_COMPILER_RESULTS
		do
			check
				non_void_codedom_provider: codedom_provider /= Void
			end
			l_compilation_unit ?= codedoms_tree.selected_item.data
			check
				has_data: l_compilation_unit /= Void
			end
			l_compiler := codedom_provider.create_compiler
			l_results := l_compiler.compile_assembly_from_dom (compiler_options, l_compilation_unit)
			display_compilation_results (l_results)
		end
	
	on_compile_from_file is
			-- Called by `select_actions' of `compile_from_file_button'.
		local
			l_compiler: SYSTEM_DLL_ICODE_COMPILER
			l_results: SYSTEM_DLL_COMPILER_RESULTS
		do
			check
				non_void_codedom_provider: codedom_provider /= Void
			end
			l_compiler := codedom_provider.create_compiler
			l_results := l_compiler.compile_assembly_from_file (compiler_options, source_filename_text_field.text)
			display_compilation_results (l_results)
		end
	
	on_compile_from_source is
			-- Called by `select_actions' of `compile_from_source_button'.
		local
			l_compiler: SYSTEM_DLL_ICODE_COMPILER
			l_results: SYSTEM_DLL_COMPILER_RESULTS
		do
			check
				non_void_codedom_provider: codedom_provider /= Void
			end
			l_compiler := codedom_provider.create_compiler
			l_results := l_compiler.compile_assembly_from_source (compiler_options, source_text.text)
			display_compilation_results (l_results)
		end
	
	on_parse is
			-- Called by `select_actions' of `parse_button'.
		local
			l_parser: SYSTEM_DLL_ICODE_PARSER
			l_text_reader: STREAM_READER
			l_compile_unit: SYSTEM_DLL_CODE_COMPILE_UNIT
			l_formatter: BINARY_FORMATTER
			l_stream: FILE_STREAM
			l_retried: BOOLEAN
		do
			if not l_retried then
				check
					non_void_codedom_provider: codedom_provider /= Void
				end
				l_parser := codedom_provider.create_parser
				create l_text_reader.make_from_path (parse_file_text_field.text)
				l_compile_unit := l_parser.parse (l_text_reader)
				create l_stream.make (serialized_folder_text_field.text + (create {OPERATING_ENVIRONMENT}).Directory_separator.out + serialized_filename_text_field.text + serialized_file_extension, {FILE_MODE}.Create_)
				create l_formatter.make
				l_formatter.serialize (l_stream, l_compile_unit)
				l_stream.close
			end
		rescue
			l_retried := True
			if l_stream /= Void then
				l_stream.close
			end
			Event_manager.raise_event (create {TESTER_EVENT}.make ("Could not parse file", True))
			retry
		end

	on_output_type_update is
			-- Update `Output Type' text field content.
		local
			l_generator: SYSTEM_DLL_ICODE_GENERATOR
			l_type: SYSTEM_DLL_CODE_TYPE_REFERENCE
		do
			if codedom_provider /= Void and not type_text_field.text.is_empty then
				l_generator := codedom_provider.create_generator
				create l_type.make_from_type_name (type_text_field.text)
				output_type_text_field.set_text (l_generator.get_type_output (l_type))
			else
				output_type_text_field.remove_text
			end
		end
	
	on_identifier_change is
			-- Update identifier test text fields.
		local
			l_generator: SYSTEM_DLL_ICODE_GENERATOR
			l_text: STRING
			l_retried: BOOLEAN
		do
			if not l_retried then
				if codedom_provider /= Void and not identifier_text_field.text.is_empty then
					l_generator := codedom_provider.create_generator
					l_text := l_generator.create_escaped_identifier (identifier_text_field.text)
					if l_text = Void then
						Event_manager.raise_event (create {TESTER_EVENT}.make ("CreateEscapedIdentifier returned Void!", False))
						escaped_identifier_text_field.remove_text
					else
						escaped_identifier_text_field.set_text (l_text)
					end
					l_text := l_generator.create_valid_identifier (identifier_text_field.text)
					if l_text = Void then
						Event_manager.raise_event (create {TESTER_EVENT}.make ("CreateValidIdentifier returned Void!", False))
						valid_identifier_text_field.remove_text
					else
						valid_identifier_text_field.set_text (l_text)
					end
					is_valid_identifier_text_field.set_text (l_generator.is_valid_identifier (identifier_text_field.text).out)
				end
			end
		rescue
			Event_manager.raise_event (create {TESTER_EVENT}.make ("The following exception occured:%N" + (create {EXCEPTIONS}).exception_trace, True))
			l_retried := True
			retry
		end
	
	on_add_codedom_tree is
			-- Add codedom tree to codedoms tree
		do
			browse_for_file ("Browse for serialized CodeDom tree...", Void, agent add_codedom_tree)
		end
	
	on_remove_codedom_tree is
			-- Add codedom tree to codedoms tree
		local
			l_selected: EV_TREE_NODE
		do
			l_selected := codedoms_tree.selected_item
			if l_selected /= Void then
				Store.remove (l_selected.tooltip)
				codedoms_tree.update
			end
		end

	on_codedom_tree_select is
			-- Called by `select_actions' of `codedom_trees'.
			-- Check kind of tree.
		local
			l_type: INTEGER
			l_object: ANY
		do
			l_object := codedoms_tree.selected_item.data
			if l_object /= Void then
				analyze (l_object)
				l_type := object_type
				inspect
					l_type
				when Codedom_compile_unit_type then
					generate_label.set_text (generate_compile_unit_label)
					compile_from_dom_button.enable_sensitive
					remove_button.enable_sensitive
				when Codedom_namespace_type then
					generate_label.set_text (generate_namespace_label)
					remove_button.enable_sensitive
					compile_from_dom_button.disable_sensitive
				when Codedom_type_type then
					generate_label.set_text (generate_type_label)
					remove_button.enable_sensitive
					compile_from_dom_button.disable_sensitive
				when Codedom_expression_type then
					generate_label.set_text (generate_expression_label)
					remove_button.enable_sensitive
					compile_from_dom_button.disable_sensitive
				when Codedom_statement_type then
					generate_label.set_text (generate_statement_label)
					remove_button.enable_sensitive
					compile_from_dom_button.disable_sensitive
				when Codedom_method_type then
					generate_label.set_text (select_codedom_tree_label)
					remove_button.disable_sensitive
					compile_from_dom_button.disable_sensitive
				when Codedom_property_type then
					generate_label.set_text (select_codedom_tree_label)
					remove_button.disable_sensitive
					compile_from_dom_button.disable_sensitive
				when Codedom_event_type then
					generate_label.set_text (select_codedom_tree_label)
					remove_button.disable_sensitive
					compile_from_dom_button.disable_sensitive
				when Codedom_field_type then
					generate_label.set_text (select_codedom_tree_label)
					remove_button.disable_sensitive
					compile_from_dom_button.disable_sensitive
				when Codedom_snippet_member_type then
					generate_label.set_text (select_codedom_tree_label)
					remove_button.disable_sensitive
					compile_from_dom_button.disable_sensitive
				else
					generate_label.set_text (select_codedom_tree_label)
					remove_button.disable_sensitive
					compile_from_dom_button.disable_sensitive
				end
				check_can_generate
				codedom_node_info_text.set_text (description)
			else
				generate_label.set_text (select_codedom_tree_label)
				remove_button.disable_sensitive
				compile_from_dom_button.disable_sensitive
			end
		end
	
	on_codedom_tree_deselect is
			-- Called by `deselect_actions' of `codedoms_tree'.
		do
			if codedoms_tree.selected_item = Void then
				generate_label.set_text (select_codedom_tree_label)
				remove_button.disable_sensitive
			end
		end

	on_browse_generated_file_folder is
			-- Called by `select_actions' of `browse_button'.
		do
			browse_for_directory ("Browse for destination folder...", Generated_file_folder_key, agent generation_path_text_field.set_text)
		end

	on_browse_source is
			-- Called by `select_actions' of `browse_source_button'.
			-- Show browse dialog, put result in text field.
		do
			browse_for_file ("Browse for Source file...", "*" + language_extension, agent source_filename_text_field.set_text)
		end

	on_source_file_name_change is
			-- Called by `change_actions' of `source_filename_text_field'.
			-- Check text field entry and enable `Compile' button if OK.
		do
			if {SYSTEM_FILE}.exists (source_filename_text_field.text) then
				source_filename_text_field.set_foreground_color (Black)
				if not compile_from_file_button.is_sensitive then
					compile_from_file_button.enable_sensitive
				end
			else
				source_filename_text_field.set_foreground_color (Red)
				if compile_from_file_button.is_sensitive then
					compile_from_file_button.disable_sensitive
				end
			end
		end

	on_source_change is
			-- Called by `change_actions' of `source_text'.
			-- Check source text and enable `Compile' button if OK.
		do
			if source_text.text.is_empty then
				compile_from_source_button.disable_sensitive
			else
				compile_from_source_button.enable_sensitive
			end
		end

	on_referenced_assembly_select is
			-- Enable `Remove' button if necessary.
		do
			if not remove_button.is_sensitive then
				remove_button.enable_sensitive
				new_reference_text_field.set_text (referenced_assemblies_list.selected_item.text)
			end
		end
		
	on_referenced_assembly_deselect is
			-- Disable `Remove' button if necessary.
		do
			if referenced_assemblies_list.selected_items.count = 0 then
				remove_button.disable_sensitive
				new_reference_text_field.remove_text
			else
				new_reference_text_field.set_text (referenced_assemblies_list.selected_item.text)
			end
		end
	
	on_browse_new_reference is
			-- Called by `select_actions' of `new_reference_browse_button'.
			-- Popup file browse dialog and update `ew_reference_text_field' accordingly.
		do
			browse_for_file ("Browse for assembly...", "*.dll", agent new_reference_text_field.set_text)
		end
		
	on_new_reference_change is
			-- Enable `Add' reference button if text field not empty.
		do
			if new_reference_text_field.text.is_empty then
				if referenced_assemblies_add_button.is_sensitive then
					referenced_assemblies_add_button.disable_sensitive
				end
			else
				if {SYSTEM_FILE}.exists (new_reference_text_field.text) then
					new_reference_text_field.set_foreground_color (Black)
					if not referenced_assemblies_add_button.is_sensitive then
						referenced_assemblies_add_button.enable_sensitive
					end
				else
					new_reference_text_field.set_foreground_color (Red)
				end
			end
		end
		
	on_add_referenced_assembly is
			-- Called by `select_actions' of `referenced_assemblies_add_button'.
		do
			referenced_assemblies_list.extend (create {EV_LIST_ITEM}.make_with_text (new_reference_text_field.text))
			new_reference_text_field.remove_text
		end
	
	on_remove_referenced_assembly is
			-- Called by `select_actions' of `referenced_assemblies_remove_button'.
		local
			l_selected_items: LIST [EV_LIST_ITEM]
		do
			l_selected_items := referenced_assemblies_list.selected_items
			from
				l_selected_items.start
			until
				l_selected_items.after
			loop
				referenced_assemblies_list.prune (l_selected_items.item)
				l_selected_items.forth
			end
		end
	
	on_browse_for_resource is
			-- Called by `select_actions' of `resource_browse_button'.
		do
			browse_for_file ("Browse for resource...", "*.res", agent resource_text_field.set_text)
		end
	
	on_browse_parse_file is
			-- Called by `select_actions' of `parse_file_browse_button'.
		do
			browse_for_file ("Browse for file to parse...", "*.es", agent parse_file_text_field.set_text)
		end
	
	on_browse_serialized_folder is
			-- Called by `select_actions' of `serialized_folder_browse_button'.
		do
			browse_for_directory ("Browse for destination folder...", Saved_serialized_folder_key, agent parse_file_text_field.set_text)
		end

	on_serialized_filename_change is
			-- Called by `change_actions' of `serialized_filename_text_field'.
			-- Check if `Parse' button should be enabled.
		do
			check_can_parse
		end

	on_serialized_folder_change is
			-- Called by `change_actions' of `serialized_folder_text_field'.
			-- Check if `Parse' button should be enabled.
		do
			check_can_parse
		end

	on_parse_file_change is
			-- Called by `change_actions' of `parse_file_text_field'.
			-- Check if `Parse' button should be enabled.
		do
			check_can_parse
		end

	on_provider_browse is
			-- Called by `select_actions' of `provider_browse_button'.
			-- Show file browse dialog.
		do
			browse_for_file ("Browse for CodeDom Provider dll...", "*.dll", agent provider_combo_box.set_text)
		end

	on_change_generation_path is
			-- Called by `change_actions' of `generation_path_text_field'.
		do
			check_can_generate
		end

	on_change_generated_filename is
			-- Called by `change_actions' of `generated_filename_text_field'.
		do
			check_can_generate
		end

	on_close is
			-- Save all settings then quit.
		local
			l_string: STRING
		do
			set_setting (Height_key, height)
			set_setting (Width_key, width)
			set_setting (X_key, x_position)
			set_setting (Y_key, y_position)
			set_text_setting (Codedom_provider_key, provider_combo_box.text)
			set_text_setting (Generated_filename_key, generated_filename_text_field.text)
			set_text_setting (Identifier_key, identifier_text_field.text)
			set_text_setting (Type_key, type_text_field.text)
			set_saved_blank_lines (blank_lines_check_button.is_selected)
			set_saved_else_at_closing (else_at_closing_check_button.is_selected)
			set_text_setting (Indent_string_key, indent_string_text_field.text)
			set_text_setting (Source_filename_key, source_filename_text_field.text)
			set_text_setting (Source_key, source_text.text)
			set_saved_generate_executable (generate_executable_check_button.is_selected)
			set_saved_generate_in_memory (generate_in_memory_check_button.is_selected)
			set_saved_include_debug (include_debug_check_button.is_selected)
			set_text_setting (Compiler_options_key, compiler_options_text_field.text)
			set_text_setting (Main_class_key, main_class_text_field.text)
			set_text_setting (Output_assembly_key, output_assembly_text_field.text)
			set_text_setting (Resource_key, resource_text_field.text)
			from
				referenced_assemblies_list.start
				if not referenced_assemblies_list.after then
					l_string := referenced_assemblies_list.item.text
					referenced_assemblies_list.forth
				else
					l_string := ""
				end
			until
				referenced_assemblies_list.after
			loop
				l_string.append_character (';')
				l_string.append (referenced_assemblies_list.item.text)
				referenced_assemblies_list.forth
			end
			set_text_setting (Referenced_assemblies_key, l_string)
			set_text_setting (Parsed_file_key, parse_file_text_field.text)
			set_text_setting (Serialized_filename_key, serialized_filename_text_field.text)
			Store.store;
			(create {EV_ENVIRONMENT}).application.destroy
		end
	
feature {NONE} -- Implementation

	check_can_generate is
			-- Check if `Generate' button should be enabled.
		do
			if {SYSTEM_DIRECTORY}.exists (generation_path_text_field.text) then
				generation_path_text_field.set_foreground_color (Black)
			else
				generation_path_text_field.set_foreground_color (Red)
			end
			if codedom_provider /= Void and codedoms_tree.selected_item /= Void then
				if {SYSTEM_DIRECTORY}.exists (generation_path_text_field.text) then
					if not generated_filename_text_field.text.is_empty then
						if not generate_button.is_sensitive then
							generate_button.enable_sensitive
						end
					else
						if generate_button.is_sensitive then
							generate_button.disable_sensitive
						end
					end
				else
					if generate_button.is_sensitive then
						generate_button.disable_sensitive
					end
				end
			end
		end
	
	check_can_parse is
			-- Check if `Parse' button should be enabled.
		do
			if {SYSTEM_DIRECTORY}.exists (serialized_folder_text_field.text) then
				serialized_folder_text_field.set_foreground_color (Black)
			else
				serialized_folder_text_field.set_foreground_color (Red)
			end
			if {SYSTEM_FILE}.exists (parse_file_text_field.text) then
				parse_file_text_field.set_foreground_color (Black)
			else
				parse_file_text_field.set_foreground_color (Red)
			end
			if {SYSTEM_FILE}.exists (serialized_folder_text_field.text + (create {OPERATING_ENVIRONMENT}).Directory_separator.out +
					serialized_filename_text_field.text + Serialized_file_extension) then
				serialized_filename_text_field.set_foreground_color (Red)
			else
				serialized_filename_text_field.set_foreground_color (Black)
			end
			if codedom_provider /= Void and not serialized_filename_text_field.text.is_empty and
				{SYSTEM_DIRECTORY}.exists (serialized_folder_text_field.text) and {SYSTEM_FILE}.exists (parse_file_text_field.text) then
					parse_button.enable_sensitive
			else
				parse_button.disable_sensitive
			end
		end
		
	display_output (a_output: STRING) is
			-- Display output `a_output'.
		require
			non_void_output: a_output /= Void
		do
			output_text.set_caret_position (1)
			output_text.insert_text (a_output)
			tests_notebook.select_item (output_text)
		end

	update_properties is
			-- Update code generator, parser and compiler properties with `codedom_provider'.
		local
			l_generator: SYSTEM_DLL_ICODE_GENERATOR
		do
			on_output_type_update
			on_identifier_change
			supports_list.wipe_out
			non_supports_list.wipe_out
			l_generator := codedom_provider.create_generator
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.Arrays_of_arrays) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Arrays of arrays"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Arrays of arrays"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.assembly_attributes) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Assembly attributes"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Assembly attributes"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.chained_constructor_arguments) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Chained constructor arguments"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Chained constructor arguments"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.complex_expressions) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Complex expressions"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Complex expressions"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.declare_delegates) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare delegates"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare delegates"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.declare_enums) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare enums"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare enums"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.declare_events) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare events"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare events"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.declare_interfaces) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare interfaces"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare interfaces"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.declare_value_types) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare value types"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Declare value types"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.entry_point_method) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Entry point method"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Entry point method"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.goto_statements) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Goto statements"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Goto statements"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.multidimensional_arrays) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Multidimensional arrays"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Multidimensional arrays"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.multiple_interface_members) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Multiple interface members"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Multiple interface members"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.nested_types) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Nested types"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Nested types"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.parameter_attributes) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Parameter attributes"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Parameter attributes"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.public_static_members) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Public static members"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Public static members"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.reference_parameters) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Reference parameters"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Reference parameters"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.return_type_attributes) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Return type attributes"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Return type attributes"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.static_constructors) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Static constructors"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Static constructors"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.try_catch_statements) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Try catch statements"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Try catch statements"))
			end
			if l_generator.supports ({SYSTEM_DLL_GENERATOR_SUPPORT}.win_32_resources) then
				supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Win32 resources"))
			else
				non_supports_list.extend (create {EV_LIST_ITEM}.make_with_text ("Win32 resources"))
			end
		end
	
	add_codedom_tree (a_path: STRING) is
			-- Add tree located at `a_path' to codedoms tree.
		require
			non_void_path: a_path /= Void
			non_empty_path: not a_path.is_empty
		do
			Store.add (a_path)
			codedoms_tree.update
		end

	compiler_options: SYSTEM_DLL_COMPILER_PARAMETERS is
			-- Compiler options from gui values
		local
			l_names: NATIVE_ARRAY [SYSTEM_STRING]
			i: INTEGER
		do
			create l_names.make (referenced_assemblies_list.count)
			from
				referenced_assemblies_list.start
			until
				referenced_assemblies_list.after
			loop
				l_names.put (i, referenced_assemblies_list.item.text)
				referenced_assemblies_list.forth
				i := i + 1
			end
			create Result.make_from_assembly_names (l_names)
			if not resource_text_field.text.is_empty then
				Result.set_win_32_resource (resource_text_field.text)
			end
			Result.set_generate_executable (generate_executable_check_button.is_selected)
			Result.set_generate_in_memory (generate_executable_check_button.is_selected)
			Result.set_include_debug_information (include_debug_check_button.is_selected)
			if not compiler_options_text_field.text.is_empty then
				Result.set_compiler_options (compiler_options_text_field.text)
			end
			if not main_class_text_field.text.is_empty then
				Result.set_main_class (main_class_text_field.text)
			end
			if not output_assembly_text_field.text.is_empty then
				Result.set_output_assembly (output_assembly_text_field.text)
			end
		end
		
	display_compilation_results (a_results: SYSTEM_DLL_COMPILER_RESULTS) is
			-- Display `a_results' in output pane.
		require
			non_void_results: a_results /= Void
		local
			l_message: STRING
			i: INTEGER
			l_collection: SYSTEM_DLL_STRING_COLLECTION
			l_errors: SYSTEM_DLL_COMPILER_ERROR_COLLECTION
			l_path: STRING
		do
			l_message := "-- Compilation Terminated --%N* Compiler output:%N"
			l_collection := a_results.output
			if l_collection /= Void then
				from
				until
					i = l_collection.count
				loop
					l_message.append (l_collection.item (i))
					l_message.append_character ('%N')
					i := i + 1
				end
			else
				l_message.append ("(None)%N")
			end
			l_errors := a_results.errors
			if l_errors /= Void and then l_errors.count > 0 then
				l_message.append ("%N* Compiler errors:%N")
				from
					i := 0
				until
					i = l_errors.count
				loop
					l_message.append (l_errors.item (i).to_string)
					l_message.append_character ('%N')
					i := i + 1				
				end
			end
			l_path := a_results.path_to_assembly
			if l_path /= Void and then not l_path.is_empty then
				l_message.append ("%N* Path to assembly:%N" + l_path)
			end
			Event_manager.raise_event (create {TESTER_EVENT}.make (l_message, False))
		end

	browse_for_file (a_title, a_filter: STRING; a_processor: ROUTINE [ANY, TUPLE [STRING]]) is
			-- Browse for file and give title `a_title' to browse dialog and filter `a_filter'.
			-- Call `a_processor' with resulting file name if not empty.
		require
			non_void_title: a_title /= Void
			non_void_processor: a_processor /= Void
		local
			l_dialog: EV_FILE_OPEN_DIALOG
			l_cur_dir: STRING
		do
			l_cur_dir := (create {EXECUTION_ENVIRONMENT}).Current_working_directory
			create l_dialog.make_with_title (a_title)
			if a_filter /= Void then
				l_dialog.filters.extend ([a_filter, a_filter])
			end
			l_dialog.show_modal_to_window (Current)
			(create {EXECUTION_ENVIRONMENT}).change_working_directory (l_cur_dir)
			if not l_dialog.file_name.is_empty then
				a_processor.call ([l_dialog.file_name])
			end
		end
		
	browse_for_directory (a_title, a_key: STRING; a_processor: ROUTINE [ANY, TUPLE [STRING]]) is
			-- Browse for directory and give title `a_title' to browse dialog.
			-- Store/retrieve last used folder in `a_key'.
			-- Call `a_processor' with resulting file name if not empty.
		require
			non_void_title: a_title /= Void
			non_void_key: a_key /= Void
			non_void_processor: a_processor /= Void
		local
			l_dialog: EV_DIRECTORY_DIALOG
			l_start_dir, l_dir: STRING
		do
			create l_dialog.make_with_title (a_title)
			l_start_dir := text_setting (a_key)
			if l_start_dir /= Void then
				l_dialog.set_start_directory (text_setting (a_key))
			end
			l_dialog.show_modal_to_window (Current)
			l_dir := l_dialog.directory
			if not l_dir.is_empty then
				set_text_setting (a_key, l_dir)
				a_processor.call ([l_dir])
			end
		end

	language_extension: STRING is
			-- Selected language extension if any
		do
			create Result.make (4)
			if codedom_provider /= Void then
				if codedom_provider.file_extension.chars (0) /= '.' then
					Result.append_character ('.')
				end
				Result.append (codedom_provider.file_extension)
			end
		ensure
			valid_extension: Result /= Void implies Result.item (1) = '.'
		end
		
feature {NONE} -- Private Access

	codedom_provider: SYSTEM_DLL_CODE_DOM_PROVIDER
			-- Associated codedom provider
		
	Serialized_file_extension: STRING is ".ecds"
			-- Serialized file extension

	Black: EV_COLOR is
			-- Black
		once
			Result := (create {EV_STOCK_COLORS}).Black
		end
		
	Red: EV_COLOR is
			-- Black
		once
			Result := (create {EV_STOCK_COLORS}).Red
		end

invariant
	generate_button_disabled_if_no_provider: is_show_requested and codedom_provider = Void implies not generate_button.is_sensitive
	compile_from_dom_button_disabled_if_no_provider: is_show_requested and codedom_provider = Void implies not compile_from_dom_button.is_sensitive
	compile_from_file_button_disabled_if_no_provider: is_show_requested and codedom_provider = Void implies not compile_from_file_button.is_sensitive
	compile_from_source_button_disabled_if_no_provider: is_show_requested and codedom_provider = Void implies not compile_from_source_button.is_sensitive
	parse_button_disabled_if_no_provider: is_show_requested and codedom_provider = Void implies not parse_button.is_sensitive

indexing
	copyright:	"Copyright (c) 1984-2006, Eiffel Software"
	license:	"GPL version 2 (see http://www.eiffel.com/licensing/gpl.txt)"
	licensing_options:	"http://www.eiffel.com/licensing"
	copying: "[
			This file is part of Eiffel Software's Eiffel Development Environment.
			
			Eiffel Software's Eiffel Development Environment is free
			software; you can redistribute it and/or modify it under
			the terms of the GNU General Public License as published
			by the Free Software Foundation, version 2 of the License
			(available at the URL listed under "license" above).
			
			Eiffel Software's Eiffel Development Environment is
			distributed in the hope that it will be useful,	but
			WITHOUT ANY WARRANTY; without even the implied warranty
			of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
			See the	GNU General Public License for more details.
			
			You should have received a copy of the GNU General Public
			License along with Eiffel Software's Eiffel Development
			Environment; if not, write to the Free Software Foundation,
			Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
		]"
	source: "[
			 Eiffel Software
			 356 Storke Road, Goleta, CA 93117 USA
			 Telephone 805-685-1006, Fax 805-685-6869
			 Website http://www.eiffel.com
			 Customer support http://support.eiffel.com
		]"


end -- class TESTER_TESTER_MAIN_WINDOW

--+--------------------------------------------------------------------
--| Eiffel CodeDOM Provider Tester
--| Copyright (C) 2001-2004 Eiffel Software
--| Eiffel Software Confidential
--| All rights reserved. Duplication and distribution prohibited.
--|
--| Eiffel Software
--| 356 Storke Road, Goleta, CA 93117 USA
--| http://www.eiffel.com
--+--------------------------------------------------------------------