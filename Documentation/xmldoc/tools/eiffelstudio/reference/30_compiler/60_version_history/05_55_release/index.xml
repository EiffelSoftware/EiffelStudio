<document title="Major changes between ISE Eiffel 5.4 and ISE Eiffel 5.5">
	<meta_data>
		<help>
			<toc>
				<envision_location>EiffelEnvision\Introduction to EiffelEnvision\History and Known Issues\Compiler History</envision_location>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<heading>
			<size>2</size>What's new
		</heading>
		<list ordered="false">
			<item>Full support for new <code><keyword>convert</keyword></code> keyword.</item>
			<item>Made <code><keyword>Void,</keyword></code> previously a feature of <class_name>ANY</class_name>, a keyword. This prevents the renaming of <feature_name>Void</feature_name> into <feature_name>not_void</feature_name> previously possible when it was a routine of <class_name>ANY</class_name>.</item>
			<item>Addition of the <code><keyword>reference</keyword></code> keyword used in generic constraints (See next point).</item>
			<item>Added support for reference and expanded constraints on a formal generic parameter. In other word, one can now write:
				<code_block><keyword>class</keyword> <class_name>A</class_name> [<keyword>reference</keyword> G]  ... <keyword>end</keyword>
<keyword>class</keyword> <class_name>B</class_name> [<keyword>expanded</keyword> G] ... <keyword>end</keyword></code_block>
				to say that the valid actual generic parameters for <class_name>A</class_name> are always reference types, and for <class_name>B</class_name> are always expanded types.
			</item>
			<item>Added support for Microsoft .NET 2.0 runtime.</item>
			<item>Allowed agent creation on infix or prefix routines.</item>
		</list>
		<heading><size>2</size>Improvements</heading>
		<list ordered="false">
			<item>Reduced, in classic mode, size of finalized executables by 10 to 50%.</item>
			<item>Improved speed of evaluation of global onces, in a multithreaded system, by having a lock-free mechanism after a once has been evaluated.</item>
			<item>Reduced memory usage of special of expanded which do not have any reference attributes. Before there was a 8 bytes (or 16 bytes depending on the platform) overhead per item in the special.</item>
		</list>
		<heading>
			<size>2</size>Changes
		</heading>
		<list ordered="false">
			<item>Compiler is now checking that you cannot redeclare a formal generic parameter into a reference type unless the formal generic parameter is being constraint to be always a reference type (See the <bold>What's new</bold> section above).</item>
			<item>Removed obsolete <feature_name>eifcid</feature_name>, <feature_name>eif_expand</feature_name> and <feature_name>eifexp</feature_name>from the CECIL interface, one has to use <feature_name>eif_type_id</feature_name>instead.</item>
			<item>In .NET, changed the naming conventions of resources included in an assembly. The extension `.resources' is appended for resources that are originally provided as `.resx' or `.txt' files. Other files are embedded as is in the assembly and the name of the resource is the name of the file.</item>
			<item>In .NET, now all classes inherit from <class_name>ANY</class_name>. Before all classes inherited from <class_name>SYSTEM_OBJECT</class_name>. The consequences are:
				<list ordered="false">
					<item>You can write an Eiffel generic classes where the actual generic parameter is a .NET class.</item>
					<item>If you used to inherit from .NET classes and Eiffel classes you can replace the inheritance clause below:
					<code_block><keyword>class</keyword> <class_name>A</class_name>
<keyword>inherit</keyword>
	<class_name>APPLICATION_EXCEPTION</class_name>
		<keyword>undefine</keyword>
			<feature_name>finalize</feature_name>,
			<feature_name>equals</feature_name>,
			<feature_name>to_string</feature_name>,
			<feature_name>get_hash_code</feature_name>
		<keyword>end</keyword>
	
	<class_name>ANY</class_name></code_block>
					by the much simpler inheritance clause:
					<code_block><keyword>class</keyword> <class_name>A</class_name>
<keyword>inherit</keyword>
	<class_name>APPLICATION_EXCEPTION</class_name>
</code_block>
					</item>
					<item>If you were using a feature of <class_name>SYSTEM_OBJECT</class_name> directly on Eiffel classes, now you need to assign the value to a variable entity of type <class_name>SYSTEM_OBJECT</class_name>. In other word:
					<code_block>e: <class_name>EIFFEL_CLASS</class_name>
o: <class_name>SYSTEM_OBJECT</class_name>
...
o := e
o.<feature_name>feature_of_system_object</feature_name></code_block>
					</item>
				<item>The following assignment attempt will succeed whereas it failed before because <class_name>SYSTEM_OBJECT</class_name> did not inherit from <class_name>ANY</class_name>:<code_block>a: <class_name>ANY</class_name>
o: <class_name>SYSTEM_OBJECT</class_name>
...
<keyword>check</keyword> o /= Void <keyword>and</keyword> a = Void <keyword>end</keyword>
a ?= o
<keyword>check</keyword> o /= Void <keyword>and</keyword> a /= Void <keyword>end</keyword></code_block></item>
				</list>
			</item>
			<item>New format of the independent storable files which takes into account internal changes made for a better generic conformance in classic mode.</item>
			<item>New validity rule for expanded types: It is valid to use an expanded type of base class <class_name>C</class_name> in the text of a class <class_name>B</class_name> if and only if it satisfies the following conditions:
				<list ordered="false">
					<item><class_name>C</class_name> is not a deferred class</item>
					<item><class_name>C</class_name>'s version of the procedure <feature_name>default_create</feature_name> (inherited from <class_name>ANY</class_name>) is one of the creation procedures of <class_name>C</class_name> available to <class_name>B</class_name> for creation.</item>
				</list>
			</item>
			<item>New validity rule for expanded class: An expanded class <class_name>C</class_name> needs to have the version of the procedure <feature_name>default_create</feature_name> (inherited from <class_name>ANY</class_name>) as one of its creation procedure.</item>
		</list>
		<heading>
			<size>2</size>Bug fixes
		</heading>
		<heading>
			<size>3</size>Language issues
		</heading>
		<list ordered="false">
			<item>Fixed issue about conformance checking of type containing a formal generic parameter. We would always evaluate the formal to its constraint, thus allowing the code below to be accepted where it should not have been:
			<code_block>
<keyword>class</keyword> <class_name>A</class_name> <symbol>[</symbol><class_name>G</class_name><symbol>]</symbol>
<keyword>feature</keyword>
	<feature_name>bug</feature_name> <keyword>is</keyword>
		<keyword>local</keyword>
			l_any<symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>ANY</class_name><symbol>]</symbol>
			l_g<symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>G</class_name><symbol>]</symbol>
		<keyword>do</keyword>
			l_any <symbol>:</symbol><symbol>=</symbol> l_g
			l_g <symbol>:</symbol><symbol>=</symbol> l_any
		<keyword>end</keyword>
			</code_block>
			The workaround is to use the <code><keyword>reference</keyword></code> keyword to guarantee that the formal generic parameter will always be instantiated with a reference type. For example the code below is correct:
			<code_block>
<keyword>class</keyword> <class_name>A</class_name> [<keyword>reference</keyword> G]
<keyword>feature</keyword>
	<feature_name>bug</feature_name> <keyword>is</keyword>
		<keyword>local</keyword>
			l_any<symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>ANY</class_name><symbol>]</symbol>
			l_g<symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>G</class_name><symbol>]</symbol>
		<keyword>do</keyword>
			l_any <symbol>:</symbol><symbol>=</symbol> l_g
			l_g <symbol>?</symbol><symbol>=</symbol> l_any
		<keyword>end</keyword>
			</code_block></item>
		</list>
		<heading>
			<size>3</size>Compiler issues
		</heading>
		<list ordered="false">
			<item>Enabled creation of <class_name>SPECIAL</class_name> instances, no need to create an instance of <class_name>TO_SPECIAL</class_name>or <class_name>ARRAY</class_name> to get a <class_name>SPECIAL</class_name>instance. Now you can simply do:<code_block>my_special: <class_name>SPECIAL</class_name> [<class_name>INTEGER</class_name>]
<keyword>create</keyword> my_special.<feature_name>make</feature_name> (10)</code_block>
			</item>
			<item>Fixed incrementality issues with <code><keyword>strip</keyword></code> and static calls on external routines which could fail after a class has been added to or removed from the system.</item>
		</list>
		<heading>
			<size>3</size>Runtime/code generation issues
		</heading>
		<list ordered="false">
			<item>Fixed incorrect code generation which would result in a C compiler error in classic mode when assigning a Void entity to a formal generic parameter that will be instantiated as a basic type.</item>
			<item>In multithreaded mode, fixed dead lock on Unix platforms when evaluating global onces.</item>
			<item>In multithreaded mode, prevented dead lock when a thread is exiting.</item>
			<item>In multithreaded mode, prevented memory corruption which could occur if the first thing that a thread performs when launched is to trigger a GC collection.</item>
			<item>Fixed incorrect generic conformance data when manipulating expanded generic types. For example, the following code:<code_block><keyword>class</keyword> <class_name>A</class_name> [G, H]
<keyword>feature</keyword>
	<feature_name>item</feature_name>: H 
<keyword>end</keyword>

<keyword>class</keyword> <class_name>C</class_name> [G]
<keyword>end</keyword>

<keyword>class</keyword> <class_name>ROOT_CLASS</class_name>
<keyword>create</keyword>
	<feature_name>make</feature_name>
<keyword>feature</keyword>
	<feature_name>make </feature_name><keyword>is</keyword>
		<keyword>local</keyword>
			l_a: <class_name>A</class_name> [<class_name>STRING</class_name>, <keyword>expanded</keyword> <class_name>C</class_name> [<class_name>ANY</class_name>]]
		<keyword>do</keyword>
			<keyword>create</keyword> l_a
			<feature_name>io</feature_name>.<feature_name>put_string</feature_name> (l_a.<feature_name>item</feature_name>.<feature_name>generating_type</feature_name>)
		<keyword>end</keyword>
<keyword>end</keyword>
</code_block>would print<code_block>expanded C [STRING]</code_block>instead of<code_block>expanded C [ANY]</code_block></item>
			<item>Fixed issue where you could get a bogus reference when trying to get a reference to the object associated to an ID (obtained through the <class_name>IDENTIFIED</class_name> class).</item>
		</list>
		<heading>
			<size>3</size>.NET issues
		</heading>
		<list ordered="false">
			<item>Fixed incorrect code generation of native arrays which would cause the code to be rejected in newer version of the .NET Framework.</item>
			<item>Fixed incorrect computation of `max_stack' for a routine body which could make the generated code not verifiable.</item>
		</list>
		<heading>	<size>3</size>Store/Retrieve issues</heading>
		<list ordered="false">
			<item>Fix some issues related to the use of recoverable storable when manipulating generic types.</item>
		</list>
	</paragraph></document>
