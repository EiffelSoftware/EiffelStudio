<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<LINK REL="stylesheet" HREF="../../../../../default.css" TYPE="text/css">
<TITLE>EiffelStore Generation Cluster</TITLE>
<style>
<!--
.Note        {  }
.tip         {  }
.warning     {  }
.figuretitle {  }
-->
</style>
</head>

<body>

<h1 align="left">Data structures use</h1>

<h2 align="left">1. Overview</h2>

<p align="left">EiffelStore affords a context that optimizes and facilitates the
use of the classes that maps your database content.&nbsp;</p>

<p align="left">The main advantage of database-specific structures is the static
checking: you can determine at compile-time the type of information you are
accessing or modifying.</p>

<p align="left">However, it can be more flexible to determine the type of data
you are dealing with at run-time. This can be particularly useful for GUI
applications, take a look at the <A HREF="../../40_dataview_cluster/index.html">DataView cluster</A>.</p>

<p align="left">Each data structure carries some meta-data about its type so
that the run-time typing hazards can be avoided with assertions based on this
meta-data.</p>

<p align="left">The advantage of this system is two-fold:</p>

<ul>
  <li>
    <p align="left">You can choose to use compile-time type checking or not,
    depending on your own needs.</li>
  <li>
    <p align="left">If you choose run-time type checking, assertions ensure that
    each object type is valid and prevent catcalls.&nbsp;</li>
</ul>
<p align="left">Let us see first <a href="#capabilities">what you can do</a>
with data structures and their context, then <a href="#implementation">how it is
implemented</a>.</p>

<h2 align="left">2. <a name="capabilities"></a>Data structure capabilities</h2>
<p align="left">Database-specific classes and their context let you perform the
following operations:</p>
<ul>
  <li>
    <p align="left"><a href="#cap_storage">Storing table/view rows content</a></li>
  <li>
    <p align="left"><a href="#cap_manipulation">Manipulating abstract table/view rows content</a></li>
  <li>
    <p align="left"><a href="#cap_objects_metadata">Getting objects metadata</a></li>
  <li>
    <p align="left"><a href="#cap_database_metadata">Accessing database metadata</a></li>
  <li>
    <p align="left"><a href="#cap_more">More interesting features</a></li>
</ul>
<h3 align="left">2.1. <a name="cap_storage"></a> Storing table/view rows content</h3>
<p align="left">You can store table/view rows content into classes that have the
table or view name: one database table/view row correspond to one Eiffel object.
Each table attribute will correspond to a class attribute with the same name. <i>set</i>
commands enable to change the object content to insert rows in the database or
update rows. <a class="eclass" href="../../../../store/reference/interface/db_selection_chart.html">DB_SELECTION</a> class can directly map database results into these
objects, and you can directly create a table/view row from one object with the
<a class="eclass" href="../../../../store/reference/interface/db_store_chart.html">DB_STORE</a> class. Take a look at the
data-object coupling section.</p>
<p align="left">[Note on the types and default values]</p>
<h3 align="left">2.2. <a name="cap_manipulation"></a> Manipulating abstract table/view rows content</h3>
<p align="left">Each table/view storage structure inherits from the <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_chart.html">DB_TABLE</a>
abstract class. This enables to handle <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_chart.html">DB_TABLE</a> objects as abstract database table/view structures.</p>
<p align="left">You can then access or modify <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_chart.html">DB_TABLE</a> attributes: instead of accessing attributes with their <i>name</i>,
which implies that the object type is known at compile-time, attributes can then
be accessed with a <i>code</i>.</p>
<BR><CODE>
tablerow: DB_TABLE<br>
...<br>
display_attribute (code: INTEGER) is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- Display attribute with `code'.<br>
&nbsp;&nbsp;&nbsp; do<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; io.putstring (tablerow.table_description.attribute (code).out)<br>
&nbsp;&nbsp;&nbsp; end
</CODE>
<p class="note"><b>Note:</b> to access attributes data with <i>code</i>, you
need to use the <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_description_chart.html">DB_TABLE_DESCRIPTION</a>
object associated to your <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_chart.html">DB_TABLE</a>
object.</p>
<h3 align="left">2.3. <a name="cap_objects_metadata"></a> Getting objects metadata</h3>
<p align="left">While manipulating <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_chart.html">DB_TABLE</a> objects, you can easily get:</p>
<ul>
  <li>
    <p align="left">Which database table/view the object references.</li>
  <li>
    <p align="left">What are the types of its attributes.</li>
</ul>
    <p align="left" class="note"><b>Note:</b> you also get objects metadata
    through the <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_description_chart.html">DB_TABLE_DESCRIPTION</a>
    object associated to your <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_chart.html">
    DB_TABLE</a> object.
<p align="left">Objects metadata used in assertions ensures objects type
validity. To illustrates this, let's look at the contract form of a class that
manipulates &quot;abstract&quot; table/view rows:</p>
<p align="left"><code>set_table_code (code: INTEGER)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- Assign `code' to `tablecode'.<br>
<br>
tablecode: INTEGER<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- Table code.<br>
<br>
compute (tablerow: DB_TABLE)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- Compute `tablerow'.<br>
&nbsp;&nbsp;&nbsp; require<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type_is_ok: tablerow.table_description.Table_code = tablecode<br>
</code></p>
<h3 align="left">2.4. <a name="cap_database_metadata"></a> Accessing database metadata</h3>
<p align="left">Basic database metadata is also available: the
<SPAN class="eclass">DB_SPECIFIC_TABLES_ACCESS_USE</SPAN> class (generated), stores <a class="eclass" href="../../../../base/reference/kernel/integer_chart.html">INTEGER</a> codes for each
database table/view. These codes afford related table/view name and related new
storing objects (i.e. that conforms to <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_chart.html">
    DB_TABLE</a> class).</p>
<p align="left"><CODE>
tables: DB_SPECIFIC_TABLES_ACCESS<br>
...<br>
</CODE>
<code>new_object (code: INTEGER): DB_TABLE is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -- New object of table with `code'.<br>
&nbsp;&nbsp;&nbsp; do<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Result := tables.obj (code)<br>
&nbsp;&nbsp;&nbsp; end</code></p>
<h3 align="left">2.5. <a name="cap_more"></a> More interesting features</h3>
<p align="left">The <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_description_chart.html">DB_TABLE_DESCRIPTION</a>
class offers more features to get table row attributes as conveniently as
possible:</p>
<ul>
  <li>
    <p align="left">The table/view row primary key value (ID)</li>
  <li>
    <p align="left">The list of table/view row attributes</li>
  <li>
    <p align="left">A selection of table/view row attributes</li>
  <li>
    <p align="left">The list of table/view row attributes mapped to a function.</li>
  <li>
    <p align="left">Printable attribute values (i.e. the associated <a class="eclass" href="../../../../base/reference/kernel/string_chart.html">STRING</a>
    values)</li>
</ul>
<h2 align="left">3. <a name="implementation"></a>Implementation</h2>

<p align="left">Database-specific classes can be divided into 3 types:</p>

<ul>
  <li>
    <p align="left">Classes holding database table rows content (inheriting from
    <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_chart.html">DB_TABLE</a>)</li>
  <li>
    <p align="left">Classes describing database tables (inheriting from <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_description_chart.html">DB_TABLE_DESCRIPTION</a>)</li>
  <li>
    <p align="left">A class describing the database and giving access to the
    previous types of classes (inheriting from <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_tables_access_chart.html">DB_TABLES_ACCESS</a>)</li>
</ul>

<p align="left">One database table is hence associated to one table class and one
    description class. Both classes are closely <a href="#table-descr_relationship"> interrelated</a> to provide what the
    developer need. The <a href="#table_access_classes">table access classes</a>
    describes the database tables
    and gives access to both table and description classes.</p>

<p align="left">Each database-specific (generated) class inherits from an
abstract class. These abstract classes gathers all the facilities&nbsp; that are not specific to
your database, and so that can be inherited by all the database-specific
classes.</p>

<p align="left">Let us see abstract and database-specific classes relationship:</p>
<p align="left"><img border="0" src="tables_access_inherit.png" width="570" height="408"></p>
<p align="left" class="figuretitle">General and generated classes relationships</p>
<ul>
  <li>
    <p align="left">Yellow classes are abstract.</li>
  <li>
    <p align="left">Green classes are database-specific.</li>
</ul>
<h2 align="left">2. <a name="table-descr_relationship"></a> Table and description classes relationship</h2>
<p align="left">Table classes, that inherit from <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_chart.html">DB_TABLE</a>,
and description classes, that inherit from <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_description_chart.html">DB_TABLE_DESCRIPTION</a>,
both deals with database tables. This section explains what are their own role
and their relationship.</p>
<h3 align="left">2.1. Table classes</h3>
<p align="left">As seen in the previous section, table classes merely store table rows attribute values. Their objects can be
<u> considered as</u> database
table rows, or more precisely, database table rows on the Eiffel side. These classes inherit from <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_chart.html">DB_TABLE</a>. </p>
<p align="left">Each of these classes are associated to a description
class. </p>
<p align="left" class="tip"><b>Tip:</b> Use table classes to <i>carry</i>
data.&nbsp;&nbsp; </p>
<h3 align="left">2.2. Description classes</h3>
<p align="left">The description classes goal is 3-fold: </p>
<ul>
  <li>
    <p align="left"><a href="#cap_objects_metadata">Getting meta-data</a> about the table represented at
    run-time.</li>
  <li>
    <p align="left"><a href="#cap_manipulation">Getting table rows data</a> dynamically.</li>
  <li>
    <p align="left"><a href="#cap_more">Facilitating data management</a>.</li>
</ul>
<p align="left">These descriptions inherit from <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_description_chart.html">DB_TABLE_DESCRIPTION</a>.</p>
<p align="left">Since they only describes a table and provide tools, description objects
can be unique. EiffelStore ensures their unicity for resources optimization.</p>
<p align="left" class="tip"><b>Tip:</b> Use description classes to <i>access and
modify</i> data.</p>
<h3 align="left">2.3. Relationship</h3>
<p align="left">Each table class is associated to the description class
corresponding to the same database table.</p>
<p align="left">A table class object provides the associated table description:</p>
<p align="left">
<code>
row: DB_TABLE<br>
description: DB_TABLE_DESCRIPTION<br>
...<br>
row := db_manager.database_result<br>
description := row.table_description
</code></p>
As descriptions are unique, every table row object is associated to the same
description. The following figure illustrates this:
<p><img border="0" src="table-descr_objects.png" width="462" height="178"></p>
<p class="figuretitle">table and description objects relationship</p>
<p>As seen in the previous section, to manipulate abstract table/view rows content,
you have to use the description class. The following example shows how to output
a table row ID value.&nbsp;</p>
<p><code>
row: DB_TABLE<br>
description: DB_TABLE_DESCRIPTION<br>
...<br>
&nbsp;&nbsp;&nbsp; -- Link description unique object to `row' content.<br>
description := row.table_description<br>
io.putstring (description.attribute (description.id_name) + &quot;: &quot;)<br>
io.putstring (description.attribute (description.id_code).out)</code></p>
<p>As descriptions are unique, this means that description objects are also
associated to a specific table object to deal with it (i.e. access or modify its
content). Actually, the <a class="efeature" href="../../../../store/reference/generation/tables_access/abstract/db_table.html#f_table_description">table_description</a> feature associates the
description with the current object and then returns this description.&nbsp;</p>
<p class="note"><b>Note:</b> The <a class="efeature" href="../../../../store/reference/generation/tables_access/abstract/db_table.html#f_table_description">table_description</a>
feature is still a
query as the association part should not be visible at the interface
level.&nbsp;</p>
<p>On the whole, you have to pay attention to always execute <a class="efeature" href="../../../../store/reference/generation/tables_access/abstract/db_table.html#f_table_description">table_description</a>
on your table/view row to get the appropriate description.</p>
<h2 align="left">3. <a name="table_access_classes"></a>Table access classes</h2>
<h3 align="left">3.1. Overview</h3>
<p align="left">Table access classes provide facilities to manage table row and
table description objects. They also give basic database table meta-data.</p>
<p align="left">The following figure shows table access classes and their
relations.</p>
<ul>
  <li>
    <p align="left">Yellow classes are EiffelStore classes</li>
  <li>
    <p align="left">Green class is generated</li>
  <li>
    <p align="left">Pink class is an application class</li>
</ul>
<p align="left"><img border="0" src="DB_SPECIFIC_TABLES_ACCESS_USE.png" width="495" height="377"></p>
<p align="left" class="figuretitle">Table access classes BON diagram</p>
<p align="left"><img border="0" src="table-descr-access_objects.png" width="660" height="248"></p>
<p align="left" class="figuretitle">Relationship between the tables access
object, description and table objects</p>
<h3 align="left">3.2. DB_SPECIFIC_TABLES_ACCESS class</h3>
<p align="left">The <SPAN class="eclass">DB_SPECIFIC_TABLES_ACCESS</SPAN> class stores the unique table
description object. It also provides the following facilities:</p>
<ul>
  <li>
    <p align="left">Every database table code</li>
  <li>
    <p align="left">Table descriptions from a table code</li>
  <li>
    <p align="left">Sample table class objects from a table code</li>
  <li>
    <p align="left">Table names from a table code</li>
</ul>
<p align="left" class="Note"><b>Note</b>: database table codes given in the
class match the table codes provided by <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_table_description_chart.html">DB_TABLE_DESCRIPTION</a>.</p>
<h3 align="left">3.3. Abstract access class</h3>
<p align="left">The <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_tables_access_chart.html">DB_TABLES_ACCESS</a> class provides an interface for the
<SPAN class="eclass">DB_SPECIFIC_TABLES_ACCESS</SPAN> class which is non-specific to the database. This can
be used by non database-specific code (for instance the <A HREF="../../40_dataview_cluster/index.html">DataView cluster</A>) to
access database tables.</p>
<p align="left">Unique table description objects and table codes are of course
not directly available from this class, but the following features are still
available:</p>
<ul>
  <li>
    <p align="left">Table descriptions from a table code</li>
  <li>
    <p align="left">Sample table class objects from a table code</li>
  <li>
    <p align="left">Table names from a table code</li>
</ul>
<h3 align="left">3.4. Use classes</h3>
<p align="left">The <SPAN class="eclass">DB_SPECIFIC_TABLES_ACCESS</SPAN> object can be accessed as a kind
of &quot;global variable&quot; by any class which inherits from
<SPAN class="eclass">DB_SPECIFIC_TABLES_ACCESS_USE</SPAN>. This class also ensures <SPAN class="eclass">DB_SPECIFIC_TABLES_ACCESS</SPAN>
object unicity.</p>
<p align="left">The <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_tables_access_use_chart.html">DB_TABLES_ACCESS_USE</a> class affords the same possibility but
with no reference to the <SPAN class="eclass">DB_SPECIFIC_TABLES_ACCESS</SPAN> object. The unique
<SPAN class="eclass">DB_SPECIFIC_TABLES_ACCESS</SPAN> should be set to this class as of type <a class="eclass" href="../../../reference/generation/tables_access/abstract/db_tables_access_chart.html">DB_TABLES_ACCESS</a>.</p>
<br>

</body>

</html>
