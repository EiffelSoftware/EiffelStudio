indexing
	description: "Objects that represent an EV_TITLED_WINDOW.%
		%The original version of this class was generated by EiffelBuild."
	date: "$Date$"
	revision: "$Revision$"

class
	GRID_TAB

inherit
	GRID_TAB_IMP
	
	GRID_ACCESSOR
		undefine
			copy, default_create, is_equal
		end
		
	EXECUTION_ENVIRONMENT
		rename
			put as execution_environment_put
		undefine
			copy, default_create, is_equal
		end
				
	PROFILING_SETTING
		undefine
			copy, default_create, is_equal
		end

feature {NONE} -- Initialization

	user_initialization is
			-- Called by `initialize'.
			-- Any custom user initialization that
			-- could not be performed in `initialize',
			-- (due to regeneration of implementation class)
			-- can be added here.
		local
			f_name: FILE_NAME
			list_item: EV_LIST_ITEM
		do
			grid.set_dynamic_content_function (agent compute_item)
			add_color_to_background_color_combo ((create {EV_STOCK_COLORS}).red)
			add_color_to_background_color_combo ((create {EV_STOCK_COLORS}).green)
			add_color_to_background_color_combo ((create {EV_STOCK_COLORS}).blue)
			add_color_to_background_color_combo ((create {EV_STOCK_COLORS}).yellow)
			add_color_to_background_color_combo ((create {EV_STOCK_COLORS}).white)
			
				-- Now load pixmaps for exapnd/collapse nodes.
			expand1 := grid.expand_node_pixmap
			collapse1 := grid.collapse_node_pixmap
			create f_name.make_from_string (current_working_directory)
			f_name.extend ("icon_bpenabled.png")
			create expand2
			expand2.set_with_named_file (f_name.out)
			create f_name.make_from_string (current_working_directory)
			f_name.extend ("icon_bpdisabled.png")
			create collapse2
			collapse2.set_with_named_file (f_name)
			
			create f_name.make_from_string (current_working_directory)
			f_name.extend ("large_expand.png")
			create expand3
			expand3.set_with_named_file (f_name.out)
			create f_name.make_from_string (current_working_directory)
			f_name.extend ("large_collapse.png")
			create collapse3
			collapse3.set_with_named_file (f_name)
			
			
			create list_item.make_with_text ("16x16")
			list_item.set_pixmap (expand1)
			subnode_pixmaps_combo.extend (list_item)
			create list_item.make_with_text ("16x16")
			list_item.set_pixmap (expand2)
			subnode_pixmaps_combo.extend (list_item)
			create list_item.make_with_text ("32x32")
			list_item.set_pixmap (expand3)
			subnode_pixmaps_combo.extend (list_item)
		end
		
	expand1, expand2, expand3, collapse1, collapse2, collapse3: EV_PIXMAP

feature {NONE} -- Implementation

	is_header_displayed_button_selected is
			-- Called by `select_actions' of `is_header_displayed_button'.
		do
			if is_header_displayed_button.is_selected then
				grid.show_header
			else
				grid.hide_header
			end
		end

	is_tree_enabled_button_selected is
			-- Called by `select_actions' of `is_tree_enabled_button'.
		do
			if is_tree_enabled_button.is_selected then
				grid.enable_tree
			else
				grid.disable_tree
			end
		end

	new_label_button_selected is
			-- Called by `select_actions' of `new_label_button'.
		local
			new_label_item_dialog: NEW_ITEM_DIALOG
		do
			create new_label_item_dialog
			new_label_item_dialog.show_relative_to_window (main_window)
		end
		
	is_vertical_divider_displayed_button_selected is
			-- Called by `select_actions' of `is_vertical_divider_displayed_button'.
		do
			if is_vertical_divider_displayed_button.is_selected then
				grid.enable_resizing_divider
				is_vertical_divider_dashed_button.enable_sensitive
				is_vertical_divider_solid_button.enable_sensitive
			else
				grid.disable_resizing_divider
				is_vertical_divider_dashed_button.disable_sensitive
				is_vertical_divider_solid_button.disable_sensitive
			end
		end
		
	is_vertical_divider_solid_button_selected is
			-- Called by `select_actions' of `is_vertical_divider_solid_button'.
		do
			grid.enable_solid_resizing_divider
		end
	
	is_vertical_divider_dashed_button_selected is
			-- Called by `select_actions' of `is_vertical_divider_dashed_button'.
		do
			grid.disable_solid_resizing_divider
		end
		
	is_horizontal_scrolling_per_item_selected is
			-- Called by `select_actions' of `is_horizontal_scrolling_per_item'.
		do
			if is_horizontal_scrolling_per_item.is_selected then
				grid.enable_horizontal_scrolling_per_item
			else
				grid.disable_horizontal_scrolling_per_item
			end
		end
	
	is_vertical_scrolling_per_item_selected is
			-- Called by `select_actions' of `is_vertical_scrolling_per_item'.
		do
			if is_vertical_scrolling_per_item.is_selected then
				grid.enable_vertical_scrolling_per_item
			else
				grid.disable_vertical_scrolling_per_item
			end
		end
		
	is_row_height_fixed_selected is
			-- Called by `select_actions' of `is_row_height_fixed'.
		do
			if is_row_height_fixed.is_selected then
				grid.enable_row_height_fixed
				fixed_row_height_spin_button.enable_sensitive
			else
				grid.disable_row_height_fixed
				fixed_row_height_spin_button.disable_sensitive
			end
		end
	
	fixed_row_height_spin_button_changed (a_value: INTEGER) is
			-- Called by `change_actions' of `fixed_row_height_spin_button'.
		do
			grid.set_row_height (a_value)
		end
		
	is_partially_dynamic_selected is
			-- Called by `select_actions' of `is_partically_dynamic'.
		do
			if is_partially_dynamic.is_selected then
				grid.enable_partial_dynamic_content
				resize_columns_to_box.enable_sensitive
				resize_rows_to_box.enable_sensitive
				is_completely_dynamic.select_actions.block
				is_completely_dynamic.disable_select
				is_completely_dynamic.select_actions.resume
			else
				if not is_completely_dynamic.is_selected then
					resize_columns_to_box.disable_sensitive
					resize_rows_to_box.disable_sensitive
					grid.disable_dynamic_content
				end
			end
		end
	
	is_completely_dynamic_selected is
			-- Called by `select_actions' of `is_completely_dynamic'.
		do
			if is_completely_dynamic.is_selected then
				grid.enable_complete_dynamic_content
				resize_columns_to_box.enable_sensitive
				resize_rows_to_box.enable_sensitive
				is_partially_dynamic.select_actions.block
				is_partially_dynamic.disable_select
				is_partially_dynamic.select_actions.resume
			else
				if not is_partially_dynamic.is_selected then
					resize_columns_to_box.disable_sensitive
					resize_rows_to_box.disable_sensitive
					grid.disable_dynamic_content
				end
			end
		end
	
	resize_columns_to_button_selected is
			-- Called by `select_actions' of `resize_columns_to_button'.
		do
			if resize_columns_to_button.is_selected then
				resize_columns_to_entry.enable_sensitive
				resize_columns_to_entry.change_actions.call ([resize_columns_to_entry.value])
			else
				resize_columns_to_entry.disable_sensitive
			end
		end
	
	resize_columns_to_entry_selected (a_value: INTEGER) is
			-- Called by `change_actions' of `resize_columns_to_entry'.
		do
			grid.set_column_count_to (a_value)
		end
		
	resize_row_to_button_selected is
			-- Called by `select_actions' of `resize_rows_to_button'.
		do
			if resize_rows_to_button.is_selected then
				resize_rows_to_entry.enable_sensitive
				resize_rows_to_entry.change_actions.call ([resize_rows_to_entry.value])
			else
				resize_rows_to_entry.disable_sensitive
			end
		end
	
	resize_rows_to_entry_changed (a_value: INTEGER) is
			-- Called by `change_actions' of `resize_rows_to_entry'.
		do
			grid.set_row_count_to (a_value)
		end
		
	add_items (an_xcount, a_ycount: INTEGER) is
			--
		local
			l_ycount, l_xcount: INTEGER
			grid_label_item: EV_GRID_LABEL_ITEM
		do
			from
				l_ycount := 1
			until
				l_ycount > a_ycount
			loop
				from
					l_xcount := 1
				until
					l_xcount > an_xcount
				loop
					create grid_label_item
					grid_label_item.set_text ("Item" + " " + l_xcount.out + ", " + l_ycount.out)
					grid.set_item (l_xcount, l_ycount, grid_label_item)
					l_xcount := l_xcount + 1
				end
				l_ycount := l_ycount + 1
			end
		end
		
		
	misc_button_selected is
			-- Called by `select_actions' of `misc_button'.
		local
			counter: INTEGER
			counter2: INTEGER
			time1, time2: DATE_TIME
		do
			create time1.make_now
			add_items (5, 400)
		--	add_items (5, 15)
			grid.column (1).set_title ("One")
			grid.column (2).set_title ("Two")
			grid.column (3).set_title ("Three")
			grid.column (4).set_title ("Four")
			grid.column (5).set_title ("Five")
			grid.enable_tree
			grid.row (1).add_subrow (grid.row (2))
			grid.row (1).add_subrow (grid.row (3))
			grid.row (3).add_subrow (grid.row (4))
			grid.row (4).add_subrow (grid.row (5))
			grid.row (5).add_subrow (grid.row (6))
			grid.row (6).add_subrow (grid.row (7))
			grid.row (7).add_subrow (grid.row (8))
			grid.row (8).add_subrow (grid.row (9))
			grid.row (9).add_subrow (grid.row (10))
			from
				counter := 11
			until
				counter > 30
			loop
				grid.row (1).add_subrow (grid.row (counter))
				counter := counter + 1
			end
--			grid.insert_new_row_parented (33, grid.row (32))
			from
				counter := 35
			until
				counter = 100
			loop
				grid.row (counter).add_subrow (grid.row (counter + 1))
				counter := counter + 1
			end
			grid.insert_new_row (110)
			grid.set_item (3, 110, create {EV_GRID_LABEL_ITEM}.make_with_text ("Deep subnode"))
			grid.row (109).add_subrow (grid.row (110))
			from
				counter := 111
			until
				counter = 120
			loop
				grid.insert_new_row (counter)
				grid.set_item (3, counter, create {EV_GRID_LABEL_ITEM}.make_with_text ("Subnode"))
				grid.row (counter - 1).add_subrow (grid.row (counter))
				counter := counter + 1
			end
			from
				counter := 113
			until
				counter = 120
			loop
				grid.insert_new_row (counter)
				grid.set_item (5, counter, create {EV_GRID_LABEL_ITEM}.make_with_text ("Subnode"))
				grid.row (112).add_subrow (grid.row (counter))
				counter := counter + 1
			end
			from
				counter := 150
			until
				counter > 155
			loop
				grid.insert_new_row (counter + 1)
				grid.set_item (1, counter + 1, create {EV_GRID_LABEL_ITEM}.make_with_text ("Subnode"))
				grid.row (150).add_subrow (grid.row (counter + 1))
				
				counter := counter + 1
			end
			from
				counter := 160
				counter2 := 360
			until
				counter = 260
			loop
				grid.row (counter).add_subrow (grid.row (counter + 1))
				
				grid.row (counter).add_subrow (grid.row (counter2))
				counter := counter + 1
				counter2 := counter2 - 1
			end
			create time2.make_now
			set_status_message (("Items added in : " + ((time2.fine_second - time1.fine_second).out)))
		end
		
	compute_item (an_x, a_y: INTEGER): EV_GRID_ITEM is
			--
		local
			drawable_item: EV_DRAWABLE_GRID_ITEM
		do
			if an_x = 2 then
				do_nothing
			end
			print ("Computing item : " + an_x.out + " " + a_y.out + "%N")
			if a_y \\ 2 = 1 then
				create {EV_GRID_LABEL_ITEM} Result.make_with_text ("Item at position : " + an_x.out + ", " + a_y.out)
			else
				create drawable_item
				drawable_item.expose_actions.extend (agent draw_grid_item (?, ?, ?, ?, ?, drawable_item))
				Result := drawable_item
			end
		end
		
	draw_grid_item (an_x, a_y, a_width, a_height: INTEGER; drawable: EV_DRAWABLE; an_item: EV_DRAWABLE_GRID_ITEM) is
			--
		local
			back_color: EV_COLOR
		do
			if back_color = Void then
				back_color := grid.background_color
			end
			drawable.set_foreground_color (back_color)
			drawable.fill_rectangle (an_x, a_y, a_width, a_height)
			drawable.set_foreground_color (create {EV_COLOR}.make_with_8_bit_rgb (((a_y + an_x).abs // 8) \\ 255, ((a_y + an_x).abs // 8) \\ 255, ((a_y + an_x).abs // 8) \\ 255))
			drawable.fill_ellipse (an_x, a_y, a_width, a_height)
		end
		
	single_item_selection_button_selected is
			-- Called by `select_actions' of `single_item_selection_button'.
		do
			grid.enable_single_item_selection
		end
	
	single_row_selection_button_selected is
			-- Called by `select_actions' of `single_row_selection_button'.
		do
			grid.enable_single_row_selection
		end
	
	multiple_item_selection_button_selected is
			-- Called by `select_actions' of `multiple_item_selection_button'.
		do
			grid.enable_multiple_item_selection
		end
	
	multiple_row_selection_button_selected is
			-- Called by `select_actions' of `multiple_row_selection_button'.
		do
			grid.enable_multiple_row_selection
		end
		
	set_selected_row_as_subnode_button_selected is
			-- Called by `select_actions' of `set_selected_row_as_subnode_button'.
		local
			selected_items: ARRAYED_LIST [EV_GRID_ITEM]
			selected_rows: ARRAYED_LIST [EV_GRID_ROW]
			current_row: EV_GRID_ROW
		do
			if grid.is_multiple_item_selection_enabled then
				selected_items := grid.selected_items
			else
				selected_rows := grid.selected_rows
				from
					selected_rows.start
				until
					selected_rows.off
				loop
					current_row := selected_rows.item
					grid.row (current_row.index - 1).add_subrow (current_row)
					selected_rows.forth
				end
			end
		end
		
	clear_selection_button_selected is
			-- Called by `select_actions' of `clear_selection_button'.
		do
			grid.remove_selection
		end
	
	select_row_button_selected is
			-- Called by `select_actions' of `select_row_button'.
		local
			warning_dialog: EV_WARNING_DIALOG
		do
			if select_row_spin_button.value >= 1 and select_row_spin_button.value <= grid.row_count then
				grid.select_row (select_row_spin_button.value)
			else
				create warning_dialog.make_with_text ("Unable to select row as you have not entered a valid row index.")
				warning_dialog.show_modal_to_window (main_window)
			end
		end
	
	select_column_button_selected is
			-- Called by `select_actions' of `select_column_button'.
		local
			warning_dialog: EV_WARNING_DIALOG
		do
			if select_column_spin_button.value >= 1 and select_column_spin_button.value <= grid.column_count then
				grid.select_column (select_column_spin_button.value)
			else
				create warning_dialog.make_with_text ("Unable to select column as you have not entered a valid column index.")
				warning_dialog.show_modal_to_window (main_window)
			end
		end
		
	select_item_button_selected is
			-- Called by `select_actions' of `select_item_button'.
		local
			warning_dialog: EV_WARNING_DIALOG
		do
			if select_item_x_spin_button.value >= 1 and select_item_x_spin_button.value <= grid.column_count and 
			select_item_y_spin_button.value >= 1 and select_item_y_spin_button.value <= grid.row_count then
				grid.item (select_item_y_spin_button.value, select_item_y_spin_button.value).enable_select
			else
				create warning_dialog.make_with_text ("Unable to select item as you have not entered a valid coordinate.")
				warning_dialog.show_modal_to_window (main_window)
			end
		end
		
	selected_items_button_selected is
			-- Called by `select_actions' of `selected_items_button'.
		local
			show_selection_dialog: SHOW_SELECTION_DIALOG
			selected_items: ARRAYED_LIST [EV_GRID_ITEM]
			selected_item_texts: ARRAYED_LIST [STRING]
			l_string: STRING
			current_item: EV_GRID_ITEM
			grid_label_item: EV_GRID_LABEL_ITEM
		do
			selected_items := grid.selected_items
			create selected_item_texts.make (selected_items.count)
			from
				selected_items.start
			until
				selected_items.off
			loop
				current_item := selected_items.item
				l_string := "Item " + current_item.column.index.out + ", " + current_item.row.index.out
				grid_label_item ?= current_item
				if grid_label_item /= Void then
					l_string.append ("      text : " + grid_label_item.text.out)
				end
				selected_item_texts.extend (l_string)
				selected_items.forth
			end
			
			create show_selection_dialog
			show_selection_dialog.populate (selected_item_texts)
			show_selection_dialog.set_title ("Selected Items")
			show_selection_dialog.show_modal_to_window (main_window)
		end
	
	selected_rows_button_selected is
			-- Called by `select_actions' of `selected_rows_button'.
		local
			show_selection_dialog: SHOW_SELECTION_DIALOG
			selected_rows: ARRAYED_LIST [EV_GRID_ROW]
			selected_row_texts: ARRAYED_LIST [STRING]
			l_string: STRING
			current_row: EV_GRID_ROW
		do
			selected_rows := grid.selected_rows
			create selected_row_texts.make (selected_rows.count)
			from
				selected_rows.start
			until
				selected_rows.off
			loop
				current_row := selected_rows.item
				l_string := "Row " + current_row.index.out
				selected_row_texts.extend (l_string)
				selected_rows.forth
			end
			
			create show_selection_dialog
			show_selection_dialog.populate (selected_row_texts)
			show_selection_dialog.set_title ("Selected Rows")
			show_selection_dialog.show_modal_to_window (main_window)
		end
		
	subrow_indent_button_changed (a_value: INTEGER) is
			-- Called by `change_actions' of `subrow_indent_button'.
		do
			grid.set_subrow_indent (a_value)
		end
		
	set_background_color_button_selected is
			-- Called by `select_actions' of `set_background_color_button'.
		do
		end
	
	set_background_color_combo_selected is
			-- Called by `select_actions' of `set_background_color_combo'.
		local
			selected_items: ARRAYED_LIST [EV_GRID_ITEM]
			color: EV_COLOR
		do
			color ?= set_background_color_combo.selected_item.data
			selected_items := grid.selected_items
			if not selected_items.is_empty then
				from
					selected_items.start
				until
					selected_items.off
				loop
					selected_items.item.set_background_color (color)
					selected_items.forth
				end
			end
		end
		
	add_color_to_background_color_combo (a_color: EV_COLOR) is
			-- Add `a_color' to `background_color_combo'.
		local
			pixmap: EV_PIXMAP
			list_item: EV_LIST_ITEM
		do
			create pixmap
			pixmap.set_size (16, 16)
			pixmap.set_foreground_color (a_color)
			pixmap.fill_rectangle (0, 0, 16, 16)
			pixmap.set_foreground_color ((create {EV_STOCK_COLORS}).black)
			pixmap.draw_rectangle (0, 0, 16, 16)
			create list_item
			list_item.set_pixmap (pixmap)
			list_item.set_data (a_color)
			set_background_color_combo.extend (list_item)
		end
		
	subnode_pixmaps_combo_selected is
			-- Called by `select_actions' of `subnode_pixmaps_combo'.
		local
			l_index: INTEGER
		do
			l_index := subnode_pixmaps_combo.index_of (subnode_pixmaps_combo.selected_item, 1)
			if l_index = 1 then
				grid.set_node_pixmaps (expand1, collapse1)
			elseif l_index = 2 then
				grid.set_node_pixmaps (expand2, collapse2)
			elseif l_index = 3 then
				grid.set_node_pixmaps (expand3, collapse3)
			end
		end
		
	expand_all_button_selected is
			-- Called by `select_actions' of `expand_all_button'.
		local
			counter: INTEGER
			current_row: EV_GRID_ROW
		do
			from
				counter := 1
			until
				counter > grid.row_count
			loop
				current_row := grid.row (counter)
				if current_row.subrow_count > 0 then
					current_row.expand			
				end
				counter := counter + 1
			end
		end
	
	collapse_all_button_selected is
			-- Called by `select_actions' of `collapse_all_button'.
		local
			counter: INTEGER
			current_row: EV_GRID_ROW
		do
			from
				counter := 1
			until
				counter > grid.row_count
			loop
				current_row := grid.row (counter)
				if current_row.subrow_count > 0 then
					current_row.collapse			
				end
				counter := counter + 1
			end
		end
		
	tree_lines_enabled_selected is
			-- Called by `select_actions' of `tree_lines_enabled'.
		do
			if tree_lines_enabled.is_selected then
				grid.show_tree_node_connectors
			else
				grid.hide_tree_node_connectors
			end
		end
		
	selection_on_click_selected is
			-- Called by `select_actions' of `selection_on_click'.
		do
			if selection_on_click.is_selected then
				grid.enable_selection_on_click
			else
				grid.disable_selection_on_click
			end
		end
		
	custom_button_selected is
			-- Called by `select_actions' of `custom_button'.
		local
			l_item: EV_GRID_ITEM
		do
			l_item := grid.item_at_virtual_position (200, 16)
--			misc_button_selected
--			grid.column (3).set_width (200)
--			grid.column (4).set_width (200)
--			grid.enable_horizontal_scrolling_per_item
			
		end

end -- class GRID_TAB

