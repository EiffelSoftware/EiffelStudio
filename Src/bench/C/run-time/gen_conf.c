/*
doc:<file name="gen_conf.c" header="eif_gen_conf.h" version="$Id$" summary="Generic conformance">
*/

#include "eif_portable.h"
#include "rt_macros.h"
#include "eif_globals.h"
#include "rt_struct.h"
#include "rt_gen_conf.h"
#include "rt_gen_types.h"
#include "rt_lmalloc.h"
#include "rt_threads.h"
#include "rt_garcol.h"
#include "rt_assert.h"
#include <ctype.h>
#include <string.h>

/*------------------------------------------------------------------*/
/* Debugging flag. If set, the names of the generated types will be */
/* output to the file 'logfile'. Simple facility.                   */
/*------------------------------------------------------------------*/

/*
#define GEN_CONF_DEBUG
*/
#ifdef GEN_CONF_DEBUG
rt_public void log_puts (char *);
rt_public void log_puti (int);
#define logfile "gentypes.log"
#endif

/*
doc:	<attribute name="eif_par_table" return_type="struct eif_par_types **" export="shared">
doc:		<summary>Parent tables. Defined by compiler C generated code in `eparents.c'. Changes to this table after melt are stored in melted file and processed by `updated.c' and stored in `eif_par_table2'.</summary>
doc:		<access>Read only through macro `par_info'.</access>
doc:		<indexing>base id; RTUD(no)</indexing>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None since initialized during runtime initialization.</synchronization>
doc:	</attribute>
doc:	<attribute name="eif_par_table_size" return_type="int" export="shared">
doc:		<summary>Size of `eif_par_table' table.</summary>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None since initialized during runtime initialization.</synchronization>
doc:	</attribute>
doc:	<attribute name="eif_par_table2" return_type="struct eif_par_types **" export="shared">
doc:		<summary>Same as `eif_par_table' except that this one contains both the static definition generated by compiler in `eparents.c' and the melted definition contained in melted file.</summary>
doc:		<access>Read only through macro `par_info'.</access>
doc:		<indexing>base id; RTUD(no)</indexing>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None since initialized during runtime initialization.</synchronization>
doc:	</attribute>
doc:	<attribute name="eif_par_table2_size" return_type="int" export="shared">
doc:		<summary>Size of `eif_par_table2' table.</summary>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None since initialized during runtime initialization.</synchronization>
doc:	</attribute>
*/
rt_shared struct eif_par_types **eif_par_table = NULL;
rt_shared int    eif_par_table_size = 0;
rt_shared struct eif_par_types **eif_par_table2 = NULL;
rt_shared int    eif_par_table2_size = 0;

#define par_info(t) (eif_par_table2[(t)])

/*
doc:	<attribute name="rtud_inv" return_type="int16 *" export="private/public">
doc:		<summary>Inverse RTUD table. Only used in workbench mode with changing dynamic types.</summary>
doc:		<access>Read only</access>
doc:		<indexing>base id; RTUD(yes)</indexing>
doc:		<result>RTUD(no)</result>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None since initialized during runtime initialization in `eif_gen_conf_init'.</synchronization>
doc:	</attribute>
*/
#ifdef WORKBENCH
#ifdef EIF_THREADS
rt_private int16 *rtud_inv = (int16 *) 0;
#else
rt_public int16 *rtud_inv = (int16 *) 0;
#endif
#endif

/*
doc:	<attribute name="eif_cid_map" return_type="int16 *" export="public">
doc:		<summary>Compound id map. Maps compiler generated IDs to themselves and run-time generated IDs to their base IDs. In other word, map full dynamic type to dynamic type. Table is dynamically reallocated except in multithreaded mode where it is by default initialized to a count which represent the greatest type id (max of uint16).</summary>
doc:		<access>Read/Write (read with macros Deif_bid, Dtype and Mapped_flags)</access>
doc:		<indexing>full type id; RTUD(yes)</indexing>
doc:		<result>base id; RTUD(yes)</result>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None</synchronization>
doc:	</attribute>
doc:	<attribute name="eif_cid_size" return_type="int" export="private">
doc:		<summary>Number of elements in following structures `eif_cid_map', `eif_derivations', `eif_con_tab', `eif_anc_id_map' and `eif_conf_tab'.</summary>
doc:		<access>Read/Write</access>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>eif_gen_mutex</synchronization>
doc:	</attribute>
*/
rt_public int16  *eif_cid_map = (int16 *) 0;
rt_private int  eif_cid_size = 0;

/*
doc:	<attribute name="egc_any_dtype" return_type="int16" export="public">
doc:		<summary>Type of ANY. Used to create ARRAY [ANY] from the runtime (e.g. used for `strip'). Value computed in `eif_gen_conf_init'.</summary>
doc:		<result>RTUD(no)</result>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None since initialized during runtime initialization in `eif_gen_conf_init'.</synchronization>
doc:	</attribute>
doc:	<attribute name="tuple_static_type" return_type="int16" export="private">
doc:		<summary>Base id of TUPLE.</summary>
doc:		<result>RTUD(no)</result>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None since initialized during runtime initialization in `eif_gen_conf_init'.</synchronization>
doc:		<fixme>Shouldn't we use `egc_tup_dtype' instead?</fixme>
doc:	</attribute>
*/
rt_public int16 egc_any_dtype = 2; /* Precise value determined in init */
rt_private int16 tuple_static_type = -1;

/*------------------------------------------------------------------*/
/* Structure representing a generic derivation. We also use this    */
/* for BIT types to remember their sizes.                           */
/*------------------------------------------------------------------*/

typedef struct eif_gen_der {
	long                size;       /* Size of type array/ nr. of bits in BIT type */
	int16               hcode;      /* Hash code to speedup search */
	int16               *typearr;   /* Array of types (cid) */
									/* RTUD(no) */
	int16               stypearr[8];/* Small type array */
									/* RTUD(no) */
	int16               *gen_seq;   /* Id sequence which generates this type */
									/* RTUD(yes) */
	int16               sgen_seq[8];/* Small id sequence */
									/* RTUD(yes) */
	int16               *ptypes;    /* Parent types */
									/* RTUD(yes) */
	int16               sptypes[8]; /* Small parent types table */
									/* RTUD(yes) */
	int16               id;         /* Run-time generated id */
									/* RTUD(no) */
	int16               base_id;    /* Compiler generated (base) id */
									/* RTUD(no) */
	int16               first_id;   /* First matching compiler gen. id */
									/* RTUD(no) */
	char                *name;      /* Full type name */
	char                is_expanded;/* Is it an expanded type? */
	char                is_bit;     /* Is it a BIT type? */
	char                is_tuple;   /* Is it a TUPLE type? */
	char                is_array;   /* Is it an ARRAY type? */
	struct eif_gen_der  *next;      /* Next derivation */
} EIF_GEN_DER;
/*------------------------------------------------------------------*/
/* Structure for conformance information. The `lower' ids are the   */
/* usual compiler generated ids. The others are generated here.     */
/*                                                                  */
/* All ids are full type ids; RTUD(yes)                             */
/* Indexing: full type ids; RTUD(yes)                               */
/*------------------------------------------------------------------*/

typedef struct {
	int16           min_low_id;     /* Minimal lower conforming id */
	int16           max_low_id;     /* Maximal lower conforming id */
	int16           min_high_id;    /* Minimal high conforming id */
	int16           max_high_id;    /* Maximal high conforming id */
	unsigned char   *low_tab;       /* Bit table for lower ids */
	unsigned char   *high_tab;      /* Bit table for high ids */
	unsigned char   slow_tab [8];   /* Small bit table for low ids */
	unsigned char   shigh_tab [8];  /* Small bit table for high ids */
	unsigned char   *low_comp;      /* Bit table for computed lower conf. */
	unsigned char   *high_comp;     /* Bit table for computed high conf. */
	unsigned char   slow_comp [8];  /* Small bit table for computed low conf.*/
	unsigned char   shigh_comp [8]; /* Small bit table for computed high conf.*/
} EIF_CONF_TAB;
/*------------------------------------------------------------------*/
/* Structure for ancestor id information.                           */
/*------------------------------------------------------------------*/

typedef struct {
	int16           min_id;         /* Minimal ancestor id; RTUD(no) */
	int16           max_id;         /* Maximal ancestor id; RTUD(no) */
	int16           *map;           /* Ancestor id map.
									   Index : RTUD(no)
									   Result: RTUD(yes)
									*/
	int16           smap [8];       /* Small ancestor id map.
									   Index : RTUD(no)
									   Result: RTUD(yes)
									*/
} EIF_ANC_ID_MAP;
/*------------------------------------------------------------------*/

/*
doc:	<attribute name="first_gen_id" return_type="int" export="private">
doc:		<summary>base id of first generic type. All values below `first_gen_id' do not represent generic classes.</summary>
doc:		<access>Read</access>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None since initialized during runtime initialization in `eif_gen_conf_init'.</synchronization>
doc:	</attribute>
doc:	<attribute name="next_gen_id" return_type="int" export="private">
doc:		<summary>ID for next new generic derivation encountered during runtime execution.</summary>
doc:		<access>Read/Write</access>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>eif_gen_mutex</synchronization>
doc:	</attribute>
*/
rt_private int  first_gen_id = 0;
rt_private int  next_gen_id  = 0;

/*
doc:	<attribute name="eif_anc_id_map" return_type="EIF_ANC_ID_MAP **" export="private">
doc:		<summary>Ancestor ID maps.</summary>
doc:		<access>Read/Write</access>
doc:		<indexing>full type id; RTUD(yes)</indexing>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>eif_gen_mutex</synchronization>
doc:	</attribute>
doc:	<attribute name="eif_conf_tab" return_type="EIF_CONF_TAB **" export="private">
doc:		<summary>Conformance tables.</summary>
doc:		<access>Read/Write</access>
doc:		<indexing>full type id; RTUD(yes)</indexing>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>eif_gen_mutex</synchronization>
doc:	</attribute>
doc:	<attribute name="eif_derivations" return_type="EIF_GEN_DER **" export="private">
doc:		<summary>Generic derivations.</summary>
doc:		<access>Read/Write</access>
doc:		<indexing>full type id; RTUD(yes)</indexing>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>eif_gen_mutex</synchronization>
doc:	</attribute>
*/
rt_private EIF_ANC_ID_MAP **eif_anc_id_map = NULL;
rt_private EIF_CONF_TAB **eif_conf_tab = NULL;
rt_private EIF_GEN_DER **eif_derivations = NULL;

#ifndef EIF_THREADS
/*
doc:	<attribute name="cid_array" return_type="int16 [3]" export="private">
doc:		<summary>Static array used by `eif_gen_cid' for `dftype' that are not generics.</summary>
doc:		<access>Read/Write</access>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>Private per thread data</synchronization>
doc:	</attribute>
*/
rt_private int16 cid_array [3];

/*
doc:	<attribute name="non_generic_type_names" return_type="char **" export="private">
doc:		<summary>Array indexed by non generic type id which contains their associated type name.</summary>
doc:		<access>Read/Write</access>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>Private per thread data</synchronization>
doc:	</attribute>
*/
rt_private char ** non_generic_type_names = NULL;
#endif

/*------------------------------------------------------------------*/
/* THREADS.                                                         */
/* Calls to public routines are indirected and protected by a mutex */
/* The indirection avoids problems with recursive calls.            */
/*------------------------------------------------------------------*/

#ifdef  EIF_THREADS

/*
doc:	<attribute name="eif_gen_mutex" return_type="" export="shared">
doc:		<summary>Calls to public routines are indirected and protected by current mutex. Indirection is needed to avoids problem with recursive calls.</summary>
doc:		<access>Read</access>
doc:		<thread_safety>Safe</thread_safety>
doc:	</attribute>
*/
rt_shared EIF_LW_MUTEX_TYPE *eif_gen_mutex = (EIF_LW_MUTEX_TYPE *) 0;

rt_public int16 eifthd_compound_id (int16 *, int16, int16, int16 *);
rt_public int16 eifthd_final_id (int16, int16 *, int16 **, int16, int );
rt_shared int eifthd_gen_count_with_dftype (int16 );
rt_shared char eifthd_gen_typecode_with_dftype (int16 , int);
rt_public int16 eifthd_gen_param_id (int16, int16 , int);
rt_public EIF_REFERENCE eifthd_gen_create (EIF_REFERENCE , int);
rt_shared int16 eifthd_register_bit_type (long);
rt_shared int16 eifthd_typeof_array_of (int16);
rt_public char *eifthd_gen_typename (EIF_REFERENCE );
rt_shared int16 *eifthd_gen_cid (int16);
rt_shared int16 eifthd_gen_id_from_cid (int16 *, int *);
rt_public int eifthd_gen_conf (int16, int16);

#define EIFMTX_LOCK   EIF_LW_MUTEX_LOCK(eif_gen_mutex, "Cannot lock mutex for eif_gen_conf\n")
#define EIFMTX_UNLOCK EIF_LW_MUTEX_UNLOCK(eif_gen_mutex, "Cannot unlock mutex for eif_gen_conf\n")

#else
/* Noop for locks in non-multithreaded mode. */
#define EIFMTX_LOCK
#define EIFMTX_UNLOCK
#endif
/*------------------------------------------------------------------*/

rt_shared size_t eif_typename_len (int16 dftype);
rt_private int16 eif_gen_param (int16, int16, int, char *, long *);
rt_private void eif_create_typename (int16, char*);
rt_private EIF_GEN_DER *eif_new_gen_der(long, int16*, int16, char, char, int16);
rt_private EIF_ANC_ID_MAP *eif_new_anc_id_map (int16, int16);
rt_private void eif_compute_anc_id_map (int16);
rt_private void eif_expand_tables(int);
rt_private int16 eif_id_of (int16, int16**, int16**, int16, int16);
rt_private void eif_compute_ctab (int16);
rt_private EIF_CONF_TAB *eif_new_conf_tab (int16, int16, int16, int16);
rt_private void eif_enlarge_conf_tab (EIF_CONF_TAB *, int16);
rt_private int16 eif_gen_seq_len (int16);
rt_private void eif_put_gen_seq (int16, int16*, int16*, int16);

/*------------------------------------------------------------------*/

#ifdef WORKBENCH
#define RTUD_INV(x)  (((x) >= fcount)?(x):rtud_inv[(x)])

#else
#define RTUD_INV(x) (x)
#endif

/*
doc:	<routine name="eif_id_for_typarr" return_type="int16" export="public">
doc:		<summary>Perform call to RTUD_INV from generated code. Needed as RTUD_INV is not exported.</summary>
doc:		<param name="id" type="int16">Full dynamic type converted back to its associated RTUD_INV.</param>
doc:		<return>RTUD_INV of `id'</return>
doc:	</routine>
*/
rt_public int16 eif_id_for_typarr (int16 id) {
	REQUIRE ("Valid id", (id >= 0) || (id == NONE_TYPE));
	return (id == NONE_TYPE ? NONE_TYPE : RTUD_INV(id));
}


/*------------------------------------------------------------------*/

#ifdef EIF_THREADS

/*------------------------------------------------------------------*/
/* Public features protected with a MUTEX.                          */
/*------------------------------------------------------------------*/

rt_public int16 eif_compound_id (int16 *cache, int16 current_dftype, int16 base_id, int16 *types)
{
	int16   result;

	EIFMTX_LOCK;
	result = eifthd_compound_id (cache, current_dftype, base_id, types);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_public int16 eif_final_id (int16 stype, int16 *ttable, int16 **gttable, int16 dftype, int offset)
{
	int16   result;

	EIFMTX_LOCK;
	result = eifthd_final_id (stype, ttable, gttable, dftype, offset);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_shared int eif_gen_count_with_dftype (int16 dftype)
{
	int result;

	EIFMTX_LOCK;
	result = eifthd_gen_count_with_dftype (dftype);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_shared char eif_gen_typecode_with_dftype (int16 dftype, int pos)
{
	char    result;

	EIFMTX_LOCK;
	result = eifthd_gen_typecode_with_dftype (dftype, pos);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_public int16 eif_gen_param_id (int16 stype, int16 dftype, int pos)
{
	int16   result;

	EIFMTX_LOCK;
	result = eifthd_gen_param_id (stype, dftype, pos);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_public EIF_REFERENCE eif_gen_create (EIF_REFERENCE obj, int pos)
{
	char    *result;

	EIFMTX_LOCK;
	result = eifthd_gen_create (obj, pos);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_shared int16 eif_register_bit_type (long size)
{
	int16   result;

	EIFMTX_LOCK;
	result = eifthd_register_bit_type (size);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_shared int16 eif_typeof_array_of (int16 dtype)
{
	int16   result;

	EIFMTX_LOCK;
	result = eifthd_typeof_array_of (dtype);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_shared int16 *eif_gen_cid (int16 dftype)
{
	int16   *result;

	EIFMTX_LOCK;
	result = eifthd_gen_cid (dftype);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_shared int16 eif_gen_id_from_cid (int16 *a_cidarr, int *dtype_map)
{
	int16   result;

	EIFMTX_LOCK;
	result = eifthd_gen_id_from_cid (a_cidarr, dtype_map);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/

rt_public int eif_gen_conf (int16 source_type, int16 target_type)
{
	int result;

	EIFMTX_LOCK;
	result = eifthd_gen_conf (source_type, target_type);
	EIFMTX_UNLOCK;

	return result;
}
/*------------------------------------------------------------------*/
/* Rename public features if EIF_THREADS is on.                     */
/*------------------------------------------------------------------*/

#define eif_compound_id           eifthd_compound_id
#define eif_final_id              eifthd_final_id
#define eif_gen_count_with_dftype eifthd_gen_count_with_dftype
#define eif_gen_typecode_with_dftype  eifthd_gen_typecode_with_dftype
#define eif_gen_param_id          eifthd_gen_param_id
#define eif_gen_create            eifthd_gen_create
#define eif_register_bit_type     eifthd_register_bit_type
#define eif_typeof_array_of       eifthd_typeof_array_of
#define eif_gen_cid               eifthd_gen_cid
#define eif_gen_id_from_cid       eifthd_gen_id_from_cid
#define eif_gen_conf              eifthd_gen_conf

#endif

/*------------------------------------------------------------------*/
/* Initialize all structures                                        */
/* Called only once before root object is created.                  */
/*------------------------------------------------------------------*/

rt_shared void eif_gen_conf_init (int max_dtype)
{
	RT_GET_CONTEXT
	int    dt;
	char   *cname;
	struct eif_par_types **pt;

#ifdef EIF_THREADS
		/* Since we want to avoid any locks to happen on the access on 
		 * eif_cid_map, we make sure that `eif_cid_map' can't be resized
		 * by giving the maximum size it can have, ie 0x0000FFFF */
	eif_cid_size = 65535;
#else
	eif_cid_size = max_dtype + 32;
#endif
	first_gen_id = next_gen_id = max_dtype + 1;

	/* Set `eif_par_table2' if it is null. */

	if (eif_par_table2 == (struct eif_par_types **) 0)
	{
		eif_par_table2 = eif_par_table;
		eif_par_table2_size = eif_par_table_size;
	}

	eif_cid_map = (int16 *) eif_malloc (eif_cid_size * sizeof (int16));

	if (eif_cid_map == (int16 *) 0)
		enomem();

	eif_derivations = (EIF_GEN_DER **) eif_malloc(eif_cid_size * sizeof (EIF_GEN_DER*));

	if (eif_derivations == (EIF_GEN_DER **) 0)
		enomem();

	eif_conf_tab = (EIF_CONF_TAB **) eif_malloc(eif_cid_size * sizeof (EIF_CONF_TAB*));

	if (eif_conf_tab == (EIF_CONF_TAB **) 0)
		enomem();

	eif_anc_id_map = (EIF_ANC_ID_MAP **) eif_malloc(eif_cid_size * sizeof (EIF_ANC_ID_MAP*));

	if (eif_anc_id_map == (EIF_ANC_ID_MAP **) 0)
		enomem();

	/* Setup a 1-1 mapping and initialize the arrays */

	for (dt = 0; dt < eif_cid_size; ++dt)
	{
		eif_cid_map [dt]     = (int16) dt;
		eif_derivations [dt] = (EIF_GEN_DER *) 0;
		eif_conf_tab [dt]    = (EIF_CONF_TAB *) 0;
		eif_anc_id_map [dt]  = (EIF_ANC_ID_MAP *) 0;
	}

	/* Now initialize egc_xxx_dtypes */

	for (dt = 0, pt = eif_par_table2; dt <= eif_par_table2_size; ++dt, ++pt)
	{
		if (*pt == (struct eif_par_types *)0)
			continue;

		cname = (*pt)->class_name;

		if ((strcmp("ANY",cname)==0))
		{
			egc_any_dtype = (int16) dt;
		}

		if ((strcmp("TUPLE",cname)==0))
		{
			tuple_static_type = (int16) dt;
		}
	}

	/* Now setup inverse RTUD table. This is used
	   to undo the effect of RTUD(type) */

#ifdef WORKBENCH

	rtud_inv = (int16 *) eif_malloc (fcount * sizeof (int16));

	if (rtud_inv == (int16 *) 0)
		enomem();
	
	for (dt = 0; dt < fcount; ++dt)
	{
		if (par_info(dt) != (struct eif_par_types *) 0)
			rtud_inv [egc_fdtypes [dt]] = dt;
	}

	rtud_inv [0] = 0;	/* For the GENERAL class */

#endif

	/* Initialize `cid_array' */

	cid_array [0] = 1;  /* count */
	cid_array [1] = 0;  /* id */
	cid_array [2] = TERMINATOR; /* Terminator */

		/* Initialize `non_generic_type_names' for root thread now that `first_gen_id' is
		 * properly computed. Indeed the first call to `eif_gen_conf_thread_init' is done
		 * before `first_gen_id' is initialized and therefore does not allocate anything
		 * since `first_gen_id' is zero. The second call will do things properly.
		 */
	eif_gen_conf_thread_init();
}

/*
doc:	<routine name="eif_gen_conf_thread_init" return_type="void" export="shared">
doc:		<summary>Initialize per thread data used for generic conformance. Root thread initialization is done in `eif_gen_conf_init' as when we are called by the `eif_thr_register' routine, the value `first_gen_id' is still zero.</summary>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None</synchronization>
doc:	</routine>
*/
rt_shared void eif_gen_conf_thread_init (void) {
	RT_GET_CONTEXT
	if (first_gen_id > 0) {
		non_generic_type_names = (char **) eif_calloc (first_gen_id, sizeof (char *));
	}
}

/*
doc:	<routine name="eif_gen_conf_thread_cleanup" return_type="void" export="shared">
doc:		<summary>Initialize per thread data used for generic conformance.</summary>
doc:		<thread_safety>Safe</thread_safety>
doc:		<synchronization>None</synchronization>
doc:	</routine>
*/
rt_shared void eif_gen_conf_thread_cleanup (void) {
	RT_GET_CONTEXT
	char *l_name;
	int i = 0;

	for (; i < first_gen_id; i++) {
		l_name = non_generic_type_names [i];
		if (l_name) {
			eif_free (l_name);
		}
	}
	eif_free (non_generic_type_names);
	non_generic_type_names = NULL;
}

/*------------------------------------------------------------------*/
/* Clean up.                                                        */
/* Called from reclaim, and free all global variables allocated     */
/* for the Generic Conformance.                                     */
/*------------------------------------------------------------------*/
rt_shared void eif_gen_conf_cleanup () 
{
	/* Free in reverse order of allocation. */

	int i, j;

#ifdef EIF_THREADS
	REQUIRE ("Called by root thread", eif_thr_is_root ());
#endif	/* EIF_THREADS */
	REQUIRE ("eif_anc_id_map not null", eif_anc_id_map);
	REQUIRE ("eif_conf_tab not null", eif_conf_tab);
	REQUIRE ("eif_derivations not null", eif_derivations);
	REQUIRE ("eif_cid_map not null", eif_cid_map);

#ifdef WORKBENCH
	eif_free (rtud_inv);	/* (int16 *) */
#endif	/* WORKBENCH */

	/* Recursively free eif_anc_id_map */
	for (i = 0; i < eif_cid_size; i++) {
		EIF_ANC_ID_MAP *tmp = eif_anc_id_map [i];

		if (tmp == (EIF_ANC_ID_MAP *) 0)
			continue;
		if (tmp->map != tmp->smap)
			eif_free (tmp->map);	/* int16 * */
		else {
#ifdef LMALLOC_CHECK
			CHECK ("", !(is_in_lm (tmp->map)));
#endif	/* LMALLOC_CHECK */
		}
		eif_free (tmp);
	}
	eif_free (eif_anc_id_map);	

	/* Recursively free eif_conf_tab */
	for (i = 0; i < eif_cid_size; i++) {
		EIF_CONF_TAB *tmp = eif_conf_tab [i];	

		if (tmp == (EIF_CONF_TAB *) 0)
			continue;

		if (tmp->low_tab != tmp->slow_tab)
			eif_free (tmp->low_tab);	/* unsigned char * */
		else {
#ifdef LMALLOC_CHECK
			CHECK ("", !(is_in_lm (tmp->low_tab)));
#endif	/* LMALLOC_CHECK */
		}
		if (tmp->high_tab != tmp->shigh_tab)
			eif_free (tmp->high_tab);	/* unsigned char * */
		else {
#ifdef LMALLOC_CHECK
			CHECK ("", !(is_in_lm (tmp->high_tab)));
#endif	/* LMALLOC_CHECK */
		}
		if (tmp->low_comp != tmp->slow_comp)	
			eif_free (tmp->low_comp);	 	/* unsigned char * */
		else {
#ifdef LMALLOC_CHECK
			CHECK ("", !(is_in_lm (tmp->low_comp)));
#endif	/* LMALLOC_CHECK */
		}
		if (tmp->high_comp != tmp->shigh_comp)	
			eif_free (tmp->high_comp);	 	/* unsigned char * */
		else {
#ifdef LMALLOC_CHECK
			CHECK ("", !(is_in_lm (tmp->high_comp)));
#endif	/* LMALLOC_CHECK */
		}
		eif_free (tmp);
	}
	eif_free (eif_conf_tab);	

	/* Recursively free eif_derivations. */
	for (i = 0; i < eif_cid_size; i++) {
		EIF_GEN_DER *tmp = eif_derivations [i];

		if (tmp == (EIF_GEN_DER *) 0)
			continue;
		if (tmp->typearr != tmp->stypearr)
			eif_free (tmp->typearr);			/* int16 * */
		else {
#ifdef LMALLOC_CHECK
			CHECK ("", !(is_in_lm (tmp->typearr)));
#endif	/* LMALLOC_CHECK */
		}
		if (tmp->gen_seq != tmp->sgen_seq)
			eif_free (tmp->gen_seq);			/* int16 * */
		else {
#ifdef LMALLOC_CHECK
			CHECK ("", !(is_in_lm (tmp->gen_seq)));
#endif	/* LMALLOC_CHECK */
		}
		if (tmp->ptypes != tmp->sptypes)
			eif_free (tmp->ptypes);		/* int16 * */
		else {
#ifdef LMALLOC_CHECK
			CHECK ("", !(is_in_lm (tmp->ptypes)));
#endif	/* LMALLOC_CHECK */
		}
		eif_free (tmp->name);			/* char * */
		for (j = i + 1; j < eif_cid_size; j++) {
			if (eif_derivations [j] == tmp)	
				eif_derivations[j] = (EIF_GEN_DER *) 0;
				
		}
		eif_free (tmp);
	}
	eif_free (eif_derivations);	

	eif_free (eif_cid_map);		/* (int16 *) */
#ifndef EIF_THREADS
	eif_gen_conf_thread_cleanup();
#endif
} /* eif_gen_conf_cleanup () */

/*------------------------------------------------------------------*/
/* Compute id for `types'. `cache' is used to cache the result in   */
/* the generated C code if possible.                                */
/*                                                                  */
/* cache   : To cache result; RTUD(yes)                             */
/* base_id : Base id of type; RTUD(no)                              */
/* types   : Id array; RTUD(no)                                     */
/* Result  : Resulting id; RTUD(yes)                                */
/*------------------------------------------------------------------*/

rt_public int16 eif_compound_id (int16 *cache, int16 current_dftype, int16 base_id, int16 *types)
{
	int16   result, gresult;
	int16   outtab [256], *outtable, *intable;

	result = base_id;

	if ((types != (int16 *)0) && (*(types+1) != TERMINATOR))
	{
		/* Check if it's cached - if yes return immediately */

		if ((cache) && (*cache != TERMINATOR))
		{
#ifdef GEN_CONF_DEBUG
			log_puts ("Cached -> ");
			log_puts (eif_typename(*cache));
			log_puts ("\r\n");
#endif
			return *cache;
		}

#ifdef GEN_CONF_DEBUG
		intable = types;
		log_puts ("{");
		while (*intable != TERMINATOR)
		{
			log_puti ((int) *intable);
			log_puts (",");
			++intable;
		}

		log_puts ("TERMINATOR} -> ");
#endif

		intable  = types+1;
		outtable = outtab;

		gresult = eif_id_of (*types, &intable, &outtable, current_dftype, 1);
		
#ifdef GEN_CONF_DEBUG
		log_puts (eif_typename(gresult));
		log_puts (" Dftype = ");
		log_puti ((int) gresult);
#endif

		if (cache) {
#ifdef GEN_CONF_DEBUG
			log_puts (" CACHED");
#endif
			*cache = gresult;
		}

#ifdef GEN_CONF_DEBUG
		log_puts ("\r\n");
#endif

		return gresult;
	}

	return RTUD(result);
}

/*------------------------------------------------------------------*/
/* Compute id for `gttable' (generic type list for feature in final */
/* mode).                                                           */
/*                                                                  */
/* stype  : static type of caller; RTUD(no)                         */
/* Result : RTUD(yes); doesn't matter since in final mode           */
/*------------------------------------------------------------------*/

rt_public int16 eif_final_id (int16 stype, int16 *ttable, int16 **gttable, int16 dftype, int offset)

{
	int16   result, *gtp;
	int16	dtype = Deif_bid(dftype);
	int	table_index = dtype - offset;

	if (gttable != (int16 **) 0)
	{
		gtp = gttable [table_index];

		if ((gtp != (int16 *) 0) && (*(gtp+1) != TERMINATOR))
		{
			*gtp = dtype;
			return eif_compound_id ((int16 *)0, dftype, ttable[table_index], gtp);
		}
	}

	result = ttable[table_index];

	return result;
}
/*------------------------------------------------------------------*/
/* Extract actual generic at position `pos' (>=1) from object `obj'.*/
/* `is_exp' is set to a non-zero value if type is expanded else it's*/
/* set to zero. `nr_bits' is > 0 if type is BIT, zero otherwise -   */
/* the value can then be used to call RTLB(nr_bits).                */
/*                                                                  */
/* stype : type of caller; RTUD(no)                                 */
/* Result: RTUD(yes)                                                */
/*------------------------------------------------------------------*/

rt_private int16 eif_gen_param (int16 stype, int16 dftype, int pos, char *is_exp, long *nr_bits)
{
	int16 result;
	EIF_GEN_DER *gdp;
	EIF_ANC_ID_MAP *amap;

	REQUIRE("Valid type", (dftype >= 0) && (dftype < next_gen_id));

	/* get actual generic from `stype' for descendant
	   `dftype' if stype >= 0 else use dftype.
	*/

	if (stype >= 0)
	{
		amap = eif_anc_id_map [dftype];

		if (amap == (EIF_ANC_ID_MAP *) 0)
		{
			eif_compute_anc_id_map (dftype);
			amap = eif_anc_id_map [dftype];
		}

		gdp = eif_derivations [(amap->map)[stype - (amap->min_id)]];
	}
	else
	{
		gdp = eif_derivations [dftype];
	}

	CHECK("A generic type", gdp && (!gdp->is_bit));
	CHECK("Valid generic parameter position", (pos > 0) && (pos <= gdp->size));

	*is_exp = (char) 0;
	*nr_bits = 0;

	result = gdp->typearr [pos-1];

	if (result < first_gen_id) {
		*is_exp = EIF_IS_EXPANDED_TYPE(System (RTUD(result)));
		return RTUD(result);
	}

	gdp = eif_derivations [result];

		/* Is it an expanded type? If yes set the `is_exp' flag. */
	if ((gdp != NULL) && (gdp->is_expanded))
		*is_exp = '1';

		/* Is it a BITn type? If yes set the number of bits */
	if ((gdp != NULL) && (gdp->is_bit))
		*nr_bits = gdp->size;

	return result;
}
/*------------------------------------------------------------------*/
/* Number of generic parameters of `obj's type. Can ONLY be used for*/
/* TUPLE and its descendants!                                       */
/*------------------------------------------------------------------*/

rt_public int eif_gen_count_with_dftype (int16 dftype)
{
	EIF_GEN_DER *gdp;

	REQUIRE("Valid type", (dftype >= 0) && (dftype < next_gen_id));

	gdp = eif_derivations [dftype];

	return (gdp ? gdp->size : 0);
}

/*------------------------------------------------------------------*/
/* Number of generic parameters of `obj's type. Can ONLY be used for*/
/* TUPLE                                                            */
/*------------------------------------------------------------------*/

rt_public int eif_tuple_count (EIF_REFERENCE obj)
{
	return (obj ? RT_SPECIAL_COUNT(obj) - 1 : 0);
}

/*------------------------------------------------------------------*/
/* Are all generic parameters of basic types? Can ONLY be used for  */
/* TUPLE                                                            */
/*------------------------------------------------------------------*/

rt_shared int eif_tuple_is_atomic (EIF_REFERENCE obj)
{
	EIF_ARG_UNION *l_item = (EIF_ARG_UNION *) obj;
	unsigned int count;
	
	if (obj == NULL) {
			/* This is atomic */
		return 1;
	}

	CHECK("Tuple object", HEADER(obj)->ov_flags & EO_TUPLE);
	count = RT_SPECIAL_COUNT(obj);

		/* Don't forget that first element of TUPLE is just a placeholder
		 * to avoid offset computation from Eiffel code */
	l_item++;
	for (; count > 0 ; count--) {
		if (eif_tuple_item_type(l_item) == EIF_REFERENCE_CODE) {
				/* It has a reference. This is therefore not atomic */
			return 0;
		}
	}
		/* No reference found. It is atomic */
	return 1;
}

/*------------------------------------------------------------------*/
/* Typecode of generic type at position `pos' in `obj'. ONLY for    */
/* TUPLE                                                            */
/*------------------------------------------------------------------*/

rt_public char eif_gen_typecode (EIF_REFERENCE obj, int pos)
{
	if (obj == NULL) {
		return (char) 0;
	} else {
		char result;
			/* Critical section as we might compute a new `eif_anc_id_map' entry */
		EIFMTX_LOCK;
		result = eif_gen_typecode_with_dftype ((int16) Dftype(obj), pos);
		EIFMTX_UNLOCK;
		return result;
	}
}

rt_shared char eif_gen_typecode_with_dftype (int16 dftype, int pos)
{
	int16 gtype;
	EIF_GEN_DER *gdp;
	EIF_ANC_ID_MAP *amap;

		/* Check type validity */
	REQUIRE ("dftype is non-negative", dftype >= 0);
	REQUIRE ("dftype is less than maximum computed id", dftype < next_gen_id);
	REQUIRE ("We have routines, so we must have tuples.", tuple_static_type >= 0);

	amap = eif_anc_id_map [dftype];

	if (amap == (EIF_ANC_ID_MAP *) 0)
	{
		eif_compute_anc_id_map (dftype);
		amap = eif_anc_id_map [dftype];
	}

	gdp = eif_derivations [(amap->map)[tuple_static_type - (amap->min_id)]];

	CHECK ("gdp not null", gdp != (EIF_GEN_DER *)0);
	CHECK ("Not a bit type", !gdp->is_bit);

	CHECK ("Valid generic position min", pos > 0);
	CHECK ("Valid generic position max", pos <= gdp->size);

	gtype = gdp->typearr [pos-1];

	if (gtype == NONE_TYPE) {
		return EIF_REFERENCE_CODE;
	}

	return EIF_TUPLE_CODE(System(eif_cid_map[RTUD(gtype)]));
}

/*------------------------------------------------------------------*/
/* Typecode string for target/argument types of a ROUTINE object.   */
/* ONLY for ROUTINE!                                                */
/*------------------------------------------------------------------*/

rt_public EIF_REFERENCE eif_gen_typecode_str (EIF_REFERENCE obj)
{
	EIF_GET_CONTEXT

	EIF_REFERENCE ret;	/* Return value. */
	int16 dftype, gtype;
	int len;
	int pos;
	EIF_GEN_DER *gdp;
	EIF_ANC_ID_MAP *amap;
	char *strp;

	REQUIRE ("obj not null", obj != (EIF_REFERENCE )0);

	dftype = Dftype(obj);

	REQUIRE ("Non negative dftype", dftype >= 0);
	REQUIRE ("Valid dftype", dftype < next_gen_id);

	gdp = eif_derivations [dftype];

	CHECK ("gdp not null", gdp != (EIF_GEN_DER *)0);
	CHECK ("Not a bit type", !gdp->is_bit);
	CHECK ("Not a routine object", gdp->size > 1);

		/* Type of call target */
	gtype = gdp->typearr [0];

		/* Now treat the arguments.  This is necessarily a TUPLE */
	dftype = gdp->typearr [1];

	CHECK ("Non negative dftype", dftype >= 0);
	CHECK ("Valid dftype", dftype < next_gen_id);
	CHECK ("Routines implies we have tuples", tuple_static_type >= 0);

	/* NOTE: Since dftype is a TUPLE we have RTUD(dftype) = dftype.  */

		/* Critical section as we might compute a new `eif_anc_id_map' entry */
	EIFMTX_LOCK;
	amap = eif_anc_id_map [dftype];
	if (amap == (EIF_ANC_ID_MAP *) 0) {
		eif_compute_anc_id_map (dftype);
		amap = eif_anc_id_map [dftype];
	}
	EIFMTX_UNLOCK;

	gdp = eif_derivations [(amap->map)[tuple_static_type - (amap->min_id)]];

	CHECK ("gdp not null", gdp != (EIF_GEN_DER *)0);
	CHECK ("Not a bit type", !gdp->is_bit);

		/* Create a string for gdp->size + 1 characters */
	len = gdp->size + 1;

	ret = emalloc(egc_str_dtype);
	RT_GC_PROTECT(ret);
		/* Protect address in case it moves */

	nstcall = 0;
	(egc_strmake)(ret, (EIF_INTEGER) len);
	RT_STRING_SET_COUNT(ret, len);

	/* We know the `area' is the very first reference
	 * of the STRING object, hence the simple de-referencing.
	 */

	strp = *(EIF_REFERENCE*)ret;

	*strp = EIF_TUPLE_CODE(System(eif_cid_map[RTUD(gtype)]));
	strp++;

	for (pos = 0; pos < gdp->size; pos++, strp++) {
		gtype = gdp->typearr [pos];
		if (gtype == NONE_TYPE) {
			*strp = EIF_REFERENCE_CODE;
		} else {
			*strp = EIF_TUPLE_CODE(System(eif_cid_map[RTUD(gtype)]));
		}
	}

	RT_GC_WEAN(ret);			/* Remove protection */

	return ret;	
}

/*------------------------------------------------------------------*/
/* Typecode string for closed argument types of a ROUTINE object.   */
/* ONLY for TUPLE!                                                  */
/*------------------------------------------------------------------*/

rt_public EIF_REFERENCE eif_gen_tuple_typecode_str (EIF_REFERENCE obj)
{
	EIF_GET_CONTEXT

	EIF_REFERENCE ret;	/* Return value. */
	int16 dftype, gtype;
	int len;
	int pos;
	EIF_GEN_DER *gdp;
	EIF_ANC_ID_MAP *amap;
	char *strp;

	REQUIRE ("obj not null", obj != (EIF_REFERENCE )0);

	dftype = Dftype(obj);

	REQUIRE ("Non negative dftype", dftype >= 0);
	REQUIRE ("Valid dftype", dftype < next_gen_id);

#ifdef EIF_ASSERTIONS
	gdp = eif_derivations [dftype];
#endif

	CHECK ("gdp not null", gdp != (EIF_GEN_DER *)0);
	CHECK ("Not a bit type", !gdp->is_bit);
	CHECK ("We have routines, so we must have tuples.", tuple_static_type >= 0);

	/* NOTE: Since dftype is a TUPLE we have RTUD(dftype) = dftype.  */

		/* Critical section as we might compute a new `eif_anc_id_map' entry */
	EIFMTX_LOCK;
	amap = eif_anc_id_map [dftype];
	if (amap == (EIF_ANC_ID_MAP *) 0) {
		eif_compute_anc_id_map (dftype);
		amap = eif_anc_id_map [dftype];
	}
	EIFMTX_UNLOCK;

	gdp = eif_derivations [(amap->map)[tuple_static_type - (amap->min_id)]];

	CHECK ("gdp not null", gdp != (EIF_GEN_DER *)0);
	CHECK ("Not a bit type", !gdp->is_bit);

		/* Create a string for gdp->size characters */
	len = gdp->size;

	ret = emalloc(egc_str_dtype);
	RT_GC_PROTECT(ret);
		/* Protect address in case it moves */

	nstcall = 0;
	(egc_strmake)(ret, (EIF_INTEGER) len);
	RT_STRING_SET_COUNT(ret, len);

	/* We know the `area' is the very first reference
	 * of the STRING object, hence the simple de-referencing.
	 */

	RT_GC_WEAN(ret);			/* Remove protection */

	strp = *(EIF_REFERENCE*)ret;

	for (pos = 0; pos < len; pos++, strp++) {
		gtype = gdp->typearr [pos];
		if (gtype == NONE_TYPE) {
			*strp = EIF_REFERENCE_CODE;
		} else {
			*strp = EIF_TUPLE_CODE(System(eif_cid_map[RTUD(gtype)]));
		}
	}

	return ret;	
}

/*------------------------------------------------------------------*/
/* Type of generic parameter in `obj' at position `pos'.            */
/*                                                                  */
/* stype : Type of caller; RTUD(no)                                 */
/* Result: RTUD(yes)                                                */
/*------------------------------------------------------------------*/

rt_public int16 eif_gen_param_id (int16 stype, int16 dftype, int pos)

{
	char    is_expanded;
	long    nr_bits;

	REQUIRE("Valid type", (dftype >= 0) && (dftype < next_gen_id));

	return eif_gen_param (stype, dftype, pos, &is_expanded, &nr_bits);
}
/*------------------------------------------------------------------*/
/* Create an object with the same type as the type of the generic   */
/* parameter at position `pos' in `obj'.                            */
/*------------------------------------------------------------------*/

rt_public EIF_REFERENCE eif_gen_create (EIF_REFERENCE obj, int pos)
{
	int16   result_type;
	char    is_expanded;
	long    nr_bits;

	REQUIRE("obj not null", obj);

	result_type = eif_gen_param (-1, (int16) Dftype(obj), pos, &is_expanded, &nr_bits);

#ifndef WORKBENCH
	if (is_expanded)
	{
		eif_panic ("Expanded generic parameter.");
	}
#endif

	/* Is it a BIT type? */

	if (nr_bits > 0)
		return RTLB(nr_bits);

#ifdef WORKBENCH
	/* Is it expanded? */

	if (is_expanded)
		return RTLX(result_type);
#endif

	/* Check for basic types */

	if (result_type < 0)
		eif_panic ("Cannot create basic type.");

	return RTLN(result_type);
}
/*------------------------------------------------------------------*/
/* Register a bit type. Return its type id.                         */
/*                                                                  */
/* Result : RTUD(yes) (doesn't matter actually)                     */
/*------------------------------------------------------------------*/

rt_shared int16 eif_register_bit_type (long size)
{
	int16 dftype;
	EIF_GEN_DER *gdp, *prev;

	/* Search for BIT type of size *intab */

	dftype = egc_bit_dtype;
	gdp    = eif_derivations [dftype];
	prev   = (EIF_GEN_DER *) 0;

	while (gdp != (EIF_GEN_DER *) 0)
	{
		if (size == gdp->size)
		{
			break; /* Found */
		}
		prev = gdp;
		gdp  = gdp->next;
	}

	if (gdp == (EIF_GEN_DER *)0)
	{
		/* Not found: we need a new id */

		gdp = eif_new_gen_der(size, (int16*)0, dftype, '1', (char) 0, 0);

		if (prev == (EIF_GEN_DER *)0) {
			eif_derivations [dftype] = gdp;
		} else {
			prev->next = gdp;
		}
		eif_derivations[gdp->id] = gdp; /* Self-reference */
	}

	return gdp->id;
}
/*------------------------------------------------------------------*/
/* Type id for ARRAY [something], where 'something' is a reference  */
/* type.                                                            */
/* dtype : full type id; RTUD(yes)                                  */
/* Result : RTUD(yes) (doesn't matter actually)                     */
/*------------------------------------------------------------------*/

rt_shared int16 eif_typeof_array_of (int16 dtype)
{
	int16   *typearr, arr_dtype, result;

	arr_dtype = RTUD_INV(egc_arr_dtype);

	typearr = (int16 *) eif_malloc (4 * sizeof(int16));
	typearr [0] = -1;						/* No static call context */
	typearr [1] = RTUD_INV(egc_arr_dtype);	/* Base type of ARRAY     */
	typearr [2] = RTUD_INV(dtype);			/* Parameter type */
	typearr [3] = TERMINATOR;

	result = eif_compound_id (NULL, (int16) 0, typearr[1], typearr);
	eif_free (typearr);
	return result;
}
/*------------------------------------------------------------------*/
/* Full type name of `obj' as STRING object.                        */
/*------------------------------------------------------------------*/

rt_public EIF_REFERENCE eif_gen_typename_of_type (int16 current_dftype)
{
	char    *name;
	EIF_REFERENCE ret;	/* Return value. */

	EIFMTX_LOCK;
	name = eif_typename (current_dftype);
	EIFMTX_UNLOCK;

	ret = makestr(name, strlen(name));
	return ret;
}
/*------------------------------------------------------------------*/
/* CID which generates `dftype'. First entry is the length of the   */
/* compound id.                                                     */
/*                                                                  */
/* dftype : full type id; RTUD(yes)                                 */
/* Result : base ids; RTUD(yes)                                     */
/*------------------------------------------------------------------*/

rt_shared int16 *eif_gen_cid (int16 dftype)
{
	RT_GET_CONTEXT
	int16 len;
	EIF_GEN_DER *gdp;

	if (dftype < first_gen_id)
	{
		cid_array [1] = dftype;
		return cid_array;
	}

	/* It's a run-time generated id */

	gdp = eif_derivations [dftype];

	if (gdp->gen_seq != (int16 *) 0)
	{
		return gdp->gen_seq;        /* already computed */
	}
	/* Compute size of array */

	len = eif_gen_seq_len (dftype);

	if (len <= 6)
	{
		/* use short array */
		gdp->gen_seq = gdp->sgen_seq;
	}
	else
	{
		gdp->gen_seq = (int16 *) eif_malloc ((len+2)*sizeof(int16));

		if (gdp->gen_seq == (int16 *) 0)
			enomem();
	}

	gdp->gen_seq [0] = len;
	gdp->gen_seq [len+1] = TERMINATOR;

	/* Fill array */

	len = 1;

	eif_put_gen_seq (dftype, gdp->gen_seq, &len, 0);

	return gdp->gen_seq;
}
/*------------------------------------------------------------------*/
/* Create an id from a type array 'a_cidarr'. If 'dtype_map' is not   */
/* NULL, use it to map old to new dtypes ('retrieve')               */
/* Format:                                                          */
/* First entry: count                                               */
/* Then 'count' type ids, then TERMINATOR                           */
/*------------------------------------------------------------------*/

rt_shared int16 eif_gen_id_from_cid (int16 *a_cidarr, int *dtype_map)

{
	int16   dftype;
	int16   count, i, dtype;

	REQUIRE ("Valid cid array", a_cidarr);

	count   = *a_cidarr;
	*a_cidarr = 0;	/* Not used anyway. */

	if (dtype_map != (int *) 0) {
			/* We need to map old dtypes to new dtypes */
		for (i = 1; i <= count; i++) {
			dtype = a_cidarr [i];

			if (dtype >= 0) {
				dtype = (int16) dtype_map [dtype];
				dtype = RTUD_INV(dtype);
				a_cidarr [i] = dtype;
			} else if (dtype == TUPLE_TYPE) {
					/* We simply skip number of generic
					 * parameters of the tuple as they are not really used
					 * and only update TUPLE dynamic type */
				i = i + TUPLE_OFFSET;
				a_cidarr [i]  = RTUD_INV((int16) dtype_map [a_cidarr [i]]);
			} else if (dtype == FORMAL_TYPE) {
					/* We skip formal position as if we were not doing it
					 * it would be updated using `dtype_map'/`RTUD_INV' at the
					 * next iteration and would not make sense anymore. */
				i++;
			}
		}
	} else {
			/* We only need to undo the effect of RTUD */
		for (i = 1; i <= count; i++) {
			dtype = a_cidarr [i];

			if (dtype >= 0) {
				dtype = RTUD_INV(dtype);
				a_cidarr [i] = dtype;
			} else if (dtype == TUPLE_TYPE) {
					/* We simply skip number of generic
					 * parameters of the tuple as they are not really used
					 * and only update TUPLE dynamic type */
				i = i + TUPLE_OFFSET;
				a_cidarr [i]  = RTUD_INV(a_cidarr [i]);
			} else if (dtype == FORMAL_TYPE) {
					/* We skip formal position as if we were not doing it
					 * it would be updated using RTUD_INV at the next iteration
					 * and it would not make sense anymore. */
				i++;
			}
		}
	}

	a_cidarr [count+1] = TERMINATOR;
	dftype  = eif_compound_id ((int16 *)0, (int16) 0, *(a_cidarr+1), a_cidarr);
	*a_cidarr = count;

	return dftype;
}
/*------------------------------------------------------------------*/
/* Conformance test. Does `source_type' conform to `target_type'?   */
/* This only applies to instantiated type.                          */
/*                                                                  */
/* Source_type : full type id; RTUD(yes)                            */
/* Target_type : full type id; RTUD(yes)                            */
/*------------------------------------------------------------------*/

rt_public int eif_gen_conf (int16 stype, int16 ttype)
{
	EIF_CONF_TAB *stab;
	EIF_GEN_DER *sgdp, *tgdp;
	int16 *ptypes;
	int i, idx, result;
	unsigned char mask;

	if (stype == ttype) {
		return 1;
	}

	if (EIF_IS_EXPANDED_TYPE(System(eif_cid_map[ttype]))) {
		/* Expanded target no conformance because types are different */
		return 0;
	} else if (stype < 0) {
			/* Target is not expanded and source is NONE, then there is conformance. */
		CHECK("NONE type", stype == NONE_TYPE);
		return 1;
	}

	stab = eif_conf_tab[stype];

	if (stab == (EIF_CONF_TAB *) 0)
	{
		eif_compute_ctab (stype);
		stab = eif_conf_tab[stype];
	}

	if (ttype < first_gen_id)
	{
		/* Lower id */

		if ((ttype >= stab->min_low_id) && (ttype <= stab->max_low_id))
		{
			idx = ttype-stab->min_low_id;
			mask = (1 << (idx % 8));

			return (mask == ((stab->low_tab)[idx/8] & mask)) ? 1 : 0;
		}
	}
	else
	{
		/* High id */

		if ((ttype < stab->min_high_id) || (ttype > stab->max_high_id))
		{
			/* We need to enlarge the table */
			eif_enlarge_conf_tab (stab, ttype);
		}

		/* Now ttype is in the table range */

		idx  = (ttype - stab->min_high_id);
		mask = (1 << (idx % 8));

		/* If we have computed it already, return result 
		 * We check first if the computed value is '1', if so, it means both that we already
		 * computed it and that is True.
		 * If the computed value is '0' we check if we compute a value, if so we return 0
		 * because we already know the computed value, otherwise we compute it
		 */

		if (mask == ((stab->high_tab)[idx/8] & mask))
			return 1;
		if (mask == ((stab->high_comp)[idx/8] & mask))
			return 0;

		/* We have to compute it now (once!) */

		sgdp = eif_derivations [stype];
		tgdp = eif_derivations [ttype];

		if (stype >= first_gen_id)
		{
			/* Both ids generated here */
		
			if (sgdp->first_id == tgdp->first_id)
			{
				/* Both have the same base class */

				/* Check BIT types. BIT n conforms to BIT m
				   iff n <= m. 
				*/

				if (sgdp->is_bit)
				{
					result = ((sgdp->size <= tgdp->size) ? 1 : 0);
					goto done;
				}

				/* Same base class. If nr. of generics
				   differs, both are TUPLEs.
				*/

				if (tgdp->size > sgdp->size)
				{
					/* Source and target are TUPLES but
					   source has fewer parameters */
					result = 0;
					goto done;
				}

				for (i = 0; i < tgdp->size; ++i)
				{
					stype = (sgdp->typearr) [i];
					ttype = (tgdp->typearr) [i];

					if (stype == ttype)
						continue; /* Same types - avoid recursion */

					if (ttype < 0)
					{
						/* Expanded target */
						result = 0;
						goto done;
					}

					if (ttype < first_gen_id)
						ttype = RTUD(ttype);

					if ((stype >= 0) && (stype < first_gen_id))
						stype = RTUD(stype);
				
					if (!eif_gen_conf (stype, ttype))
					{
						result = 0;
						goto done;
					}
				}

				result = 1;
				goto done;
			}
		}

		/* Target is generic.
		   We need to check every parent of the source
		   against the target */

		ptypes = sgdp->ptypes;

		result = 0;

		while (!result && (*ptypes != TERMINATOR))
		{
			result = eif_gen_conf (*ptypes, ttype);
			++ptypes;
		}

done:
		/* Register that we have computed it */
		(stab->high_comp)[idx/8] |= mask;

		if (result)
			(stab->high_tab)[idx/8] |= mask;

		return result;
	}

	return 0;
}
/*------------------------------------------------------------------*/
/* Private routines.                                                */
/*------------------------------------------------------------------*/

/*------------------------------------------------------------------*/
/* Computation of a new id.                                         */
/*                                                                  */
/* stype      : Static type of caller; RTUD(no); <= 0 if none.      */
/* intab      : RTUD(no) except for dtypes of objects               */
/* outtab     : List of computed ids for generics; RTUD(no).        */
/* obj_type   : Full type of object; RTUD(yes). Used to replace a   */
/*              formal generic by an actual generic of the object.  */
/* apply_rtud : Send result through RTUD?                           */
/*------------------------------------------------------------------*/

rt_private int16 eif_id_of (int16 stype, int16 **intab, 
							int16 **outtab, int16 obj_type, 
							int16 apply_rtud)

{
	int16   dftype, gcount = 0, i, hcode;
	int16   *save_otab;
	int     pos, mcmp;
	char    is_expanded, is_tuple;
	struct eif_par_types *pt;
	EIF_GEN_DER *gdp, *prev;
	EIF_ANC_ID_MAP *amap;

	/* Get full type */

	dftype = **intab;

	if (dftype >= 0) {
		is_expanded = EIF_IS_EXPANDED_TYPE(System (eif_cid_map[RTUD(dftype)]));
	} else {
		is_expanded = (char) 0;
	}

	/* Check whether it's a TUPLE Type */

	if (dftype == TUPLE_TYPE) {
		(*intab)++;
		gcount = **intab;       /* Number of generic params */
		(*intab)++;
		dftype = **intab;       /* Base id for TUPLE */

		if (dftype >= 0) {
			is_expanded = EIF_IS_EXPANDED_TYPE(System (eif_cid_map[RTUD(dftype)]));
		}

		is_tuple = '1';
	} else {
		is_tuple = (char) 0;
	}

	if (dftype == FORMAL_TYPE) {
			/* formal generic */
		(*intab)++;
		pos = **intab;	/* Position of formal generic */

		/* get actual generic from `stype' for descendant
		   `obj_type' if stype > 0 else use obj_type.
		*/

		if (stype > 0)
		{
			amap = eif_anc_id_map [obj_type];

			if (amap == (EIF_ANC_ID_MAP *) 0)
			{
				eif_compute_anc_id_map (obj_type);
				amap = eif_anc_id_map [obj_type];
			}

			gdp = eif_derivations [(amap->map)[stype - (amap->min_id)]];

			if ((gdp == NULL) || (gdp->size == 0))
			{
				/* The static call context is not a generic class.
				   Hence we have to take 'obj_type'. */

				gdp = eif_derivations [obj_type];
			}
		}
		else
		{
			gdp = eif_derivations [obj_type];
		}

		dftype = gdp->typearr [pos-1];

		(*intab)++;
		**outtab = dftype;
		(*outtab)++;

		return (apply_rtud ? RTUD(dftype) : dftype);
	}

	if (RTUD(dftype) == egc_bit_dtype) {
		(*intab)++;
		dftype = eif_register_bit_type ((long) (**intab));
		**outtab = dftype;
		(*intab)++;
		(*outtab)++;
		return dftype;
	}

	if ((dftype < 0) || (dftype >= first_gen_id)) {
		/* It's a basic type or an already created gen. type */
		(*intab)++;
		**outtab = dftype;
		(*outtab)++;
		/* RTUD would not have an effect here */
		return dftype;
	}

	/* It's an ordinary id generated by the compiler */

	pt = par_info(dftype);

	if (!is_tuple)
		gcount = pt->nb_generics;

	if (!is_tuple && (gcount == 0)) {
		/* Neither a generic type nor a TUPLE type */
		(*intab)++;

		**outtab = dftype;
		(*outtab)++;

		return (apply_rtud ? RTUD(dftype) : dftype);
	}

	save_otab = *outtab;
	(*intab)++;

	for (hcode = 0, i = gcount; i; --i) {
		hcode += eif_id_of (stype, intab, outtab, obj_type, 0);
	}

	/* Search */

	gdp  = eif_derivations [RTUD(dftype)];
	prev = (EIF_GEN_DER *) 0;

	while (gdp != (EIF_GEN_DER *) 0) {
		if ((hcode == gdp->hcode) && 
			(is_expanded == gdp->is_expanded) &&
			(gcount == gdp->size))
		{
			mcmp = 0;

			if (gcount > 0)
				mcmp = memcmp((char*)save_otab, (char*)(gdp->typearr),gcount*sizeof(int16));

			if (mcmp == 0)
			{
				break; /* Found */
			}
		}
		prev = gdp;
		gdp  = gdp->next;
	}

	if (gdp == (EIF_GEN_DER *)0) {
		/* Not found: we need a new id */

		gdp = eif_new_gen_der((long)gcount, save_otab, dftype, is_expanded, is_tuple, hcode);

		if (prev == (EIF_GEN_DER *)0)
			eif_derivations [RTUD(dftype)] = gdp;
		else
			prev->next = gdp;

		eif_derivations[gdp->id] = gdp; /* Self-reference */
	}

	/* Put full id */
	*outtab = save_otab;
	**outtab = gdp->id;
	(*outtab)++;

	/* RTUD would not have an effect here */
	return gdp->id;
}
/*------------------------------------------------------------------*/
/* Create a new generic derivation. Actually we create one for every*/
/* type, generic or not.                                            */
/*                                                                  */
/* size     : Nr. of bits in a bit type; nr. of generics in a ge-   */
/*            neric type; 0 otherwise.                              */
/* typearr  : Ids of generic paramenters; RTUD(no); null pointer    */
/*            if not a generic type                                 */
/* base_id  : Base id of type; RTUD(no)                             */
/* is_exp   : Is it expanded?                                       */
/* is_tuple : Is it a tuple?                                        */
/* hcode    : Hash code for faster search                           */
/*------------------------------------------------------------------*/

rt_private EIF_GEN_DER *eif_new_gen_der(long size, int16 *typearr, int16 base_id, char is_exp, char is_tuple, int16 hcode)
{
	EIF_GEN_DER *result;
	int16 *tp, dt;
	char *cname;
	struct eif_par_types **pt;

	result = (EIF_GEN_DER *) eif_malloc(sizeof (EIF_GEN_DER));

	if (result == (EIF_GEN_DER *) 0)
		enomem();

	if (typearr == (int16 *)0)
	{
		/* It's not a generic type. If size > 0 then it's a BIT type */

		result->size        = size;
		result->hcode       = hcode;
		result->typearr     = (int16 *) 0;
		result->gen_seq     = (int16 *) 0;      /* Generated on request only */
		result->ptypes      = (int16 *) 0;      /* Generated on request only */
		result->id          = ((size > 0) ? next_gen_id++ : base_id);
		result->base_id     = base_id;
		result->first_id    = -1;
		result->is_expanded = is_exp;
		result->is_bit      = ((size > 0) ? '1' : (char) 0);
		result->is_tuple    = is_tuple;
		result->is_array    = (char) 0;
		result->name        = (char *) 0;       /* Generated on request only */
				/* `name' must be allocated dynamically. */
		result->next        = (EIF_GEN_DER *)0;

		if (size > 0)
			goto finish;

		/* Just a simple, compiler generated id */

		goto finish_simple;
	}

	if (size > 8) {
			/* Large array */
		tp = (int16 *) eif_malloc((size + 1)*sizeof(int16));
		if (tp == (int16 *)0)
			enomem();
	} else {
			/* Small array */
		tp = result->stypearr;
	}

	tp[size]=-1;

	if (size > 0)
	{
		memcpy (tp, typearr, size*sizeof(int16));
	}

	result->size        = size;
	result->hcode       = hcode;
	result->typearr     = tp;
	result->gen_seq     = (int16 *) 0;      /* Generated on request only */
	result->ptypes      = (int16 *) 0;      /* Generated on request only */
	result->id          = next_gen_id++;
	result->base_id     = base_id;
	result->first_id    = -1;
	result->is_expanded = is_exp;
	result->is_bit      = (char) 0;
	result->is_tuple    = is_tuple;
	result->is_array    = (char) 0;
	result->name        = (char *) 0;       /* Generated on request only */
				/* `name' must be allocated dynamically. */
	result->next        = (EIF_GEN_DER *)0;

finish:

	/* Expand tables if necessary */

	if (next_gen_id >= eif_cid_size)
		eif_expand_tables (next_gen_id + 32);

	/* Map it to RTUDed compiler generated base id.
	   NOTE: at this point `result->id' is a new id
			 so we have: RTUD(result->id) = result->id.
	*/

	eif_cid_map [result->id] = RTUD(base_id);

finish_simple:

	/* Now find first entry in parent table
	   which has the same class name as `base_id'.
	*/

	cname = (par_info(base_id))->class_name;

	if (strcmp (cname, "ARRAY") == 0)
		result->is_array = '1';

	for (dt = 0, pt = eif_par_table2; dt <= eif_par_table2_size; ++dt, ++pt)
	{
		if (*pt == (struct eif_par_types *)0)
			continue;

		if (strcmp (cname,(*pt)->class_name) == 0)
		{
			result->first_id = dt;
			break;
		}
	}

	return result;
}
/*------------------------------------------------------------------*/
/* Create new conformance table.                                    */
/*                                                                  */
/* All ids are full type ids; RTUD(yes)                             */
/*------------------------------------------------------------------*/

rt_private EIF_CONF_TAB *eif_new_conf_tab(int16 min_low, int16 max_low, int16 min_high, int16 max_high) {
	EIF_CONF_TAB *result;
	int16 size;
	unsigned char *tab;

	result = (EIF_CONF_TAB *) eif_malloc(sizeof (EIF_CONF_TAB));

	if (result == (EIF_CONF_TAB *) 0)
		enomem();

	result->min_low_id = min_low;
	result->max_low_id = max_low;
	result->min_high_id = min_high;
	result->max_high_id = max_high;
	result->low_tab = result->slow_tab;
	result->high_tab = result->shigh_tab;
	result->low_comp = result->slow_comp;
	result->high_comp = result->shigh_comp;

	if (min_low <= max_low) {
		size = (max_low - min_low + 8)/8;

		if (size > 8) {
			tab = (unsigned char *) eif_calloc (size, sizeof (unsigned char));
			if (!tab)
				enomem ();
			result->low_tab = tab;

			tab = (unsigned char *) eif_calloc (size, sizeof (unsigned char));
			if (!tab)
				enomem ();
			result->low_comp = tab;
		} else {
			memset (result->low_tab, '\0', size);
			memset (result->low_comp, '\0', size);
		}
	} else {
		size = 8;
		memset (result->low_tab, '\0', size);
		memset (result->low_comp, '\0', size);
	}


	if (min_high <= max_high) {
		size = (max_high - min_high + 8)/8;

		if (size > 8) {
			tab = (unsigned char *) eif_calloc (size, sizeof (unsigned char));
			if (!tab)
				enomem ();
			result->high_tab = tab;

			tab = (unsigned char *) eif_calloc (size, sizeof (unsigned char));
			if (!tab)
				enomem ();
			result->high_comp = tab;
		} else {
			memset (result->high_tab, '\0', size);
			memset (result->high_comp, '\0', size);
		}
	} else {
		size = 8;
		memset (result->high_tab, '\0', size);
		memset (result->high_comp, '\0', size);
	}

	
	return result;
}

/*------------------------------------------------------------------*/
/* Enlarge conformance table to include `new_id'                    */
/*                                                                  */
/* New_id: full type id; RTUD(yes)                                  */
/*------------------------------------------------------------------*/

rt_private void eif_enlarge_conf_tab(EIF_CONF_TAB *table, int16 new_id)
{
	unsigned char *tab, *comp, *old_tab, *old_comp;
	unsigned char stab [8], scomp [8];
	int offset, was_small, is_low;
	int16 min_old, max_old, min_new, max_new, size, old_size;

	was_small = 0;
	is_low = 0;

	if (new_id < first_gen_id)
	{
		/* It's a lower id */

		is_low  = 1;
		min_old = min_new = table->min_low_id;
		max_old = max_new = table->max_low_id;

		if (new_id < min_new)
			min_new = new_id - (new_id % 8);    /* alignment */

		if (new_id > max_new)
			max_new = new_id;

		old_tab  = table->low_tab;
		old_comp = table->low_comp;
		tab      = table->slow_tab;
		comp     = table->slow_comp;

		/* Check if we were using the small tables so far */

		if (old_tab == table->slow_tab)
		{
			/* Yes, copy them and set `was_small' */

			was_small = 1;

			memcpy ((void *)stab, (void *)old_tab, 8);
			memcpy ((void *)scomp, (void *)old_comp, 8);

			old_tab  = stab;
			old_comp = scomp;
		}
	}
	else
	{
		/* It's a high id */

		min_old = min_new = table->min_high_id;
		max_old = max_new = table->max_high_id;

		if (new_id < min_new)
			min_new = new_id - (new_id % 8);    /* alignment */

		if (new_id > max_new)
			max_new = new_id;

		old_tab  = table->high_tab;
		old_comp = table->high_comp;
		tab      = table->shigh_tab;
		comp     = table->shigh_comp;

		/* Check if we were using the small tables so far */

		if (old_tab == table->shigh_tab)
		{
			/* Yes, copy them and set `was_small' */

			was_small = 1;

			memcpy ((void *)stab, (void *)old_tab, 8);
			memcpy ((void *)scomp, (void *)old_comp, 8);

			old_tab  = stab;
			old_comp = scomp;
		}
	}

	if (min_old <= max_old)
	{
		old_size = (max_old - min_old + 8)/8;
	}
	else
	{
		old_size = 8;
	}

	/* Now allocate new tables if size > 8 */

	size = (max_new - min_new + 8)/8;

	if (size > 8) {
		tab = (unsigned char *) eif_calloc (size, sizeof (unsigned char));
		if (!tab)
			enomem ();

		comp = (unsigned char *) eif_calloc (size, sizeof (unsigned char));
		if (!comp)
			enomem ();
	} else {
		memset (tab, '\0', size);
		memset (comp, '\0', size);
	}

		/* Initialize new tables from old tables */
	if (min_old <= max_old)
	{
		offset = (min_old - min_new) / 8;

		memcpy ((void *)(tab + offset), (void *)old_tab, old_size);
		memcpy ((void *)(comp + offset), (void *)old_comp, old_size);
	}

	/* Free old tables if they were not small (i.e. static) */

	if (!was_small)
	{
		eif_free (old_tab);
		eif_free (old_comp);
	}

	/* Now update structure values */

	if (is_low)
	{
		table->min_low_id = min_new;
		table->max_low_id = max_new;

		if (size > 8)
		{
			table->low_tab  = tab;
			table->low_comp = comp;
		}
	}
	else
	{
		table->min_high_id = min_new;
		table->max_high_id = max_new;

		if (size > 8)
		{
			table->high_tab  = tab;
			table->high_comp = comp;
		}
	}
}
/*------------------------------------------------------------------*/
/* Create new ancestor id map.                                      */
/*                                                                  */
/* min_id : minimal ancestor id; RTUD (no)                          */
/* max_id : maximal ancestor id; RTUD (no)                          */
/*------------------------------------------------------------------*/

rt_private EIF_ANC_ID_MAP *eif_new_anc_id_map (int16 min_id, int16 max_id) {
	EIF_ANC_ID_MAP *result;
	int16 *map, size;

	result = (EIF_ANC_ID_MAP *) eif_malloc(sizeof (EIF_ANC_ID_MAP));

	if (result == (EIF_ANC_ID_MAP *) 0)
		enomem();

	result->min_id = min_id;
	result->max_id = max_id;
	result->map    = result->smap;

	if (min_id <= max_id) {
		size = (max_id - min_id + 1);

		if (size > 8) {
			map = (int16 *) eif_calloc (size, sizeof(int16));

			if (map == (int16 *) 0)
				enomem ();

			result->map = map;
		} else
			memset (result->map, '\0', size * sizeof(int16));
	} else {
		memset (result->map, '\0', 8 * sizeof(int16));
	}

	return result;
}
/*------------------------------------------------------------------*/
/* Expand `eif_cid_map', `eif_conf_tab' , `eif_derivations' and     */
/* `eif_anc_id_map' to `new_size'                                   */
/*------------------------------------------------------------------*/

rt_private void eif_expand_tables(int new_size)
{
#ifdef EIF_THREADS
	eif_panic ("Cannot resize Generic conformance tables in multithreaded mode.");
#else
	EIF_GEN_DER **new;
	EIF_CONF_TAB **tab;
	EIF_ANC_ID_MAP **amap;
	int16       *map;
	int         i;

	new = (EIF_GEN_DER **) eif_realloc((char*)eif_derivations, new_size*sizeof (EIF_GEN_DER*));

	if (new == (EIF_GEN_DER **) 0)
		enomem();

	eif_derivations = new;

	tab = (EIF_CONF_TAB **) eif_realloc((char*)eif_conf_tab, new_size*sizeof (EIF_CONF_TAB*));

	if (tab == (EIF_CONF_TAB **) 0)
		enomem();

	eif_conf_tab = tab;

	amap = (EIF_ANC_ID_MAP **) eif_realloc((char*)eif_anc_id_map, new_size*sizeof (EIF_ANC_ID_MAP*));

	if (amap == (EIF_ANC_ID_MAP **) 0)
		enomem();

	eif_anc_id_map = amap;

	map = (int16 *) eif_realloc((char*)eif_cid_map, new_size*sizeof (int16));

	if (map == (int16 *) 0)
		enomem();

	eif_cid_map = map;

	for (i = eif_cid_size; i < new_size; ++i)
	{
		eif_cid_map [i]     = 0;
		eif_derivations [i] = (EIF_GEN_DER *) 0;
		eif_conf_tab [i]    = (EIF_CONF_TAB *) 0;
		eif_anc_id_map [i]  = (EIF_ANC_ID_MAP *) 0;
	}

	eif_cid_size = new_size;
#endif
}
/*------------------------------------------------------------------*/
/* Full type name for type `dftype' as C string.                    */
/*                                                                  */
/* dftype : full type id; RTUD(yes)                                 */
/* Attention! This routine is not threaded safe (because of the    */
/* static buffer "result"). It must be protected by a lock.         */
/* ATTENTION: kill the previous 'attention' comment.                */
/*------------------------------------------------------------------*/

rt_shared char *eif_typename (int16 dftype)
{
	/* Not MT-safe. */
	EIF_GEN_DER *gdp;
	size_t len;
	char    *result;
			
	REQUIRE("Valid type", (dftype >= 0) && (dftype < next_gen_id));

	if (dftype < first_gen_id) {
		RT_GET_CONTEXT
		char *l_name;

		l_name = non_generic_type_names [dftype];
		if (l_name == NULL) {
			char *l_class_name = par_info(RTUD_INV(dftype))->class_name;

			if (EIF_NEEDS_EXPANDED_KEYWORD(System (dftype))) {
				l_name = eif_malloc (10 + strlen (l_class_name));
				l_name [0] = '\0';
				strcat (l_name, "expanded ");
			} else if (EIF_NEEDS_REFERENCE_KEYWORD(System (dftype))) {
				l_name = eif_malloc (11 + strlen (l_class_name));
				l_name [0] = '\0';
				strcat (l_name, "reference ");
			} else {
				l_name = eif_malloc (strlen (l_class_name) + 1);
				l_name [0] = '\0';
			}
			strcat (l_name, l_class_name);
			non_generic_type_names[dftype] = l_name;
		}
		return l_name;
	}

	gdp = eif_derivations [dftype];

	if (gdp->name != (char *) 0)    /* Already computed */
	{
		return gdp->name;	/* Allocated dynamically! */
	}

	len = eif_typename_len (dftype);

	/* Create dynamic buffer for string */

	result = eif_malloc (len + 1);

	if (result == (char *) 0)
		enomem();

	*result = '\0';

	eif_create_typename (dftype, result);

	/* It may happen that gdp->name is now not NULL (BIT types).
	   In this case we have to free 'result' and use
	   gdp->name instead. */

	if (gdp->name != (char *) 0)
	{
		eif_free (result);
		result = gdp->name;
	}
	else
	{
		/* Remember the string in gdp->name. Otherwise
		   we get a memory leak. */

		gdp->name = result;
	}

	return result;
}
/*------------------------------------------------------------------*/
/* Produce full type name of `dftype' in `result'.                  */
/*                                                                  */
/* dftype : full type id; RTUD(yes)                                 */
/*------------------------------------------------------------------*/

rt_private void eif_create_typename (int16 dftype, char *result)
{
	EIF_GEN_DER *gdp;
	int16       *gp, dtype, i;
	int         size;
	char        *bits;
	int	needs_expanded = 0, needs_reference = 0;

	if (dftype < 0) {
		CHECK("NONE type", dftype == NONE_TYPE);
		strcat(result, "NONE");
		return;
	}

	needs_expanded = EIF_NEEDS_EXPANDED_KEYWORD(System(eif_cid_map[dftype]));
	needs_reference = EIF_NEEDS_REFERENCE_KEYWORD(System(eif_cid_map[dftype]));

	if (dftype < first_gen_id) {
		if (needs_expanded) {
			strcat (result, "expanded ");
		} else if (needs_reference) {
			strcat (result, "reference ");
		}
		/* Compiler generated id */
		strcat (result, par_info(RTUD_INV(dftype))->class_name);
		return;
	}

	/* We have created this id */

	gdp = eif_derivations [dftype];

	if (gdp->name != (char *) 0)    /* Already computed */
	{
		strcat (result, gdp->name);
		return;
	}

	if (gdp->is_bit)
	{
		size = gdp->size;
		i = 4;

		while (size)
		{
			size /= 10;
			++i;
		}

		bits = eif_malloc (i+1);

		if (bits == (char *) 0)
			enomem ();

		strcpy (bits, "BIT ");

		size = gdp->size;
		bits [i] = '\0';

		for (--i; size; --i)
		{
			bits [i] = (size % 10) + '0';
			size /= 10;
		}

		strcat (result, bits);

		gdp->name = bits;
				/* `name' must be allocated dynamically. */

		return;
	}
	
	/* Generic case */

	i = (int16) gdp->size;

	if (needs_expanded) {
		strcat (result, "expanded ");
	} else if (needs_reference) {
		strcat (result, "reference ");
	}

	strcat (result, par_info(gdp->base_id)->class_name);

	if (i > 0)
	{
		strcat (result, " [");

		gp = gdp->typearr;

		while (i--)
		{
			dtype = *gp;

			if (dtype >= 0) {
				dtype = RTUD(dtype);
			}

			eif_create_typename (dtype, result);
			++gp;

			if (i)
				strcat (result, ", ");
		}

		strcat(result, "]");
	}
}
/*------------------------------------------------------------------*/
/* Compute length of string needed for full type name of `dftype'   */
/*                                                                  */
/* dftype : full type id; RTUD(yes)                                 */
/*------------------------------------------------------------------*/

rt_shared size_t eif_typename_len (int16 dftype)
{
	EIF_GEN_DER *gdp;
	int16       *gp, i, dtype;
	size_t len = 0;
	int         size;
	int	needs_expanded = 0, needs_reference = 0;

	if (dftype < 0) {
		CHECK ("NONE type", dftype == NONE_TYPE);
		return 4;
	}

	needs_expanded = EIF_NEEDS_EXPANDED_KEYWORD(System(eif_cid_map[dftype]));
	needs_reference = EIF_NEEDS_REFERENCE_KEYWORD(System(eif_cid_map[dftype]));

	if (dftype < first_gen_id) {
		if (needs_expanded) {
			len = 9;
		} else if (needs_reference) {
			len = 10;
		}
		/* Compiler generated id */
		return len + strlen (par_info(RTUD_INV(dftype))->class_name);
	}

	/* We have created this id */

	gdp = eif_derivations [dftype];

	if (gdp->name != (char *) 0)    /* Already computed */
	{
		return strlen (gdp->name);
	}

	if (gdp->is_bit)
	{
		size = gdp->size;
		len += 4;

		while (size)
		{
			size /= 10;
			++len;
		}
		return len;   /* "BIT n" */
	}

	/* Generic case */

	i = (int16) gdp->size;

	len += (int16) strlen (par_info(gdp->base_id)->class_name);

	if (needs_expanded) {
		len += 9;
	} else if (needs_reference) {
		len += 10;
	}

	if (i == 0)         /* TUPLE without generics */
		return len;

	len += 3 + (i-1)*2;

	gp = gdp->typearr;

	while (i--)
	{
		dtype = *gp;

		if (dtype >= 0)
			dtype = RTUD(dtype);

		len += eif_typename_len (dtype);
		++gp;
	}

	return len;
}
/*------------------------------------------------------------------*/
/* Compute length of generating id sequence for `dftype'            */
/*                                                                  */
/* dftype : full type id; RTUD(doesn't matter)                      */
/*------------------------------------------------------------------*/

rt_private int16 eif_gen_seq_len (int16 dftype)
{
	EIF_GEN_DER *gdp;
	long i;
	int16 len;

	REQUIRE ("dftype is not a formal generic parameter", dftype != FORMAL_TYPE);
	REQUIRE ("dftype is not a tuple", dftype != TUPLE_TYPE);
	REQUIRE ("dftype is not a terminator", dftype != TERMINATOR);

		/* Simple id */
	if (dftype < first_gen_id) {
		return 1;
	}

		/* It's a generic type or a BIT type */
	gdp = eif_derivations[dftype];

		/* Is it a BIT type? */
	if (gdp->is_bit) {
		return 2;
	}

	len = 0;

		/* Is it a TUPLE? */
	if (gdp->is_tuple) {
			/* Size is TUPLE_OFFSET because we need to take into account
			 * TUPLE_TYPE constant, number of generic parameters
			 * in seqence for tuple type */
		len += TUPLE_OFFSET;
	}

	for (i = gdp->size-1; i >= 0; --i)
		len += eif_gen_seq_len (gdp->typearr [i]);

	return len + 1; /* Base id plus generics */
}
/*------------------------------------------------------------------*/
/* Produce generating id sequence for `dftype' in `typearr'.        */
/*                                                                  */
/* dftype    : full type id; RTUD(not apply_rtud)                   */
/* typearr   : Base type ids; RTUD(yes)                             */
/* idx       : index where to put id                                */
/* apply_rtud: must we send entries through RTUD?                   */
/*------------------------------------------------------------------*/

rt_private void eif_put_gen_seq (int16 dftype, int16 *typearr, int16 *idx, int16 apply_rtud)
{
	EIF_GEN_DER *gdp;
	int16 i, len;

	REQUIRE ("dftype is not a formal generic parameter", dftype != FORMAL_TYPE);
	REQUIRE ("dftype is not a tuple", dftype != TUPLE_TYPE);
	REQUIRE ("dftype is not a terminator", dftype != TERMINATOR);

	/* Simple id */

	if (dftype < first_gen_id) {
		if (dftype < 0) {
			typearr [*idx] = dftype;
		} else {
			typearr [*idx] = (apply_rtud ? RTUD(dftype) : dftype);
		}
		(*idx)++;
		return;
	}

		/* It's a generic type or a BIT type */
	gdp = eif_derivations[dftype];

		/* Is it a BIT type? */
	if (gdp->is_bit) {
		typearr [*idx] = egc_bit_dtype;    /* Bit type */
		(*idx)++;
		typearr [*idx] = (int16) (gdp->size); /* Nr of bits */
		(*idx)++;
		return;
	}

		/* Is it a TUPLE type? */
	if (gdp->is_tuple) {
		typearr [*idx] = TUPLE_TYPE;                   /* TUPLE type */
		(*idx)++;
		typearr [*idx] = (int16) (gdp->size);   /* Nr of generics */
		(*idx)++;
	}

	typearr [*idx] = RTUD(gdp->base_id);
	(*idx)++;

	len = (int16) gdp->size;

	for (i = 0; i < len; ++i) {
		eif_put_gen_seq (gdp->typearr [i], typearr, idx, 1);
	}
}
/*------------------------------------------------------------------*/
/* Compute conformance table for `dftype'                           */
/*                                                                  */
/* dftype : full type id; RTUD(yes)                                 */
/*------------------------------------------------------------------*/

rt_private void eif_compute_ctab (int16 dftype)

{
	int16 outtab [256], *outtable, *intable;
	int16 min_low, max_low, min_high, max_high, pftype, dtype, *ptypes;
	int i, count, offset, pcount;
	unsigned char *src, *dest, *src_comp, *dest_comp, mask;
	char is_expanded;
	struct eif_par_types *pt;
	EIF_CONF_TAB *ctab, *pctab;
	EIF_GEN_DER *gdp;

	/* Get parent table */

	dtype = Deif_bid(dftype);

		/* Compiler generated id */
	pt = par_info (RTUD_INV(dtype));

	is_expanded = pt->is_expanded;

	/* Compute the ranges of the bit tables */

	outtable = outtab;
	intable = pt->parents;

	CHECK ("Parents never NULL", intable);

	min_low = next_gen_id;
	max_low = 0;
	min_high = next_gen_id;
	max_high = 0;

	/* Type conforms to itself */

	if (dftype < first_gen_id)
	{
		min_low = max_low = dftype;
	}
	else
	{
		min_high = max_high = dftype;
	}

	pcount = 1; /* Parent count + 1 */

	while (*intable != TERMINATOR)
	{
		pftype = eif_id_of (-1, &intable, &outtable, dftype, 1);
		++pcount;

		ctab = eif_conf_tab [pftype];

		if (ctab == (EIF_CONF_TAB *) 0)
		{
			eif_compute_ctab (pftype);
			ctab = eif_conf_tab [pftype];
		}

		if (ctab->min_low_id < min_low)
			min_low = ctab->min_low_id;
		if (ctab->max_low_id > max_low)
			max_low = ctab->max_low_id;
		if (ctab->min_high_id < min_high)
			min_high = ctab->min_high_id;
		if (ctab->max_high_id > max_high)
			max_high = ctab->max_high_id;
	}

	/* Create a new table */
	/* Make sure that the min values are == 0 mod 8 */

	min_low  -= (min_low % 8);
	min_high -= (min_high % 8);

	ctab = eif_new_conf_tab (min_low, max_low, min_high, max_high);

	eif_conf_tab [dftype] = ctab;

	/* Create table of parent types */

	gdp = eif_derivations [dftype];

	if (gdp == (EIF_GEN_DER *) 0)
	{
		gdp = eif_new_gen_der ((long)0, (int16*) 0, (int16) RTUD_INV(dtype), (char) 0, (char) 0, (int16) 0);

		eif_derivations [dftype] = gdp;
	}

	if (pcount <= 8)
	{
		/* Use small table */
		gdp->ptypes = ptypes = gdp->sptypes;
	}
	else
	{
		ptypes = (int16 *) eif_malloc (sizeof (int16)*pcount);

		if (ptypes == (int16 *) 0)
			enomem ();

		gdp->ptypes = ptypes;
	}

	/* Fill bit tables */

	outtable = outtab;
	intable = pt->parents;

	CHECK ("Parents never NULL", intable);

	while (*intable != TERMINATOR)
	{
		pftype = eif_id_of (-1, &intable, &outtable, dftype, 1);
		pctab = eif_conf_tab [pftype];

		/* Register parent type */

		*(ptypes++) = pftype;

		if ((min_low <= max_low) && (pctab->min_low_id <= pctab->max_low_id))
		{
			count  = (pctab->max_low_id-pctab->min_low_id+8)/8;
			offset = (pctab->min_low_id - min_low)/8;
			src  = pctab->low_tab;
			dest = ctab->low_tab + offset;
			src_comp = pctab->low_comp;
			dest_comp = ctab->low_comp + offset;

			for (i = count; i; --i)
			{
				/* We conform to everything our parent
				   conforms to */

				*dest |= *src;

				/* Consider only those bits as already
				   computed for which conformance holds
				   because we may conform to something
				   to which the parent does not! */
				   
				*(dest_comp) |= ((*src) & (*src_comp));
				++dest;
				++src;
				++src_comp;
				++dest_comp;
			}
		}

		if ((min_high <= max_high) && (pctab->min_high_id <= pctab->max_high_id))
		{
			count  = (pctab->max_high_id-pctab->min_high_id+8)/8;
			offset = (pctab->min_high_id - min_high)/8;
			src  = pctab->high_tab;
			dest = ctab->high_tab + offset;
			src_comp = pctab->high_comp;
			dest_comp = ctab->high_comp + offset;

			for (i = count; i; --i)
			{
				/* We conform to everything our parent
				   conforms to */
				*dest |= *src;

				/* Consider only those bits as already
				   computed for which conformance holds
				   because we may conform to something
				   to which the parent does not! */
				   
				*(dest_comp) |= ((*src) & (*src_comp));
				++dest;
				++src;
				++src_comp;
				++dest_comp;
			}
		}
	}

	*ptypes = TERMINATOR;

	/* Put own type in table if it's not expanded */

	if (is_expanded)
		return;

	if (dftype < first_gen_id)
	{
		offset = (dftype - min_low);
		mask   = (1 << (offset % 8));
		(ctab->low_tab)[offset/8] |= mask;
		(ctab->low_comp)[offset/8] |= mask;
	}
	else
	{
		offset = (dftype - min_high);
		mask   = (1 << (offset % 8));
		(ctab->high_tab)[offset/8] |= mask;
		(ctab->high_comp)[offset/8] |= mask;
	}
}
/*------------------------------------------------------------------*/
/* Compute ancestor id map for `dftype'.                            */
/*                                                                  */
/* dftype                      : full type; RTUD(yes)               */
/* min_id, max_id, table index : RTUD(no)                           */
/* Table entries               : RTUD(yes)                          */
/*------------------------------------------------------------------*/

rt_private void eif_compute_anc_id_map (int16 dftype)

{
	int16 outtab [256], *outtable, *intable;
	int16 min_id, max_id, pftype, dtype;
	int i, count, offset;
	int16 *src, *dest;
	struct eif_par_types *pt;
	EIF_ANC_ID_MAP *map, *pamap;

	/* Get parent table */

	dtype = Deif_bid(dftype);

		/* Compiler generated id */
	pt = par_info (RTUD_INV(dtype));

	/* Compute the range of the id map */

	outtable = outtab;
	intable = pt->parents;

	CHECK ("Parents never NULL", intable);

	min_id = max_id = RTUD_INV(dtype);

	while (*intable != TERMINATOR)
	{
		pftype = eif_id_of (-1, &intable, &outtable, dftype, 1);

		map = eif_anc_id_map [pftype];

		if (map == (EIF_ANC_ID_MAP *) 0)
		{
			eif_compute_anc_id_map (pftype);
			map = eif_anc_id_map [pftype];
		}

		if (map->min_id < min_id)
			min_id = map->min_id;
		if (map->max_id > max_id)
			max_id = map->max_id;
	}

	/* Create a new map */

	map = eif_new_anc_id_map (min_id, max_id);

	eif_anc_id_map [dftype] = map;

	/* Fill map */

	outtable = outtab;
	intable = pt->parents;

	CHECK ("Parents never NULL", intable);

	while (*intable != TERMINATOR)
	{
		pftype = eif_id_of (-1, &intable, &outtable, dftype, 1);
		pamap = eif_anc_id_map [pftype];

		/* Register parent type */

		if ((min_id <= max_id) && (pamap->min_id <= pamap->max_id))
		{
			count  = (pamap->max_id-pamap->min_id+1);
			offset = (pamap->min_id - min_id);
			src    = pamap->map;
			dest   = map->map + offset;

			for (i = count; i; --i)
			{
				if (*src)
				{
					*dest = *src;
				}

				++dest;
				++src;
			}
		}
	}

	/* Put own type in table */

	(map->map)[RTUD_INV(dtype)-(map->min_id)] = dftype;
}

/*------------------------------------------------------------------*/
/*------------------------------------------------------------------*/
/*------------------------------------------------------------------*/
#ifdef GEN_CONF_DEBUG

#include    <stdio.h>

rt_private FILE *lfp = (FILE *) 0;

rt_public void log_puts (char *s)

{
	if (lfp == (FILE *) 0)
		lfp = fopen (logfile, "w");

	fprintf (lfp,"%s",s);
	fflush (lfp);
}

rt_public void log_puti (int i)

{
	if (lfp == (FILE *) 0)
		lfp = fopen (logfile, "w");

	fprintf (lfp,"%d",i);
	fflush (lfp);
}
#endif
/*------------------------------------------------------------------*/

/*
doc:</file>
*/
