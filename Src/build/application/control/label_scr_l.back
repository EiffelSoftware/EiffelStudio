
class LABEL_SCR_L  

inherit

	COMMAND
		export
			{NONE} all
		end;

	COMMAND_ARGS
		rename First as unused,
		Second as set_show_action,
		Third as set_label_action
		export
			{NONE} all
		end;

	LABEL_STONE
		export
			{NONE} all
		redefine
			transportable
		end;

	SCROLL_LIST
		rename 
			make as list_make,
			merge_right as list_merge_right,
			search_equal as list_search_equal,
			selected_item as list_selected_item
		end;

	SCROLL_LIST
		rename		
			make as list_make
		redefine
			search_equal, selected_item, merge_right
		select
			search_equal, selected_item, merge_right
		end;

	REMOVABLE
		export
			{NONE} all
		end


creation

	make

	
feature {NONE}

	remove_yourself is
		local
			cut_label_command: APP_CUT_LABEL
		do
			!!cut_label_command;
			cut_label_command.execute (selected_item);
		end;

	transportable: BOOLEAN;
			-- Is the stone able to be transported ?

        label: STRING is
                do
                       	Result := selected_item
                end;

	original_stone: CMD_LABEL is
		do
		end;

        symbol:PIXMAP is
                do
                end;

        source:WIDGET is
                do
                        Result := Current 
                end;

	
feature 

	make (a_name: STRING; a_parent: COMPOSITE) is
		do
			list_make (a_name, a_parent);
			add_button_press_action (3, Current, set_show_action);
			add_button_press_action (3, Current, set_label_action);
			initialize_transport
		end; -- Create

	
feature {NONE}

	label_names: SORTED_TWO_WAY_LIST [TRAN_NAME];
			-- List of the labels names. 

	
feature 

	merge_right (l: SORTED_TWO_WAY_LIST [TRAN_NAME]) is
			-- Merge right of cursor position put `l'. Construct label_names
			-- from `l'.
		require else
			not_void_l: not (l = Void)
		do
			l.start;
			label_names := l.duplicate (l.count);	
			list_merge_right (l);
		end;

	search_equal (v: TRAN_NAME) is
			-- Move cursor to first position (at or after current cursor 
			-- position) where item in label_names is v and then set current
			-- cursor to same position as in label_names; go off right if none. 
		require else
			label_names_same_size_as_current: label_names.count = count;
			not_void_v: not (v = Void)
		do
			label_names.start;
			label_names.search_equal (v);
			if
				not label_names.after
			then
				go_i_th (label_names.index);
			end;
		end; -- search_equal

	selected_item: TRAN_NAME is
			-- Selected item if single or browse selection mode is selected.
			-- Void is nothing is selected.
		require else
			label_names_same_size_as_current: label_names.count = count
		do
			io.putint (selected_position);
			io.new_line;
			if
				not (selected_position = 0)
			then
				Result := label_names.i_th (selected_position);
				io.putstring (Result.label_name);
				io.new_line
			end;
		end; -- selected_item
	
	
feature {NONE}

	execute (argument: ANY) is
			-- Execute the command
		do
			if
				argument = set_label_action
			then
				io.putstring ("transporting ...\n");
				if
					(selected_item = Void)
				then
					transportable := false
				else
					transportable := true;
				end;
			elseif
				argument = set_show_action
			then
				transportable := false
			end
		end; -- execute

end -- class LABEL_SCR_L
	
