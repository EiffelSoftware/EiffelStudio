<document title="EiffelBase, Iteration">
	<meta_data>
		<help>
			<toc>
				<envision_location>Class Libraries\EiffelBase\EiffelBase\EiffelBase Data Structures Overview</envision_location>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph> The classes of the Iteration cluster encapsulate control structures representing common traversal operations.</paragraph>
		<heading>
			<size>1</size>Iterators and Agents
		</heading>
		<paragraph> The recent introduction of the agents mechanism in ISE Eiffel offers an attractive alternative to the 
			<code>
				<cluster_name>Iterator</cluster_name>
			</code> cluster of EiffelBase.
		</paragraph>
		<heading>
			<size>1</size>The Notion of iterator
		</heading>
		<paragraph>  Let us first explore the role of iterators in the architecture of a system.</paragraph>
		<heading>
			<size>2</size>Iterating over data structures
		</heading>
		<paragraph>  Client software that uses data structures of a certain type, for example lists or trees,  often needs to traverse a data structure of that type in a predetermined order so as to  apply a certain action to all the items of the structure, or to all items that satisfy a certain  criterion. Such a systematic traversal is called an iteration.
			<line_break/>  Cases of iteration can be found in almost any system. Here are a few typical  examples:
		</paragraph>
		<list ordered="false">
			<item>A text processing system may maintain a list of paragraphs. In response to a user  command, such as a request to resize the column width, the system will iterate  over the entire list so as to update all paragraphs.</item>
			<item>A business system may maintain a list of customers. If the company decides that  a special promotion will target all customers satisfying a certain criterion (for  example all customers that have bought at least one product over the past six  months), the system will iterate over the list, generating a mailing for every list  item that satisfies the criterion.</item>
			<item>An interactive development environment for a programming language may  maintain a syntax tree. In response to a program change, the system will traverse  the tree to determine what nodes are affected by the change and update them.</item>
		</list>
		<paragraph> These examples illustrate the general properties of iteration. An iteration involves a data structure of a known general type and a particular ordering of the structure's items. For some structures, more than one ordering will be available; for example a tree iteration may use preorder, postorder or breadth-first (as defined below). The iteration involves an operation, say 
			<code>
				<feature_name>item_action</feature_name>
			</code>, to be applied to the selected items. It may also involve a boolean-valued query, say 
			<code>
				<feature_name>item_test</feature_name>
			</code>, applicable to candidate items. Finally, it involves a certain policy, usually based on 
			<code>
				<feature_name>item_test</feature_name>
			</code>, as to which items should be subjected to item_action. Typical example policies are:
		</paragraph>
		<list ordered="false">
			<item>Apply 
				<code>
					<feature_name>item_action</feature_name>
				</code> to all the items in the structure.  (In this case item_test is not relevant).
			</item>
			<item>Apply 
				<code>
					<feature_name>item_action</feature_name>
				</code> to all items that satisfy  
				<code>
					<feature_name>item_test</feature_name>
				</code>.
			</item>
			<item>Apply 
				<code>
					<feature_name>item_action</feature_name>
				</code> to all items up to the first one  that satisfies 
				<code>
					<feature_name>item_test</feature_name>
				</code>.
			</item>
		</list>
		<paragraph>  The Iteration library provides many more, covering in particular all the standard  control structures.</paragraph>
		<heading>
			<size>2</size>Iterations and control structures
		</heading>
		<paragraph>  You can perform iterations without any special iteration classes. For example if  customers is declared as</paragraph>
		<code_block>
	<feature_name>customers</feature_name><symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>CUSTOMER</class_name><symbol>]</symbol> 
		</code_block>
		<paragraph>  then a class 
			<code>
				<class_name>SPECIAL_PROMOTION</class_name>
			</code> of a text processing  system may include in one of its routines a loop of the form
		</paragraph>
		<code_block>
	<keyword>from</keyword>
    		<feature_name>customers</feature_name>.<feature_name>start</feature_name>
	<keyword>until</keyword>
	    	<feature_name>customers</feature_name>.<feature_name>exhausted</feature_name>
	<keyword>loop</keyword>
	    	<keyword>if</keyword> <feature_name>recent_purchases</feature_name>.<feature_name>has</feature_name> <symbol>(</symbol><feature_name>customers</feature_name>.<feature_name>item</feature_name><symbol>)</symbol> <keyword>then</keyword>
        		<feature_name>target_list</feature_name>.<feature_name>put</feature_name> <symbol>(</symbol><feature_name>customers</feature_name>.<feature_name>item</feature_name><symbol>)</symbol>
	    	<keyword>end</keyword>
	    	<feature_name>customers</feature_name>.<feature_name>forth</feature_name>
	<keyword>end</keyword>
		</code_block>
		<paragraph>  Such schemes are quite common. But it is precisely because they occur frequently  that it is useful to rely on library classes to handle them. One of the principal tasks of  object-oriented software development is to identify recurring patterns and build reusable  classes that encapsulate them, so that future developers will be able to rely on ready-made  solutions.
			<line_break/>  The classes of the Iteration library address this need. Using them offers two  benefits:
		</paragraph>
		<list ordered="false">
			<item>You avoid writing loops, in which the definition of sub-components such as exit  conditions, variants and invariants is often delicate or error-prone.</item>
			<item>You can more easily adapt the resulting features in descendant classes.  The rest of this chapter shows how to obtain these benefits.</item>
		</list>
		<heading>
			<size>1</size>Simple Examples
		</heading>
		<paragraph>  To get a first grasp of how one can work with the Iteration library, let us look at a typical  iteration class and a typical iteration client.</paragraph>
		<heading>
			<size>2</size>An example iterator routine
		</heading>
		<paragraph>  Here, given with its full implementation, is a typical Iteration library routine: the  procedure until_do from  
			<link>
				<url>../../reference/structures/iteration/linear_iterator_chart.html</url>
				<label>LINEAR_ITERATOR</label>
			</link>, the class  defining iteration mechanisms on linear (sequential) structures.
		</paragraph>
		<code_block>
	until_<keyword>do</keyword> <keyword>is</keyword>
	        <comment>-- Apply action to every item of target,</comment>
        	<comment>-- up to but excluding first one satisfying test.</comment>
	        <comment>-- (Apply to full list if no item satisfies test.)</comment>
	<keyword>require</keyword>
        	traversable_exists<symbol>:</symbol> target <symbol>/=</symbol> Void
    	<keyword>do</keyword>
        	<keyword>from</keyword>
	            <feature_name>target</feature_name>.<feature_name>start</feature_name>
        	<keyword>invariant</keyword>
	            invariant_value
        	<keyword>until</keyword>
	            <feature_name>target</feature_name>.<feature_name>exhausted</feature_name> <keyword>or</keyword> <keyword>else</keyword> test
        	<keyword>loop</keyword>
	            <feature_name>action</feature_name>
        	    <feature_name>target</feature_name>.<feature_name>forth</feature_name>
	        <keyword>end</keyword>
	<keyword>ensure</keyword>
	        achieved<symbol>:</symbol> <feature_name>target</feature_name>.<feature_name>exhausted</feature_name> <keyword>or</keyword> <keyword>else</keyword> test
		invariant_satisfied<symbol>:</symbol> invariant_value
	<keyword>end</keyword>
		</code_block>
		<paragraph>  The precise form of the procedure in the class relies on a call to another procedure,  until_continue,  and on inherited assertions. Here everything has been unfolded for illustration  purposes.
			<line_break/>  This procedure will traverse the linear structure identified by  target  and apply the procedure called  action  on every item up to but excluding the first one satisfying test.
			<line_break/>  The class similarly offers  do_all,  do_while,  do_for,  do_if  and other procedures representing the common control structures.  It also includes functions such as  exists and  forall,  corresponding to the usual quantifiers.
			<line_break/>  These iteration schemes depend on the procedure  action,  defining the action to beapplied to successive elements, and on the function  test,  defining the boolean query to be applied to these elements. These features are declared in class  ITERATOR  (the highest-level deferred class of the Iteration library); here is  test:
		</paragraph>
		<code_block>
	<feature_name>test</feature_name><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
        	<comment>-- Test to be applied to item at current position in</comment>
	        <comment>-- target (default: value of item_test on item)</comment>
	<keyword>require</keyword>
        	traversable_exists<symbol>:</symbol> <feature_name>target</feature_name> <symbol>/=</symbol> Void
	        not_off<symbol>:</symbol> <keyword>not</keyword> <feature_name>target</feature_name>.<feature_name>off</feature_name>
    	<keyword>do</keyword>
        	Result <symbol>:</symbol><symbol>=</symbol> <feature_name>item_test</feature_name> <symbol>(</symbol><feature_name>target</feature_name>.<feature_name>item</feature_name><symbol>)</symbol>
	<keyword>ensure</keyword>
        	not_off<symbol>:</symbol> <keyword>not</keyword> <feature_name>target</feature_name>.<feature_name>off</feature_name>
	<keyword>end</keyword>
		</code_block>
		<paragraph> This indicates that the value of the boolean function test will be obtained by applying item_test to the item at the current position in the target structure. In ITERATOR, function item_test always return 
			<code>
				<keyword>False</keyword>
			</code>; descendant classes will redefine it so as to describe the desired test. Similarly, action is declared in class ITERATOR as a call to item_action. Descendants will redefine item_action, which as initially declared in ITERATOR is a procedure with a null body.
			<line_break/> Going through item_action and item_test provides an extra degree of flexibility. Normally the action and test performed at each step apply to target
			<code>
				<symbol>.</symbol>
			</code>itemitem, so that it suffices to redefine the item_features. This is the case will all examples studied in this chapter. In a more general setting, however, you might need to redefine action and test themselves.
		</paragraph>
		<heading>
			<size>2</size>An example use of iteration
		</heading>
		<paragraph>  Here now is an example illustrating the use of these mechanisms. The result will enable  us to resize all the paragraphs of a text up to the first one that has been modified - as we  might need to do, in a text processing system, to process an interactive user request.  Assume a class 
			<code>
				<class_name>TEXT</class_name>
			</code> that describes lists of paragraphs  with certain additionalfeatures. The example will also assume a class  
			<code>
				<class_name>PARAGRAPH</class_name>
			</code> with a procedure 
			<code>
				<feature_name>resize</feature_name>
			</code>,  and a boolean-valued attribute 
			<code>
				<feature_name>modified</feature_name>
			</code> which indicates  whether a paragraph has been modified. Class 
			<code>
				<class_name>TEXT</class_name>
			</code> inherits  from LINKED_LIST and  so is a descendant of LINEAR:
		</paragraph>
		<code_block>
	<keyword>class</keyword>
		<class_name>TEXT</class_name>

	<keyword>inherit</keyword>
		<class_name>LINKED_LIST</class_name> <symbol>[</symbol><class_name>PARAGRAPH</class_name><symbol>]</symbol>
    		...
	<keyword>feature</keyword>
    		...
	<keyword>end</keyword> 
		</code_block>
		<paragraph>  In a class 
			<code>
				<class_name>TEXT_PROCESSOR</class_name>
			</code>, you can use an iteration  procedure to write a very simple procedure 
			<code>
				<feature_name>resize_ paragraphs</feature_name>
			</code>  that will resize all paragraphs up to but excluding the first one that has been modified:
		</paragraph>
		<code_block>
	<keyword>class</keyword>
		<class_name>TEXT_PROCESSOR</class_name>

	<keyword>inherit</keyword>
		<class_name>LINEAR_ITERATOR</class_name> <symbol>[</symbol><class_name>PARAGRAPH</class_name><symbol>]</symbol>
			<keyword>redefine</keyword>
				<feature_name>item_action</feature_name>, <feature_name>item_test</feature_name>
			<keyword>end</keyword>

	<keyword>feature</keyword>

		<feature_name>resize_paragraphs</feature_name> <symbol>(</symbol>t<symbol>:</symbol> <class_name>TEXT</class_name><symbol>)</symbol> <keyword>is</keyword>
        			<comment>-- Resize all the paragraphs of t up to but excluding</comment>
		        	<comment>-- the first one that has been modified.</comment>
    			<keyword>do</keyword>
				<feature_name>set</feature_name> <symbol>(</symbol>t<symbol>)</symbol>
        			<feature_name>until_do</feature_name>
    			<keyword>end</keyword>

	<keyword>feature</keyword> <symbol>{</symbol>NONE<symbol>}</symbol>

		<feature_name>item_test</feature_name> <symbol>(</symbol>p <class_name>PARAGRAPH</class_name><symbol>)</symbol><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
        			<comment>-- Has p been modified?</comment>
    			<keyword>do</keyword>
			        Result <symbol>:</symbol><symbol>=</symbol> <feature_name>p</feature_name>.<feature_name>modified</feature_name>
    			<keyword>end</keyword>

		<feature_name>item_action</feature_name> <symbol>(</symbol>p<symbol>:</symbol> <class_name>PARAGRAPH</class_name><symbol>)</symbol> <keyword>is</keyword>
			        <comment>-- Resize p.</comment>
			<keyword>do</keyword>
			        <feature_name>p</feature_name>.<feature_name>resize</feature_name>
    			<keyword>end</keyword>
		...
	<keyword>end</keyword>
		</code_block>
		<paragraph>  Thanks to the iteration mechanism, the procedure 
			<code>
				<feature_name>resize_paragraphs</feature_name>
			</code>  simply needs two procedure calls:
		</paragraph>
		<list ordered="false">
			<item>To set its argument 
				<code>
					<local_variable>t</local_variable>
				</code> as the iteration target, it uses procedure  
				<code>
					<feature_name>set</feature_name>
				</code>. (This procedure is from class  ITERATOR  which passes it on to all iterator classes.)
			</item>
			<item>Then it simply calls  until_do  as defined above.</item>
		</list>
		<paragraph>  Procedure  item_action  is redefined to describe the operation to be performed oneach successive element. Function  item_test  is redefined to describe the exit test.
			<line_break/>  As presented so far, the mechanism seems to limit every descendant of an iteration class to just  one form of iteration. As shown later in this chapter, it is in fact easy to generalize the  technique to allow a class to use an arbitrary number of iteration schemes.
			<line_break/>  What is interesting here is that the redefinitions of  item_test  and  item_action  take care of all the details. There is no need to write any loop or other control structure. We  are at the very heart of the object-oriented method, enjoying the ability to encapsulate  useful and common software schemes so that client developers will only need to fill in  what is specific to their application.
		</paragraph>
		<heading>
			<size>1</size>Using the Iteration Library
		</heading>
		<paragraph>  Let us now explore the classes of the Iteration library and the different ways of using  them.</paragraph>
		<heading>
			<size>2</size>Overview of the classes
		</heading>
		<paragraph>  There are only four Iteration classes, whose simple inheritance structure appeared at the  beginning of this chapter.</paragraph>
		<list ordered="false">
			<item>ITERATOR,  a deferred class which describes the most general notion.</item>
			<item>LINEAR_ITERATOR,  for iterating over linear structures and chains.</item>
			<item>TWO_WAY_CHAIN_ITERATOR,  a repeated heir of  LINEAR_ITERATOR,  for iterating in either direction over a bilinear structure.</item>
			<item>CURSOR_TREE_ITERATOR,  for iterating over trees.</item>
		</list>
		<paragraph>  As you will remember from the 
			<link>
				<url>/libraries/base/content/20_structures/10_taxonomy.html</url>
				<label>presentation</label>
			</link> of the abstract overall taxonomy,  the traversal hierarchy describes how data structures can be traversed; its most general class  is TRAVERSABLE.
			<line_break/>  Each one of the iterator classes is paired with a traversal class (ortwo in one case):
		</paragraph>
		<table>
			<row>
				<cell>ITERATOR</cell>
				<cell>TRAVERSABLE</cell>
			</row>
			<row>
				<cell>LINEAR_ITERATOR</cell>
				<cell>LINEAR</cell>
			</row>
			<row>
				<cell>TWO_WAY_CHAIN_ITERATOR</cell>
				<cell>TWO_WAY_LIST</cell>
			</row>
			<row>
				<cell>TWO_WAY_CHAIN_ITERATOR</cell>
				<cell>TWO_WAY_LIST, TWO_WAY_CIRCULAR</cell>
			</row>
			<row>
				<cell>CURSOR_TREE_ITERATOR</cell>
				<cell>CURSOR_TREE</cell>
			</row>
		</table>
		<paragraph>Each iterator class relies on the corresponding traversal class to provide the features  for traversing the corresponding data structures, such as start, forth and exhausted for  linear structures.
			<line_break/>  Of course the data structure class used in connection with a given iterator class does not need to  be the iterator?s exact correspondent as given by the above table; it may be any one of its  descendants. For example you may use  LINEAR_ITERATOR  to iterate over data structuresdescribed not just by  LINEAR  but also by such descendants as  LIST, LINKED_LIST,  ARRAYED_LIST,  or even  TWO_WAY_LIST  if you do not need the backward iteration features (for which you will have to use  TWO_WAY_CHAIN_ITERATOR  ).
		</paragraph>
		<heading>
			<size>2</size>General iteration facilities
		</heading>
		<paragraph>  Class  ITERATOR  defines the features that apply to all forms of iterator.
			<line_break/>  An iterator will always apply to a certain target structure. The target is introduced in  ITERATOR by the feature  target:  TRAVERSABLE [G]
			<line_break/>  Both the iterator classes and the traversal classes are generic, with a formal generic  parameter G. The actual generic parameters will be matched through the choice of  iteration target: for a generic derivation of the form  
			<code>
				<class_name>SOME_ITERATOR</class_name>
			</code> [
			<code>
				<class_name>ACTUAL_TYPE</class_name>
			</code>]  the target can only be of type  
			<code>
				<class_name>SOME_TRAVERSABLE</class_name>
			</code> [
			<code>
				<class_name>ACTUAL_TYPE</class_name>
			</code>]  for the same
			<code>
				<class_name>ACTUAL_TYPE</class_name>
			</code>, where  
			<code>
				<class_name>SOME_TRAVERSABLE</class_name>
			</code> is the traversal class matching  
			<code>
				<class_name>SOME_ITERATOR</class_name>
			</code> according to the preceding table  (LINEAR  for  LINEAR_ITERATOR  and so on), or one of its proper descendants.
			<line_break/>  Each of the proper descendants of  ITERATOR  redefines the type of target to the matching proper descendant of  TRAVERSABLE,  to cover more specific variants of the iteration target, For example in  LINEAR_ITERATOR the feature is redefined to be of  type LINEAR.  ITERATOR  also introduces the procedure for selecting a target:
		</paragraph>
		<code_block>
	set <symbol>(</symbol>s<symbol>:</symbol> <keyword>like</keyword> target<symbol>)</symbol> <keyword>is</keyword>
        		<comment>-- Make s the new target of iterations.</comment>
    		<keyword>require</keyword>
        		s <symbol>/=</symbol> Void
    		<keyword>do</keyword>
        		<feature_name>target</feature_name> <symbol>:</symbol><symbol>=</symbol> s
    		<keyword>ensure</keyword>
        		<feature_name>target</feature_name> <symbol>=</symbol> s
        		<feature_name>target</feature_name> <symbol>/= Void</symbol>
    		<keyword>end</keyword>
		</code_block>
		<paragraph>  Next  ITERATOR  introduces the routines describing the elementary action and test  that will be applied to items of the iteration targets:</paragraph>
		<code_block>
	action <keyword>is</keyword>
    		    	<comment>-- Action to be applied to item at current position in</comment>
		    	<comment>-- target.</comment>
        		<comment>-- (default: item_action on item at current position.)</comment>
        		<comment>-- Note: for iterators to work properly, redefined</comment>
		        <comment>-- versions of this feature should not change the</comment>
		        <comment>-- traversable structure.</comment>
	    	<keyword>require</keyword>
        		traversable_exists<symbol>:</symbol> <feature_name>target</feature_name> <symbol>/=</symbol> Void
        		not_off<symbol>:</symbol> <keyword>not</keyword> <feature_name>target</feature_name>.<feature_name>off</feature_name>
        		invariant_satisfied<symbol>:</symbol> invariant_value
    		<keyword>do</keyword>
        		<feature_name>item_action </feature_name><symbol>(</symbol><feature_name>target</feature_name>.<feature_name>item</feature_name><symbol>)</symbol>
    		<keyword>ensure</keyword>
        		not_off<symbol>:</symbol> <keyword>not</keyword> <feature_name>target</feature_name>.<feature_name>off</feature_name>
        		invariant_satisfied<symbol>:</symbol> invariant_value
    		<keyword>end</keyword>

	<feature_name>test</feature_name><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
        		<comment>-- Test to be applied to item at current position in</comment>
        		<comment>-- target (default: value of item_test on item)</comment>
    		<keyword>require</keyword>
        		traversable_exists<symbol>:</symbol> <feature_name>target</feature_name> <symbol>/=</symbol> Void
        		not_off<symbol>:</symbol> <keyword>not</keyword> <feature_name>target</feature_name>.<feature_name>off</feature_name>
    		<keyword>do</keyword>
        		Result <symbol>:</symbol><symbol>=</symbol> item_test <symbol>(</symbol><feature_name>target</feature_name>.<feature_name>item</feature_name><symbol>)</symbol>
    		<keyword>ensure</keyword>
        		<keyword>not</keyword> <feature_name>target</feature_name>.<feature_name>off</feature_name>
    	<keyword>end</keyword>
		</code_block>
		<paragraph>  These routines rely on two others,  item_action and  item_test,  which both take anargument of type G, the formal generic parameter. The reason, already noted above, is  that in a vast majority of cases the iterated action and test solely depend, at each step of  the traversal, on the item (of type G) at the current position. To define an iteration  process, then, it suffices to redefine item_action and item_test in a descendant of the  appropriate iteration class. Only in complex cases will it be necessary to redefine action and test themselves.
			<line_break/>  If you encounter such a case, note the caveat about action changing the target?s structure.  Understandably enough, an iterator that attempts to change the data structure while traversing it  may engage in strange behavior. No such risk exists if you only redefine item_action, which  may change the contents of items but not the structure itself.
			<line_break/>  Another feature introduced in  ITERATOR  is the query  invariant_value,  describing invariant properties that must be ensured at the beginning of any iteration and preserved  by every iteration step. As declared in  ITERATOR  this query always returns true, but proper descendants can redefine it to describe more interesting  invariant properties.
			<line_break/>  Finally,  ITERATOR  introduces in deferred form the general iteration routines applicable to all iteration variants.  They include two queries corresponding to the quantifiers of first-order predicate calculus:
		</paragraph>
		<list ordered="false">
			<item>for_all  will return true if all items of the target structure satisfy test.</item>
			<item>exists  will return true if at least one item satisfies test.</item>
		</list>
		<paragraph>  The other routines are commands which will traverse the target structure and apply  action to items selected through test:</paragraph>
		<list ordered="false">
			<item>do_all  applies action to all items.</item>
			<item>do_if,  to those items which satisfy test.</item>
			<item>until_do,  to all items up to but excluding the first one that satisfies test.</item>
			<item>do_until,  to all items up to and including the first one that satisfies test.</item>
			<item>while_do  and  do_while,  to all items up to the first one that does not satisfy  test.  (This can also be achieved with  until_do  or  do_until  by choosing the opposite test.)</item>
		</list>
		<paragraph>  All these features, and most of the other iteration features introduced in proper  descendants of  ITERATOR  and described next, have no argument. Information about the target of iteration comes  from feature  target,  set by procedure  set;  information about what needs to be done for each item of the target structure comes from  item_action  and  item_test.</paragraph>
		<heading>
			<size>2</size>Linear and chain iteration
		</heading>
		<paragraph>LINEAR_ITERATOR,  an effective class, refines the iteration mechanisms for cases inwhich the target is a linear  structure, such as a list in any implementation or a circular chain.
			<line_break/>  The class effects all the deferred features inherited from  ITERATOR,  taking advantage of the linear traversal mechanisms present in the corresponding traversal class,  LINEAR.  Here for example is the effecting of  do_if:
		</paragraph>
		<code_block>
	do_<keyword>if</keyword> <keyword>is</keyword>
			<comment>-- Apply action to every item of target satisfying         </comment>
			<comment>-- test.</comment>
    		<keyword>do</keyword>
        		<keyword>from</keyword>
				<feature_name>target</feature_name>.<feature_name>start</feature_name>
        		<keyword>invariant</keyword>
            			invariant_value
        		<keyword>until</keyword>
            			<feature_name>target</feature_name>.<feature_name>exhausted</feature_name>
        		<keyword>loop</keyword>
            			<keyword>if</keyword> <feature_name>test</feature_name> <keyword>then</keyword>
                		<feature_name>action</feature_name>
            		<keyword>end</keyword>
            		<feature_name>forth</feature_name>
        	<keyword>end</keyword>
    	<keyword>end</keyword>
		</code_block>
		<paragraph>  This routine text relies on features  start,  forth and  exhausted  which, together with  off,  have for convenience been carried over to  LINEAR_ITERATOR  from their counterparts in  LINEAR,  with feature declarations such as</paragraph>
		<code_block>
	<feature_name>off</feature_name><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
			<comment>-- Is position of target off?</comment>
    		<keyword>require</keyword>
        		traversable_exists<symbol>:</symbol> target <symbol>/=</symbol> Void
    		<keyword>do</keyword>
        		Result <symbol>:</symbol><symbol>=</symbol> <feature_name>target</feature_name>.<feature_name>off</feature_name>
    		<keyword>end</keyword>
		</code_block>
		<paragraph>  and similarly for the others.
			<line_break/>  In addition to effecting the general iteration features from  ITERATOR,  class  LINEAR_ITERATOR  introduces iteration features that apply to the specific case of linear structures:
		</paragraph>
		<list ordered="false">
			<item>search
				<code>
					<symbol>(</symbol>
					<local_variable>b</local_variable>
					<symbol>:</symbol>BOOLEAN)  moves the iteration to the first position satisfying test if 
					<local_variable>b</local_variable>  is true, or not satisfying test if 
					<local_variable>b</local_variable>
				</code> is false. This use of a boolean argument to  switch between two opposite semantics is not part of the recommended style, and  you will find few if any other examples in the Base libraries. Here, however, it  was deemed preferable to the alternative, which would have involved four  separate procedures (if together with  search  we consider  continue_search  discussed next).
			</item>
			<item>With a linear structure we can implement an iteration corresponding to the 'for'  loop of traditional programming languages, defined by three integers: the starting  position, the number of items to be traversed, and the step between consecutive  items. This is provided by procedure  do_for
				<code>
					<symbol>(</symbol>
					<local_variable>starting</local_variable>
					<symbol>,</symbol>
					<local_variable>number</local_variable>
					<symbol>,</symbol>
					<local_variable>step</local_variable>
					<symbol>:</symbol>INTEGER).
				</code>
			</item>
			<item>Since with a linear target the iterator can advance the cursor step by step, the  basic iteration operations are complemented by variants which pick up from the  position reached by the last call:  continue_until,  until_continue,  continue_while,  while_continue,  continue_search,  continue_for.</item>
		</list>
		<heading>
			<size>2</size>Two-way iteration
		</heading>
		<paragraph>  Class  TWO_WAY_CHAIN_ITERATOR  has all the features of  LINEAR_ITERATOR,  to which it adds features for iterating backward as well as forward.
			<line_break/>  The class introduces commands  finish and  back,  applying the correspondingoperations to the two-way target. It also has a backward variant for every iteration  feature. The name of each such variant is the name of the forward feature followed by  
			<italic>_back</italic>:  do_all_back,  until_do_back  and so on.
			<line_break/>  An alternative design would have kept just one set of features and added two features: a  command reverse to reverse the direction of future iteration operations, and a query backward  to find out the direction currently in force.
			<line_break/>  Contrary to what one might at first imagine, class  TWO_WAY_CHAIN_ITERATOR  is extremely short and simple; its 
			<code>
				<keyword>Feature</keyword>
			</code> clause only contains the declarations of two  features,  finish and  back.
			<line_break/>  The trick is to use repeated inheritance.  TWO_WAY_CHAIN_ITERATOR  inherits twice from  LINEAR_ITERATOR;  the first inheritance branch yields the forward iteration features,  the second yields those for backward iteration. There is  no need for any explicit declaration or redeclaration of iteration features. Here is the  entire class text that yields this result:
		</paragraph>
		<code_block>
	<keyword>class</keyword>
    		<class_name>TWO_WAY_CHAIN_ITERATOR</class_name> <symbol>[</symbol><class_name>G</class_name><symbol>]</symbol>

	<keyword>inherit</keyword>
    		<class_name>LINEAR_ITERATOR</class_name> <symbol>[</symbol><class_name>G</class_name><symbol>]</symbol>
        		<keyword>redefine</keyword>
            			<feature_name>target</feature_name>
        		<keyword>select</keyword>
            			<feature_name>start</feature_name>,
            			<feature_name>forth</feature_name>,
             			<feature_name>do_all</feature_name>,
            			<feature_name>until_do</feature_name>,
            			<feature_name>do_until</feature_name>,
            			<feature_name>do_if</feature_name>,
            			<feature_name>do_for</feature_name>,
            			<feature_name>search</feature_name>,
            			<feature_name>forall</feature_name>,
            			<feature_name>exists</feature_name>,
             			<feature_name>until_continue</feature_name>,
            			<feature_name>continue_until</feature_name>,
             			<feature_name>continue_for</feature_name>,
            			<feature_name>continue_search</feature_name>
        		<keyword>end</keyword>

		<class_name>LINEAR_ITERATOR</class_name> <symbol>[</symbol><class_name>G</class_name><symbol>]</symbol>
			<keyword>rename</keyword>
   				<feature_name>start</feature_name> <keyword>as</keyword> <feature_name>finish</feature_name>,
   				<feature_name>forth</feature_name> <keyword>as</keyword> <feature_name>back</feature_name>,
   				<feature_name>do_all</feature_name> <keyword>as</keyword> <feature_name>do_all_back</feature_name>,
   				<feature_name>until_do</feature_name> <keyword>as</keyword> <feature_name>until_do_back</feature_name>,
   				<feature_name>do_until</feature_name> <keyword>as</keyword> <feature_name>do_until_back</feature_name>,
   				<feature_name>do_if</feature_name> <keyword>as</keyword> <feature_name>do_if_back</feature_name>,
   				<feature_name>do_for</feature_name> <keyword>as</keyword> <feature_name>do_for_back</feature_name>,
   				<feature_name>search</feature_name> <keyword>as</keyword> <feature_name>search_back</feature_name>,
   				<feature_name>forall</feature_name> <keyword>as</keyword> <feature_name>forall_back</feature_name>,
   				<feature_name>exists</feature_name> <keyword>as</keyword> <feature_name>exists_back</feature_name>,
   				<feature_name>until_continue</feature_name> <keyword>as</keyword> <feature_name>until_continue_back</feature_name>,
   				<feature_name>continue_until</feature_name> <keyword>as</keyword> <feature_name>continue_until_back</feature_name>,
   				<feature_name>continue_for</feature_name> <keyword>as</keyword> <feature_name>continue_for_back</feature_name>,
   				<feature_name>continue_search</feature_name> <keyword>as</keyword> <feature_name>continue_search_back</feature_name>
        		<keyword>redefine</keyword>
            			<feature_name>target</feature_name>
        		<keyword>end</keyword>

	<keyword>feature</keyword> -- Status report

    		<feature_name>target</feature_name><symbol>:</symbol> <class_name>BILINEAR</class_name> <symbol>[</symbol><class_name>G</class_name><symbol>]</symbol>
            		<comment>-- The structure to which iteration features will</comment>
            		<comment>-- apply</comment>

	<keyword>feature</keyword> -- Curs<keyword>or</keyword> movement

    		<feature_name>finish</feature_name> <keyword>is</keyword>
        			<comment>-- Move cursor of target to last position.</comment>
        		<keyword>do</keyword>
            			<feature_name>target</feature_name>.<feature_name>finish</feature_name>
        		<keyword>end</keyword>

    		<feature_name>back</feature_name> <keyword>is</keyword>
            			<comment>-- Move cursor of target backward one position.</comment>
        		<keyword>do</keyword>
            			<feature_name>target</feature_name>.<feature_name>back</feature_name>
        		<keyword>end</keyword>
	<keyword>end</keyword>
		</code_block>
		<paragraph>  This class provides a good example of the economy of expression that the full  inheritance mechanism affords through the combination of renaming, redefinition,  repeated inheritance rules and selection, without sacrificing clarity and maintainability.</paragraph>
		<heading>
			<size>2</size>Tree iteration
		</heading>
		<paragraph>  Tree iterations, provided by class  CURSOR_TREE_ITERATOR,  work on trees of the cursor tree form; only with this form of tree are traversal operations possible.  Three forms of iteration are provided: preorder, postorder and breadth-first. They  correspond to the three traversal policies described in the discussion of trees.  Here too it would seem that a rather lengthy class is needed, but repeated  inheritance works wonders.
			<line_break/>CURSOR_TREE_ITERATOR  simply inherits three times from  LINEAR_ITERATOR,  renaming the features appropriately in each case:
		</paragraph>
		<list ordered="false">
			<item>
				<code>
					<feature_name>pre_do_all</feature_name>
				</code>,  
				<code>
					<feature_name>pre_until</feature_name>
				</code>  and so on.
			</item>
			<item>
				<code>
					<feature_name>post_do_all</feature_name>
				</code>,  
				<code>
					<feature_name>post_until</feature_name>
				</code>  and so on.
			</item>
			<item>
				<code>
					<feature_name>breadth_do_all</feature_name>
				</code>,  
				<code>
					<feature_name>breadth_until</feature_name>
				</code>  and so on.
			</item>
		</list>
		<paragraph>  All it needs to do then is to redefine the type of target to be  CURSOR_TREE
			<code>
				<symbol>[</symbol>
			</code>
			<code>
				<class_name>G</class_name>
			</code>
			<code>
				<symbol>]</symbol>
			</code>,  and to redefine six features: the three renamed  start  (
			<code>
				<feature_name>pre_start</feature_name>
			</code>  etc.) and the three  forth  (
			<code>
				<feature_name>pre_ forth</feature_name>
			</code>  and so on). These seven redefinitions give us a full-fledged battery of tree  iteration mechanisms.
		</paragraph>
		<heading>
			<size>1</size>Building and Using Iterators
		</heading>
		<paragraph>  To conclude this discussion, let us now put together the various mechanisms studied so  far, to see how authors of client software can use the Iteration library to perform  possibly complex iterations on various data structures without ever writing a single loop  or test. The basic ideas were sketched above but now we have all the elements for the  full view.
			<line_break/>  An application class may use one of the iteration classes in either of two ways: as a  descendant (single or repeated) or as a client. The descendant technique is extremely  simple but less versatile.
		</paragraph>
		<heading>
			<size>2</size>The single descendant technique
		</heading>
		<paragraph>  Assume an application class  
			<code>
				<class_name>PROCESSOR</class_name>
			</code>  that is a proper descendant of one of the effective iteration classes studied in this chapter.  Then a routine of  
			<code>
				<class_name>PROCESSOR</class_name>
			</code>, say  
			<code>
				<feature_name>iterate</feature_name>
			</code>, may iterate a certain action over a data structure, subject to a certain test.  First, class 
			<code>
				<class_name>PROCESSOR</class_name>
			</code> must specify the action by redefining  item_action and  item_test  (or, in the most general case,  action and  test).  Then routine iterate must specify the target data structure through a call of the form  set
			<code>
				<symbol>(</symbol>
			</code>
			<code>
				<local_variable>t</local_variable>
				<symbol>)</symbol>  where 
				<local_variable>t</local_variable> represents the selected target data structure. The type of  
				<local_variable>t</local_variable> must correspond tothe iteration class selected as ancestor of  
			</code>
			<code>
				<class_name>PROCESSOR</class_name>
			</code>:  for  LINEAR_ITERATOR  it must be a descendant of  LINEAR  (such as  LINKED_LIST,  ARRAYED_LIST,  LINKED_CIRCULAR  or any other list or circular chain classes); for  TWO_WAY_CHAIN_ITERATOR  it must be a descendant of  BILINEAR  such as  TWO_WAY_LIST  or  TWO_WAY_CIRCULAR;  for  CURSOR_TREE_ITERATOR  it must be a descendant of  CURSOR_TREE.  In all cases the actual generic parameters of the iterator class and ofthe data structure class must be compatible.  Then the iteration proper is obtained simply by calling the appropriate procedure, without any qualification  or arguments, for example:  do_ if
			<line_break/>  It is hard to imagine a simpler scheme: no loops, no initialization, no arguments.  Feature  item_action  may need to rely on some variable values. Because it does not take any  argument, such values will have to be treated as attributes, with the corresponding 
			<code>
				<feature_name>set_...</feature_name>
			</code>  procedures to set and change their values. This also applies to the two schemes set next.
			<line_break/>  The single descendant technique has one drawback: it provides the iterating class,  
			<code>
				<class_name>PROCESSOR</class_name>
			</code>,  with only one set of iteration particulars. This limitation does not affect  the number of targets: you may use as many targets as you wish, as long as they are of  compatible types, by calling a routine such as iterate several times, or calling several  such routines, each call being preceded by a call to set to define a new target. The  limitation also does not affect the iterating scheme: one iteration could use  do_if,  the next  do_all  and so on. But it does require the action and test to be the same in all cases.
			<line_break/>  The next two techniques will remove this limitation.
		</paragraph>
		<heading>
			<size>2</size>Using repeated inheritance
		</heading>
		<paragraph>  One way to obtain several iteration schemes is a simple extension to the single  descendant technique. You can use repeated inheritance to provide two or more variants.  We have in fact already encountered the technique when studying how to derive  TWO_WAY_CHAIN_ITERATOR  and  CURSOR_TREE_ITERATOR  from  LINEAR_ITERATOR.  The general pattern, applied here to just two iteration schemes but easily generalized to  more, is straightforward:</paragraph>
		<code_block>
	<keyword>class</keyword>
		<class_name>DUAL_PROCESSOR</class_name>

	<keyword>inherit</keyword>
		<class_name>LINEAR_ITERATOR</class_name> <symbol>[</symbol><class_name>SOME_TYPE</class_name><symbol>]</symbol>
 			<keyword>rename</keyword>
				<feature_name>item_action</feature_name> <keyword>as</keyword> <feature_name>action1</feature_name>,
 				<feature_name>item_test</feature_name> <keyword>as</keyword> <feature_name>test1</feature_name>,
				<feature_name>do_if</feature_name> <keyword>as</keyword> <feature_name>do_if1</feature_name>,
			<keyword>redefine</keyword>
				<feature_name>action1</feature_name>, <feature_name>test1</feature_name>
			<keyword>select</keyword>
				<feature_name>action1</feature_name>, <feature_name>test1</feature_name>
        		<keyword>end</keyword>

		<class_name>LINEAR_ITERATOR</class_name> <symbol>[</symbol><class_name>SOME_TYPE</class_name><symbol>]</symbol>
			<keyword>rename</keyword>
				<feature_name>item_action</feature_name> <keyword>as</keyword> <feature_name>action2</feature_name>,
				<feature_name>item_test</feature_name> <keyword>as</keyword> <feature_name>test2</feature_name>,
				<feature_name>do_if</feature_name> <keyword>as</keyword> <feature_name>do_if2</feature_name>,
			<keyword>redefine</keyword>
				<feature_name>action2</feature_name>, <feature_name>test2</feature_name>
			<keyword>end</keyword>

	<keyword>feature</keyword>

		<feature_name>action1</feature_name> <keyword>is</keyword>
				<comment>-- Action for the first scheme</comment>
			<keyword>do</keyword>
				...
			<keyword>end</keyword>

		<feature_name>test1</feature_name><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
				<comment>-- Test for the first scheme</comment>
			<keyword>do</keyword>
				...
			<keyword>end</keyword>

		<feature_name>action2</feature_name> <keyword>is</keyword>
				<comment>-- Action for the second scheme</comment>
			<keyword>do</keyword>
				...
			<keyword>end</keyword>

		<feature_name>test2</feature_name><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
				<comment>-- Test for the second scheme</comment>
			<keyword>do</keyword>
				...
			<keyword>end</keyword>

		<feature_name>iterate1</feature_name> <keyword>is</keyword>
				<comment>-- Execute iteration of first kind.</comment>
			<keyword>do</keyword>
				<feature_name>set </feature_name><symbol>(</symbol>...<symbol>)</symbol>
				<feature_name>do_if1</feature_name>
			<keyword>end</keyword>

		<feature_name>iterate2</feature_name> <keyword>is</keyword>
				<comment>-- Execute iteration of second kind.</comment>
			<keyword>do</keyword>
				<feature_name>set</feature_name> <symbol>(</symbol>...<symbol>)</symbol>
				<feature_name>do_if2</feature_name>
			<keyword>end</keyword>

			... 
		</code_block>
		<paragraph>  The repeated inheritance machinery takes care of the rest.</paragraph>
		<heading>
			<size>2</size>Using explicit iterator objects
		</heading>
		<paragraph>  To obtain maximum flexibility, classes that need iteration facilities should be clients  rather than descendants of the iteration classes. The resulting scheme is completely  dynamic: to perform iterations you use iterator objects as discussed earlier.
			<line_break/>  The following example illustrates the technique. Consider a deferred class  
			<code>
				<class_name>FIGURE</class_name>
			</code> describing the notion of graphical figure,  with many effective descendants (
			<code>
				<class_name>POLYGON</class_name>
			</code>,  
			<code>
				<class_name>CIRCLE</class_name>
			</code> and so on). It is useful to define  
			<code>
				<class_name>COMPLEX_FIGURE</class_name>
			</code>, describing figures that  are recursively composed of sub-figures. This is a remarkable example of multiple  inheritance:
		</paragraph>
		<code_block>
	<keyword>class</keyword>
    		<class_name>COMPLEX_FIGURE</class_name>

	<keyword>inherit</keyword>
    		<class_name>FIGURE</class_name>,
    		<class_name>LINKED_LIST</class_name> <symbol>[</symbol><class_name>FIGURE</class_name><symbol>]</symbol>

	<keyword>feature</keyword>
    		... <keyword>end</keyword> 
		</code_block>
		<paragraph>  In the feature clause we want to provide the appropriate effectings for the deferred  features of class 
			<code>
				<class_name>FIGURE</class_name>
			</code>:  
			<code>
				<feature_name>display</feature_name>
			</code>, 
			<code>
				<feature_name>hide</feature_name>
			</code>,  
			<code>
				<feature_name>translate</feature_name>
			</code> and all other basic figure operations.
			<line_break/>  We can use loops for that purpose, for example
		</paragraph>
		<code_block>
	display <keyword>is</keyword>
        		<comment>-- Recursively display all components of the complex</comment>
        		<comment>-- figure</comment>
    		<keyword>do</keyword>
        		<keyword>from</keyword>
            			<feature_name>start</feature_name>
        		<keyword>until</keyword>
            			<feature_name>exhausted</feature_name>
        		<keyword>loop</keyword>
				<feature_name>item</feature_name>.<feature_name>display</feature_name>
            			<feature_name>forth</feature_name>
        		<keyword>end</keyword>
    		<keyword>end</keyword>
		</code_block>
		<paragraph>  Although acceptable and even elegant, this scheme will cause significant  duplication: all the 
			<code>
				<class_name>FIGURE</class_name>
			</code> features - not  just 
			<code>
				<feature_name>display</feature_name>
			</code> but also 
			<code>
				<feature_name>hide</feature_name>
			</code>,  
			<code>
				<feature_name>rotate</feature_name>
			</code>, 
			<code>
				<feature_name>move</feature_name>
			</code> and  others - will have the same structure, with a loop. We can use iterators to avoid this  duplication. The repeated inheritance technique would work, but given the large number  of 
			<code>
				<class_name>FIGURE</class_name>
			</code> features the amount of repeated inheritance that would be needed seems  unwieldy. It is also not very desirable to have to change the inheritance structure of the  system just to add a new feature to 
			<code>
				<class_name>FIGURE</class_name>
			</code>. The more dynamic approach using iterator  objects seems preferable.
			<line_break/>  To implement this approach, define a class for iterating on complex figures: 
		</paragraph>
		<code_block>
	<keyword>class</keyword>
    		<class_name>COMPLEX_FIGURE_ITERATOR</class_name>

	<keyword>inherit</keyword>
    		<class_name>LINEAR_ITERATOR</class_name>
        		<keyword>redefine</keyword>
            			<feature_name>target</feature_name>
        		<keyword>end</keyword>

	<keyword>create</keyword>
    		<feature_name>set</feature_name>

	<keyword>feature</keyword>

    		<feature_name>target</feature_name><symbol>:</symbol> <class_name>COMPLEX_FIGURE</class_name>

	<keyword>end</keyword> 
		</code_block>
		<paragraph>  Then for each operation to be iterated define a small class. For example:</paragraph>
		<code_block>
	<keyword>class</keyword>
    		<class_name>FIGURE_DISPLAYER</class_name>

	<keyword>inherit</keyword>
    		<class_name>COMPLEX_FIGURE_ITERATOR</class_name>
        		<keyword>redefine</keyword>
            			<feature_name>item_action</feature_name>
        		<keyword>end</keyword>

	<keyword>create</keyword>
    		<feature_name>set</feature_name>

	<keyword>feature</keyword>

    		<feature_name>item_action</feature_name> <symbol>(</symbol>f<symbol>:</symbol> <class_name>FIGURE</class_name><symbol>)</symbol> <keyword>is</keyword>
		            	<comment>-- Action to be applied to each figure: display</comment>
            			<comment>-- it.</comment>
        		<keyword>do</keyword>
            			<feature_name>f</feature_name>.<feature_name>display</feature_name>
       			<keyword>end</keyword>
    	<keyword>end</keyword>
		</code_block>
		<paragraph>  Similarly, you may define 
			<code>
				<class_name>FIGURE_HIDER</class_name>
			</code>, 
			<code>
				<class_name>FIGURE_MOVER</class_name>
			</code> and others. Then  the features of 
			<code>
				<class_name>COMPLEX_FIGURE</class_name>
			</code> are written almost trivially, without any explicit  loops; for example:
		</paragraph>
		<code_block>
	<feature_name>display</feature_name> <keyword>is</keyword>
        		<comment>-- Recursively display all components of the complex</comment>
        		<comment>-- figure</comment>
    		<keyword>local</keyword>
        		<feature_name>disp</feature_name><symbol>:</symbol> <class_name>FIGURE_DISPLAYER</class_name>
    		<keyword>do</keyword>
        		<keyword>create</keyword> <feature_name>disp</feature_name>.<feature_name>set</feature_name> <symbol>(</symbol>Current<symbol>)</symbol>
        		<feature_name>disp</feature_name>.<feature_name>do_all</feature_name>
    		<keyword>end</keyword>
		</code_block>
		<paragraph>  and similarly for all the others.
			<line_break/>  Note the use of 
			<code>
				<feature_name>set</feature_name>
			</code> as creation procedure, which is more convenient than requiring  the clients first to create an iterator object and then to call 
			<code>
				<feature_name>set</feature_name>
			</code>. This is also safer, since  with 
			<code>
				<feature_name>set</feature_name>
			</code> as a creation procedure the client cannot forget to initialize the target. (If a class  
			<code>
				<class_name>C</class_name>
			</code> has a creation clause, the creation instruction  
			<code>
				<keyword>create</keyword>
			</code>  
			<code>
				<class_name>C</class_name>
			</code>.)
		</paragraph>
	</paragraph></document>