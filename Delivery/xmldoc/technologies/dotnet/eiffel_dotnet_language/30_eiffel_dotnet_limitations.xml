<document title="Eiffel for .NET Limitations" output="studio">
	<meta_data/>
	<paragraph>
		<heading>
			<size>2</size>Differences between Eiffel and Eiffel for .NET
		</heading>
		<heading>
			<size>3</size>Limitation of Eiffel for .NET in version 5. 2
		</heading>
		<paragraph>Most of the Eiffel mechanisms are supported in 5. 2. All missing features listed below are planned for addition in future releases: </paragraph>
		<list ordered="false">
			<item>No creation of Eiffel expanded class support</item>
			<item>Partial implementation of generic conformance (same as what was supported up to and including the 4.2 release of the Eiffel development environment). </item>
		</list>
		<paragraph>Eiffel for .NET supports:</paragraph>
		<list ordered="false">
			<item>Multiple Inheritance</item>
			<item>Design By Contract</item>
			<item>Exception handling</item>
			<item>Genericity</item>
			<item>Covariance</item>
			<item>Compilation of any existing Eiffel libraries as long as it does not include C externals that call into the Eiffel Software C runtime</item>
		</list>
		<heading>
			<size>3</size>Added to Eiffel and Eiffel for .NET
		</heading>
		<paragraph>The following syntax can be used to declare .NET custom attributes on Eiffel entities (features and classes):</paragraph>
		<code_block>
	<feature_name>empty</feature_name><symbol>:</symbol> <class_name>BOOLEAN</class_name> <keyword>is</keyword>
		<keyword>indexing</keyword>
			<comment>description</comment><symbol>:</symbol> "<string>Is Current empty?</string>"
			<comment>attribute</comment><symbol>:</symbol> <keyword>create</keyword> <symbol>{</symbol><class_name>SYSTEM_OBSOLETEATTRIBUTE</class_name><symbol>}</symbol><feature_name></feature_name>.<feature_name>make_obsoleteattribute_1</feature_name> <symbol>(</symbol>"<string>Use `is_empty</string><symbol>'</symbol> instead"<symbol>)</symbol> <keyword>end</keyword>
		<keyword>obsolete</keyword>
			"<string>Use is_empty instead</string>"
		<keyword>do</keyword>
			Result <symbol>:</symbol><symbol>=</symbol> is_empty
		<keyword>end</keyword>
</code_block>
		<paragraph>The previous example shows the declaration of the obsolete feature 
			<feature_name>empty</feature_name> . The custom attribute defined by 
			<class_name>SYSTEM_OBSOLETEATTRIBUTE</class_name> is used to ensure that any consumer of the resulting assembly will see the feature as being obsolete. The custom attribute is defined in the indexing clause 
			<code>
				<contract_tag>attribute</contract_tag>
			</code>. The definition consists of a creation expression that creates the custom attribute with the right parameters.
		</paragraph>
		<heading>
			<size>2</size>Differences between Eiffel for .NET and .NET
		</heading>
		<heading>
			<size>3</size>Covariance
		</heading>
		<paragraph>The CLR (Common Language Runtime) does not support covariance due to the type safety issue that full covariance implies (known as polymorphic CATCALLS in Eiffel). Although very rare, CATCALLS are not suitable to .NET where safety is one of the primary goals. </paragraph>
		<paragraph>Eiffel for .NET implements a safe variant of covariance that will always perform a check on the types to avoid a CATCALL. So when a CATCALL is going to be performed a `Invalid Cast Exception' will be raised by the CLR instead of an unexpected behavior as it is currently done in Eiffel. </paragraph>
		<paragraph>Another advantage of Eiffel for .NET's implementation of covariance is that it can be easily understood by CLS compliant consumer tools. These tools will actually benefit from the Eiffel for .NET covariance. </paragraph>
		<heading>
			<size>3</size>Genericity
		</heading>
		<paragraph>The CLR does not support generics at all, so that the following Eiffel for .NET classes:</paragraph>
		<list ordered="false">
			<item>
				<class_name>LIST [ANY]</class_name>
			</item>
			<item>
				<class_name>LIST [INTEGER]</class_name>
			</item>
		</list>
		<paragraph>will actually be generated as:</paragraph>
		<list ordered="false">
			<item>
				<class_name>LIST_ANY</class_name>
			</item>
			<item>
				<class_name>LIST_Int32</class_name>
			</item>
		</list>
		<paragraph>Meaning that if one wants to reuse an Eiffel generic class from another language than Eiffel for .NET, one has to use either 
			<class_name>LIST_ANY</class_name> or 
			<class_name>LIST_Int32</class_name>.
		</paragraph>
		<heading>
			<size>3</size>Enum types
		</heading>
		<paragraph>Eiffel for .NET supports .NET enum types implicitly. From the point of view of Eiffel, they are just considered as expanded classes. The only difference is in the code generation. Eiffel for .NET cannot declare new enum types yet. </paragraph>
		<heading>
			<size>3</size>ByRef
		</heading>
		<paragraph>Eiffel does not have the notion of `byref' argument passing. At the moment, Eiffel for .NET cannot call nor can it redefine a feature that has a byref argument. </paragraph>
	</paragraph></document>
