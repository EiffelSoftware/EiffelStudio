<document output="studio" title="Working at predefined level">
	<meta_data/>
	<paragraph>
		<table><border>1</border>
			<row>
				<cell>The example classes discussed in this section appear in the        subdirectory 
					<italic>predef </italic>of the example directory
				</cell>
			</row>
		</table>
		<paragraph>The first example shows how to use the predefined level classes,    covering many common client-server schemes. The work needed in this case    is minimal: just effect or redefine a few routines describing the    specific processing that your client and your server require.</paragraph>
		<heading>
			<size>3</size>The example
		</heading>
		<paragraph>The example describes a simple communication protocol. The client    sends to the server a list of strings, which together form the message 
			<italic>"This    is my test"</italic>; the server receives the corresponding object    structure, appends to it one more element - the string 
			<italic>"I'm    back"</italic> - and returns the result to the client, which will accept    it and print it. The server increases a counter each time it closes a    connection with a client, and will only accept three connections.
		</paragraph>
		<heading>
			<size>3</size>Object structures
		</heading>
		<paragraph>As noted above, it is possible with sockets, as any other <code><class_name>IO_MEDIUM</class_name></code>,    to send and receive simple objects such as integers. But for this first    example we are already more ambitious and want to exchange entire linked    lists of strings. The structures that we will exchange are described by    the following class:    
<code_block>
	<keyword>class</keyword>
		<class_name>OUR_MESSAGE</class_name>

	<keyword>inherit</keyword>

		<class_name>LINKED_LIST</class_name> <symbol>[</symbol><class_name>STRING</class_name><symbol>]</symbol>

		<class_name>STORABLE</class_name>

	<keyword>creation</keyword>
		<feature_name>make</feature_name>

	<keyword>end</keyword>
</code_block>
			<paragraph>Note that to make use of the storage and retrieval facilities the    objects to be exchanged must be instances of a class which, as here, is    a descendant of <code><class_name>STORABLE</class_name></code>.</paragraph>
			<heading>
				<size>3</size>Application classes and system structure
			</heading>
			<paragraph>The client and server mechanisms will be described by instances of    two classes that make up the example, called<code><class_name> OUR_CLIENT</class_name></code> and <code><class_name>OUR_SERVER</class_name></code>.</paragraph>
			<paragraph>We want to have the two communicating systems be two different    systems (compiled separately, with two separate Ace files).<code><class_name> OUR_CLIENT</class_name></code>
				<italic/>will be part of one of these systems; <code><class_name>OUR_SERVER</class_name></code>
				<italic/>will be part    of the other.
			</paragraph>
			<paragraph>There are four predefined classes, corresponding to the client and    server sides with, in each case, the choice between the "Unix"    (single-machine) and "network" (multi-machine) styles of    communication. Note that all these classes support stream communication;    for datagrams, see 
				<link>
					<url>70_datagram_sockets.xml</url>
					<label>using datagram sockets</label>
				</link>.    The server class should inherit from <code><class_name>UNIX_SERVER</class_name></code>    or 
				<link>
					<url>../reference/network/client_server/network_server_chart.xml</url>
					<label>NETWORK_SERVER</label>
				</link>;    the client class should inherit from <code><class_name>UNIX_CLIENT</class_name></code>    or <code><class_name>NETWORK_CLIENT</class_name></code>.    The choice between <code><class_name>UNIX_</class_name></code> and <code><class_name>NETWORK_</class_name></code> classes must of course be the same    on both sides.
			</paragraph>
			<heading>
				<size>3</size>The client
			</heading>
			<paragraph>Here is the client class:    
<code_block>
	<keyword>class</keyword>
		<class_name>OUR_CLIENT</class_name>

	<keyword>inherit</keyword>
	
		<class_name>UNIX_CLIENT</class_name>
			<keyword>redefine</keyword>  
				<feature_name>received</feature_name>
			<keyword>end</keyword>
	
	<keyword>creation</keyword>
		<feature_name> make_client</feature_name>
	
	<keyword>feature</keyword>
	
		<feature_name>our_list</feature_name><symbol>:</symbol> <class_name>OUR_MESSAGE</class_name>
	
		<feature_name>received</feature_name><symbol>:</symbol> <class_name>OUR_MESSAGE</class_name>
			<comment>-- Type redefinition</comment>
	
		<feature_name>make_client</feature_name> <keyword>is</keyword>
				<comment>-- Build list, send it, receive modified list, and print it.</comment>
			<keyword>do</keyword>
				<feature_name>make</feature_name> <symbol>(</symbol><string>"/tmp/here"</string><symbol>)</symbol>
	    			<feature_name>build_list</feature_name>
				<feature_name>send</feature_name> <symbol>(</symbol><feature_name>our_list</feature_name><symbol>)</symbol>
				<feature_name>receive</feature_name>  
				<feature_name>process_received</feature_name>
				<feature_name>cleanup</feature_name>
			<keyword>rescue</keyword>  
				<feature_name>cleanup </feature_name>
			<keyword>end</keyword>
	
		<feature_name>build_list </feature_name><keyword>is</keyword>  
				<comment>-- Build list of strings our_list for transmission to server. </comment>
			<keyword>do</keyword> 
				<keyword>create</keyword> <feature_name>our_list</feature_name>.<feature_name>make</feature_name>;
				<feature_name>our_list</feature_name>.<feature_name>extend</feature_name> <symbol>(</symbol><string>"This "</string><symbol>)</symbol>;
				<feature_name>our_list</feature_name>.<feature_name>extend</feature_name> <symbol>(</symbol><string>"is  "</string><symbol>)</symbol>
				<feature_name>our_list</feature_name>.<feature_name>extend</feature_name> <symbol>(</symbol><string>"our "</string><symbol>)</symbol>; 
				<feature_name>our_list</feature_name>.<feature_name>extend</feature_name> <symbol>(</symbol><string>"test"</string><symbol>)</symbol>
			<keyword>end</keyword>
	
		<feature_name>process_received </feature_name><keyword>is</keyword>
				<comment>-- Print the contents of received in sequence.</comment>
			<keyword>do</keyword> 
				<keyword>if</keyword> <feature_name>received </feature_name><symbol>=</symbol> <keyword>Void</keyword> <keyword>then</keyword> 
					<feature_name>io</feature_name>.<feature_name>putstring</feature_name> <symbol>(</symbol><string>"No list received"</string><symbol>)</symbol> 
				<keyword>else</keyword> 
					<keyword>from</keyword> 
						<feature_name>received</feature_name>.<feature_name>start</feature_name>  
					<keyword>until</keyword>
						<feature_name>received</feature_name>.<feature_name>after</feature_name>  
					<keyword>loop</keyword>
						<feature_name>io</feature_name>.<feature_name>putstring</feature_name><symbol>(</symbol><feature_name>received</feature_name>.<feature_name>item</feature_name><symbol>)</symbol>  
						<feature_name>received</feature_name>.<feature_name>forth</feature_name>  
					<keyword>end</keyword> 
				<keyword>end</keyword> 
	        			<feature_name>io</feature_name>.<feature_name>new_line</feature_name>
	    		<keyword>end</keyword> 
	<keyword>end</keyword>
</code_block>
				<paragraph>The scheme is very simple:    
					<list ordered="false">
						<item>The inherited procedure 
							<italic>make</italic> takes care of the many details      of creating a socket and setting up the communication; the following      sections will give some insight into what this involves. The      argument to 
							<italic>make</italic> is the path name that has been selected to      enable communication with the server: 
							<italic>/tmp/here</italic>.
						</item>
						<item>The client has defined a procedure 
							<italic>build_list</italic> to construct      an object structure.
						</item>
						<item>It then uses the inherited procedure 
							<italic>send</italic> to send this      object structure to the server; 
							<italic>send</italic> expects an argument of a      type conforming to <code><class_name>STORABLE</class_name></code>,      so that it can use all the predefined storage and retrieval      facilities.
						</item>
						<item>The 
							<italic>receive</italic> procedure, called next, obtains an object      structure from the server; here, as will be seen from the server's      text below, this is the original list to which the server has      appended a new element. The result of procedure 
							<italic>receive</italic> is      available through feature 
							<italic>received</italic>. To avoid the need for an      assignment attempt (as with the result of a 
							<italic>retrieve</italic>      operation with <code><class_name>STORABLE</class_name></code>)      the class redefines 
							<italic>received</italic> to be of type <code><class_name>STORABLE</class_name></code>.
						</item>
						<item>The client has defined a procedure 
							<italic>process_received</italic> to      print the received string.
						</item>
						<item>Finally, a call to 
							<italic>cleanup </italic>is necessary to close the      sockets that have been opened and free the corresponding resources.
						</item>
					</list>
					<paragraph>Of course, in a typical object-oriented design, the class and those    which appear in the rest of this set of examples may "do" more    than one thing and so may have more routines than the ones shown in this    document.</paragraph>
					<paragraph>This example shows how to write a client class in the most common    cases: inherit from <code><class_name>UNIX_CLIENT</class_name></code> or    <code><class_name>NETWORK_CLIENT</class_name></code>;    use 
						<italic>make</italic> to specify the socket address, 
						<italic>send</italic> to send an    object structure, 
						<italic>receive </italic>to receive an object structure, 
						<italic>received</italic>    to access it, and 
						<italic>cleanup </italic>to clean things up.
					</paragraph>
					<paragraph>There would be one difference for a <code><class_name>NETWORK_CLIENT</class_name></code>:    procedure 
						<italic>make</italic> would need two arguments, the name of a host and a    port on that host. For example, to connect to a server running on a    machine of name 
						<italic>serverhost </italic>and using port 2000, the call would    be:    
						<paragraph>make ("serverhost", 2000)</paragraph>
						<paragraph>As noted earlier, you may identify the machine by an Internet address    such as 
							<italic>"127.0.0.1"</italic> rather than by a host name.
						</paragraph>
						<heading>
							<size>3</size>The server
						</heading>
						<paragraph>Now, the server class:    
<code_block>
	<keyword>class</keyword>
	    <class_name>OUR_SERVER</class_name>
	
	<keyword>inherit</keyword>
	
	    <class_name>UNIX_SERVER</class_name>
	    <keyword>redefine</keyword>
	        received, respond
	    <keyword>end</keyword>
	
	<keyword>creation</keyword>
	    <feature_name>make_server</feature_name>
	
	<keyword>feature</keyword>
	
		<feature_name>received</feature_name><symbol>:</symbol> <class_name>OUR_MESSAGE</class_name>
	
		<feature_name>make_server</feature_name> <keyword>is</keyword>
				<comment>-- Receive list, print it, extend it, and send the result back.</comment>
			<keyword>do</keyword>
				<feature_name>make</feature_name> <symbol>(</symbol><string>"/tmp/here"</string><symbol>)</symbol>
				<feature_name>execute</feature_name>
			<keyword>rescue</keyword>
				<feature_name>cleanup</feature_name>
			<keyword>end</keyword>
		
		<feature_name>process_message</feature_name> <keyword>is</keyword>
				<comment>-- Print received list.</comment>
			<keyword>do</keyword>
				<keyword>from</keyword>
					<feature_name>received</feature_name>.<feature_name>start</feature_name>
				<keyword>until</keyword>
					<feature_name>received</feature_name>.<feature_name>after</feature_name>
				<keyword>loop</keyword>
					<feature_name>io</feature_name>.<feature_name>putstring</feature_name> <symbol>(</symbol><feature_name>received</feature_name>.<feature_name>item</feature_name><symbol>)</symbol>
					<feature_name>received</feature_name>.<feature_name>forth</feature_name>
				<keyword>end</keyword>
				<feature_name>io</feature_name>.<feature_name>new_line</feature_name>
			<keyword>end</keyword>
		
		<feature_name>respond</feature_name> <keyword>is</keyword>
				<comment>-- Extend received list.</comment>
			<keyword>do</keyword>
				<feature_name>received</feature_name>.<feature_name>extend</feature_name> <symbol>(</symbol>"<symbol>%</symbol><class_name>N</class_name> <class_name>I</class_name><symbol>'</symbol>m <feature_name>back</feature_name>.<feature_name></feature_name><symbol>%</symbol><class_name>N</class_name>"<symbol>)</symbol>
				<feature_name>resend</feature_name> <symbol>(</symbol><feature_name>received</feature_name><symbol>)</symbol>
			<keyword>end</keyword>
		
	<keyword>end</keyword>
</code_block>
							<paragraph>The developer's task is even easier here than on the client side. The    last instruction in the creation procedure is 
								<italic>execute</italic>, inherited    from the chosen <code><class_name>_SERVER</class_name></code> 
								<italic/>class, which executes a loop that will    repeatedly call 
								<italic>receive</italic>, 
								<italic>process_message</italic>, 
								<italic>respond</italic>    and 
								<italic>close</italic>. This loop is actually an infinite one, which will only    terminate if the server is killed (in which case a Rescue clause will    execute procedure 
								<italic>cleanup</italic>); indeed, a server is not expected to    terminate under normal circumstances.
							</paragraph>
							<paragraph>To define a server's behavior as desired for your particular    application, all you are required to do is to effect the procedure 
								<italic>process_message</italic>,    inherited from the <code><class_name>_SERVER</class_name></code> class in deferred form. (Remember that to    "effect" a deferred feature is to provide a non-deferred    version, also called an effective version.) Here the effective version    prints the list of strings received from the client.
							</paragraph>
							<paragraph>In addition, you may also, as here, redefine procedure 
								<italic>respond</italic>.    In the <code><class_name>_SERVER</class_name></code> class this procedure is effective, but it does nothing;    this means that you have nothing special to do for the common case in    which the server does not respond when it has received a message. Here,    however, we do want to respond; the redefined version of 
								<italic>respond</italic>    extends the 
								<italic>received</italic> string and returns it. Procedure 
								<italic>resend</italic>    sends an object structure back to the last connected client. It is also    possible to have more sophisticated versions of 
								<italic>respond</italic>, for    example to dispatch objects to all active clients; this will be shown in    a later example
							</paragraph>
							<paragraph>As in the client case there is a cleanup procedure to free the    sockets, but you do not need to call it explicitly; it is called by    execute. You may redefine this procedure to free some additional    resources of your own.</paragraph>
						</paragraph>
					</paragraph>
				</paragraph>
			</paragraph>
		</paragraph>
	</paragraph></document>
