<document title="Advanced Options" output="studio">
	<meta_data/>
	<paragraph>
		<paragraph>
			<image>
				<url/>
				<alt_text>Advanced dialog</alt_text>
			</image>
		</paragraph>
		<list ordered="false">
			<item>Address expression: lets you pass ` 
				<bold>$(s.to_c)</bold>' to a feature instead of declaring `a' of type 
				<bold>ANY</bold>, and then assigning ` 
				<bold>s.to_c</bold>' to `a' and passing ` 
				<bold>$a</bold>'. Turn this option on only if you have advanced knowledge of the garbage collector insides, since using this syntax illegally can lead to bugs very hard to trace. 
			</item>
			<item>Check vape: Enforce 
				<code>
					<compiler_error>VAPE</compiler_error>
				</code> validity constraint: lets you disable type checking for 
				<code>
					<compiler_error>VAPE</compiler_error>
				</code> errors in preconditions, which correspond to insufficiently exported features used in preconditions (ETL 2nd edition page 122).
			</item>
			<item>Console application: has no effect on Unix systems. It lets Windows users choose between creating a console application or a GUI application (in which case a console will be created if needed, instead of using the console the program was launched from).</item>
			<item>Dead code removal: should unused code be removed? (C code generation mode only)</item>
			<item>Dynamic runtime: makes the generated executable use a shared library version of the runtime on both Windows (DLL) and Unix platforms (.so) that supports shared libraries.(C code generation mode only)</item>
		</list>
		<note>
			<bold>Note</bold>: On Windows, the dynamic run-time is available only if you compile with the Microsoft Visual compiler.
		</note>
		<list ordered="false">
			<item>Exception trace: makes it possible to see a complete exception trace in a finalized application. Because it is adding some code to remember where the application was during the crash it can slow down the performance of your application by a factor of 5% to 30% depending of your platform. (C code generation mode only)</item>
			<item>Inlining, Inlining size: enables inlining on Eiffel features that can be inlined, i.e. whose size is less or equal to the specified size in the combo box. The size value given in parameter corresponds to the number of instructions as seen by the Eiffel compiler (for example a := b.f corresponds to 2 instructions). The inlining is very powerful since it can inline a function in all your Eiffel code, without scope limitation as found in C or C++ compilers. (C code generation mode only)</item>
			<item>Multithreaded runtime: generates a multithreaded application. This option cannot be changed during the development of your project and has to be set correctly at the first compilation of your system. (C code generation mode only)</item>
			<item>Old verbatim strings: Use the old format for verbatim strings</item>
			<item>Platform: override platform value used for checking conditions, useful for cross compilation</item>
			<item>Shared library definition: lets you specify a `file_name.def' as the file where the Eiffel compiler will look when it tries to generate the exported functions of the shared library you are developing (C code generation mode only). To have more information concerning definition files, see the 
				<link>
					<url>../30_compiler/40_dynamic_library_generation/00_introduction.xml</url>
					<label>Dynamic library builder reference</label>
				</link>.
			</item>
			<item>Library root: Absolute path to use as base for relative paths. If this is not defined, the path to the configuration file will be used.</item>
		</list>
		<heading>
			<size>2</size>.NET Options
		</heading>
		<list ordered="false">
			<item>Use optimized precompile: use an optimized version of a precompile</item>
			<item>Use cluster name as namespace: See  
				<link>
					<url>50_advanced_general.xml</url>
					<anchor_name>dotnet_naming</anchor_name>
					<label>Class and feature naming</label>
				</link>
			</item>
			<item>Use recursive cluster name as namespace: See  
				<link>
					<url>50_advanced_general.xml</url>
					<anchor_name>dotnet_naming</anchor_name>
					<label>Class and feature naming</label>
				</link>
			</item>
			<item>.NET naming convention: See  
				<link>
					<url>50_advanced_general.xml</url>
					<anchor_name>dotnet_naming</anchor_name>
					<label>Class and feature naming</label>
				</link>
			</item>
			<item>IL verifiable: in the .NET world, verifiability is important. This is the only way to ensure that an application is not going to crash or to crash your system by accessing not authorized memory locations. Due to some semantic differences between Eiffel and.NET, our code generation is not always verifiable for performance reasons. If you want your code to be verifiable, you need to select this option. The compiler will then generate a code that will be slightly slower.</item>
			<item>CLS compliant: mark generated assemblies as CLS compliant</item>
			<item>Metadata cache path: Location where information about external assemblies is stored.</item>
			<item>Classes per module: How many classes per generated module?</item>
			<item>.NET runtime version: .NET version to use</item>
			<item>Generation type: generate an exe or a dll (exe is default)</item>
			<item>Signing key: specify a cryptographic key for your application so that the compiled assembly can be added to the Global Assembly Cache (GAC).  If a non existing filename is choosen, a key will be automatically generated.</item>
			<item>Force 32bit: on a 64bit machine, forces compilation for 32 bit.</item>
		</list>
		<anchor>dotnet_naming</anchor>
		<heading>
			<size>3</size>Class and feature naming
		</heading>
		<paragraph> </paragraph>The standard naming conventions for .NET and Eiffel are different.  To accommodate this difference Eiffel Studio provides a number of options to the developer, allowing for consistent naming of classes and features within and between .NET systems.  To illustrate this we shall consider a system using the EiffelBase library and focus on the CURSOR class.  The base cluster is included in the project settings Cluster tab as shown below, where $ISE_EIFFEL is the environment variable pointing to the location of Eiffel on your hard disk. 
		<paragraph> </paragraph>
		<paragraph>The CURSOR class is located at '$ISE_EIFFEL\library\base\structures\cursors'.  </paragraph>
		<paragraph> </paragraph>
		<list ordered="false">
			<item>Follow .NET naming guidelines: this option determines whether the generated .NET code uses the Eiffel or .NET naming convention.  Using Ildasm, the IL disassembler tool provided with the .NET Framework, we can see the difference between them.  The Eiffel naming convention uses uppercase characters for all classes whereas the .NET nomenclature uses the Camel Case style.  Note that this option is only available in a non-compiled system.  Once the system has been compiled the naming standard is fixed for the project.</item>
		</list>
		<paragraph>No .NET naming guidelines</paragraph>
		<paragraph>
			<image>
				<url>../../../../images/eiffelstudio/project_settings/ildasm_no_dotnet_naming.png</url>
				<border>0</border>
			</image>
		</paragraph>
		<paragraph>.NET naming guidelines</paragraph>
		<paragraph>
			<image>
				<url>../../../../images/eiffelstudio/project_settings/ildasm_dotnet_naming.png</url>
				<border>0</border>
			</image>
		</paragraph>
		<paragraph> </paragraph>
		<list ordered="false">
			<item>Use cluster names and Use recursive cluster names:  These options dictate how a class is known to the system.  In our CURSOR example there are 4 main scenarios.  For a quick overview of all scenarios refer to the table at the bottom of the page.  If neither box is selected we just have 'CURSOR' or 'Cursor' (depending on whether the .NET naming guidelines are used), as seen above.  If 'Use cluster names' is checked then the cluster name is pre-pended to the class name, so 'CURSOR' now becomes 'base.CURSOR'.</item>
		</list>
		<paragraph>
			<image>
				<url>../../../../images/eiffelstudio/project_settings/use_cluster_names.png</url>
				<border>0</border>
			</image>
		</paragraph>
		<paragraph> </paragraph>
		<paragraph>If 'Use recursive cluster names' is true then the full cluster name is pre-pended to the class name, so it thus becomes 'base.structures.cursors.CURSOR'.</paragraph>
		<paragraph> </paragraph>
		<paragraph>
			<image>
				<url>../../../../images/eiffelstudio/project_settings/use_full_cluster_names.png</url>
				<border>0</border>
			</image>
		</paragraph>
		<paragraph> </paragraph>
		<paragraph>The final scenario is where a namespace has been defined for the cluster in the Clusters tab of the Project Settings.  In this situation the namespace overrides the name of the cluster.  In the example below the namespace name 'MyBaseNameSpace' is used so the resulting name is 'MyBaseNameSpace.structures.cursors.CURSOR'.</paragraph>
		<paragraph> </paragraph>
		<paragraph>
			<image>
				<url>../../../../images/eiffelstudio/project_settings/use_namespace_name.png</url>
				<border>0</border>
			</image>
		</paragraph>
		<paragraph> </paragraph>
		<heading>
			<size>3</size>Naming Scenarios
		</heading>
		<paragraph>This table shows how the class name generation is affected by the naming options using the CURSOR class found in '$ISE_EIFFEL\library\base\structures\cursors' as an example.</paragraph>
		<table>
			<row>
				<cell>Use .NET naming guidelines</cell>
				<cell>Use cluster names</cell>
				<cell>Use full cluster names</cell>
				<cell>Namespace Name</cell>
				<cell>Generated Name</cell>
			</row>
			<row>
				<cell>no</cell>
				<cell>no</cell>
				<cell>no</cell>
				<cell>(empty)</cell>
				<cell>CURSOR</cell>
			</row>
			<row>
				<cell>yes</cell>
				<cell>no</cell>
				<cell>no</cell>
				<cell>(empty)</cell>
				<cell>Cursor</cell>
			</row>
			<row>
				<cell>no</cell>
				<cell>yes</cell>
				<cell>no</cell>
				<cell>(empty)</cell>
				<cell>base.CURSOR</cell>
			</row>
			<row>
				<cell>yes</cell>
				<cell>yes</cell>
				<cell>no</cell>
				<cell>(empty)</cell>
				<cell>Base.Cursor</cell>
			</row>
			<row>
				<cell>no</cell>
				<cell>no</cell>
				<cell>yes</cell>
				<cell>(empty)</cell>
				<cell>structures.cursors.CURSOR</cell>
			</row>
			<row>
				<cell>yes</cell>
				<cell>no</cell>
				<cell>yes</cell>
				<cell>(empty)</cell>
				<cell>Structures.Cursors.Cursor</cell>
			</row>
			<row>
				<cell>no</cell>
				<cell>yes</cell>
				<cell>yes</cell>
				<cell>(empty)</cell>
				<cell>base.structures.cursors.CURSOR</cell>
			</row>
			<row>
				<cell>yes</cell>
				<cell>yes</cell>
				<cell>yes</cell>
				<cell>(empty)</cell>
				<cell>Base.Structures.Cursors.Cursor</cell>
			</row>
			<row>
				<cell>no</cell>
				<cell>no</cell>
				<cell>no</cell>
				<cell>MyNameSpace</cell>
				<cell>MyNameSpace.CURSOR</cell>
			</row>
			<row>
				<cell>yes</cell>
				<cell>no</cell>
				<cell>no</cell>
				<cell>MyNameSpace</cell>
				<cell>MyNameSpace.Cursor</cell>
			</row>
			<row>
				<cell>no</cell>
				<cell>yes</cell>
				<cell>no</cell>
				<cell>MyNameSpace</cell>
				<cell>MyNameSpace.CURSOR</cell>
			</row>
			<row>
				<cell>yes</cell>
				<cell>yes</cell>
				<cell>no</cell>
				<cell>MyNameSpace</cell>
				<cell>MyNameSpace.Cursor</cell>
			</row>
			<row>
				<cell>no</cell>
				<cell>no</cell>
				<cell>yes</cell>
				<cell>MyNameSpace</cell>
				<cell>MyNameSpace.structures.cursors.CURSOR</cell>
			</row>
			<row>
				<cell>yes</cell>
				<cell>no</cell>
				<cell>yes</cell>
				<cell>MyNameSpace</cell>
				<cell>MyNameSpace.structures.cursors.Cursor</cell>
			</row>
			<row>
				<cell>no</cell>
				<cell>yes</cell>
				<cell>yes</cell>
				<cell>MyNameSpace</cell>
				<cell>MyNameSpace.structures.cursors.CURSOR</cell>
			</row>
			<row>
				<cell>yes</cell>
				<cell>yes</cell>
				<cell>yes</cell>
				<cell>MyNameSpace</cell>
				<cell>MyNameSpace.Structures.Cursors.Cursor</cell>
			</row>
		</table>
	</paragraph>
</document>
