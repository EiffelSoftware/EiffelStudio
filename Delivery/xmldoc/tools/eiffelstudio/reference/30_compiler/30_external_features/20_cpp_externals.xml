<document title="C++ Externals" output="studio">
	<meta_data>
		<help/>
	</meta_data>
	<paragraph>
		<heading>
			<size>2</size>Introduction
		</heading>
		<paragraph>Before making C++ calls in EiffelStudio, you may want to learn the basics of making 
			<link>
				<url>10_c_externals.xml</url>
				<label>C calls</label>
			</link>, since these basics are not repeated here but they might be useful for C++ users as well and are necessary to fully benefit from this document.
		</paragraph>
		<heading>
			<size>2</size>Overview
		</heading>
		<paragraph>Eiffel software must interact with software written in other languages. In this document you will learn about how to incorporate C++ classes in your Eiffel software.</paragraph>
		<paragraph>The C++/Eiffel interface offers the following mechanisms:</paragraph>
		<list ordered="false">
			<item>You can create instances of C++ classes from Eiffel, using the C++ "constructor" of your choice.</item>
			<item>You can apply to these objects all the corresponding operations from the C++ class: executing functions ("methods"), accessing data members, executing destructors.</item>
			<item>On Windows, you can use the Legacy++ tool to produce an Eiffel "wrapper class" encapsulating all the features of a C++ class, so that the result will look to the rest of the Eiffel software as if it had been written in Eiffel.</item>
		</list>
		<paragraph>The discussion concentrates on using C++ software from Eiffel. In the other direction, you can use the Cecil library (C-Eiffel Call-In Library) described in chapter 24 of 
			<link>
				<url>http://vig.pearsoned.com/store/product/1,3498,store-3841_isbn-0132479257,00.xml</url>
				<label>Eiffel: The Language</label>
			</link> with important complements in the 
			<link>
				<url>/technologies/cecil/index.xml</url>
				<label>Cecil manual</label>
			</link>.
		</paragraph>
		<heading>
			<size>2</size>Syntax specification
		</heading>
		<paragraph>In the following specification, the syntax for 
			External and External_name is retained unchanged from 
			<italic>Eiffel: The Language</italic>, where 
			Language_name is defined simply as 
			Manifest_string; the rest covers the additional facilities.
			<code_block>
External == external Language_name [External_name]

Language_name ==
		'"'
		Basic_language_name
		[Special_external_declaration]
		[Signature]
		[Include_files]
				'"'

Basic_language_name == "C" | "C++"

Special_external_declaration == "[" Special_feature "]"

Special_feature == Special_C_feature | Special_C++_feature

Special_C_feature == <comment>-- .... See appendix E of Eiffel: The Language...
</comment>
Special_C++_feature ==
		Member_function_call|
		Static_function_call |
		Object_creation |
		Object_deletion |
		Data_member_access |

Member_function_call == C++_Class

C++_Class == Class_name File_name

Class_name == Identifier

Static_function_call == <keyword>static</keyword> C++_Class

Object_creation == <keyword>new</keyword> C++_Class

Object_deletion == <keyword>delete</keyword> C++_Class

Data_member_access == <keyword>data_member</keyword> C++_Class

			<comment>-- The remaining elements are repeated
			-- from the C interface specification (page 291 in Eiffel: The Environment).</comment>

File_name ==  User_file_name | System_file_name

User_file_name == '%"' Manifest string '%"'

System_file_name == "&lt;" Manifest_string "&gt;"

Signature ==  "(" Type_list ")" [Result_type]

Type_list ==  {Type "," ...}

Result_type ==  ":" Type

Include_files ==  "|" File_list

File_list ==  {File_name "," ...}

External_name ==  <keyword>alias</keyword> Manifest_string
</code_block>
		</paragraph>
		<paragraph>As with the C extensions of the previous appendix, the syntax description conventions are those of 
			<italic>Eiffel: The Language</italic>. 		
			== means "is defined as". The vertical bar 
			| separates alternative choices, such as the three possibilities for Special_feature. The brackets 
			[...] enclose optional components; for example a 
			Language_name is made of required quotes, a required Basic_language_name and three further components, any or all of which may be absent. The notation 
			{Element Separator ...} means: 0 or more occurrences ("specimens") of 
			Element separated, if more than one, by Separator.
		</paragraph>
		<paragraph>Several of the symbols of the syntax notation, such as the brackets or the vertical bar, also appear in the language; to avoid any confusion they are given in double quotes. For example the specification for 
			Include_files begins with 
			"|" to indicate that an 
			Include_files part starts with a vertical bar. Single quotes may be used instead of double quotes when one of the quoted characters is itself a double quote; for example 
			'%"' appearing in the production for 
			User_file_name denotes the percent character followed by the double quote character. Special words such as 
			<bold>static</bold> in bold italics stand for themselves, unquoted.
		</paragraph>
		<heading>
			<size>2</size>Available possibilities
		</heading>
		<heading>
			<size>3</size>Processing C++ features
		</heading>
		<paragraph>A 
			Special_C++_feature, if present, indicates one of the following, all illustrated by examples in the next sections:
		</paragraph>
		<list ordered="false">
			<item>If the special feature's declaration simply starts with a C++ class name, followed by the associated file name, it indicates that the Eiffel feature will call a C++ member function (also known as a "method") from that class. The name of the member function is by default the same as the name of the Eiffel feature; as usual, you can specify a different name through the alias clause of the external declaration.</item>
			<item>If the declaration starts with <code><keyword>static</keyword></code>, it indicates a call to a C++ static function.
			</item>
			<item>If the declaration starts with <code><keyword>new</keyword></code>, it indicates a call to one of the constructors in the C++ class, which will create a new instance of that class and apply to it the corresponding constructor function.
			</item>
			<item>If the declaration starts with <code><keyword>delete</keyword></code>, it indicates a call to a destructor from the C++ class. In this case the Eiffel class may inherit 
				<link>
					<url>/libraries/base/reference/kernel/memory.xml</url>
				</link> and redefine the dispose procedure to execute the destructor operations whenever the Eiffel objects are garbage-collected.
			</item>
			<item>If the declaration starts with <code><keyword>data_member</keyword></code>, it indicates access to a data member (attribute in Eiffel terminology) from the C++ class.
			</item>
		</list>
		<paragraph>The rest of the possible components are the same as in the C interface: 
			Signature to specify types for arguments and results; possible 
			Include file.
		</paragraph>
		<heading>
			<size>3</size>Extra argument
		</heading>
		<paragraph>For a non-static C++ member function or destructor, the corresponding Eiffel feature should include an extra argument of type POINTER, at the first position. This argument represents the C++ object to which the function will be applied.</paragraph>
		<paragraph>For example, a C++ function</paragraph>
		<code_block>void add(int new_int);</code_block>
		<paragraph>should have the Eiffel counterpart</paragraph>
		<code_block>
	<feature_name>cpp_add</feature_name> (obj: <class_name>POINTER</class_name>; new_int: <class_name>INTEGER</class_name>) <keyword>is</keyword>
		<comment>-- Encapsulation of member function add.</comment>
	<keyword>external</keyword>
		"C++ [IntArray %"intarray.h%"] (IntArray *, int)"
	<keyword>end</keyword>
</code_block>This scheme, however, is often inconvenient because it forces the Eiffel side to work on objects in a non-object-oriented way. (The object-oriented way treats the current object, within a class, as implicit.) A better approach, used by Legacy++, is to make a feature such as cpp_add secret, and to export a feature whose signature corresponds to that of the original C++ function, with no extra object argument; that feature will use a secret attribute object_ptr to access the object. In the example this will give the feature
		<code_block>
	<feature_name>add</feature_name> (new_int: <class_name>INTEGER</class_name>) <keyword>is</keyword>
		<comment>-- Encapsulation of member function add.</comment>
	<keyword>do</keyword>
		<feature_name>cpp_add</feature_name> (object_ptr, new_int)
	<keyword>end</keyword>
</code_block>
		<paragraph>where 
			<italic>object_ptr</italic> is a secret attribute of type <code><class_name>POINTER</class_name></code>, 
			initialized by the creation procedures of the class. To the Eiffel developer, <code><feature_name>add</feature_name></code> looks like a normal object-oriented feature, which takes only the expected argument. Further examples appear below. This technique only works of course when the C++ object is implicit in the context of the Eiffel class.
		</paragraph>
		<paragraph>There is no need for an extra argument in the case of static member functions and constructors.</paragraph>
		<heading>
			<size>2</size>Wrapping C++ classes: Legacy++
		</heading>
		<paragraph>Before taking a look at examples of the various facilities mentioned, it is useful to consider the tool that will help you, in many cases, avoid worrying about their details.</paragraph>
		<heading>
			<size>3</size>The role of Legacy++
		</heading>
		<paragraph>Often you will want to provide an Eiffel encapsulation of all the facilities -- member functions, static functions, constructors, destructors, data members -- of a C++ class. This means producing an Eiffel class that will provide an Eiffel feature for each one of these C++ facilities, using external declarations based on the mechanisms listed in the preceding section.</paragraph>
		<paragraph>Rather than writing these external declarations and the class structure manually, you can use the Legacy++ tool to produce the Eiffel class automatically from the C++ class.</paragraph>
		<heading>
			<size>3</size>Calling Legacy++
		</heading>
		<paragraph>Legacy++ is called with an argument denoting a 
			<italic>.h</italic> file that must contain C++ code: one or more classes and structure declarations. It will translate these declarations into Eiffel wrapper classes. Legacy++ is only available on Windows. 
			It is located in the $ISE_EIFFEL\studio\spec\windows\bin directory, under the name legacy.exe.
		</paragraph>
		<paragraph>The following options are available:</paragraph>
		<list ordered="false">
			<item>
				<bold>-E</bold>: apply the C preprocessor to the file, so that it will process #include, #define, #ifdef and other preprocessor directives. This is in fact the default, so that you do not need to specify -E explicitly (see next option).
			</item>
			<item>
				<bold>-NE</bold>: do not apply the C preprocessor to the file.
			</item>
			<item>
				<bold>-p</bold> 
				<italic>directories</italic>: use 
				<italic>directories</italic> as include path.
			</item>
			<item>
				<bold>-c</bold> 
				<italic>compiler</italic>: use 
				<italic>compiler</italic> as the C++ compiler.
			</item>
			<item>
				<bold>-g</bold>: treat the C++ code as being intended for the GNU C++ compiler.
			</item>
		</list>
		<heading>
			<size>3</size>Result of applying Legacy++
		</heading>
		<paragraph>Running Legacy++ on a C++ file will produce the corresponding Eiffel classes. Legacy++ processes not only C++ classes but also C++ "structs"; in both cases it will generate an Eiffel class.</paragraph>
		<paragraph>Legacy++ knows about default specifiers: public for structs, private for classes.</paragraph>
		<paragraph>Legacy++ will generate Eiffel features for member functions (static or not).</paragraph>
		<paragraph>It will also handle any constructors and destructors given in the C++ code, yielding the corresponding Eiffel creation procedures. If there is no explicit constructor, it will produce a creation procedure with no arguments and an empty body.</paragraph>
		<paragraph>For any non-static member function or destructor, Legacy++ will generate a secret feature with an extra argument representing the object, as explained in the preceding section in this page. It will also produce a public feature with the same number of arguments as the C++ function, relying on a call to the secret feature, as illustrated for <code><feature_name>add </feature_name></code>and <code><feature_name>cpp_add</feature_name></code> above.</paragraph>
		<paragraph>The char* type is translated into <code><class_name>STRING</class_name></code>. 
			Pointer types, as well as reference types corresponding to classes and types that Legacy++ 
			has processed, will be translated into <code><class_name>POINTER</class_name></code>. 
			Other types will yield the type 
			<code>
				<class_name>UNRESOLVED_TYPE</class_name>
			</code>.
		</paragraph>
		<heading>
			<size>3</size>Legacy++ limitations
		</heading>
		<paragraph>It is up to you to supply Eiffel equivalents of all the needed types. If Legacy++ encounters the name of a C++ class or type that it does not know -- i.e. it is neither a predefined type nor a previously translated class -- it will use the Eiffel type name 
			<code>
				<class_name>UNRESOLVED_TYPE</class_name>
			</code>. If you do not change that type in the generated class, the Eiffel compiler will produce an error (unknown class) at degree 5.
		</paragraph>
		<paragraph>Legacy++ does not handle inline function declarations.</paragraph>
		<paragraph>Legacy++ does not handle C++ templates.</paragraph>
		<paragraph>Legacy++ makes no effort to understand the C++ inheritance structure.</paragraph>
		<paragraph>More generally, given the differences in the semantic models of C++ and Eiffel, Legacy++ can only perform the basic Eiffel wrapping of a C++ class, rather than a full translation. You should always inspect the result and be prepared to adapt it manually.</paragraph>
		<paragraph>Legacy++'s contribution is to take care of the bulk of the work, in particular the tedious and repetitive parts. The final details are left to the Eiffel software developer.</paragraph>
		<paragraph>Legacy++ is only supported on the windows platform.</paragraph>
		<heading>
			<size>2</size>Example
		</heading>
		<paragraph>Consider the following C++ class, which has an example of every kind of facility that one may wish to access from the Eiffel side:</paragraph>
		<code_block>
class IntArray {
	public:
		IntArray(int size);
		~IntArray();
		void output();
		void add(int new_int);
		static char * type();

	protected:
		int *_integers;
};
</code_block>
		<paragraph>Here is the result of applying Legacy++ to that class, which will serve as an illustration of both the C++ interface mechanisms and Legacy++:</paragraph>
		<code_block>
<keyword>indexing</keyword>
	description: "Eiffel encapsulation of C++ class IntArray";
	date: "$Date$";
	revision: "$Revision$"

<keyword>class</keyword>
	<class_name>INTARRAY</class_name>

<keyword>inherit</keyword>
	<class_name>MEMORY</class_name>
		<keyword>redefine</keyword>
			<feature_name>dispose</feature_name>
		<keyword>end</keyword>

<keyword>create</keyword>
	<feature_name>make</feature_name>

<keyword>feature</keyword> <comment>-- Initialization</comment>

	<feature_name>make</feature_name> (size: <class_name>INTEGER</class_name>) <keyword>is</keyword>
			<comment>-- Create Eiffel and C++ objects.</comment>
		<keyword>do</keyword>
			<feature_name>object_ptr</feature_name> := <feature_name>cpp_new</feature_name> (size)
		<keyword>end</keyword>

<keyword>feature</keyword><comment>-- Removal</comment>

	<feature_name>dispose</feature_name> <keyword>is</keyword>
			<comment>-- Delete C++ object.</comment>
		<keyword>do</keyword>
			<feature_name>cpp_delete</feature_name> (<feature_name>object_ptr</feature_name>)
		<keyword>end</keyword>

<keyword>feature</keyword>

	<feature_name>output</feature_name> <keyword>is</keyword>
			<comment>-- Call C++ counterpart.</comment>
		<keyword>do</keyword>
			<feature_name>cpp_output</feature_name> (<feature_name>object_ptr</feature_name>)
		<keyword>end</keyword>

	<feature_name>add</feature_name> (new_int: <class_name>INTEGER</class_name>) <keyword>is</keyword>
			<comment>-- Call C++ counterpart.</comment>
		<keyword>do</keyword>
			<feature_name>cpp_add</feature_name> (<feature_name>object_ptr</feature_name>, new_int)
		<keyword>end</keyword>

<keyword>feature</keyword> {<class_name>INTARRAY</class_name>}

	<feature_name>underscore_integers</feature_name>: <class_name>POINTER</class_name> <keyword>is</keyword>
			<comment>-- Value of corresponding C++ data member.</comment>
		<keyword>do</keyword>
			<keyword>Result </keyword>:= <feature_name>underscore_integers</feature_name> (<feature_name>object_ptr</feature_name>)
		<keyword>end</keyword>

<keyword>feature</keyword> {NONE} <comment>-- Externals</comment>

	<feature_name>cpp_new</feature_name> (size: <class_name>INTEGER</class_name>): <class_name>POINTER</class_name> <keyword>is</keyword>
			<comment>-- Call single constructor of C++ class.</comment>
		<keyword>external</keyword>
			"C++ [new IntArray %"INTARRAY.H%"] (EIF_INTEGER)"
		<keyword>end</keyword>

	<feature_name>cpp_delete</feature_name> (cpp_obj: <class_name>POINTER</class_name>) <keyword>is</keyword>
			<comment>-- Call C++ destructor on C++ object.</comment>
		<keyword>external</keyword>
			"C++ [delete IntArray %"INTARRAY.H%"] ()"
		end

	<feature_name>cpp_output</feature_name> (cpp_obj: <class_name>POINTER</class_name>) <keyword>is</keyword>
			<comment>-- Call C++ member function.</comment>
		<keyword>external</keyword>
			"C++ [IntArray %"INTARRAY.H%"] ()"
		<keyword>alias</keyword>
			"output"
		<keyword>end</keyword>

	<feature_name>cpp_add </feature_name>(cpp_obj: <class_name>POINTER</class_name>; new_int: <class_name>INTEGER</class_name>) <keyword>is</keyword>
			<comment>-- Call C++ member function.</comment>
		<keyword>external</keyword>
			"C++ [IntArray %"INTARRAY.H%"] (EIF_INTEGER)"
		<keyword>alias</keyword>
			"add"
		<keyword>end</keyword>

	<feature_name>cpp_underscore_integers</feature_name> (cpp_obj: <class_name>POINTER</class_name>): <class_name>POINTER</class_name> is
			<comment>-- Value of C++ data member</comment>
		<keyword>external</keyword>
			"C++ [data_member IntArray %"INTARRAY.H%"]: EIF_POINTER"
		<keyword>alias</keyword>
			"_integers"
		<keyword>end</keyword>

<keyword>feature</keyword> {<class_name>NONE</class_name>} <comment>-- Implementation</comment>

	<feature_name>object_ptr</feature_name>: <class_name>POINTER</class_name>

<keyword>end</keyword> <comment>-- class INTARRAY</comment>
</code_block>
	</paragraph>
</document>
