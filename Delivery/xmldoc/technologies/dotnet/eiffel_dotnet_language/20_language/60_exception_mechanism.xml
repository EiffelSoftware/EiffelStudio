<document title="Exception Mechanism">
	<meta_data>
		<help>
			<toc>
				<envision_location>Eiffel, The Language\The Eiffel for .NET Language</envision_location>
				<envision_pseudo_name>60</envision_pseudo_name>
				<envision_title>Exception Mechanism</envision_title>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<heading>
			<size>1</size>Exception Mechanism
		</heading>
		<heading>
			<size>2</size>Motivation: Concerning Robustness
		</heading>
		<paragraph>The notion of software correctness that we saw in 
			<link>
				<url>../../eiffel_dotnet_language/20_language/50_design_by_contract.xml</url>
				<label>Design by Contract and Assertions</label>
			</link> is half of the formula for software reliability. Correctness covers what the software is supposed to do, that is, its specification. 
		</paragraph>
		<paragraph>Of course,there is always a potential for things to go out of the bounds of the specification. This happens, for exampleif a client makes a call to a routine from a state in which the routine's precondition is not true. </paragraph>
		<paragraph>How well software responds to situations which outside specification is called robustness. Together correctness and robustness define software reliability. </paragraph>
		<heading>
			<size>2</size>Consequences of Contracts
		</heading>
		<paragraph>In the presence of Design by Contract, what happens to running software boils down to a simple rule:</paragraph>
		<paragraph>A routine callcan complete in one of only two ways:</paragraph>
		<list ordered="true">
			<item>The routine fulfills its contract. </item>
			<item>The routine fails to fulfill its contract. </item>
		</list>
		<paragraph>As a follow-on, we can add that:</paragraph>
		<list ordered="false">
			<item>Any routine that fails to fulfill its contract must cause an exception in its caller. </item>
		</list>
		<heading>
			<size>2</size>Reacting to Exceptions
		</heading>
		<paragraph>Again, because of Design by Contract, we can state the following rule for dealing with exceptions:</paragraph>
		<paragraph>A routine that incurs an exeception can react in one of only two ways:</paragraph>
		<list ordered="true">
			<item>It can return the instance to a stable state and retry the entire routine with the same or a different strategy. </item>
			<item>It can fail, causing an exception in its caller. </item>
		</list>
		<paragraph>There is an Eiffel mechanism called the rescue clause which facilitates the first alternative. </paragraph>
		<heading>
			<size>3</size>The Rescue Clause
		</heading>
		<paragraph>The 
			<code>
				<keyword>rescue</keyword>
			</code> clause is part of the routine structure we saw in 
			<link>
				<url>../../eiffel_dotnet_language/20_language/20_adding_class_features.xml</url>
				<label>Adding Class Features</label>
			</link>. The rescue clause is a sequence of instructions introduced by the keyword "
			<code>
				<keyword>rescue</keyword>
			</code>". At the point that an exception occurs, the processing of the normal instructions in the routine body will cease, and the instructions in the rescue clause will be executed instead. 
		</paragraph>
		<paragraph>If the instructions in the rescue clause can set things up so that it mightprove fruitful to attempt to retry the routine, it can do so by issuing a 
			<code>
				<keyword>retry</keyword>
			</code> instruction. When the 
			<code>
				<keyword>retry</keyword>
			</code> instruction is executed, the routine is restarted from its beginning, although local entities are not re-initialized. You will see why inthe example below. 
		</paragraph>
		<paragraph>If the rescue clause exits without issuing a 
			<code>
				<keyword>retry</keyword>
			</code> instruction, then the routine fails. 
		</paragraph>
		<paragraph>It should be noted that rescue clauses and retry instructions are not something that are used commonly. Out of the approximately 2000 class in the delivered Eiffel libraries, there are only 16 occurrences. Many of these are oriented toward network and database operations for which some reasonable recovery might be possible. </paragraph><code_block>
transmit: (p: PACKET)
            -- Transmit packet `p'
        require
                packet_not_void: p /= Void
        local
            current_retries: INTEGER
            r: RANDOM_NUMBER_GENERATOR
        do
            line.send (p)
        rescue
            if current_retries &lt; max_retries then
                r.next
                wait_millisecs (r.value_between (20, 500))
                current_retries := current_retries + 1
                retry
            end
        end
</code_block> 
		<paragraph>In the example above, 
			<code>
				<keyword>rescue</keyword>
			</code> is used to recover from a situation in which an exception occurs in trying to send a packet. When the exception occurs the rescue clause will, if the maximum number of retries has not been reached, wait for some random length of time. Then, after having updated the number of retries, it will issue the 
			<code>
				<keyword>retry</keyword>
			</code> instruction. If the maximum number of retries is reached, the rescue clause will exit without executing the retry, constituting a failure. 
		</paragraph>
	</paragraph></document>