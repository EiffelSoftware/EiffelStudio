indexing
	description: "[
		The ecosystem's default implementation for the {FILE_NOTIFIER_S} interface.
		
		The implementation performs simple cataloging of file records upon check requests and notifies listening clients of modifications.
		Modification events are passed a modification type argument, which corresponds to a value of {FILE_NOTIFIER_MODIFICATION_TYPES}.
	]"
	doc: "wiki://File Notifier Service"
	legal: "See notice at end of class."
	status: "See notice at end of class.";
	date: "$Date$";
	revision: "$Revision$"

class
	FILE_NOTIFIER

inherit
	FILE_NOTIFIER_S

	EVENT_OBSERVER_CONNECTION [!FILE_NOTIFIER_EVENT_OBSERVER]
		redefine
			safe_dispose
		end

	SAFE_DISPOSABLE

create
	make

feature {NONE} -- Initialization

	make
			-- Initialize the file notification service
		do
			create file_records.make_default
			create file_modified_callbacks.make_default
			create file_modified_events

			file_modified_events.subscribe (agent on_file_modified)
		end

feature {NONE} -- Clean up

	safe_dispose (a_disposing: BOOLEAN)
			-- Action to be executed just before garbage collection
			-- reclaims an object.
			--
			-- `a_disposing': True if Current is being explictly disposed of, False to indicate finalization.
		do
			if a_disposing then
				file_modified_callbacks.do_all (agent (a_events: !EVENT_TYPE [TUPLE [modification_type: NATURAL_8]])
						-- Clean up all events created
					do
						a_events.dispose
					end)
				file_modified_callbacks.wipe_out
				file_records.wipe_out
				file_modified_events.dispose
			end

			Precursor {EVENT_OBSERVER_CONNECTION} (a_disposing)
		end

feature {NONE} -- Access

	file_records: !DS_HASH_TABLE [!FILE_NOTIFIER_RECORD, !STRING_32]
			-- Table of monitored file last changed timestamps
			--
			-- Key: File name key as generated by `file_record_key'
			-- Value: Last known file changed timestamp and a monitor count

	file_modified_callbacks: !DS_HASH_TABLE [!EVENT_TYPE [TUPLE [modification_type: NATURAL_8]], !STRING_32]
			-- Table of actions to be performed for individual file change notifications
			--
			-- Key: File name key as generated by `file_record_key'
			-- Value: The event to be fired when a modification occurs.

feature {NONE} -- Status report

	is_modification_self_published: BOOLEAN
			-- Indicates if the file modification event was published by Current.

feature -- Query

	is_monitoring (a_file_name: !STRING_32): BOOLEAN
			-- Determines if a file is being monitored.
			--
			-- `a_file_name': The file name to determine if change notifications are being published for.
			-- `Result': True if the file is being monitored, False otherwise.
		do
			Result := file_records.has (file_name_key (a_file_name))
		ensure then
			file_records_has_a_file_name: Result implies file_records.has (file_name_key (a_file_name))
		end

feature {NONE} -- Query

	events (a_observer: !FILE_NOTIFIER_EVENT_OBSERVER): DS_ARRAYED_LIST [TUPLE [event: EVENT_TYPE [TUPLE]; action: PROCEDURE [ANY, TUPLE]]]
			-- List of events and associated action.
			--
			-- `a_observer': Event observer interface to bind agent actions to.
			-- `Result': A list of event types paired with a associated action on the passed observer.
		do
			create Result.make (1)
			Result.put_last ([file_modified_events, agent a_observer.on_file_modified])
		end

feature -- Basic operation

	check_modifications (a_file_name: !STRING_32)
			-- Checks a file for any modifications.
			-- Note: This must be called everytime a client wants to determine if a file has changed. The appropriate modification
			--       event will be fired based on the file state. There is no real automatic solution because of the last of file
			--       system event notifications on Unix.
			--
			--       Be sure to call `uncheck_modifications' when notification is no longer needed.
			--
			-- `a_file_name': The file to check for modifications.
		local
			l_key: like file_name_key
			l_records: like file_records
			l_record: FILE_NOTIFIER_RECORD
			l_events: like file_modified_events
			l_modification_type: NATURAL_8
			l_timestamp: INTEGER
		do
			l_key := file_name_key (a_file_name)
			l_records := file_records
			if l_records.has (l_key) then
				l_record := l_records.item (l_key)
				l_timestamp := l_record.time_stamp
				l_record.refresh
				if l_record.file_exists then
					if l_record.time_stamp /= l_timestamp then
							-- The file has been modified, as the timestamps have changed
						l_modification_type := {FILE_NOTIFIER_MODIFICATION_TYPES}.file_changed
					end
				else
						-- The file has been deleted since the last refresh
					l_modification_type := {FILE_NOTIFIER_MODIFICATION_TYPES}.file_deleted
				end

				l_events := file_modified_events
				if l_modification_type /= 0 and then not l_events.is_suspended then
						-- Only call the actions if they are not suspended.
					is_modification_self_published := True
					l_events.publish ([a_file_name, l_modification_type])
					is_modification_self_published := False
				end
			else
					-- Create a new record and add it to the record table
				create l_record.make (a_file_name)
				if {l_new_record: !FILE_NOTIFIER_RECORD} l_record then
					l_records.put (l_new_record, l_key)
				end
			end

			check l_record_attached: l_record /= Void end
			l_record.increment_monitor_lock
		ensure then
			not_is_modification_self_published_unchanged: not is_modification_self_published
			a_file_name_added: file_records.has (file_name_key (a_file_name))
			a_file_name_record_monitored: file_records.item (file_name_key (a_file_name)).is_monitoring
--			a_file_name_record_monitor_count_increased: old file_records.has (file_name_key (a_file_name)) implies
--				file_records.item (file_name_key (a_file_name)).monitor_count = old file_records.item (file_name_key (a_file_name)).monitor_count + 1
		rescue
			is_modification_self_published := False
		end

	check_modifications_with_callback (a_file_name: !STRING_32; a_callback: PROCEDURE [ANY, TUPLE [modification_type: NATURAL_8]])
			-- Checks a file for any modifications.
			-- Note: This must be called everytime a client wants to determine if a file has changed. The appropriate modification
			--       event will be fired based on the file state. There is no real automatic solution because of the last of file
			--       system event notifications on Unix.
			--
			--       Be sure to call `uncheck_modifications_with_callback' when notification is no longer needed.
			--
			-- `a_file_name': The full path to the file to check for modifications.
			-- `a_callback': The agent to call back when the file is modified.
		local
			l_key: like file_name_key
			l_callbacks: like file_modified_callbacks
			l_events: !EVENT_TYPE [TUPLE [modification_type: NATURAL_8]]
		do
				-- Add the callback to the events object
			l_key := file_name_key (a_file_name)
			l_callbacks := file_modified_callbacks
			if l_callbacks.has (l_key) then
				l_events := l_callbacks.item (l_key)
			else
				create l_events
				l_callbacks.force (l_events, l_key)
			end
			l_events.subscribe (a_callback)

				-- Now perform the check, which will call the call back if a modification has taken place.
			check_modifications (a_file_name)
		ensure then
			not_is_modification_self_published_unchanged: not is_modification_self_published
			a_file_name_added: file_records.has (file_name_key (a_file_name))
			a_file_name_record_monitored: file_records.item (file_name_key (a_file_name)).is_monitoring
--			a_file_name_record_monitor_count_increased: old file_records.has (file_name_key (a_file_name)) implies
--				file_records.item (file_name_key (a_file_name)).monitor_count = old file_records.item (file_name_key (a_file_name)).monitor_count + 1
		end

	uncheck_modifications (a_file_name: !STRING_32)
			-- Indicates to the service that the file no longer needs to be monitored.
			-- Note: Unchecking a file does not necessarly mean that it is no longer monitored. Other parts of the
			--       system could be moniroting the same file. However, it is somewhat important that for every check call
			--       there is a corresponding uncheck call.
			--
			-- `a_file_name': The full path to the file to remove modifications checks for.
		local
			l_key: like file_name_key
			l_records: like file_records
			l_record: FILE_NOTIFIER_RECORD
			l_callbacks: like file_modified_callbacks
		do
			l_key := file_name_key (a_file_name)
			l_records := file_records
			if l_records.has (l_key) then
				l_record := l_records.item (l_key)
				l_record.decrement_monitor_lock
				if not l_record.is_monitoring then
						-- The record is no longer being monitored, so remove it.
					l_records.remove (l_key)
					l_callbacks := file_modified_callbacks
					if l_callbacks.has (l_key) then
							-- Clean up and remove events object
						l_callbacks.item (l_key).dispose
						l_callbacks.remove (l_key)
					end
				end
			end
		ensure then
			a_file_name_removed: (old file_records.has (file_name_key (a_file_name))) and then not (old file_records.item (file_name_key (a_file_name))).is_monitoring implies not file_records.has (file_name_key (a_file_name))
			a_file_name_record_monitor_count_decreased: file_records.has (file_name_key (a_file_name)) implies file_records.item (file_name_key (a_file_name)).monitor_count = old file_records.item (file_name_key (a_file_name)).monitor_count - 1
		end

	uncheck_modifications_with_callback (a_file_name: !STRING_32; a_callback: PROCEDURE [ANY, TUPLE [modification_type: NATURAL_8]])
			-- Indicates to the service that the file no longer needs to be monitored.
			-- Note: Unchecking a file does not necessarly mean that it is no longer monitored. Other parts of the
			--       system could be moniroting the same file. However, it is (very* important that for every check call
			--       there is a corresponding uncheck call or the actions will be called even after an action handler's
			--       has no use for the notifications. In addition a lingering agent will cause memory leaks.
			--
			-- `a_file_name': The full path to the file to remove modifications checks for.
			-- `a_callback': The agent that was use to call back when the file is modified.
		local
			l_key: like file_name_key
			l_callbacks: like file_modified_callbacks
			l_events: !EVENT_TYPE [TUPLE [modification_type: NATURAL_8]]
		do
			l_key := file_name_key (a_file_name)
			l_callbacks := file_modified_callbacks
			if l_callbacks.has (l_key) then
					-- Unsubscribe the callback from the events object
				l_events := l_callbacks.item (l_key)
				check l_events.is_subscribed (a_callback) end
				if l_events.is_subscribed (a_callback) then
					l_events.unsubscribe (a_callback)
				end
			end

			uncheck_modifications (a_file_name)
		ensure then
			a_file_name_removed: (old file_records.has (file_name_key (a_file_name))) and then not (old file_records.item (file_name_key (a_file_name))).is_monitoring implies not file_records.has (file_name_key (a_file_name))
			a_file_name_record_monitor_count_decreased: file_records.has (file_name_key (a_file_name)) implies file_records.item (file_name_key (a_file_name)).monitor_count = old file_records.item (file_name_key (a_file_name)).monitor_count - 1
		end

feature {NONE} -- Formatting

	file_name_key (a_file_name: !STRING_32): !STRING_32
			-- Generates a string recored key, as used by `file_records', for a given file name.
			--
			-- `a_file_name': The name of the file to generate a record key for.
			-- `Result': The generated record key.
		require
			not_a_file_name_is_empty: not a_file_name.is_empty
		do
			if {PLATFORM}.is_windows then
				Result ?= a_file_name.as_lower
			else
				Result := a_file_name
			end
		ensure
			not_result_is_empty: not Result.is_empty
			result_consistent: Result.hash_code = file_name_key (a_file_name).hash_code
		end

feature -- Events

	file_modified_events: !EVENT_TYPE [TUPLE [file_name: !STRING_32; modification_type: NATURAL_8]]
			-- Events fired after check a file and discovering there have been modifications.
			--
			-- `file_name': The name of the file modified.
			-- `modification_type': The type of modification applied to the file. See {FILE_NOTIFIER_MODIFICATION_TYPES} for the respective flags

feature -- Event handlers

	on_file_modified (a_file_name: !STRING_32; a_type: NATURAL_8)
			-- Called when a file has been modified.
			--
			-- `a_file_name': The name of the file modified.
			-- `a_type': The type of modification applied to the file. See {FILE_NOTIFIER_MODIFICATION_TYPES} for the respective flags
		local
			l_key: like file_name_key
			l_records: like file_records
			l_record: FILE_NOTIFIER_RECORD
			l_callbacks: like file_modified_callbacks
		do
			l_key := file_name_key (a_file_name)

			if not is_modification_self_published then
					-- A client published a modification event explicitly so we need to be sure to refresh
					-- the file record
				l_records := file_records
				if l_records.has (l_key) then
					l_record := l_records.item (l_key)
					l_record.refresh
				end
			end

			l_callbacks := file_modified_callbacks
			if l_callbacks.has (l_key) then
				l_callbacks.item (l_key).publish ([a_type])
			end
		end

feature {NONE} -- Constants

	deleted_timestamp: INTEGER_32 = -1

invariant
	file_records_contains_monitored_items: file_records.for_all (agent (a_record: !FILE_NOTIFIER_RECORD): BOOLEAN
		do
			Result := a_record.is_monitoring
		end)

;indexing
	copyright:	"Copyright (c) 1984-2007, Eiffel Software"
	license:	"GPL version 2 (see http://www.eiffel.com/licensing/gpl.txt)"
	licensing_options:	"http://www.eiffel.com/licensing"
	copying: "[
			This file is part of Eiffel Software's Eiffel Development Environment.
			
			Eiffel Software's Eiffel Development Environment is free
			software; you can redistribute it and/or modify it under
			the terms of the GNU General Public License as published
			by the Free Software Foundation, version 2 of the License
			(available at the URL listed under "license" above).
			
			Eiffel Software's Eiffel Development Environment is
			distributed in the hope that it will be useful,	but
			WITHOUT ANY WARRANTY; without even the implied warranty
			of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
			See the	GNU General Public License for more details.
			
			You should have received a copy of the GNU General Public
			License along with Eiffel Software's Eiffel Development
			Environment; if not, write to the Free Software Foundation,
			Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
		]"
	source: "[
			 Eiffel Software
			 356 Storke Road, Goleta, CA 93117 USA
			 Telephone 805-685-1006, Fax 805-685-6869
			 Website http://www.eiffel.com
			 Customer support http://support.eiffel.com
		]"

end
