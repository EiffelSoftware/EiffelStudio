<html>
<head>
<title>Apache 1.3 API: request_rec</title>
</head>
<body>
<h1>Apache 1.3 API Documentation</h1>
<h3>Structure request_rec</h3>

<p>Definition:</p>
<dl>
	<dd><pre>
typedef struct request_rec request_rec; 
struct request_rec { 
    pool *<a href="apidoc_pool.html">pool</a>; 
    <a href="apidoc_conn_rec.html">conn_rec</a> *connection; 
    <a href="apidoc_server_rec.html">server_rec</a> *server; 
    request_rec *next; 
    request_rec *prev; 
    request_rec *main; 
    char *the_request; 
    int assbackwards; 
    enum <a href="apidoc_proxyreqtype.html">proxyreqtype</a> proxyreq; 
    int header_only; 
    char *protocol; 
    int proto_num; 
    char *hostname; 
    time_t request_time; 
    const char *status_line; 
    int status; 
    const char *method; 
    int method_number; 
    int allowed; 
    int sent_bodyct; 
    long bytes_sent; 
    time_t mtime; 
    int chunked; 
    int byterange; 
    char *boundary; 
    const char *range; 
    long clength; 
    long remaining; 
    long read_length; 
    int read_body; 
    int read_chunked; 
    unsigned expecting_100; 
    table *headers_in; 
    table *headers_out; 
    table *err_headers_out; 
    table *subprocess_env; 
    <a href="apidoc_table.html">table</a> *notes; 
    const char *content_type; 
    const char *handler; 
    const char *content_encoding; 
    const char *content_language; 
    <a href="apidoc_array_header.html">array_header</a> *content_languages; 
    char *vlist_validator; 
    int no_cache; 
    int no_local_copy; 
    char *unparsed_uri; 
    char *uri; 
    char *filename; 
    char *path_info; 
    char *args; 
    struct stat finfo; 
    <a href="apidoc_uri_components.html">uri_components</a> parsed_uri; 
    void *per_dir_config; 
    void *request_config; 
    const struct htaccess_result *htaccess; 
    char *case_preserved_filename; 
};
     </pre></dd>
</dl>
<p>Usage example:</p>
<dl>
	<dd><pre>
No examples available.
     </pre></dd>
</dl>
<p>The <code>request_rec</code> structure is key to Apache's
processing of client requests. A pointer to a <code>request_req</code>
structure is passed to all phase handlers and many API routines, and it
is usually given the argument name '<code>r</code>' (<i>e.g.</i>, <code><a
	href="apidoc_ap_add_common_vars.html">ap_add_common_vars</a>(r)</code>).</p>

<h4>Detailed Field Descriptions</h4>
<dl>
	<dt><code><b>pool *<a href="apidoc_pool.html">pool</a></b></code></dt>
	<dd>If a <a href="apidoc_module.html">module</a> routine is passed
	a <code>request_rec</code> structure, the <code><a
		href="apidoc_pool.html">pool</a></code> pointer in the structure is available
	for memory allocation. (See the description of <code><a
		href="apidoc_ap_palloc.html">ap_palloc</a>()</code> and related routines.)
	When the request is completed, the memory <a href="apidoc_pool.html">pool</a>
	will be released.</dd>
	<dt><code><b><a href="apidoc_conn_rec.html">conn_rec</a>
	*connection</b></code></dt>
	<dd>This is a pointer to the <code><a
		href="apidoc_conn_rec.html">conn_rec</a></code> structure describing the
	TCP/IP connexion over which the request was received.</dd>

	<dt><code><b><a href="apidoc_server_rec.html">server_rec</a>
	*server</b></code></dt>
	<dd>This field contains a pointer to the <code><a
		href="apidoc_server_rec.html">server_rec</a></code> structure for the virtual
	host which was assigned to handle the request.</dd>
	<dt><code><b>request_rec *next</b></code></dt>
	<dt><code><b>request_rec *prev</b></code></dt>

	<dt><code><b>request_rec *main</b></code></dt>
	<dd>These fields are pointers to other <code>request_rec</code>
	structures in the case of a complex opertion involving subrequests. The
	<code>main</code> pointer refers to the request actually received from
	the client, as opposed to any internal ones created by Apache during
	its request resolution.</dd>
	<dt><code><b>char *the_request</b></code></dt>
	<dd>This is a pointer to the actual request string received from
	the client (<i>e.g.</i>, "<code>GET;/index.html;HTTP/1.1</code>").</dd>

	<dt><code><b>int assbackwards</b></code></dt>
	<dd>This is a Boolean flag indicating whether the request was made
	using the HTTP/0.9 protocol. It is set to non-zero if so.</dd>
	<dt><code><b>enum <a href="apidoc_proxyreqtype.html">proxyreqtype</a>
	proxyreq</b></code></dt>
	<dd>This field is only used by proxy modules, and indicates the
	type of proxy request involved. See the description of the <code><a
		href="apidoc_proxyreqtype.html">proxyreqtype</a></code> enumeration for more
	information.</dd>

	<dt><code><b>int header_only</b></code></dt>
	<dd>This Boolean flag is set to non-zero if the request was made
	with the <code>HEAD</code> method. The response headers will be
	returned, but modules shouldn't bother to generate any content for the
	response.</dd>
	<dt><code><b>char *protocol</b></code></dt>
	<dd>This is a pointer to a string representing the protocol of the
	request, such as "<code>HTTP/0.9</code>" or "<code>HTTP/1.1</code>".</dd>

	<dt><code><b>int proto_num</b></code></dt>
	<dd>This is a numeric representation of the protocol level. It can
	be parsed with the <code><a
		href="apidoc_HTTP_VERSION_MAJOR.html">HTTP_VERSION_MAJOR</a>()</code> and <code><a
		href="apidoc_HTTP_VERSION_MINOR.html">HTTP_VERSION_MINOR</a>()</code> macros
	(<i>q.q.v.</i>).</dd>
	<dt><code><b>char *hostname</b></code></dt>

	<dd>Pointer to a string indicating the hostname to which the
	request was directed (extracted from either the <code>r-&gt;the_request</code>
	string or the <code>Host</code> request header field). Note that this
	value may be different from the name of the host actually processing
	the request; that is, it may differ from any value in the <code>r-&gt;server-&gt;names</code>
	array.</dd>
	<dt><code><b>time_t request_time</b></code></dt>

	<dd>This field is used to record the time the request was received
	by the server. This value is stored in local time, not GMT.</dd>
	<dt><code><b>const char *status_line</b></code></dt>
	<dd>This field is reserved to and used by the core server for
	constructing the status line portion of the response header.</dd>
	<dt><code><b>int status</b></code></dt>
	<dd>This is used to contain the numeric code of the HTTP response
	status, such as <code><a href="apidoc_HTTP_NOT_MODIFIED.html">HTTP_NOT_MODIFIED</a></code>.
	It is typically not used by modules because the protocol module derives
	the correct value from <a href="apidoc_module.html">module</a>
	responses and the HTTP specification defining the interaction of header
	fields.</dd>

	<dt><code><b>const char *method</b></code></dt>
	<dd>This is a pointer to a string representing the name of the
	HTTP method used to make the request, such as "<code>GET</code>", as
	extracted from the <code>r-&gt;the_request</code> string. Modules may
	want to reference this field if they handle extension methods not
	directly known to the core server and therefore not represented by a
	numeric value. (See th enext field, <code>method_number</code>.)</dd>
	<dt><code><b>int method_number</b></code></dt>

	<dd>This field contains a numeric value representing the request
	method. The possible values are give mnemonic names prefixed with "<code>M_</code>",
	such as "<code><a href="apidoc_M_GET.html">M_GET</a></code>" and "<code><a
		href="apidoc_M_DELETE.html">M_DELETE</a></code>" (<i>q.q.v.</i>; see the
	description of <code><a href="apidoc_M_GET.html">M_GET</a></code> for
	additional references and information.) If the request was made using a
	method unknown to the core server, the value in this field will be <code><a
		href="apidoc_M_INVALID.html">M_INVALID</a></code>, even if the server has
	been configured to recognise the method (such as with the <code>Script</code>
	directive). In this case modules should check the string value in the <code>method</code>
	field of the <code>request_rec</code> structure, which immediately
	precedes this one.</dd>

	<dt><code><b>int allowed</b></code></dt>
	<dd>This is a bitmask of the HTTP methods permitted for the
	resource. The <a href="apidoc_module.html">module</a> that generates
	the response content is responsible for setting this; it should do so
	before or during the content generation phase, before the response
	header is sent. This mask is used solely to create the <code>Allowed</code>
	response header field. It's a good idea to set it in an earlier phase
	if possible, in case the request method is <code>OPTIONS</code> and
	will be handled by the <code>default_handler</code>. Due to the
	dependence on hard-coded bitmask values, Apache 1.3 provides no support
	for listing extension methods in this field.</dd>

	<dt><code><b>int sent_bodyct</b></code></dt>
	<dd>This field is reserved for use by the core server.</dd>
	<dt><code><b>long bytes_sent</b></code></dt>
	<dd>This field is reserved for use by the core server. At the
	completion of the request it contains the number of bytes sent as the
	response body; it does not include the bytes in the response header. It
	is primarily used by logging modules.</dd>
	<dt><code><b>time_t mtime</b></code></dt>
	<dd>This field contains the last-modified time for the current
	document. It should be set with the <code><a
		href="apidoc_ap_update_mtime.html">ap_update_mtime</a>()</code> or <code><a
		href="apidoc_ap_rationalize_mtime.html">ap_rationalize_mtime</a>()</code>
	routines.</dd>
	<dt><code><b>int chunked</b></code></dt>
	<dd>This field is reserved for use by the core server. It is a
	Boolean value indicating whether the response is being sent using
	chunked encoding.</dd>
	<dt><code><b>int byterange</b></code></dt>
	<dd>This field contains the number of distinct byte-ranges in the
	request header's <code>Range</code> field.</dd>

	<dt><code><b>char *boundary</b></code></dt>
	<dd>The delimiting string used in multipart or byterange bodies.</dd>
	<dt><code><b>const char *range</b></code></dt>
	<dd>The value of the request's <code>Range</code> header field.
	This is stored here for convenience; it is also available in the <code>headers_in</code>
	<a href="apidoc_table.html">table</a> described below.</dd>

	<dt><code><b>long clength</b></code></dt>
	<dd>The actual length in bytes of the response body. Set with the
	<code><a href="apidoc_ap_set_content_length.html">ap_set_content_length</a>()</code>
	routine (<i>q.v.</i>).</dd>
	<dt><code><b>long remaining</b></code></dt>
	<dd>The number of bytes in the request body that have not yet been
	read. This is updated by the server core each time a <a
		href="apidoc_module.html">module</a> asks the server core for more of
	the body. Modules must regard it as a read-only field.</dd>

	<dt><code><b>long read_length</b></code></dt>
	<dd>Similar to the <code>remaining</code> field described above,
	this field contains the count of bytes already read from the request
	bosy. Modules must regard this as a read-only field.</dd>
	<dt><code><b>int read_body</b></code></dt>
	<dt><code><b>int read_chunked</b></code></dt>
	<dt><code><b>unsigned expecting_100</b></code></dt>

	<dd>This field is reserved for use by the core server in handling
	aspects of the HTTP/1.1 protocol.</dd>
	<dt><code><b><a href="apidoc_table.html">table</a>
	*headers_in</b></code></dt>
	<dd>This <a href="apidoc_table.html">table</a> contains a
	key/value pair for every field in the request header. Some of the
	fields are also represented in other ways, such as the <code>Range</code>
	field, but all of the original request header fields are stored in this
	table in their raw form. Modules must regard this <a
		href="apidoc_table.html">table</a> as read-only.</dd>

	<dt><code><b><a href="apidoc_table.html">table</a>
	*headers_out</b></code></dt>
	<dd>This <a href="apidoc_table.html">table</a> is used to hold the
	key/value pairs of the header fields to be sent as part of the
	response. Under certain conditions, such as error responses, the values
	in this <a href="apidoc_table.html">table</a> will <b>not</b> be used
	in the construction of the response header. Under normal circumstances,
	however, its contents are merged with those in the <code>r-&gt;err_headers_out</code>

	<a href="apidoc_table.html">table</a> to form the response header.</dd>
	<dt><code><b><a href="apidoc_table.html">table</a>
	*err_headers_out</b></code></dt>
	<dd>Similar to the <code>headers_out</code> table described
	previously, the contents of this <a href="apidoc_table.html">table</a>
	are used in the formation of the response header. However, the values
	in <i>this</i> <a href="apidoc_table.html">table</a> are <b>always</b>
	used, even under error conditions. Under normal conditions, they are
	merged with those in the <code>r-&gt;header_out</code> <a
		href="apidoc_table.html">table</a> and the result is used.</dd>

	<dt><code><b><a href="apidoc_table.html">table</a>
	*subprocess_env</b></code></dt>
	<dd>The name of this field is somewhat misleading. This <a
		href="apidoc_table.html">table</a> contains the names and values of
	'environment' variables that are available to subsequent stages of
	processing for the request. They are set as actual environment
	variables only if a child process needs to be created, such as for
	invoking a CGI script. However, these values are also available for use
	by things such as <code>mod_include</code>, even though no actual
	subprocess creation is involved.</dd>
	<dt><code><b><a href="apidoc_table.html">table</a>
	*notes</b></code></dt>

	<dd>This <a href="apidoc_table.html">table</a> has no strictly
	defined purpose; it is generally intended to provide a means for
	modules to communicate with each other when processing a request, or
	for different phase handlers of the same <a href="apidoc_module.html">module</a>
	to pass information from phase to another. For example, <code>mod_speling</code>
	uses this <a href="apidoc_table.html">table</a> to pass a list of
	possible document variants to <code>mod_negotiation</code>.</dd>

	<dt><code><b>const char *content_type</b></code></dt>
	<dd>Specifies the content-type of the respose body (if there is
	one). Modules should set this field rather than inserting an entry
	directly into either <code>r-&gt;headers_out</code> or <code>r-&gt;err_headers_out</code>.</dd>
	<dt><code><b>const char *handler</b></code></dt>
	<dt><code><b>const char *content_encoding</b></code></dt>

	<dt><code><b>const char *content_language</b></code></dt>
	<dt><code><b><a href="apidoc_array_header.html">array_header</a>
	*content_languages</b></code></dt>
	<dt><code><b>char *vlist_validator</b></code></dt>
	<dt><code><b>int no_cache</b></code></dt>
	<dt><code><b>int no_local_copy</b></code></dt>

	<dt><code><b>char *unparsed_uri</b></code></dt>
	<dt><code><b>char *uri</b></code></dt>
	<dt><code><b>char *filename</b></code></dt>
	<dt><code><b>char *path_info</b></code></dt>
	<dt><code><b>char *args</b></code></dt>
	<dt><code><b>struct stat finfo</b></code></dt>

	<dt><code><b><a href="apidoc_uri_components.html">uri_components</a>
	parsed_uri</b></code></dt>
	<dt><code><b>void *per_dir_config</b></code></dt>
	<dt><code><b>void *request_config</b></code></dt>
	<dt><code><b>const struct htaccess_result *htaccess</b></code></dt>
	<dt><code><b>char *case_preserved_filename</b></code></dt>

	<dd>This field contains the original translated filename
	representing the document source (if it actually is a file) before
	canonicalisation. This is necessary for some situations in which
	canonicalisation actually modifies the name for later use. For example,
	on Windows systems Apache always always translates filenames to
	lowercase for security reasons (among others). This would cause
	problems if the case of the requested name was actually significant
	though the case of the actual filename was not, such as if the request
	was referring to a Java class file. This field provides the original
	filename before the downcasing (or other canonicalisation transform)
	has been performed.</dd>
</dl>


</body>
</html>


