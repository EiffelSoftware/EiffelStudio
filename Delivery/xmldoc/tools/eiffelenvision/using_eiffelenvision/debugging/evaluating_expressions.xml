<document output="envision" title="Evaluating Expressions">
	<meta_data>
		<help>
			<toc>
				<envision_title>Evaluating Expressions</envision_title>
				<envision_pseudo_name>00</envision_pseudo_name>
			</toc>
			<xml>
				<keyword>
					<index>K</index>
					<term>Debugging, Evaluating expressions</term>
				</keyword>
				<keyword>
					<index>K</index>
					<term>Debugger, Evaluating expressions</term>
				</keyword>
				<keyword>
					<index>K</index>
					<term>Evaluating Expressions</term>
				</keyword>
				<keyword>
					<index>K</index>
					<term>Debugging EiffelEnvision projects, Expressions</term>
				</keyword>
				<keyword>
					<index>K</index>
					<term>Debugging, EiffelEnvision projects</term>
				</keyword>
				<keyword>
					<index>K</index>
					<term>Expressions, EiffelEnvision</term>
				</keyword>
				<keyword>
					<index>K</index>
					<term>Expression evaluation, in managed code</term>
				</keyword>
			</xml>
		</help>
	</meta_data>
	<paragraph>
		<paragraph>
			The EiffelEnvision debugger includes an expression evaluator that evaluates expressions entered 
			in the <help_link>
				<keywords>vcurfQuickWatchDialogBox</keywords>
				<tab_index>0</tab_index>
				QuickWatch
			</help_link> dialog box, in the <help_link>
				<keywords>vcurfWatchWindow</keywords>
				<tab_index>0</tab_index>
				Watch
			</help_link>, or in the <help_link>
				<keywords>vcurfAutosWindow</keywords>
				<tab_index>0</tab_index>
				Autos
			</help_link> or <help_link>
				<keywords>vcurfLocalsWindow</keywords>
				<tab_index>0</tab_index>
				Locals
			</help_link> windows. The expression evaluator 
			is also at work in the <help_link>
				<keywords>vcurfBreakpointsWindow</keywords>
				<tab_index>0</tab_index>
				Breakpoints Window
			</help_link>. If you type 
			the name of a function where you want to set a breakpoint, for example, the expression evaluator 
			handles it.
		</paragraph>
		
		<paragraph>	
			The following topics offer specific information and discuss some of the expression types that are not supported: 
			
			<list ordered="false">
				<item><link><url>evaluating_expressions.xml</url><anchor_name>identifiers</anchor_name><label>Identifiers and Types</label></link></item>
				<item><link><url>evaluating_expressions.xml</url><anchor_name>funtion_evaluation</anchor_name><label>Function Evaluation</label></link></item>
				<item><link><url>evaluating_expressions.xml</url><anchor_name>operators</anchor_name><label>Operators</label></link></item>
				<item><link><url>evaluating_expressions.xml</url><anchor_name>arrays</anchor_name><label>Arrays</label></link></item>
				<item><link><url>evaluating_expressions.xml</url><anchor_name>strings</anchor_name><label>Strings</label></link></item>
				<item><link><url>evaluating_expressions.xml</url><anchor_name>casts</anchor_name><label>Casts</label></link></item>
				<item><link><url>evaluating_expressions.xml</url><anchor_name>comparison</anchor_name><label>Object Comparison and Assignment</label></link></item>
				<item><link><url>evaluating_expressions.xml</url><anchor_name>property_evaluation</anchor_name><label>Property Evaluation</label></link></item>
			</list>
			 
			The debugger uses auto-expand rules to display the contents of a data type in meaningful form. If you need to, you can add custom auto-expand elements to display your own custom data types. For more information, see <help_link>
				<keywords>vchowDisplayingElementsOfCustomDataType</keywords>
				<tab_index>0</tab_index>
				Displaying Elements of a Custom Data Type
			</help_link>.
		</paragraph>
		
		<anchor>identifiers</anchor>
		<heading>
			<size>2</size>
			<content>Identifiers and Types</content>
		</heading>
		<paragraph>
			Debugger expressions can use any identifier visible within the current scope. If the debugger is halted in function <code><feature_name>magh</feature_name></code>, for example, you can use any identifier visible within <code><feature_name>magh</feature_name></code>, including constants, and variable names.
		</paragraph>
		<paragraph>
			The debugger can correctly display any variable of a primitive, or intrinsic type. For variables of class type, the debugger correctly displays the value based on the derived-most type. If you have an object leo of type <code><class_name>LION</class_name></code>, derived from type <code><class_name>CAT</class_name></code>, you can evaluate <code><local_variable>leo</local_variable><symbol>.</symbol><feature_name>claw_length</feature_name></code> and get the correct value for an object of type <code><class_name>LION</class_name></code>.
		</paragraph>	
		<paragraph>
			For <link><url>url</url><label>Eiffel for .NET</label></link>, you can assign a new value to any left-hand expression that us an l-value and has non-array type. This includes primitive, class, and <code><class_name>SYSTEM_OBJECT</class_name></code> (<code><class_name>System.Object</class_name></code>) types.
		</paragraph>
		
		<anchor>funtion_evaluation</anchor>
		<heading>
			<size>2</size>
			<content>Function Evaluation</content>
		</heading>
		<paragraph>
			Evaluation of functions is not supported in EiffelEnvision. 
		</paragraph>
		
		<anchor>operators</anchor>
		<heading>
			<size>2</size>
			<content>Operators</content>
		</heading>
		<paragraph>
			EiffelEnvision supports all of the common infix operators in <link><url>url</url><label>Eiffel for .NET</label></link>. The following operators are valid in the expression:
			<table>
				<width>350</width>
				<padding>4</padding>
				<row>
					<cell><alignment>center</alignment><bold>Symbol</bold></cell>
					<cell><bold>Definition</bold></cell>
				</row>
				<row>
					<cell><alignment>center</alignment><code><symbol>+</symbol></code></cell>
					<cell>Plus</cell>
				</row>
				<row>
					<cell><alignment>center</alignment><code><symbol>-</symbol></code></cell>
					<cell>Minus</cell>
				</row>
				<row>
					<cell><alignment>center</alignment><code><symbol>*</symbol></code></cell>
					<cell>Multiply</cell>
				</row>
				<row>
					<cell><alignment>center</alignment><code><symbol>/</symbol></code></cell>
					<cell>Divide</cell>
				</row>
				<row>
					<cell><alignment>center</alignment><code><symbol>//</symbol></code></cell>
					<cell>Integer Division</cell>
				</row>
				<row>
					<cell><alignment>center</alignment><code><symbol>\\</symbol></code></cell>
					<cell>Remainder</cell>
				</row>
				<row>
					<cell><alignment>center</alignment><code><symbol>^</symbol></code></cell>
					<cell>Power</cell>
				</row>
				<row>
					<cell><alignment>center</alignment><code><symbol>lt;</symbol></code></cell>
					<cell>Lesser</cell>
				</row>
				<row>
					<cell><alignment>center</alignment><code><symbol>gt;</symbol></code></cell>
					<cell>Greater</cell>
				</row>
				<row>
					<cell><alignment>center</alignment><code><symbol>lt;=</symbol></code></cell>
					<cell>Lesser or equal</cell>
				</row>
				<row>
					<cell><alignment>center</alignment><code><symbol>gt;=</symbol></code></cell>
					<cell>Greater or equal</cell>
				</row>
				<row>
					<cell><alignment>center</alignment><code><symbol>=</symbol></code></cell>
					<cell>Equal</cell>
				</row>
				<row>
					<cell><alignment>center</alignment><code><symbol>/=</symbol></code></cell>
					<cell>Not equal</cell>
				</row>
				<row>
					<cell><alignment>center</alignment>AND</cell>
					<cell>And</cell>
				</row>
				<row>
					<cell><alignment>center</alignment>AND THEN</cell>
					<cell>And then</cell>
				</row>
				<row>
					<cell><alignment>center</alignment>OR</cell>
					<cell>Or</cell>
				</row>
				<row>
					<cell><alignment>center</alignment>OR ELSE</cell>
					<cell>Or else</cell>
				</row>
				<row>
					<cell><alignment>center</alignment><code><symbol>@</symbol></code></cell>
					<cell>Item at index, applies only to arrays.</cell>
				</row>
			</table>
		</paragraph>
		
		<anchor>arrays</anchor>
		<heading>
			<size>2</size>
			<content>Arrays</content>
		</heading>
		<paragraph>
			EiffelEnvision supports two types of arrays. Eiffel <class_name>ARRAY</class_name>s and .NET <class_name>NATIVE_ARRAY</class_name> (<class_name>System.Array</class_name>). 
			Both arrays may be indexed using the <code><symbol>@</symbol></code> infix operator.
<code_block>
<local_variable>l_arr</local_variable> <symbol>@</symbol> <number>1</number>
</code_block>
			The above expression will yield the value at index <code><number>1</number></code>.
		</paragraph>
		<paragraph>
			For multi-dimensional arrays, dimension indexes may be retrieved by grouping an <code><symbol>@</symbol></code> with <code><symbol>()</symbol></code>:
<code_block>
<symbol>(</symbol> <local_variable>l_arr</local_variable> <symbol>@</symbol> <number>3</number><symbol>)</symbol> <symbol>@</symbol> <number>2</number>
</code_block>
		</paragraph>
		
		<anchor>strings</anchor>
		<heading>
			<size>2</size>
			<content>Strings</content>
		</heading>
		<paragraph>
			In EiffelEnvision you may write a string in the Watch window such as:
<code_block>
<string>"Hello"</string>
</code_block>
			and it will correctly display. Strings entered in this way are <class_name>SYSTEM_STRING</class_name>s (<class_name>System.String</class_name>) and not Eiffel <class_name>STRING</class_name>s.
		</paragraph>
		<paragraph>
			EiffelEnvision also supports the concatenation of strings.
<code_block>
<string>"Hello"</string> <symbol>+</symbol> <string>"World"</string>
</code_block>
			would correctly display 
<code_block>
<string>"HelloWorld"</string>
</code_block>
			in the watching window. Variables of type <class_name>SYSTEM_STRING</class_name> can also be concatenated in the same way:
<code_block>
<local_variable>l_sys_str</local_variable> <symbol>+</symbol> <string>"World"</string>
</code_block>
		</paragraph>
		
		<anchor>casts</anchor>
		<heading>
			<size>2</size>
			<content>Casts</content>
		</heading>
		<paragraph>
			Simple cast expressions work in the debugger:
<code_block>
<symbol>(</symbol><class_name>A</class_name><symbol>)</symbol><local_variable>x</local_variable>
</code_block>
		</paragraph>
		
		<anchor>comparison</anchor>
		<heading>
			<size>2</size>
			<content>Object Comparison and Assignment</content>
		</heading>
		<paragraph>
		</paragraph>
		
		<anchor>property_evaluation</anchor>
		<heading>
			<size>2</size>
			<content>Property Evaluation</content>
		</heading>
		<paragraph>
			Evaluation property on .NET objects is not supported in EiffelEnvision. 
			Evaluating a property in the debugger can have side effects that produce unexpected and undesired results.
		</paragraph>

		<anchor>also_see</anchor>
		<heading>
			<size>2</size>
			<content>Related Sections</content>
		</heading>
		<seealso>
			<bold>See also</bold>
			<line_break/>
			<link>
				<url>index.xml</url>
				<label>Debugging in EiffelEnvision</label>
			</link>
			<line_break/>		
			<help_link>
				<keywords>vchowUsingExpressionsInDebugger</keywords>
				<tab_index>0</tab_index>
				Expressions in the Debugger
			</help_link>
			<line_break/>
			<help_link>
				<keywords>vcurfQuickWatchDialogBox</keywords>
				<tab_index>0</tab_index>
				QuickWatch
			</help_link>
			<line_break/>
			<help_link>
				<keywords>vcurfWatchWindow</keywords>
				<tab_index>0</tab_index>
				Watch Window
			</help_link>
			<line_break/>
			<help_link>
				<keywords>vcurfAutosWindow</keywords>
				<tab_index>0</tab_index>
				Autos Window
			</help_link>
			<line_break/>
			<help_link>
				<keywords>vcurfLocalsWindow</keywords>
				<tab_index>0</tab_index>
				Locals Window
			</help_link>
		</seealso>
	</paragraph>
</document>
