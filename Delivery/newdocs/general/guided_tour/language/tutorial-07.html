<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML XMLNS:MSHelp="http://msdn.microsoft.com/mshelp">
	<XML>
		<MSHelp:Keyword Index="K" Term="Eiffel Tutorial, The Dynamic Structure: Execution Model" />
		<MSHelp:Attr Name="Product" Value="Eiffel"/>
		<MSHelp:Attr Name="Locale" Value="kbEnglish"/>
	</XML>
	<HEAD>
		<TITLE>An Eiffel Tutorial, The Dynamic Structure: Execution Model</TITLE>
		<LINK HREF="../../../default.css" TYPE="text/css" REL="STYLESHEET">
	</HEAD>
	<BODY>
		<TABLE CLASS="HEADER">
			<TR>
				<TD CLASS="HEADER">Eiffel ENViSioN!</TD>
			</TR>
			<TR>
				<TD CLASS="SUBHEADER">An Eiffel Tutorial, The Dynamic Structure: Execution Model</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FRAME">
			<TR>
				<TD>
					<A NAME="pgfId-514214"></A>

					<P>A system with a certain static structure describes a set of possible
					executions. The run-time model governs the structure of the data
					(<SPAN CLASS="bold">objects</SPAN>) created during such executions.</P>

					<P>The properties of the run-time model are not just of interest to
					implementers; they also involve concepts directly relevant to the needs
					of system modelers and analysts at the most abstract levels.</P>

					<H2>Objects, fields, values and references</H2>

					<P>A class was defined as the static description of a a type of run-time
					data structures. The data structures described by a class are called
					<SPAN CLASS="bold">instances</SPAN> of the class, which in turn is
					called their <SPAN CLASS="bold">generating class</SPAN> (or just
					"<SPAN CLASS="italics">generator</SPAN>"). An instance of
					<SPAN CLASS="eclass">ACCOUNT</SPAN> is a data structure representing a
					bank account; an instance of <SPAN CLASS="eclass">LINKED_LIST</SPAN>
					is a data structure representing a linked list.</P>

					<P>An <SPAN CLASS="bold">object</SPAN>, as may be created during the
					execution of a system, is an instance of some class of the system.</P>

					<P>Classes and objects belong to different worlds: a class is an
					element of the software text; an object is a data structure created
					during execution. Although it is possible to define a class whose instances
					represent classes (as class <SPAN CLASS="eclass">E_CLASS</SPAN> in the
					ISE libraries, used to access properties of classes at run time), this
					does not eliminate the distinction between a static, compile-time notion,
					class, and a dynamic, run-time notion, object.</P>

					<P>An object is either an atomic object (integer, real, boolean, double)
					or a composite object made of a number of
					<SPAN CLASS="bold">fields</SPAN>, represented by adjacent rectangles on
					the conventional run-time diagrams:</P>

					<IMG SRC="tutorial-5.png">

					<P>Each field is a <SPAN CLASS="bold">value</SPAN>. A value can be
					either an object or an object reference:</P>

					<UL>
						<LI>When a field is an object, it will in most cases be an atomic
						object, as on the figure where the first field from the top is an
						integer and the third a character. But a field can also be a
						composite object, in which case it is called a
						<SPAN CLASS="bold">subobject</SPAN>.


						<LI>A <SPAN CLASS="bold">reference</SPAN> is either void or
						uniquely identifies an object, to which it is said to be
						<SPAN CLASS="bold">attached</SPAN>. In the preceding figure the
						second field from the top is a reference -- attached in this case,
						as represented by the arrow, to the enclosing object itself. The
						bottom field is a void reference.</LI>
					</UL>

					<H2>Features</H2>

					<IMG SRC="tutorial-6.png">

					<P>A feature, as noted, is an operation available on instances of a
					class. A feature can be either an <SPAN CLASS="bold">attribute</SPAN>
					or a <SPAN CLASS="bold">routine</SPAN>. This classification, which you
					can follow by starting from the <SPAN CLASS="italics">right</SPAN> on
					the figure above, is based on implementation considerations:</P>

					<UL>
						<LI>An attribute is a feature implemented through memory: it
						describes a field that will be found in all instances of the class.
						For example class <SPAN CLASS="eclass">ACCOUNT</SPAN> may have an
						attribute <SPAN CLASS="efeature">balance</SPAN>; then all instances
						of the class will have a corresponding field containing each account's
						current balance.


						<LI>A routine describes a computation applicable to all instances of
						the class. <SPAN CLASS="eclass">ACCOUNT</SPAN> may have a routine
						<SPAN CLASS="efeature">withdraw</SPAN>.


						<LI>Routines are further classified into
						<SPAN CLASS="bold">functions</SPAN>, which will return a result, and
						<SPAN CLASS="bold">procedures</SPAN>, which will not. Routine
						<SPAN CLASS="efeature">withdraw</SPAN> will be a procedure; an example
						of function may be <SPAN CLASS="efeature">highest_deposit</SPAN>,
						which returns the highest deposit made so far to the account.</LI>
					</UL>

					<P>If we instead take the viewpoint of the
					<SPAN CLASS="bold">clients</SPAN> of a class (the classes relying on its
					feature), you can see the relevant classification by starting from the
					<SPAN CLASS="italics">left</SPAN> on the figure:</P>

					<UL>
						<LI><SPAN CLASS="bold">Commands</SPAN> have no result, and may modify an
						object. They may only be procedures.


						<LI><SPAN CLASS="bold">Queries</SPAN> have a result: they return
						information about an object. You may implement a query as either an
						attribute (by reserving space for the corresponding information in
						each instance of the class, a memory-based solution) or a function
						(a computation-based solution). An attribute is only possible for a
						query without argument, such as <SPAN CLASS="efeature">balance</SPAN>;
						a query with arguments, such as <SPAN CLASS="efeature">balance_on</SPAN>
						(<SPAN CLASS="elocal">d</SPAN>), returning the balance at date
						<SPAN CLASS="elocal">d</SPAN>, can only be a function.</LI>
					</UL>

					<P>From the outside, there is no difference between a query implemented as
					an attribute and one implemented as a function: to obtain the balance of
					an account <SPAN CLASS="elocal">a</SPAN>, you will always write
					<SPAN CLASS="efeature">a</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">balance</SPAN>.
					In the implementation suggested above, <SPAN CLASS="elocal">a </SPAN>
					is an attribute, so that the notation denotes an access to the
					corresponding object field. But it is also possible to implement
					<SPAN CLASS="efeature">a</SPAN> as a function, whose algorithm will explore
					the lists of deposits and withdrawals and compute their accumulated value.
					To the clients of the class, and in the official class documentation as
					produced by the environment tools, the difference is not visible.</P>

					<P>This principle of<A NAME="UNIFORM_ACCESS"></A>
					<SPAN CLASS="bold">Uniform Access</SPAN> is central to Eiffel's goals of
					extendibility, reusability and maintainability: you can change the
					implementation without affecting clients; and you can reuse a class
					without having to know the details of its features' implementations. Most
					object-oriented languages force clients to use a different notation for a
					function call and an attribute access. This violates Uniform Access and is
					an impediment to software evolution, turning internal representation
					changes into interface changes that may disrupt large parts of a system.</P>

					<H2>A simple class</H2>

					<P>The following simple class text illustrates the
					preceding concepts</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">indexing</SPAN></P>

						<P>&nbsp;&nbsp; <SPAN CLASS="eitag">description</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="estring">"Simple bank accounts"</SPAN></P>

						<P><SPAN CLASS="ekeyword">class</SPAN></P>

						<P>&nbsp;&nbsp; <SPAN CLASS="eclass">ACCOUNT</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN> <SPAN CLASS="ecomment">-- Access</SPAN></P>

						<P>&nbsp;&nbsp; <SPAN CLASS="efeature">balance</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Current balance</SPAN></P>

						<P>&nbsp;&nbsp; <SPAN CLASS="efeature">deposit_count</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN> <SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Number of deposits made since opening</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">if</SPAN> <SPAN CLASS="efeature">all_deposits</SPAN>
						<SPAN CLASS="esymbol">/=</SPAN> <SPAN CLASS="efeature">Void</SPAN>
						<SPAN CLASS="ekeyword">then</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">Result</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="efeature">all_deposits</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">count</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN CLASS="ekeyword">end</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="ecomment">-- Element change</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">deposit</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">sum</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Add sum to account.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">if</SPAN> <SPAN CLASS="efeature">all_deposits</SPAN>
						<SPAN CLASS="esymbol">=</SPAN> <SPAN CLASS="efeature">Void</SPAN>
						<SPAN CLASS="ekeyword">then</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="efeature">all_deposits</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">all_deposits</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">extend</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">sum</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">balance</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="efeature">balance</SPAN>
						<SPAN CLASS="esymbol">+</SPAN> <SPAN CLASS="elocal">sum</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="esymbol">{</SPAN>NONE<SPAN CLASS="esymbol">}</SPAN>
						<SPAN CLASS="ecomment">-- Implementation</SPAN></P>

						<P>&nbsp;&nbsp; <SPAN CLASS="efeature">all_deposits</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">DEPOSIT_LIST</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- List of deposits since account's opening.</SPAN></P>

						<P><SPAN CLASS="ekeyword">invariant</SPAN></P>

						<P>&nbsp;&nbsp; <SPAN CLASS=etag>consistent_balance</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">all_deposits</SPAN>
						<SPAN CLASS="esymbol">/=</SPAN> <SPAN CLASS="efeature">Void</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">implies</SPAN> <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">balance</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="efeature">all_deposits</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">total</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P>&nbsp;&nbsp; <SPAN CLASS=etag>zero_if_no_deposits</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">all_deposits</SPAN>
						<SPAN CLASS="esymbol">=</SPAN> <SPAN CLASS="efeature">Void</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">implies</SPAN> <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">balance</SPAN>
						<SPAN CLASS="esymbol">=</SPAN> <SPAN CLASS=enumber>0</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P><SPAN CLASS="ekeyword">end</SPAN><SPAN CLASS="ecomment"> -- class </SPAN> ACCOUNT</P>
					</CODE>

					<P>(The <SPAN CLASS="esymbol">{</SPAN><SPAN CLASS="eclass">NONE</SPAN><SPAN CLASS="esymbol">}</SPAN>
					qualifier and the <SPAN CLASS="ekeyword">invariant</SPAN> clause, used here
					to make the example closer to a real class, will be explained shortly.
					<SPAN CLASS="eclass">DEPOSIT_LIST</SPAN> refers to another class, which can
					be written separately using library classes.)</P>

					<P>It's easy to deduce, from a feature's syntactic appearance, the
					category to which it belongs. Here:</P>

					<UL>
						<LI>Only <SPAN CLASS="efeature">deposit</SPAN> and
						<SPAN CLASS="efeature">deposit_count</SPAN>, which include a
						<SPAN CLASS="ekeyword">do</SPAN> … clause, are routines.


						<LI><SPAN CLASS="efeature">balance</SPAN> and
						<SPAN CLASS="efeature">all_deposits</SPAN>, which are simply declared with
						a type, are attributes. Note that even for attributes it is recommended
						to have a header comment.


						<LI>Routine <SPAN CLASS="efeature">deposit_count</SPAN> is declared as
						returning a result (of type <SPAN CLASS="eclass">INTEGER</SPAN>); so it
						is a function. Routine <SPAN CLASS="efeature">deposit</SPAN> has no
						such result and hence is a procedure.</LI>
					</UL>

					<A NAME="59651"></A><H2>Creating and initializing objects</H2>

					<P>Classes, as noted, are a static notion. Objects appear at run time;
					they are created explicitly. Here is the basic instruction to create
					an object of type <SPAN CLASS="eclass">ACCOUNT</SPAN> and attach it to
					<SPAN CLASS="elocal">x</SPAN>:</P>

					<CODE>
						<SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">x</SPAN>
					</CODE>

					<P>assuming that <SPAN CLASS="elocal">x</SPAN> has been declared of type
					<SPAN CLASS="eclass">ACCOUNT</SPAN>. Such an instruction must be in a
					routine of some class -- the only place where instructions can appear
					-- and its effect at run time will be threefold: create a new object
					of type <SPAN CLASS="eclass">ACCOUNT</SPAN>; initialize its fields to
					default values; and attach the value of <SPAN CLASS="elocal">x</SPAN>
					to it. Here the object will have two fields corresponding to the two
					attributes of the generating class: an integer for
					<SPAN CLASS="efeature">balance</SPAN>, which will be initialized to 0,
					and a reference for <SPAN CLASS="efeature">all_deposits</SPAN>, which
					will be initialized to a void reference:

					<IMG SRC="tutorial-7.png">

					<P>The language specifies default initialization values for all
					possible types:</P>

					<A NAME="25630"></A><TABLE CLASS=WITHBORDER>
						<TR CLASS=TITLE>
							<TD>
								Type
							</TD>
							<TD>
								Default value
							</TD>
						</TR>
						<TR>
							<TD>
								<SPAN CLASS="eclass">INTEGER</SPAN>,
								<SPAN CLASS="eclass">REAL</SPAN>,
								<SPAN CLASS="eclass">DOUBLE</SPAN>
							</TD>
							<TD>
								Zero
							</TD>
						</TR>
						<TR>
							<TD>
								<SPAN CLASS="eclass">BOOLEAN</SPAN>
							</TD>
							<TD>
								False
							</TD>
						</TR>
						<TR>
							<TD>
								<SPAN CLASS="eclass">CHARACTER</SPAN>
							</TD>
							<TD>
								Null
							</TD>
						</TR>
						<TR>
							<TD>
								Reference types (such as <SPAN CLASS="eclass">ACCOUNT</SPAN>
								and <SPAN CLASS="eclass">DEPOSIT_LIST</SPAN>)
							</TD>
							<TD>
								Void reference
							</TD>
						</TR>
						<TR>
							<TD>
								Composite expanded types (see next)
							</TD>
							<TD>
								Same rules, applied recursively to all fields
							</TD>
						</TR>
					</TABLE>

					<P>It is possible to override the initialization values by providing -- as
					in the earlier example of class <SPAN CLASS="eclass">HELLO</SPAN> -- one or
					more creation procedures. For example we might change
					<SPAN CLASS="eclass">ACCOUNT</SPAN> to make sure that every account is
					created with an initial deposit:</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">indexing</SPAN></P>

						<P>&nbsp;&nbsp; <SPAN CLASS="eitag">description</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="estring">"Simple bank accounts, initialized with a first deposit"</SPAN></P>

						<P><SPAN CLASS="ekeyword">class</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">ACCOUNT1</SPAN></P>

						<P><SPAN CLASS="ekeyword">create</SPAN></P>

						<P>&nbsp;&nbsp; <SPAN CLASS="efeature">make</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN> <SPAN CLASS="ecomment">-- Initialization</SPAN></P>

						<P>&nbsp;&nbsp; <SPAN CLASS="efeature">make</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">sum</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Initialize account with sum.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">deposit</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">sum</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp; ...The rest of class ACCOUNT...</P>

						<P><SPAN CLASS="ekeyword">end</SPAN> <SPAN CLASS="ecomment">-- class </SPAN>ACCOUNT1</P>
					</CODE>

					<P>A <SPAN CLASS="ekeyword">create</SPAN> clause may list zero or more (here
					just one) procedures of the class.</P>

					<P CLASS="note">Note the use of the same keyword,
					<SPAN CLASS="ekeyword">create</SPAN>, for both a creation clause, as here,
					and creation instructions such as <SPAN CLASS="ekeyword">create</SPAN>
					<SPAN CLASS="elocal">x</SPAN>.</P>

					<P>In this case the original form of creation instruction,
					<SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="elocal">x</SPAN>, is not
					valid any more for creating an instance of
					<SPAN CLASS="eclass">ACCOUNT1</SPAN>; you must use the form

					<CODE>
						<SPAN CLASS="ekeyword">create</SPAN>
						<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">make</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS=enumber>2000</SPAN><SPAN CLASS="esymbol">)</SPAN>
					</CODE>

					<P>known as a creation call. Such a creation call will have the same
					effect as the original form -- creation, initialization, attachment to
					<SPAN CLASS="elocal">x</SPAN> -- followed by the effect of calling the
					selected creation procedure, which here will call
					<SPAN CLASS="efeature">deposit</SPAN> with the given argument.</P>

					<P>Note that in this example all that <SPAN CLASS="efeature">make</SPAN>
					does is to call <SPAN CLASS="efeature">deposit</SPAN>. So an alternative
					to introducing a new procedure <SPAN CLASS="efeature">make</SPAN> would
					have been simply to introduce a creation clause of the form
					<SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="efeature">deposit</SPAN>,
					elevating <SPAN CLASS="efeature">deposit</SPAN> to the status of creation
					procedure. Then a creation call would be of the form
					<SPAN CLASS="ekeyword">create</SPAN>
					<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">deposit</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS=enumber>2000</SPAN><SPAN CLASS="esymbol">)</SPAN>.

					<P CLASS=note>Some variants of the basic creation instruction will be
					reviewed later: instruction with an explicit type; creation expressions.
					See <A HREF="tutorial-11.html#28280">"Creation variants"</A>.</P>

					<H2>Entities</H2>

					<P>The example assumed <SPAN CLASS="elocal">x</SPAN> declared of type
					<SPAN CLASS="eclass">ACCOUNT</SPAN> (or <SPAN CLASS="eclass">ACCOUNT1</SPAN>).
					Such an <SPAN CLASS="elocal">x</SPAN> is an example of
					<SPAN CLASS="bold">entity</SPAN>, a notion generalizing the well-known
					concept of variable. An entity is a name that appears in a class text to
					represent possible run-time values (a value being, as defined earlier,
					an object or a reference). An entity is one of the following:</P>

					<UL>
						<LI>An attribute of the enclosing class, such as
						<SPAN CLASS="efeature">balance</SPAN> and
						<SPAN CLASS="efeature">all_deposits</SPAN>.</LI>

						<LI>A formal argument of a routine, such as
						<SPAN CLASS="elocal">sum</SPAN> for <SPAN CLASS="efeature">deposit</SPAN>
						and <SPAN CLASS="efeature">make</SPAN>.</LI>

						<LI>A local entity declared for the internal needs of a routine.</LI>

						<LI>The special entity <SPAN CLASS="ekeyword">Result</SPAN> in a function.</LI>
					</UL>

					<P>The third case, local entities, arises when a routine needs some
					auxiliary values for its computation. Here is an example of the syntax:</P>

					<CODE>
						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">deposit</SPAN>
						(<SPAN CLASS="elocal">sum</SPAN>: <SPAN CLASS="eclass">INTEGER</SPAN>)
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Add <SPAN CLASS="elocal">sum</SPAN> to account.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">local</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="elocal">new</SPAN>: <SPAN CLASS="eclass">AMOUNT</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">create</SPAN>
						<SPAN CLASS="elocal">new</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">make</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">sum</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS=efature>all_deposits</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS=efature>extend</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">new</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">balance</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="efeature">balance</SPAN> <SPAN CLASS="esymbol">+</SPAN>
						<SPAN CLASS="elocal">sum</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>This example is a variant of <SPAN CLASS="efeature">deposit</SPAN> for which
					we assume that the elements of a <SPAN CLASS="eclass">DEPOSIT_LIST</SPAN> such
					as <SPAN CLASS="efeature">all_deposits</SPAN> are no longer just integers, but
					objects, instances of a new class, <SPAN CLASS="eclass">AMOUNT</SPAN>. Such an
					object will contain an integer value, but possibly other information as well.
					So for the purpose of procedure <SPAN CLASS="efeature">deposit</SPAN> we create
					an instance of <SPAN CLASS="eclass">AMOUNT</SPAN> and insert it, using procedure
					<SPAN CLASS="efeature">extend</SPAN>, into the list
					<SPAN CLASS="efeature">all_deposits</SPAN>. The object is identified through the
					local entity <SPAN CLASS="elocal">new</SPAN>, which is only needed within each
					execution of the routine (as opposed to an attribute, which yields an object
					field that will remain in existence for as long as the object).</P>

					<P>The last case of entity, <SPAN CLASS="ekeyword">Result</SPAN>, serves to
					denote, within the body of a function, the final result to be returned by that
					function. This was illustrated by the function
					<SPAN CLASS="efeature">deposits_count</SPAN>, which read</P>

					<CODE>
						<P><SPAN CLASS="efeature">deposit_count</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN> <SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ecomment">--
						Number of deposits made since opening (provisional version)</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">if</SPAN>
						<SPAN CLASS="efeature">all_deposits</SPAN>
						<SPAN CLASS="esymbol">/=</SPAN> <SPAN CLASS="efeature">Void</SPAN>
						<SPAN CLASS="ekeyword">then</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">
						Result</SPAN> <SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="efeature">all_deposits</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">count</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>The value returned by any call will be the value of the expression
					<SPAN CLASS="efeature">all_deposits</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">count</SPAN>
					(to be explained in detail shortly) for that call, unless <SPAN CLASS="efeature">all_deposits</SPAN>
					has value <SPAN CLASS="efeature">Void</SPAN>, denoting a void reference
					(<SPAN CLASS="esymbol">/=</SPAN> is "not equal").</P>

					<P>The default initialization rules seen earlier for attributes (see the
					corresponding <A HREF="tutorial-07.html#25630">table</A>) also serve to
					initialize local entities and <SPAN CLASS="ekeyword">Result</SPAN> on routine
					entry. So in the last example, if <SPAN CLASS="efeature">all_deposits</SPAN> is
					void (as in the case on initialization with the class as given so far),
					<SPAN CLASS="ekeyword">Result</SPAN> keeps its default value of 0, which will be
					returned as the result of the function.</P>

					<H2>Calls</H2>

					<P>Apart from object creation, the basic computational mechanism, in the
					object-oriented style of computation represented by Eiffel, is feature call.
					In its basic form, it appears as</P>

					<CODE>
						<P><SPAN CLASS="elocal">target</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">feature</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">argument1</SPAN><SPAN CLASS="esymbol">,
						…)</SPAN></P>
					</CODE>

					<P>where <SPAN CLASS="elocal">target</SPAN> is an entity or more generally an
					expression, <SPAN CLASS="efeature">feature</SPAN> is a feature name, and there
					may be zero or more <SPAN CLASS="elocal">argument</SPAN> expressions. In the
					absence of any <SPAN CLASS="elocal">argument</SPAN> the part in parentheses
					should be removed.</P>

					<P>We have already seen such calls. If the <SPAN CLASS="efeature">feature</SPAN>
					denotes a procedure, the call is an instruction, as in</P>

					<CODE>
						<P><SPAN CLASS="efeature">all_deposits</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">extend</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">new</SPAN><SPAN CLASS="esymbol">)</SPAN></P>
					</CODE>

					<P>If <SPAN CLASS="efeature">feature</SPAN> denotes a query (function or
					attribute), the call is an expression, as in the right-hand side of</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">Result</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="efeature">all_deposits</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">count</SPAN></P>
					</CODE>

					<P>Following the principle of <A HREF="#UNIFORM_ACCESS">Uniform Access</A>,
					this form is the same for calls to attributes and to functions without
					arguments. In this example, feature <SPAN CLASS="efeature">count</SPAN> from
					class <SPAN CLASS="eclass">DEPOSIT_LIST</SPAN> may indeed be implemented in
					either of these two ways: we can keep a <SPAN CLASS="efeature">count</SPAN>
					field in each list, updating it for each insertion and removal; or we can
					compute <SPAN CLASS="efeature">count</SPAN>, whenever requested, by traversing
					the list and counting the number of items.</P>

					<P>In the case of a routine with arguments -- procedure or function -- the
					routine will be declared, in its class, as</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">formal1</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">TYPE1</SPAN><SPAN CLASS="esymbol">; …)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN>
						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;…</P>
						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN>
					</CODE>

					<P>meaning that, at the time of each call, the value of each formal will be
					set to the corresponding actual (<SPAN CLASS="elocal">formal1</SPAN> to
					<SPAN CLASS="elocal">argument1</SPAN> and so on).</P>

					<P>In the routine body, it is not permitted to change the value of a formal
					argument, although it is possible to change the value of an attached object
					through a procedure call such as
					<SPAN CLASS="elocal">formal1</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">some_procedure</SPAN>
					<SPAN CLASS="esymbol">(…)</SPAN>.</P>

					<H2>Infix and prefix notation</H2>

					<P>Basic types such as <SPAN CLASS="eclass">INTEGER</SPAN> are, as noted,
					full-status citizens of Eiffel's type system, and so are declared as classes
					(part of the Kernel Library). <SPAN CLASS="eclass">INTEGER</SPAN>, for example,
					is characterized by the features describing integer operations: plus, minus,
					times, division, less than, and so on.</P>

					<P>With the dot notation seen so far, this would imply that simple arithmetic
					operations would have to be written with a syntax such as
					<SPAN CLASS="elocal">i</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">plus</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">j</SPAN><SPAN CLASS="esymbol">)</SPAN>
					instead of the usual <SPAN CLASS="elocal">i</SPAN> <SPAN CLASS="esymbol">+</SPAN>
					<SPAN CLASS="elocal">j</SPAN>. This would be awkward. Infix and prefix features
					solve the problem, reconciling the object-oriented view of computation with
					common notational practices of mathematics. The addition function is declared
					in class <SPAN CLASS="eclass">INTEGER</SPAN> as</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">infix</SPAN>
						<SPAN CLASS="esymbol">"</SPAN><SPAN CLASS=efature>+</SPAN><SPAN CLASS="esymbol">"</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">other</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">):</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN> <SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;…</P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>Such a feature has all the properties and prerogatives of a normal
					"identifier" feature, except for the form of the calls, which is infix, as in
					<SPAN CLASS="elocal">i</SPAN> <SPAN CLASS="esymbol">+</SPAN> <SPAN CLASS="elocal">j</SPAN>,
					rather than using dot notation. An infix feature must be a function, and take
					exactly one argument. Similarly, a function can be declared as
					<SPAN CLASS="ekeyword">prefix</SPAN>
					<SPAN CLASS="esymbol">"</SPAN><SPAN CLASS="efeature">-</SPAN><SPAN CLASS="esymbol">"</SPAN>,
					with no argument, permitting calls of the form <SPAN CLASS=enumber>-3</SPAN>
					rather than <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS=enumber>3</SPAN><SPAN CLASS="esymbol">)</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">negated</SPAN>.</P>

					<P>Predefined library classes covering basic types such as
					<SPAN CLASS="eclass">INTEGER</SPAN>, <SPAN CLASS="eclass">CHARACTER</SPAN>,
					<SPAN CLASS="eclass">BOOLEAN</SPAN>, <SPAN CLASS="eclass">REAL</SPAN>,
					<SPAN CLASS="eclass">DOUBLE</SPAN> are known to the Eiffel compiler, so that a
					call of the form <SPAN CLASS="elocal">i</SPAN> <SPAN CLASS="esymbol">+</SPAN>
					<SPAN CLASS="elocal">j</SPAN>, although conceptually equivalent to a routine
					call, can be processed just as efficiently as the corresponding arithmetic
					expression in an ordinary programming language. This brings the best of both
					worlds: conceptual simplicity, enabling Eiffel developers, when they want to,
					to think of integers and the like as objects; and efficiency as good as in
					lower-level approaches.</P>

					<P>Infix and prefix features are available to any class, not just the basic
					types' predefined classes. For example a graphics class could use the name
					<SPAN CLASS="ekeyword">infix</SPAN>
					<SPAN CLASS="esymbol">"</SPAN><SPAN CLASS="efeature">|-|</SPAN><SPAN CLASS="esymbol">"</SPAN>
					for a function computing the distance between two points, to be used in
					expressions such as <SPAN CLASS="elocal">point1</SPAN>
					<SPAN CLASS="efeature">|-|</SPAN> <SPAN CLASS="elocal">point2</SPAN>.</P>

					<H2>Type declaration</H2>

					<P>Every entity appearing in an Eiffel text is declared as being of a certain
					type, using the syntax already encountered in the above examples:</P>

					<CODE>
						<P><SPAN CLASS="elocal">entity_name</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">TYPE_NAME</SPAN></P>
					</CODE>

					<P>This applies to attributes, formal arguments of routines and local
					entities. You will also declare the result type for a function, as in the
					earlier example:</P>

					<CODE>
						<P><SPAN CLASS="efeature">deposit_count</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN> <SPAN CLASS="ekeyword">is</SPAN>…</P>
					</CODE>

					<P>Specifying such a function result type also declares, implicitly, the type
					for <SPAN CLASS="ekeyword">Result</SPAN> as used in the function's body.</P>

					<P>What is a type? With the elements seen so far, every type is a
					<SPAN CLASS="ekeyword">class</SPAN>. <SPAN CLASS="eclass">INTEGER</SPAN>, used in
					the declaration of <SPAN CLASS="efeature">deposits_count</SPAN>, is, as we have
					seen, a library class; and the declaration
					<SPAN CLASS="efeature">all_deposits</SPAN><SPAN CLASS="esymbol">:</SPAN>
					<SPAN CLASS="eclass">DEPOSIT_LIST</SPAN> assumes the existence of a class
					<SPAN CLASS="eclass">DEPOSIT_LIST</SPAN>.</P>

					<P>Three mechanisms introduced later in this tutorial
					-- <A HREF="#40534">expanded types</A>,
					<A HREF="tutorial-08.html#pgfId-514722">genericity</A> and
					<A HREF="tutorial-10.html#46019">anchored declarations</A>
					-- will generalize the notion of type slightly. But they do not change the
					fundamental property that
					<SPAN CLASS="bold">every type is based on a class</SPAN>, called the type's
					<SPAN CLASS="bold">base class</SPAN>. In the examples seen so far, each type
					<SPAN CLASS="italics">is</SPAN> a class, serving as its own base class.</P>

					<P>An instance of a class <SPAN CLASS="eclass">C</SPAN> is also called
					"an object of type <SPAN CLASS="eclass">C</SPAN>".</P>

					<H2><A NAME="40534"></A>Type categories</H2>

					<P>It was noted above that a value is either an object or a reference. This
					corresponds to two kinds of type: reference types and expanded types.</P>

					<P>If a class is declared as just</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">class</SPAN></P>
						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">CLASS_NAME</SPAN></P>
						<P>…</P>
					</CODE>

					<P>it defines a reference type. The entities declared of that type will denote
					references. So in the declaration

					<CODE>
						<P><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">ACCOUNT</SPAN></P>
					</CODE>

					<P>the possible run-time values for <SPAN CLASS="elocal">x</SPAN> are
					references, which will be either void or attached to instances of class
					<SPAN CLASS="eclass">ACCOUNT</SPAN>.</P>

					<P>Instead of <SPAN CLASS="ekeyword">class</SPAN>, however, you may use the
					double keyword <SPAN CLASS="ekeyword">expanded class</SPAN>, as in the
					EiffelBase class definition

					<CODE>
						<P><SPAN CLASS="ekeyword">indexing</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eitag">description:</SPAN>
						<SPAN CLASS="estring">"Integer values"</SPAN></P>

						<P><SPAN CLASS="ekeyword">expanded class</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">INTEGER</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="ecomment">-- Basic operations</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">infix</SPAN>
						<SPAN CLASS="esymbol">"</SPAN><SPAN CLASS="efeature">+</SPAN><SPAN CLASS="esymbol">"</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">other</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">):</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN> <SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>
						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;…</P>
						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;… Other feature declarations …</P>

						<P><SPAN CLASS="ekeyword">end</SPAN>
						<SPAN CLASS="ecomment">-- class</SPAN> INTEGER</P>
					</CODE>

					<P>In this case the value of an entity declared as
					<SPAN CLASS="elocal">n</SPAN><SPAN CLASS="esymbol">:</SPAN>
					<SPAN CLASS="eclass">INTEGER</SPAN> is not a reference to an object, but the
					object itself -- in this case an atomic object, an integer value.</P>

					<P>It is also possible, for some non-expanded class C, to declare an entity as

					<CODE>
						<P><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="ekeyword">expanded</SPAN> <SPAN CLASS="eclass">C</SPAN></P>
					</CODE>

					<P>so that the values for <SPAN CLASS="elocal">x</SPAN> will be objects of type
					<SPAN CLASS="eclass">C</SPAN>, rather than references to such objects. This is
					our first example of a type -- <SPAN CLASS="ekeyword">expanded</SPAN>
					<SPAN CLASS="eclass">C</SPAN> -- that is not directly a class, although it is
					based on a class, <SPAN CLASS="eclass">C</SPAN>. The base type of such a type is
					<SPAN CLASS="eclass">C</SPAN>.</P>

					<P>Note that the value of an entity of an expanded type can never be void;
					only a reference can. Extending the earlier terminology, an expanded entity is
					always <SPAN CLASS="bold">attached to</SPAN> an object, atomic (as in the case
					of <SPAN CLASS="elocal">n</SPAN><SPAN CLASS="esymbol">:</SPAN>
					<SPAN CLASS="eclass">INTEGER</SPAN>) or composite (as in
					<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">:</SPAN>
					<SPAN CLASS="ekeyword">expanded</SPAN> <SPAN CLASS="eclass">ACCOUNT</SPAN>).</P>

					<P>Expanded declarations make it possible to construct composite objects with
					subobjects, as in the following abbreviated class declaration (indexing clause
					and routines omitted):</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">class</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">CAR</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">engine</SPAN>
						<SPAN CLASS="esymbol">:</SPAN> <SPAN CLASS="ekeyword">expanded</SPAN>
						<SPAN CLASS="eclass">ENGINE</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">originating_plant</SPAN>
						<SPAN CLASS="esymbol">:</SPAN> <SPAN CLASS="eclass">PLANT</SPAN></P>

						<P><SPAN CLASS="ekeyword">end</SPAN> <SPAN CLASS="ecomment">-- class</SPAN>
						<SPAN CLASS="eclass">CAR</SPAN></P>
					</CODE>

					<P>Here is an illustration of the structure of a typical instance of
					<SPAN CLASS="eclass">CAR</SPAN>:</P>

					<IMG SRC="tutorial-8.png">

					<P>This example also illustrates that the distinction between expanded and
					reference types is important not just for system implementation purposes but
					for high-level system modeling as well. Consider the example of a class
					covering the notion of car. Many cars share the same
					<SPAN CLASS="efeature">originating_plant</SPAN>, but an
					<SPAN CLASS="efeature">engine</SPAN> belongs to just one car. References
					represent the modeling relation "knows about"; subobjects, as permitted by
					expanded types, represent the relation "has part", also known as aggregation.
					The key difference is that sharing is possible in the former case but not in
					the latter.</P>

					<A NAME="12485"></A><H2>Basic operations</H2>

					<P>To assign, copy and compare values, you can rely on a number of mechanisms.
					Two of them, assignment and equality testing, are language constructs; the
					others are library features, coming from the top-level class
					<SPAN CLASS="eclass">ANY</SPAN> seen <A HREF="tutorial-06.html#ANY">earlier</A>.</P>

					<P>Assignment uses the symbol <SPAN CLASS="esymbol">:=</SPAN>. The assignment
					instruction

					<CODE>
						<P><SPAN CLASS="elocal">x</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="elocal">y</SPAN></P>
					</CODE>

					<P>updates the value of <SPAN CLASS="elocal">x</SPAN> to be the same as that of
					<SPAN CLASS="elocal">y</SPAN>. This means that:</P>

					<UL>
						<LI>For entities of reference types, the value of
						<SPAN CLASS="elocal">x</SPAN> will be a void reference if the value of
						<SPAN CLASS="elocal">y</SPAN> is void, and otherwise
						<SPAN CLASS="elocal">x</SPAN> will be attached to the same object OBJ2 as
						<SPAN CLASS="elocal">y</SPAN>:

						<BR /><A NAME="REASSIGNEMENT"></A><IMG SRC="tutorial-9.png">

						<LI>For entities of expanded types, the values are objects; the object
						attached to <SPAN CLASS="elocal">x</SPAN> will be overwritten with the
						contents of the object attached to <SPAN CLASS="elocal">y</SPAN>. In the
						case of atomic objects, as in <SPAN CLASS="elocal">n</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS=enumber>3</SPAN> with the
						declaration <SPAN CLASS="elocal">n</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN>, this has the expected effect of
						assigning to <SPAN CLASS="elocal">n</SPAN> the integer value
						<SPAN CLASS=enumber>3</SPAN>; in the case of composite objects, this
						overwrites the fields for <SPAN CLASS="elocal">x</SPAN>, one by one, with
						the corresponding <SPAN CLASS="elocal">y</SPAN> fields.</LI>
					</UL>

					<P>To copy an object, use
					<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">copy</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">)</SPAN>
					which assumes that both <SPAN CLASS="elocal">x</SPAN> and <SPAN CLASS="elocal">y</SPAN>
					are non-void, and copies the contents of <SPAN CLASS="elocal">y</SPAN>'s
					attached object onto those of <SPAN CLASS="elocal">x</SPAN>'s. For expanded
					entities the effect is the same as that the of the assignment
					<SPAN CLASS="elocal">x</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
					<SPAN CLASS="elocal">y</SPAN>.</P>

					<P>A variant of the <SPAN CLASS="efeature">copy</SPAN> operation is
					<SPAN CLASS="efeature">clone</SPAN>. The expression
					<SPAN CLASS="efeature">clone</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">)</SPAN>
					produces a newly created object, initialized with a copy of the object
					attached to <SPAN CLASS="elocal">y</SPAN>, or a void value if
					<SPAN CLASS="elocal">y</SPAN> itself is void. For a reference type (the only
					interesting case) the returned result for non-void
					<SPAN CLASS="elocal">y</SPAN> is a reference to the new object. This means we
					may view <SPAN CLASS="efeature">clone</SPAN> as a function that performs</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">create</SPAN> <SPAN CLASS="ekeyword">Result</SPAN></P>

						<P><SPAN CLASS="ekeyword">Result</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">copy</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">)</SPAN></P>
					</CODE>

					<P>So in the assignment <SPAN CLASS="elocal">x</SPAN>
					<SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="efeature">clone</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">)</SPAN>,
					assuming both entities of reference types and <SPAN CLASS="elocal">y</SPAN> not
					void, will attach <SPAN CLASS="elocal">x</SPAN> to a
					<SPAN CLASS="bold">new object</SPAN> identical to <SPAN CLASS="elocal">y</SPAN>'s
					attached object, as opposed to the assignment <SPAN CLASS="elocal">x</SPAN>
					<SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="elocal">y</SPAN> which attaches
					<SPAN CLASS="elocal">x</SPAN> to the <SPAN CLASS="bold">same object</SPAN> as
					<SPAN CLASS="elocal">y</SPAN>.</P>

					<P>To determine whether two values are equal, use the expression
					<SPAN CLASS="elocal">x</SPAN> <SPAN CLASS="esymbol">=</SPAN> <SPAN CLASS="elocal">y</SPAN>.
					For references, this comparison will yield true if the values are either both
					void or both attached to the same object; this is the case in the last figure
					in the state after the assignment, but not before. The symbol for
					<SPAN CLASS="italics">not</SPAN> equal is <SPAN CLASS=symbol>/=</SPAN>, as in
					<SPAN CLASS="elocal">x</SPAN> <SPAN CLASS=symbol>/=</SPAN> <SPAN CLASS="elocal">y</SPAN>.</P>

					<P>As with assignment, there is also a form that works on objects rather than
					references: <SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">is_equal </SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">)</SPAN>
					will return true when <SPAN CLASS="elocal">x</SPAN> and <SPAN CLASS="elocal">y</SPAN>
					are both non-void and attached to field-by-field identical objects. This can
					be true even when <SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">=</SPAN>
					<SPAN CLASS="elocal">y</SPAN> is not, for example, in the figure,
					<SPAN CLASS="efeature">before</SPAN> the assignment, if the two objects shown
					are field-by-field equal.</P>

					<P>A more general variant of <SPAN CLASS="efeature">is_equal</SPAN> is used
					under the form <SPAN CLASS="efeature">equal</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN>,
					<SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">)</SPAN>. This is always
					defined, even if <SPAN CLASS="elocal">x</SPAN> is void, returning true whenever
					<SPAN CLASS="efeature">is_equal</SPAN> would but also if
					<SPAN CLASS="elocal">x</SPAN> and <SPAN CLASS="elocal">y</SPAN> are both void.
					(In contrast, <SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">is_equal</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">)</SPAN>
					is not defined for void <SPAN CLASS="elocal">x</SPAN> and would, if evaluated, yield an
					exception as explained in
					<A HREF="tutorial-09.html#10722">"Exception handling"</A></P>

					<P><SPAN CLASS="efeature">Void</SPAN> denotes a void reference. So you can make
					<SPAN CLASS="elocal">x</SPAN> void through the assignment
					<SPAN CLASS="elocal">x</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
					<SPAN CLASS="efeature">Void</SPAN>, and test whether it is void through
					<SPAN CLASS="ekeyword">if</SPAN> <SPAN CLASS="elocal">x</SPAN>
					<SPAN CLASS="esymbol">=</SPAN> <SPAN CLASS="efeature">Void</SPAN>
					<SPAN CLASS="ekeyword">then</SPAN> … </P>

					<P>Where assignment <SPAN CLASS="esymbol">:=</SPAN> and the equality operators
					<SPAN CLASS="esymbol">=</SPAN> and <SPAN CLASS="esymbol">/=</SPAN> were language
					constructs, <SPAN CLASS="efeature">copy</SPAN>,
					<SPAN CLASS="efeature">clone</SPAN>, <SPAN CLASS="efeature">is_equal</SPAN>,
					<SPAN CLASS="efeature">equal</SPAN> and <SPAN CLASS="efeature">Void</SPAN>
					are <SPAN CLASS="bold">library features</SPAN> coming from class
					<SPAN CLASS="eclass">ANY</SPAN>. The type of <SPAN CLASS="efeature">Void</SPAN>,
					as declared in <SPAN CLASS="eclass">ANY</SPAN>, is <SPAN CLASS="eclass">NONE</SPAN>,
					the "bottom" type.</P>

					<P>Using the redefinition mechanisms to be seen in the discussion of
					inheritance, a class can redefine <SPAN CLASS="efeature">copy</SPAN> and
					<SPAN CLASS="efeature">is_equal</SPAN> to cover specific notions of copy and
					equality. The assertions will ensure that the two remain compatible: after
					<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">copy</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">)</SPAN>,
					the property
					<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">is_equal</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">)</SPAN>
					must always be true. The effect of <SPAN CLASS="efeature">clone</SPAN> will
					automatically follow a redefinition of <SPAN CLASS="efeature">copy</SPAN>,
					and <SPAN CLASS="efeature">equal</SPAN> will follow
					<SPAN CLASS="efeature">is_equal</SPAN>.</P>

					<P>To guarantee the original, non-redefined semantics you may use the variants
					<SPAN CLASS="efeature">standard_copy</SPAN>,
					<SPAN CLASS="efeature">standard_clone</SPAN>,
					<SPAN CLASS="efeature">standard_equal</SPAN>, all defined in
					<SPAN CLASS="eclass">ANY</SPAN> as "frozen", that is to say non-redefinable.</P>

					<A NAME="35815"></A><H2>Deep operations and persistence</H2>

					<P>Feature <SPAN CLASS="efeature">clone</SPAN> only duplicates one object. If
					some of the object's fields are references to other objects, the references
					themselves will be copied, not those other objects.</P>

					<P>It is useful, in some cases, to duplicate not just one object but an entire
					object structure. The expression <SPAN CLASS="efeature">deep_clone</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">y</SPAN><SPAN CLASS="esymbol">)</SPAN>
					achieves this goal: assuming non-void <SPAN CLASS="elocal">y</SPAN>, it will
					produce a duplicate not just of the object attached to
					<SPAN CLASS="elocal">y</SPAN> but of the entire object structure starting at
					that object. The mechanism respects all the possible details of that
					structure, such as cyclic reference chains. Like the preceding features,
					<SPAN CLASS="efeature">deep_clone</SPAN> comes from class
					<SPAN CLASS="eclass">ANY</SPAN>.</P>

					<P>A related mechanism provides a powerful <SPAN CLASS="bold">persistence</SPAN>
					facility. A call of the form</P>

					<CODE>
						<P><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">store</SPAN>
						<SPAN CLASS="esymbol">(</SPAN>
						<SPAN CLASS="efeature">Some_file_or_network_connection</SPAN>
						<SPAN CLASS="esymbol">)</SPAN></P>
					</CODE>

					<P>will store a copy of the entire object structure starting at
					<SPAN CLASS="elocal">x</SPAN>, under a suitable representation. Like
					<SPAN CLASS="efeature">deep_clone</SPAN>, procedure
					<SPAN CLASS="efeature">store</SPAN> will follow all references to the end and
					maintain the properties of the structure. The function
					<SPAN CLASS="efeature">retrieved</SPAN> can then be used -- in the same system,
					or another -- to recreate the structure from the stored version.</P>

					<P>As the name suggests, <SPAN CLASS="efeature">Some_file_or_network_connection</SPAN>
					can be an external medium of various possible kinds, not just a file but
					possibly a database or network. ISE's EiffelNet client-server library indeed
					uses the <SPAN CLASS="efeature">store</SPAN> - <SPAN CLASS="efeature">retrieved</SPAN>
					mechanism to exchange object structures over a network, between compatible or
					different machine architectures, for example a Windows client and a Unix server.</P>

					<H2>Memory management</H2>

					<P>Reference reattachments <SPAN CLASS="elocal">x</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
					<SPAN CLASS="elocal">y</SPAN> of the form illustrated by this
					<A HREF="#REASSIGNEMENT">figure</A> can cause objects to become
					unreachable. This is the case for the object identified as OBJ2 on that
					figure (the object to which <SPAN CLASS="elocal">x</SPAN> was attached before
					the assignment) if no other reference was attached to it.</P>

					<P>In all but toy systems, it is essential to reclaim the memory that has
					been allocated for such objects; otherwise memory usage could grow forever,
					as a result of creation instructions <SPAN CLASS="ekeyword">create</SPAN>
					<SPAN CLASS="elocal">x</SPAN>… and calls to <SPAN CLASS="efeature">clone</SPAN>
					and the like, leading to thrashing and eventually to catastrophic termination.</P>

					<P>The Eiffel method suggests that the task of detecting and reclaiming such
					unused object space should be handled by an automatic mechanism (part of the
					Eiffel run-time environment), not manually by developers (through calls to
					procedures such as Pascal's <SPAN CLASS="efeature">dispose</SPAN> and C/C++'s
					<SPAN CLASS="efeature">free</SPAN>). The arguments for this view are:</P>

					<UL>
						<LI><SPAN CLASS="bold">Simplicity</SPAN>: handling memory reclamation
						manually can add enormous complication to the software, especially when
						-- as is often the case in object-oriented development -- the system
						manipulates complex run-time data structures with many links and cycles.</LI>

						<LI><SPAN CLASS="bold">Reliability</SPAN> : memory management errors, such
						as the incorrect reclamation of an object that is still referenced by a
						distant part of the structure, are a notorious source of dangerous and
						hard-to-correct bugs.</LI>
					</UL>

					<P>ISE Eiffel provides a sophisticated <SPAN CLASS="bold">garbage collector</SPAN>
					which efficiently handles the automatic reclamation process, while causing no
					visible degradation of a system's performance and response time.</P>

					<H2>Information hiding and the call rule</H2>

					<P>The basic form of computation, it has been noted, is a call of the form
					<SPAN CLASS="elocal">target</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">feature </SPAN>
					<SPAN CLASS="esymbol">(</SPAN>…<SPAN CLASS="esymbol">)</SPAN>. This is only
					meaningful if <SPAN CLASS="efeature">feature</SPAN> denotes a feature of the
					generating class of the object to which <SPAN CLASS="elocal">target</SPAN>
					(assumed to be non-void) is attached. The precise rule is the following:</P>

					<P CLASS="note"><SPAN CLASS="bold">Feature Call rule</SPAN><BR /><BR />
					A call of the form
					<SPAN CLASS="elocal">target</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">feature</SPAN>
					<SPAN CLASS="esymbol">(</SPAN>…<SPAN CLASS="esymbol">)</SPAN> appearing in a class
					<SPAN CLASS="eclass">C</SPAN> is only valid if
					<SPAN CLASS="efeature">feature</SPAN> is a feature of the base class of
					<SPAN CLASS="elocal">target</SPAN>'s type, and is available to
					<SPAN CLASS="eclass">C</SPAN> .</P>

					<P>The first condition simply expresses that if <SPAN CLASS="elocal">target</SPAN>
					has been declared as <SPAN CLASS="elocal">target</SPAN><SPAN CLASS="esymbol">:</SPAN>
					<SPAN CLASS="eclass">A</SPAN> then <SPAN CLASS="efeature">feature</SPAN> must be
					the name of one of the features of <SPAN CLASS="eclass">A</SPAN>. The second
					condition reflects Eiffel's application of the principles of information
					hiding. A <SPAN CLASS="ekeyword">feature</SPAN> clause, introducing one or more
					feature declarations, may appear not only as</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="ecomment">-- Comment identifying the feature category</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;… Feature declaration …</P>

						<P>&nbsp;&nbsp;&nbsp;… Feature declaration …</P>

						<P>&nbsp;&nbsp;&nbsp;…</P>
					</CODE>

					<P>but may also include a list of classes in braces,
					<SPAN CLASS="ekeyword">feature</SPAN>
					<SPAN CLASS="esymbol">{</SPAN><SPAN CLASS="eclass">A</SPAN>,
					<SPAN CLASS="eclass">B</SPAN>, …<SPAN CLASS="esymbol">}</SPAN>,
					as was illustrated for <SPAN CLASS="eclass">ACCOUNT</SPAN>:</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="esymbol">{</SPAN><SPAN CLASS="eclass">NONE</SPAN><SPAN CLASS="esymbol">}</SPAN>
						<SPAN CLASS="ecomment">-- Implementation</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">all_deposits</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">DEPOSIT_LIST</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- List of deposits since account's opening.</SPAN></P>
					</CODE>

					<P>This form indicates that the features appearing in that clause are only
					<SPAN CLASS="bold">available</SPAN> -- in the sense of available for calls,
					as used in the Feature Call rule -- to the classes listed. In the example
					feature <SPAN CLASS="efeature">all_deposits</SPAN> is only available to
					<SPAN CLASS="eclass">NONE</SPAN>. Because of the
					<A HREF="tutorial-06.html#GLOBAL">global inheritance structure</A> this
					means it is in fact available to no useful client at all, and is equivalent
					in practice to <SPAN CLASS="ekeyword">feature</SPAN>
					<SPAN CLASS="esymbol">{</SPAN> <SPAN CLASS="esymbol">}</SPAN> with an empty class
					list, although the form listing <SPAN CLASS="eclass">NONE</SPAN> explicitly is
					more visible and hence preferred.</P>

					<P>With this specification a class text including the declaration
					<SPAN CLASS="elocal">acc</SPAN><SPAN CLASS="esymbol">:</SPAN>
					<SPAN CLASS="eclass">ACCOUNT</SPAN> and a call of the form</P>

					<CODE>
						<P><SPAN CLASS="elocal">acc</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">all_deposits</SPAN></P>
					</CODE>

					<P>violates the Feature Call rule and will be rejected by the
					Eiffel compiler.</P>

					<P>Besides fully exported features (introduced by
					<SPAN CLASS="ekeyword">feature</SPAN> … without further qualification) and fully
					secret ones (<SPAN CLASS="ekeyword">feature</SPAN>
					<SPAN CLASS="esymbol">{</SPAN> <SPAN CLASS="esymbol">}</SPAN> or
					<SPAN CLASS="ekeyword">feature</SPAN>
					<SPAN CLASS="esymbol">{</SPAN><SPAN CLASS="eclass">NONE</SPAN><SPAN CLASS=symbol>}</SPAN>),
					it is possible to export features selectively to some specified classes, using
					the specification</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="esymbol">{</SPAN><SPAN CLASS="eclass">A</SPAN>,
						<SPAN CLASS="eclass">B</SPAN>, …<SPAN CLASS="esymbol">}</SPAN></P>
					</CODE>

					<P>for arbitrary classes <SPAN CLASS="eclass">A</SPAN>,
					<SPAN CLASS="eclass">B</SPAN>, … This enables a group of related classes to
					provide each other with privileged access, without requiring the introduction
					of a special module category above the class level (see
					<A HREF="tutorial-06.html#CLUSTERS">"Clusters"</A>).</P>

					<P>Exporting features selectively to a set of classes
					<SPAN CLASS="eclass">A</SPAN>, <SPAN CLASS="eclass">B</SPAN>, … also makes them
					available to the descendants of these classes. So a feature clause beginning
					with just <SPAN CLASS="ekeyword">feature</SPAN> is equivalent to one starting
					with <SPAN CLASS="ekeyword">feature</SPAN>
					<SPAN CLASS="esymbol">{</SPAN><SPAN CLASS="eclass">ANY</SPAN><SPAN CLASS="esymbol">}</SPAN>.
					</P>

					<P>These rules enable successive feature clauses to specify exports to
					different clients. In addition, the recommended style, illustrated in the
					examples of this chapter, suggests writing separate feature clauses --
					regardless of their use for specifying export privileges -- to group features
					into separate categories. The standard style rules define a number of
					fundamental categories and the order in which they should appear; they include:
					<SPAN CLASS="ecomment">Initialization</SPAN> for creation procedures,
					<SPAN CLASS="ecomment">Access</SPAN> for general queries,
					<SPAN CLASS="ecomment">Status report</SPAN> for boolean-valued queries,
					<SPAN CLASS="ecomment">Status setting</SPAN>,
					<SPAN CLASS="ecomment">Element change</SPAN>,
					<SPAN CLASS="ecomment">Implementation</SPAN> (for selectively exported or secret
					features). Every feature in the EiffelBase library classes belongs to one of
					the predefined categories.</P>

					<P>The Feature Call rule is the first of the rules that make Eiffel a
					<SPAN CLASS="bold">statically typed</SPAN> approach, where the applicability of
					operations to objects is verified at compile time rather than during execution.
					Static typing is one of the principal components of Eiffel's support for
					reliability in software development.</P>

					<H2>Execution scenario</H2>

					<P>The preceding elements make it possible to understand the overall scheme of
					an Eiffel system's execution.</P>

					<P>At any time during the execution of a system, one object is the
					<SPAN CLASS="bold">current object</SPAN> of the execution, and one of the
					routines of the system, the <SPAN CLASS="bold">current routine</SPAN>, is
					being executed, with the current object as its target. (We will see below how
					the current object and current routine are determined.) The text of a class,
					in particular its routines, make constant implicit references to the current
					object. For example in the instruction</P>

					<CODE>
						<P><SPAN CLASS="efeature">balance</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="efeature">balance</SPAN> + <SPAN CLASS="elocal">sum</SPAN></P>
					</CODE>

					<P>appearing in the body of procedure <SPAN CLASS="efeature">deposit</SPAN>
					of class <SPAN CLASS="eclass">ACCOUNT</SPAN>, the name of the attribute
					<SPAN CLASS="efeature">balance</SPAN>, in both occurrences, denotes the
					<SPAN CLASS=efeture>balance</SPAN> field of the current object, assumed to
					be an instance of <SPAN CLASS="eclass">ACCOUNT</SPAN>. In the same way, the
					procedure body that we used for the creation procedure
					<SPAN CLASS="efeature">make</SPAN> in the <SPAN CLASS="eclass">ACCOUNT1</SPAN>
					variant</P>

					<CODE>
						<P><SPAN CLASS="efeature">make</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">sum</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ecomment">-- Initialize
						account with</SPAN> <SPAN CLASS="elocal">sum</SPAN>.</P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">deposit</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">sum</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>contains a call to the procedure <SPAN CLASS="efeature">deposit</SPAN>.
					Contrary to earlier calls written in dot notation as
					<SPAN CLASS="elocal">target</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">feature</SPAN>
					<SPAN CLASS="esymbol">(</SPAN>…<SPAN CLASS="esymbol">)</SPAN>, the call to
					<SPAN CLASS="efeature">deposit</SPAN> has no explicit target; this means its target
					is the current object, an instance of <SPAN CLASS="eclass">ACCOUNT1</SPAN>. Such a call
					is said to be <SPAN CLASS="bold">unqualified</SPAN>; those using dot notations
					are <SPAN CLASS="bold">qualified</SPAN> calls.</P>

					<P>Although most uses of the current object are implicit, a class may need to
					name it explicitly. The predefined expression <SPAN CLASS="ekeyword">Current</SPAN>
					is available for that purpose. A typical use, in a routine
					<A NAME='ROUTINE_MERGE'></A><SPAN CLASS="efeature">merge</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">other</SPAN><SPAN CLASS="esymbol">:</SPAN>
					<SPAN CLASS="eclass">ACCOUNT</SPAN><SPAN CLASS="esymbol">)</SPAN> of class
					<SPAN CLASS="eclass">ACCOUNT</SPAN>, would be a test of the form</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">if</SPAN>
						<SPAN CLASS="elocal">other</SPAN> <SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="ekeyword">Current</SPAN> <SPAN CLASS="ekeyword">then</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">report_error</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="estring">"Error:
						trying to merge an account with itself!"</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P><SPAN CLASS="ekeyword">else</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;… Normal processing (merging two different accounts) …</P>

						<P><SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>With these notions it is not hard to define precisely the overall scenario
					of a system execution by defining which object and routine will, at each
					instant, be the current object and the current routine:</P>

					<UL>
						<LI>Starting a system execution, as we have seen, consists in creating an
						instance of the root class, the root object, and executing a designated
						creation procedure, the root procedure, with the root object as its
						target. The root object is the initial current object, and the root
						procedure is the initial current procedure.</LI>

						<LI>From then on only two events can change the current object and current
						procedure: a qualified routine call; and the termination of a routine.</LI>

						<LI>In a call of the form
						<SPAN CLASS="elocal">target</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">routine</SPAN>
						<SPAN CLASS="esymbol">(</SPAN>…<SPAN CLASS="esymbol">)</SPAN>,
						<SPAN CLASS="elocal">target</SPAN> denotes a certain object TC. (If not, that
						is to say, if the value of target is void, attempting to execute the call
						will trigger an exception, as studied below.) The generating class of TC
						must, as per the Feature Call rule, contain a routine of name
						<SPAN CLASS="efeature">routine</SPAN>. As the call starts, TC becomes the new
						current object and <SPAN CLASS="efeature">routine</SPAN> becomes the new
						current routine.</LI>

						<LI>When a routine execution terminates, the target object and routine of
						the most recent non-terminated call -- which, just before the
						terminated call, were the current object and the current routine -- assume
						again the role of current object and current routine.</LI>

						<LI>The only exception to the last rule is termination of the original
						root procedure call; in this case the entire execution terminates.</LI>
					</UL>

					<H2>Abstraction</H2>

					<P>The description of assignments stated that in
					<SPAN CLASS="elocal">x</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
					<SPAN CLASS="elocal">y</SPAN> the target <SPAN CLASS="elocal">x</SPAN> must be an
					entity. More precisely it must be a <SPAN CLASS="bold">writable</SPAN> entity.
					This notion excludes formal routine arguments: as noted, a routine
					<SPAN CLASS="efeature">r</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">arg</SPAN><SPAN CLASS="esymbol">:</SPAN>
					<SPAN CLASS="eclass">SOME_TYPE</SPAN><SPAN CLASS="esymbol">)</SPAN> may assign to
					<SPAN CLASS="elocal">arg</SPAN> (reattaching it to a different object), although it
					can change the attached objects through calls of the form
					<SPAN CLASS="elocal">arg</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">procedure</SPAN>
					<SPAN CLASS="esymbol">(</SPAN>…<SPAN CLASS="esymbol">)</SPAN>.</P>

					<P>Restricting assignment targets to entities precludes assignments of the
					form <SPAN CLASS="elocal">obj</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">some_attribute</SPAN>
					<SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="elocal">some_value</SPAN>, since the
					left-hand side
					<SPAN CLASS="elocal">obj</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">some_attribute</SPAN>
					is an expression (a feature call), not an entity: you may no more assign to
					<SPAN CLASS="elocal">obj</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">some_attribute</SPAN>
					than to, say, <SPAN CLASS="elocal">a</SPAN> <SPAN CLASS="esymbol">+</SPAN>
					<SPAN CLASS="elocal">b</SPAN> -- another expression that is also, formally, a feature call.</P>

					<P>To obtain the intended effect of such an assignment you may use a
					procedure call of the form
					<SPAN CLASS="elocal">obj</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">set_attribute </SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">some_value</SPAN><SPAN CLASS="esymbol">)</SPAN>,
					where the base class of <SPAN CLASS="elocal">obj</SPAN>'s type has defined the procedure</P>

					<CODE>
						<P><SPAN CLASS="efeature">set_attribute</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">v</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">VALUE_TYPE</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ecomment">-- Set value
						of attribute to <SPAN CLASS="elocal">v</SPAN>.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">attribute</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="elocal">v</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>This rule is essential to enforcing the method. Permitting direct
					assignments to an object's fields -- as in C++ and Java -- would violate
					all the tenets of information hiding by letting clients circumvent the
					interface carefully crafted by the author of a supplier class. It is the
					responsibility of each class author to define the exact privileges that
					the class gives to each of its clients, in particular field modification
					rights. Building a class is like building a machine: you design the
					internals, to give yourself the appropriate mechanisms; and you design the
					control panel, letting users (clients) access the desired subset of these
					mechanisms, safely and conveniently.</P>

					<P>The levels of privilege available to the class author include, for any
					field:</P>

					<UL>
						<LI>Hide the field completely from clients, by exporting the
						corresponding attribute to <SPAN CLASS="eclass">NONE</SPAN>.</LI>

						<LI>Export it, but in read-only mode, by not exporting any
						procedure that modifies it.</LI>

						<LI>Export it for free read and write by any client, by also
						exporting a procedure of the <SPAN CLASS="efeature">set_attribute</SPAN>
						kind.</LI>

						<LI>Export it in <SPAN CLASS="bold">restricted-write</SPAN> mode, by
						exporting a procedure such as <SPAN CLASS="efeature">deposit </SPAN>
						of class <SPAN CLASS="eclass">ACCOUNT</SPAN>, which adds a specified
						amount to the <SPAN CLASS="efeature">balance</SPAN> field, rather than
						directly setting the balance.</LI>
					</UL>

					<P>The last case is particularly interesting is that it allows the class
					designer to set the precise way in which clients will manipulate the class
					instances, respecting the properties of the class and its integrity. The
					exported routines may, through the
					<A HREF="tutorial-09.html#pgfId-514761">Design by Contract&#153 mechanism</A> reviewed
					later, place some further restrictions on the permitted modifications, for
					example by requiring the withdrawn amount to be positive.</P>

					<P>These rules follow directly from the more general goals (reusability,
					extendibility, reliability) and principles (Uniform Access, information
					hiding) underlying Eiffel software design. They reflect a view that each
					class must denote a well-understood abstraction, defined by a set of exported
					features chosen by the class designer -- the "control panel".</P>

					<P>The class documentation (see the
					<A HREF="tutorial-09.html#pgfId-514906">contract form</A>) makes this view clear to
					client authors; no violation of that interface is permitted. This approach
					also paves the way for future <SPAN CLASS="bold">generalization</SPAN>
					-- the final step of the cluster lifecycle, seen
					<A HREF="tutorial-04.html#10958">earlier</A> -- of the most promising
					components, and their inclusion into reusable libraries.</P>

					<P CLASS="seealso"><B>See also</B><BR />
						<A HREF="tutorial-08.html">Genericity And Arrays</A>
					</P>
				</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FOOTER">
			<TR>
				<TD>© 2003-2004 Eiffel Software. All rights reserved.</TD>
			</TR>
		</TABLE>
	</BODY>
</HTML>
