<document title="Obtaining a finer degree of control">
	<meta_data>
		<help>
			<toc>
				
				<envision_pseudo_name>60</envision_pseudo_name>
				<envision_title>Obtaining a Finer Degree of Control</envision_title>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph>Let us now take a more internal look at the workings of EiffelNet.    The two examples that follow have the same behavior as the preceding    one; since their text is less simple, they are only interesting as an    illustration of the lower-level facilities that you may want to use in    specific cases. If you are already familiar with socket programming,    they will also give you a more precise idea of how EiffelNet    encapsulates the basic socket mechanisms.</paragraph>
		<paragraph>As before, we have a client and a server class, still called    <code><class_name>OUR_CLIENT</class_name></code>
			<italic/>and
			<italic/><code><class_name>OUR_SERVER</class_name></code>, which are part of two different    systems and will run concurrently. The communication uses streams rather    than datagrams; the datagram form of communication will be examined in    section 
			<link>
				<url>70_datagram_sockets.xml</url>
				<label>using datagram sockets</label>
			</link>.
		</paragraph>
		<heading>
			<size>3</size>A client and a server on the same machine
		</heading>
		<note>The example classes discussed in this section appear in the        subdirectory 
			<italic>same_mach </italic>of the example directory
		</note>
		<paragraph>First, let us assume that the client and server run on the same    machine, so that we will use the UNIX_ versions of the classes (the next    example will be multi-machine). The communication protocol is also the    same as before: the client sends a list of strings, the server returns    it extended.</paragraph>
		<paragraph>Here we will create and manipulate sockets directly. For that reason,    both classes inherit from the EiffelNet class <code><class_name>SOCKET_RESOURCES</class_name></code> 
			<italic/>which introduces a number of constants and other useful    socket-related features.
		</paragraph>
		<paragraph>The two sockets must be able to refer to a common address. For a    communication within a single machine, as noted, this address is a path    name, again 
			<italic>/tmp/here</italic> for this example. The address will be an    argument of the creation procedure used to obtain a socket 
			<italic>soc1 </italic>on    either side:     
<code_block>
	<keyword>create</keyword> <feature_name>soc1</feature_name>.<feature_name>make_client</feature_name> <symbol>(</symbol><string>"/tmp/here"</string><symbol>)</symbol>
	<keyword>create</keyword> <feature_name>soc1</feature_name>.<feature_name>make_server</feature_name> <symbol>(</symbol><string>"/tmp/here"</string><symbol>)</symbol>
</code_block>The 
			<italic>make_</italic> procedures take care of all the hassles of    establishing a socket for a client or a server: creating an address    object, setting it to the given path name, binding the socket to the    address, and in the client case establishing the connection. For finer    control, these procedures are still available: you can create a bare    socket by using the basic creation procedure 
			<italic>make</italic> (rather than    the more sophisticated 
			<italic>make_client </italic>and 
			<italic>make_server</italic>), then    create a separate address object, associate the two, and call the 
			<italic>bind</italic>    and 
			<italic>connect</italic> procedures.
		</paragraph>
		<paragraph>Because communication is bidirectional, the distinction between    client and server is not between who sends and who receives, although    here the server only sends messages of acknowledgment. The client is the    party that initiates the communication; the server is the party which    stands ready to accept the communication. This difference justifies the    presence of two creation procedures 
			<italic>make_client</italic> and 
			<italic>make_server    </italic>as illustrated above. To initiate the communication, the client will    execute:     
			<code_block>	<feature_name>soc1</feature_name>.<feature_name>connect</feature_name></code_block>
			<paragraph>To make itself ready for the communication, the server will execute:     
				<code_block>	<feature_name>soc1</feature_name>.<feature_name>listen</feature_name> <symbol>(</symbol>n<symbol>)</symbol></code_block>
				<paragraph>where 
					<italic>n</italic> is a positive integer indicating the maximum number of    client connection attempts that may be queued. The value 5, used in the    example, is typical for 
					<italic>n</italic>.
				</paragraph>
				<paragraph>When you use the <code><class_name>_SERVER </class_name></code>classes of the predefined level, as in the    earlier example, 5 is indeed the default; you can change the value to a    positive integer 
					<italic>n</italic> through the call 
					<italic>set_queued </italic>( 
					<italic>n</italic>).
				</paragraph>
				<paragraph>Whenever the server needs to exchange objects with one of the    clients, it obtains access to the socket through the following sequence:    
<code_block>
	<feature_name>soc1</feature_name>.<feature_name>accept</feature_name>
	<feature_name>soc2</feature_name> <symbol>:</symbol><symbol>=</symbol> <feature_name>soc1</feature_name>.<feature_name>accepted</feature_name>
	... Storage <keyword>and</keyword> retrieval operations using soc2 <symbol>(</symbol><keyword>not</keyword> soc1<symbol>)</symbol> ...
	<feature_name>soc2</feature_name>.<feature_name>close</feature_name>

</code_block>
					<paragraph>Procedure 
						<italic>accept </italic>ensures synchronization with the client. When    communication is established, 
						<italic>accept</italic> creates a new socket which    will be accessible through attribute 
						<italic>accepted</italic>, whose value is    here assigned to the local entity 
						<italic>soc2</italic>. To receive objects, the    server will use operations of the form introduced earlier ( 
						<link>
							<url>20_overview.xml</url><anchor_name>structures</anchor_name>
							<label>An    overview of EiffelNet, sending and receiving object structures</label>
						</link>):    
						<code_block>	<feature_name>struct</feature_name> <symbol>?</symbol><symbol>=</symbol> <feature_name>soc2</feature_name>.<feature_name>retrieved</feature_name></code_block>
						<paragraph>applying to 
							<italic>soc2</italic>, not 
							<italic>soc1</italic>; this makes 
							<italic>soc1 </italic>available    to accept connections with other clients, a fundamental feature of    client-server mechanisms.
						</paragraph>
						<paragraph>The operation 
							<italic>soc2</italic>. 
							<italic>close</italic> which terminates the above    sequence closes the new socket. In principle this is not necessary,    since garbage collection should eventually reclaim the socket object,    and the 
							<italic>dispose</italic> procedure of the corresponding socket class    includes a call to 
							<italic>close</italic>. But the risk exists that you run out of    sockets before garbage collection reclaims all currently opened sockets,    so it is preferable to include the 
							<italic>close</italic> calls explicitly.
						</paragraph>
						<paragraph>At the end of the processing it is necessary to close the original    socket 
							<italic>soc1</italic> but also to unlink it. The feature 
							<italic>cleanup</italic>    from class 
							<italic>SOCKET</italic> takes care of both closing and unlinking.
						</paragraph>
						<paragraph>Here is the server class based on these principles. The actual    processing has been put aside in a procedure 
							<italic>process</italic>. 
<code_block>
	<keyword>class</keyword>
		<class_name>OUR_SERVER</class_name> 
	<keyword>inherit</keyword>
	
		<class_name>SOCKET_RESOURCES</class_name>
	
		<class_name>STORABLE</class_name>
	
	<feature_name>creation</feature_name> 
		<feature_name>make</feature_name>
	
	<keyword>feature</keyword>
	
		<feature_name>soc1</feature_name>, <feature_name>soc2</feature_name><symbol>:</symbol> <class_name>UNIX_STREAM_SOCKET</class_name>
	
		make <keyword>is</keyword> 
				<comment>-- Accept communication with client and exchange messages</comment>
			<keyword>local</keyword> 
				count<symbol>:</symbol> <class_name>INTEGER</class_name>
			<keyword>do</keyword> 
				<keyword>create</keyword> <feature_name>soc1</feature_name>.<feature_name>make_server</feature_name> <symbol>(</symbol>"/tmp/here"<symbol>)</symbol> 
				<keyword>from</keyword> 
					soc1listen <symbol>(</symbol>5<symbol>)</symbol> 
					count <symbol>:</symbol><symbol>=</symbol> 0
				<keyword>until</keyword> 
					count <symbol>=</symbol> 3
				<keyword>loop</keyword> 
					process -- See below
					count <symbol>:</symbol><symbol>=</symbol> count <symbol>+</symbol> 1
				<keyword>end</keyword> 
				<feature_name>soc1</feature_name>.<feature_name>cleanup</feature_name>
			<keyword>rescue</keyword> 
				<feature_name>soc1</feature_name>.<feature_name>cleanup</feature_name>
			<keyword>end</keyword>
	
	process <keyword>is</keyword> 
			<comment>-- Receive a message, extend it, and send it back</comment>
		<keyword>local</keyword> 
			our_new_list<symbol>:</symbol> <class_name>OUR_MESSAGE</class_name>
		<keyword>do</keyword>
			<feature_name>soc1</feature_name>.<feature_name>accept</feature_name>
			soc2 <symbol>?</symbol>=<symbol></symbol> <feature_name>soc1</feature_name>.<feature_name>accepted</feature_name>
			our_new_list <symbol>?</symbol>=<symbol></symbol> retrieved <symbol>(</symbol>soc2<symbol>)</symbol> 
			<keyword>from</keyword> 
				<feature_name>our_new_list</feature_name>.<feature_name>start</feature_name>
			<keyword>until</keyword> 
				<feature_name>our_new_list</feature_name>.<feature_name>after</feature_name>
			<keyword>loop</keyword> 
				<feature_name>io</feature_name>.<feature_name>putstring</feature_name> <symbol>(</symbol><feature_name>our_new_list</feature_name>.<feature_name>item</feature_name><symbol>)</symbol> 
				<feature_name>io</feature_name>.<feature_name>new_line</feature_name>
				<feature_name>our_new_list</feature_name>.<feature_name>forth</feature_name>
			<keyword>end</keyword> 
			<feature_name>our_new_list</feature_name>.<feature_name>extend</feature_name> <symbol>(</symbol>"<symbol>%</symbol><class_name>N</class_name> <class_name>I</class_name><symbol>'</symbol>m <feature_name>back</feature_name>.<feature_name></feature_name><symbol>%</symbol><class_name>N</class_name>"<symbol>)</symbol> 
			<feature_name>our_new_list</feature_name>.<feature_name>general_store</feature_name> <symbol>(</symbol>soc2<symbol>)</symbol> 
			<feature_name>soc2</feature_name>.<feature_name>close</feature_name>
		<keyword>end</keyword>
	
	<keyword>end</keyword>
</code_block>
							<paragraph>Note that at the end the server should not only closes the original    socket 
								<italic>soc1 </italic>but also unlinks it. It is recommended to have a    Rescue clause which, as here, ensures that the socket will be closed and    unlinked if the system terminates abnormally before its term.    
								<paragraph>Here now is the client class:    
<code_block>
	<keyword>class</keyword> 
		<class_name>OUR_CLIENT</class_name>
	
	<keyword>inherit</keyword>
	
		<class_name>SOCKET_RESOURCES</class_name>
	
	<keyword>creation </keyword>
		<feature_name>make</feature_name>
	
	<keyword>feature</keyword>
	
		<feature_name>soc1</feature_name><symbol>:</symbol> <class_name>UNIX_STREAM_SOCKET</class_name>
	
		<feature_name>make</feature_name> <keyword>is</keyword> 
				<comment>-- Establish communication with server, and exchange messages</comment>
			<keyword>do</keyword> 
				<keyword>create</keyword> <feature_name>soc1</feature_name>.<feature_name>make_client</feature_name> <symbol>(</symbol>"/tmp/here"<symbol>)</symbol> 
				<feature_name>soc1</feature_name>.<feature_name>connect</feature_name>
				process -- See below
				<feature_name>soc1</feature_name>.<feature_name>cleanup</feature_name>
			<keyword>rescue</keyword> 
				<feature_name>soc1</feature_name>.<feature_name>cleanup</feature_name>
			<keyword>end</keyword>
	
		<feature_name>process</feature_name> <keyword>is</keyword> 
				<comment>-- Build a message to server, receive answer, build</comment>
				<comment>-- modified message from that answer, and print it.</comment>
			<keyword>local</keyword> 
				our_list, our_new_list<symbol>:</symbol> <class_name>OUR_MESSAGE</class_name>
			<keyword>do</keyword> 
				<keyword>create</keyword> <feature_name>our_list</feature_name>.<feature_name>make</feature_name>
				<feature_name>our_list</feature_name>.<feature_name>extend</feature_name><symbol>(</symbol>"This"<symbol>)</symbol>; <feature_name>our_list</feature_name>.<feature_name>extend</feature_name> <symbol>(</symbol>" is"<symbol>)</symbol> 
				<feature_name>our_list</feature_name>.<feature_name>extend</feature_name> <symbol>(</symbol>" our"<symbol>)</symbol>; <feature_name>our_list</feature_name>.<feature_name>extend</feature_name> <symbol>(</symbol>" test"<symbol>)</symbol> 
				<feature_name>our_list</feature_name>.<feature_name>general_store</feature_name> <symbol>(</symbol>soc1<symbol>)</symbol> 
				our_new_list <symbol>?</symbol>=<symbol></symbol> <feature_name>soc1</feature_name>.<feature_name>retrieved</feature_name>
	 			<keyword>from</keyword> 
					<feature_name>our_new_list</feature_name>.<feature_name>start</feature_name>
				<keyword>until</keyword> 
					<feature_name>our_new_list</feature_name>.<feature_name>after</feature_name>
				<keyword>loop</keyword> 
					<feature_name>io</feature_name>.<feature_name>putstring</feature_name> <symbol>(</symbol><feature_name>our_new_list</feature_name>.<feature_name>item</feature_name><symbol>)</symbol> 
					<feature_name>our_new_list</feature_name>.<feature_name>forth</feature_name>
				<keyword>end</keyword> 
				<feature_name>io</feature_name>.<feature_name>new_line</feature_name>
			<keyword>end</keyword>
	
	<keyword>end</keyword>
</code_block>
									<heading>
										<size>3</size>Communication between two different machines
									</heading>
									<table><border>1</border>
										<row>
											<cell>The example classes discussed in this section appear in the        subdirectory 
												<italic>two_mach </italic>of the example directory
											</cell>
										</row>
									</table>
									<paragraph>Let us now assume that the client and the server will run on two    separate machines. Instead of UNIX_ sockets, we must now use    sockets of type <code><class_name>NETWORK_STREAM_SOCKET</class_name></code>.</paragraph>
									<paragraph>The available creation procedures are slightly different. The server    will be set up so as to listen to clients from any machine; it    designates a 
										<bold>port</bold>, identified by an integer, on which it will    listen. The socket creation on the server side is then    
										<code_block><keyword>create</keyword> <feature_name>soc1</feature_name>.<feature_name>make_server_port</feature_name> <symbol>(</symbol>2000<symbol>)</symbol></code_block>For the client, the creation will specify two elements of    information: the port number and the server. The server argument, a    string, identifies the machine used as a server; it may be the host name    of that machine, for example 
										<italic>"serverhost" </italic>as used in    the example; or it can be the machine's internet address, made of a    sequence of numbers separated by periods, such as 
										<italic>"127.0.0.1"</italic>.
									</paragraph>
									<paragraph>The rest of the classes is as before.    
<code_block>
	<keyword>class</keyword> 
		<class_name>OUR_SERVER</class_name>
	
	<keyword>inherit</keyword>
	
		<class_name>SOCKET_RESOURCES</class_name>
	
		<class_name>STORABLE</class_name>
	
	<keyword>creation</keyword> 
		<feature_name>make</feature_name>
	
	<keyword>feature</keyword>
	
		<feature_name>soc1</feature_name>, <feature_name>soc2</feature_name><symbol>:</symbol> <class_name>NETWORK_STREAM_SOCKET</class_name>
	
		<feature_name>make</feature_name> <keyword>is</keyword> 
				<comment>-- Accept communication with client and exchange messages.</comment>
			<keyword>do</keyword> 
				<keyword>create</keyword> <feature_name>soc1</feature_name>.<feature_name>make_server_by_port</feature_name> <symbol>(</symbol>2000<symbol>)</symbol> 
				... The rest <keyword>as</keyword> before...
			<keyword>end</keyword>      
	
		<feature_name>process</feature_name> <keyword>is</keyword> 
			... As before ...
		<keyword>end</keyword>
	
	<keyword>end</keyword> 
	
	<keyword>class</keyword> 
		<class_name>OUR_CLIENT</class_name>
	
	<keyword>inherit</keyword>
	
		<class_name>SOCKET_RESOURCES</class_name>
	
	<keyword>creation </keyword>
	    <feature_name>make</feature_name>
	
	<keyword>feature</keyword>
	
		<feature_name>soc1</feature_name><symbol>:</symbol> <class_name>NETWORK_STREAM_SOCKET</class_name>
	
		<feature_name>make</feature_name> <keyword>is</keyword> 
			<keyword>do</keyword> 
				<keyword>create</keyword> <feature_name>soc1</feature_name>.<feature_name>make_client_by_port</feature_name> <symbol>(</symbol>2000, "serverhost"<symbol>)</symbol> 
				... The rest <keyword>as</keyword> before ...
			<keyword>end</keyword>
	
		<feature_name>process</feature_name> <keyword>is</keyword> 
				... As before ...
			<keyword>end</keyword>
	
	<keyword>end</keyword>
</code_block>
									</paragraph>
								</paragraph>
							</paragraph>
						</paragraph>
					</paragraph>
				</paragraph>
			</paragraph>
		</paragraph>
	</paragraph></document>
