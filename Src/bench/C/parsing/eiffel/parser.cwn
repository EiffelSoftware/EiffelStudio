
# line 13 "parser.y"
#include "eiffel_c.h"
#include <stdio.h>

#define NORMAL_LEVEL	0
#define ASSERT_LEVEL	1
#define INVARIANT_LEVEL	2
#define SET_POS(x) yacc_position = x

#ifndef FALSE
#define FALSE 0
#endif
#ifndef TRUE
#define TRUE 1
#endif
#ifndef NULL
#define NULL 0
#endif

extern char token_str[];
/* extern int yacc_current_position; */

#define CR_EMPTY	0
#define CR_ROUTINE	1
#define CR_CONSTANT	2


# line 40 "parser.y"
typedef union
#ifdef __cplusplus
	YYSTYPE
#endif
 {
	char *node;
	int32  value;
	struct cr_struct {		/* Structure used for resolving conflicts on
							 * feature declaration body 
							 */
		char *cr_node;		/* either node ROUTINE_AS or CONSTANT_AS */
		int cr_type;		/* either CR_ROUTINE  or CR_CONSTANT */
	} cr_node;
} YYSTYPE;
# define TE_DOTDOT 257
# define TE_IMPLIES 258
# define TE_OR 259
# define TE_XOR 260
# define TE_AND 261
# define TE_NE 262
# define TE_EQ 263
# define TE_LT 264
# define TE_GT 265
# define TE_LE 266
# define TE_GE 267
# define TE_PLUS 268
# define TE_MINUS 269
# define TE_STAR 270
# define TE_SLASH 271
# define TE_MOD 272
# define TE_DIV 273
# define TE_POWER 274
# define TE_FREE 275
# define TE_NOT 276
# define TE_STRIP 277
# define TE_OLD 278
# define TE_DOT 279
# define TE_LPARAN 280
# define TE_ALIAS 281
# define TE_ALL 282
# define TE_INTEGER 283
# define TE_CHAR 284
# define TE_REAL 285
# define TE_STRING 286
# define TE_ID 287
# define TE_A_BIT 288
# define TE_BANG 289
# define TE_BIT 290
# define TE_SEMICOLON 291
# define TE_COLON 292
# define TE_COMMA 293
# define TE_CREATION 294
# define TE_LARRAY 295
# define TE_RARRAY 296
# define TE_RPARAN 297
# define TE_LCURLY 298
# define TE_RCURLY 299
# define TE_LSQURE 300
# define TE_RSQURE 301
# define TE_CONSTRAIN 302
# define TE_FALSE 303
# define TE_TRUE 304
# define TE_ACCEPT 305
# define TE_ADDRESS 306
# define TE_AS 307
# define TE_ASSIGN 308
# define TE_CHECK 309
# define TE_CLASS 310
# define TE_CURRENT 311
# define TE_DEBUG 312
# define TE_DEFERRED 313
# define TE_DO 314
# define TE_ELSE 315
# define TE_ELSEIF 316
# define TE_END 317
# define TE_ENSURE 318
# define TE_EXPANDED 319
# define TE_EXPORT 320
# define TE_EXTERNAL 321
# define TE_FEATURE 322
# define TE_FROM 323
# define TE_FROZEN 324
# define TE_IF 325
# define TE_INDEXING 326
# define TE_IN_END 327
# define TE_INFIX 328
# define TE_INHERIT 329
# define TE_INSPECT 330
# define TE_INVARIANT 331
# define TE_IS 332
# define TE_LIKE 333
# define TE_LOCAL 334
# define TE_LOOP 335
# define TE_OBSOLETE 336
# define TE_ONCE 337
# define TE_PREFIX 338
# define TE_REDEFINE 339
# define TE_RENAME 340
# define TE_REQUIRE 341
# define TE_RESCUE 342
# define TE_RESULT 343
# define TE_RETRY 344
# define TE_SELECT 345
# define TE_SEPARATE 346
# define TE_THEN 347
# define TE_UNDEFINE 348
# define TE_UNIQUE 349
# define TE_UNTIL 350
# define TE_VARIANT 351
# define TE_WHEN 352
# define EIF_ERROR2 353
# define EIF_ERROR3 354
# define EIF_ERROR4 355
# define EIF_ERROR5 356
# define EIF_ERROR6 357
# define EIF_ERROR7 358

#ifdef __STDC__
#include <stdlib.h>
#include <string.h>
#else
#include <malloc.h>
#include <memory.h>
#endif

/*#include <values.h>*/

#ifdef __cplusplus

#ifndef yyerror
	void yyerror(const char *);
#endif

#ifndef yylex
#ifdef __EXTERN_C__
	extern "C" { int yylex(void); }
#else
	int yylex(void);
#endif
#endif
	int yyparse(void);

#endif
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
extern int yychar;
extern int yyerrflag;
YYSTYPE yylval;
YYSTYPE yyval;
typedef int yytabelem;
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
#if YYMAXDEPTH > 0
int yy_yys[YYMAXDEPTH], *yys = yy_yys;
YYSTYPE yy_yyv[YYMAXDEPTH], *yyv = yy_yyv;
#else	/* user does initial allocation */
int *yys;
YYSTYPE *yyv;
#endif
static int yymaxdepth = YYMAXDEPTH;
# define YYERRCODE 256

# line 1373 "parser.y"

char deferred;					/* Boolean mark for deferred class */
char expanded;					/* Boolean mark for expanded class */
char separate;					/* Boolean mark for separate class */
char is_frozen;					/* Boolean mark for frozen feature names */

int id_level;					/* Boolean for controlling the semantic
								 * action of rule `A_feature' .
								 */
int inherit_context;			/* Flag for context sensitivity of token
								 * TE_END.
								 */
char generic_name[IDLENGTH];	/* Formal generic parameter name */
int yywrap(void)
{
	return 1;
}
yytabelem yyexca[] ={
-1, 1,
	0, -1,
	-2, 0,
-1, 3,
	310, 7,
	313, 7,
	319, 7,
	346, 7,
	-2, 5,
-1, 10,
	310, 6,
	313, 6,
	319, 6,
	346, 6,
	-2, 42,
-1, 51,
	294, 270,
	-2, 269,
-1, 52,
	287, 65,
	-2, 42,
-1, 57,
	322, 25,
	-2, 24,
-1, 68,
	287, 32,
	328, 32,
	338, 32,
	-2, 274,
-1, 82,
	287, 33,
	328, 33,
	338, 33,
	-2, 277,
-1, 86,
	320, 75,
	339, 75,
	345, 75,
	348, 75,
	-2, 70,
-1, 101,
	287, 77,
	328, 77,
	338, 77,
	-2, 76,
-1, 106,
	313, 166,
	314, 166,
	317, 166,
	321, 166,
	334, 166,
	337, 166,
	342, 166,
	350, 166,
	351, 166,
	-2, 383,
-1, 119,
	298, 83,
	-2, 42,
-1, 129,
	313, 167,
	314, 167,
	317, 167,
	321, 167,
	334, 167,
	337, 167,
	342, 167,
	350, 167,
	351, 167,
	-2, 383,
-1, 140,
	317, 95,
	339, 95,
	345, 95,
	-2, 96,
-1, 185,
	317, 31,
	322, 31,
	331, 31,
	-2, 43,
-1, 189,
	317, 99,
	345, 99,
	-2, 100,
-1, 237,
	317, 103,
	-2, 104,
-1, 335,
	283, 373,
	285, 373,
	-2, 22,
-1, 373,
	287, 112,
	-2, 137,
-1, 382,
	315, 139,
	316, 139,
	317, 139,
	318, 139,
	331, 139,
	342, 139,
	350, 139,
	351, 139,
	352, 139,
	-2, 143,
-1, 392,
	312, 252,
	323, 239,
	325, 200,
	330, 217,
	-2, 290,
-1, 424,
	315, 138,
	316, 138,
	317, 138,
	318, 138,
	331, 138,
	342, 138,
	350, 138,
	351, 138,
	352, 138,
	-2, 142,
-1, 480,
	316, 205,
	-2, 204,
	};
# define YYNPROD 384
# define YYLAST 902
yytabelem yyact[]={

   168,   507,    29,   220,   122,   462,   380,   484,   386,   111,
   105,   171,   382,   183,   179,   177,   178,   130,   182,   464,
   337,   489,    38,   501,   140,    20,   510,   379,   158,   299,
    28,   237,   165,   164,   377,   349,   189,    40,    41,   184,
   166,   169,   167,    14,   163,   223,    48,   172,    35,   173,
    38,    14,    37,    35,    13,    38,    28,    37,    99,   176,
   352,   335,    13,    21,    25,    47,   475,    33,    34,    71,
   296,    21,    33,    34,   126,   180,    40,    41,   423,    71,
    26,   101,    76,     5,    90,    14,    52,   408,   432,     6,
    25,   312,    35,    39,    38,    14,    37,     3,    21,   451,
   359,   360,   431,   124,   114,    48,   285,   181,   362,   422,
    79,    33,    34,   123,   115,   433,     7,   127,   340,   153,
   119,    39,   313,   368,   361,   508,    39,   535,   505,   151,
   125,   521,   494,   476,   149,   150,   174,   458,    36,   114,
   388,   415,   421,   117,   170,   286,    91,   156,   482,   115,
   354,   434,   196,    14,   314,    31,   294,   123,   221,   218,
    15,   232,   435,    27,    36,    39,   195,   283,    88,    74,
   147,   278,   152,   154,   277,   102,   159,   155,   146,   138,
    62,    31,    96,   428,   187,   137,   427,   430,    61,    27,
   429,    43,   222,   224,   225,   226,   227,   228,   276,   478,
    83,   456,   159,   477,    16,   210,   209,   211,   208,   217,
   216,   215,   213,   214,   212,   201,   202,   203,   204,   205,
   206,   207,   184,   218,   343,   218,   218,   218,   218,   218,
   248,   249,   250,   251,   252,   253,   254,   255,   257,   259,
   260,   261,   262,   263,   264,   265,   266,   267,   268,   218,
   218,   218,   218,   218,   218,   218,   218,    60,   218,   275,
   218,   218,   218,   218,   218,   218,   218,   218,   218,   218,
   310,   175,   331,   316,   309,    85,   218,   279,   279,   279,
   269,   301,   526,   304,    68,   291,   221,   292,   497,    98,
    32,   317,   218,   218,   165,   164,   218,   132,   520,   295,
   306,   184,   166,   169,   167,   302,   163,   194,    44,   172,
    35,   173,    38,    14,    37,   355,    32,   330,   300,   218,
    53,   176,   221,    19,   142,   393,    17,   218,   437,    33,
    34,   318,    40,    41,   219,   336,    14,   180,    21,   295,
   123,   326,    35,   279,    56,    14,   387,    28,    35,   279,
    45,    14,    40,    41,   385,    45,   110,    46,   243,   221,
   366,   446,   200,   327,   364,   123,   323,   272,   460,   181,
   297,    14,   231,   256,   233,   347,   374,   383,   303,   232,
   207,   184,   500,    39,   373,   499,   134,   136,   498,   390,
    87,   300,    78,   157,   394,    70,   395,   241,   144,   392,
   192,   342,   396,    81,   247,    24,   413,   411,   412,   410,
   424,   409,    67,   426,   230,   193,   339,   273,   123,   201,
   202,   203,   204,   205,   206,   207,   184,   274,   293,   270,
    11,   280,   281,   229,    55,   420,    95,   218,   414,   218,
   218,   218,   218,   218,   218,   289,   447,    22,    66,    58,
    50,   454,   436,   389,   467,    36,   438,   439,   440,   441,
   442,   443,   466,   457,   455,    84,   468,   325,   470,   472,
    93,   419,    31,   479,   324,   319,   485,   145,   320,    80,
    27,   104,    92,   450,    82,   486,   490,   491,   531,   186,
   203,   204,   205,   206,   207,   184,   315,    72,   107,   465,
   485,   512,   509,   516,   218,   511,   469,   444,   523,   486,
   108,   514,   518,   418,   148,   525,   496,   483,   503,   487,
   218,   473,   471,   453,   417,   218,   328,   522,   218,   528,
   519,   495,   530,   532,   506,   502,   493,   524,   533,   534,
   197,   198,   480,   487,   513,   515,   517,   165,   164,   527,
   199,   145,   246,   461,   184,   166,   169,   167,   416,   163,
    63,    54,   172,    35,   173,    38,    14,    37,    49,   165,
   164,   375,   121,   103,   176,   129,   184,   166,   169,   167,
   128,   163,    33,    34,   172,    35,   173,    38,    14,    37,
   180,   106,   240,   245,   258,   391,   176,   378,   365,   353,
   381,   363,   370,   369,    33,    34,   372,    32,   346,   298,
   350,   345,   180,   109,   332,   287,   238,   190,   244,   191,
   141,   143,   181,   120,    69,    59,   284,   305,   235,   116,
    97,   185,   131,    94,    65,    23,    39,    18,    10,     8,
     9,   307,     4,   334,   181,   338,   282,   113,   112,   135,
   133,   481,    75,   311,   160,   162,   406,   399,    39,   210,
   209,   211,   208,   217,   216,   215,   213,   214,   212,   201,
   202,   203,   204,   205,   206,   207,   184,   210,   209,   211,
   208,   217,   216,   215,   213,   214,   212,   201,   202,   203,
   204,   205,   206,   207,   184,   210,   209,   211,   208,   217,
   216,   215,   213,   214,   212,   201,   202,   203,   204,   205,
   206,   207,   184,   210,   209,   211,   208,   217,   216,   215,
   213,   214,   212,   201,   202,   203,   204,   205,   206,   207,
   184,   344,    64,   161,   448,   459,   449,   425,   398,    57,
   401,   400,   376,   407,   445,   405,   488,   474,   529,   404,
   403,   463,   333,   504,   492,   402,    73,    42,    86,    89,
   367,   397,   348,   351,   357,   384,   452,   210,   209,   211,
   208,   217,   216,   215,   213,   214,   212,   201,   202,   203,
   204,   205,   206,   207,   184,   210,   209,   211,   208,   217,
   216,   215,   213,   214,   212,   201,   202,   203,   204,   205,
   206,   207,   184,   371,   239,   358,   271,   209,   211,   208,
   217,   216,   215,   213,   214,   212,   201,   202,   203,   204,
   205,   206,   207,   184,   211,   208,   217,   216,   215,   213,
   214,   212,   201,   202,   203,   204,   205,   206,   207,   184,
   356,   341,   329,   322,   236,   188,   139,   242,   118,   100,
    51,   321,   288,   234,    77,    30,    12,     2,   290,   208,
   217,   216,   215,   213,   214,   212,   201,   202,   203,   204,
   205,   206,   207,   184,   217,   216,   215,   213,   214,   212,
   201,   202,   203,   204,   205,   206,   207,   184,     1,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   308 };
yytabelem yypact[]={

  -229,-10000000,  -230,-10000000,-10000000,-10000000,-10000000,-10000000,    49,  -150,
    35,-10000000,-10000000,    31,-10000000,    51,    49,-10000000,  -192,-10000000,
  -109,-10000000,-10000000,    15,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,    72,-10000000,-10000000,-10000000,
-10000000,-10000000,  -290,-10000000,  -192,-10000000,-10000000,  -243,  -264,    57,
-10000000,-10000000,    35,-10000000,  -113,-10000000,-10000000,-10000000,   -10,    51,
-10000000,-10000000,    57,  -133,  -249,  -212,   -10,-10000000,   -98,    51,
    35,  -132,-10000000,-10000000,    51,  -171,-10000000,  -212,-10000000,-10000000,
-10000000,-10000000,-10000000,  -117,    35,-10000000,  -259,-10000000,  -126,-10000000,
  -132,-10000000,-10000000,-10000000,   -98,  -224,-10000000,    49,-10000000,-10000000,
  -200,-10000000,-10000000,  -216,-10000000,-10000000,-10000000,-10000000,-10000000,     4,
-10000000,-10000000,-10000000,-10000000,  -264,  -264,  -114,-10000000,  -324,    35,
  -224,  -123,-10000000,  -132,    51,    51,    84,  -134,-10000000,-10000000,
   301,-10000000,  -224,-10000000,-10000000,-10000000,-10000000,-10000000,    49,  -303,
-10000000,   -98,-10000000,    14,-10000000,  -141,-10000000,  -216,-10000000,  -132,
  -132,-10000000,-10000000,    67,-10000000,-10000000,   301,    35,   527,    42,
-10000000,-10000000,-10000000,   301,   301,   301,   301,   301,   301,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
    93,   100,    95,-10000000,-10000000,-10000000,-10000000,-10000000,  -314,-10000000,
  -224,   -98,    35,    76,  -224,  -224,-10000000,-10000000,-10000000,    35,
-10000000,   301,   301,   301,   301,   301,   301,   301,    26,   279,
   301,   301,   301,   301,   301,   301,   301,   301,   301,   301,
-10000000,   -17,   509,    79,-10000000,-10000000,-10000000,-10000000,-10000000,    87,
   301,    49,    49,    49,-10000000,  -218,  -172,-10000000,  -224,     4,
    35,-10000000,-10000000,-10000000,  -224,-10000000,-10000000,-10000000,   220,   220,
   106,   106,   106,   106,   106,   612,   301,   564,   301,   548,
   598,   151,   151,   151,   151,   151,   151,-10000000,   527,-10000000,
  -236,    91,    49,   -15,    12,   527,-10000000,-10000000,    99,    79,
-10000000,-10000000,     7,-10000000,  -224,-10000000,-10000000,  -224,     4,-10000000,
     4,   612,   564,   -23,-10000000,   527,  -189,    49,   -24,    -2,
-10000000,-10000000,   301,    49,-10000000,    86,  -218,-10000000,     4,-10000000,
  -236,-10000000,   301,-10000000,-10000000,-10000000,-10000000,    49,   527,    99,
-10000000,    35,    25,   -25,-10000000,-10000000,   455,-10000000,-10000000,  -271,
  -216,-10000000,-10000000,-10000000,-10000000,  -231,-10000000,   -73,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,    49,  -306,    -2,  -274,  -165,
    23,  -213,-10000000,-10000000,-10000000,  -216,  -195,-10000000,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,    35,  -308,  -320,-10000000,
-10000000,    73,    60,-10000000,-10000000,-10000000,  -177,-10000000,-10000000,-10000000,
-10000000,-10000000,    34,-10000000,-10000000,    60,-10000000,-10000000,-10000000,-10000000,
-10000000,-10000000,  -202,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,  -216,    95,
-10000000,-10000000,-10000000,-10000000,  -122,  -118,  -223,  -242,  -208,  -161,
  -147,-10000000,    93,   301,    34,    39,-10000000,   301,   301,   301,
   301,   301,   301,-10000000,    81,-10000000,   437,  -244,   527,   527,
   527,   527,   419,   527,-10000000,-10000000,   -96,  -180,    91,    89,
-10000000,-10000000,-10000000,  -333,-10000000,-10000000,-10000000,    60,-10000000,-10000000,
    49,-10000000,-10000000,  -333,-10000000,  -265,  -184,   -94,-10000000,    79,
-10000000,  -167,-10000000,    64,  -330,-10000000,-10000000,-10000000,    60,-10000000,
-10000000,  -185,-10000000,    -5,-10000000,   131,   128,   125,  -327,   301,
-10000000,-10000000,  -187,  -191,-10000000,-10000000,  -321,    64,    84,    58,
    64,   301,     6,   527,  -186,-10000000,  -191,-10000000,   301,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,   -53,
   301,-10000000,-10000000,-10000000,   401,-10000000,-10000000,   527,-10000000,-10000000,
-10000000,-10000000,-10000000,  -190,-10000000,-10000000 };
yytabelem yypgo[]={

     0,   888,   857,   856,   430,    45,   405,    80,   144,    11,
     2,   855,   136,     8,   271,    65,   392,   854,   403,   853,
   851,   850,   395,   849,   848,   400,   847,   846,   845,   844,
   843,   842,   841,   840,   805,   803,   765,   764,   763,   762,
   761,   760,   393,     4,   759,   390,   758,   757,   434,   756,
   755,   754,     1,   753,   751,   750,   749,   747,   746,   745,
   744,   743,   742,   741,   740,   739,   412,   738,   737,   736,
   735,    28,   156,   733,     7,   732,   398,   731,   657,   656,
    10,    18,    16,    15,    14,   655,   198,     3,   654,   415,
   174,   171,   652,     0,    13,   651,   119,     9,   650,   649,
   167,   356,   648,   647,   646,    17,   645,   643,   642,   640,
   639,   638,   204,   637,   635,   634,   633,   632,   631,   630,
   629,   628,   627,   626,   625,   624,   623,   621,   620,   619,
   618,   613,   617,   616,   615,   614,    20,   611,    29,   610,
   609,   608,   606,   603,     6,   602,   601,   600,    12,   599,
   598,   597,   595,   591,   580,   575,   573,   572,   568,   561,
   560,   558,   553,   542,   536,   534,   533,   531,   527,   524,
   523,     5,   522,   521,   517,   516,   515,   513,   507,   499,
   488,   482,   471,   464,   463,   454,   453,   449,   448,   436,
   435,   433,   429,   428,   427,   417,   414 };
yytabelem yyr1[]={

     0,   109,     1,    97,     2,   110,     2,     2,   111,   111,
   113,     4,     3,     3,   114,   114,     6,     6,   108,   108,
   108,   108,    15,    15,    75,   115,    75,    17,    17,   116,
   117,    16,    18,    18,    89,   119,    89,   120,   120,   118,
   118,   112,   112,   121,   122,    19,   104,   104,   100,   123,
   123,   101,   101,   101,   102,   103,    98,    99,    20,   107,
   107,   106,   106,   106,    21,   124,    21,    21,   125,   125,
    22,    22,    22,    46,    46,    23,    23,   126,    23,   127,
   127,    76,    24,   128,    24,    24,   129,   129,    25,    26,
   130,    26,   131,   131,    27,    27,   132,    27,    28,    28,
   133,    28,    29,    29,   134,    29,    30,    30,   135,    30,
   136,   136,   137,   139,    77,   138,   138,   140,   140,    31,
    31,   141,    32,    33,    33,    33,    34,   142,    35,    36,
    36,   143,    37,   145,    37,    38,   146,    38,   144,   144,
   148,   148,   147,   147,    40,    40,    40,    40,    40,    40,
    40,    40,    40,    40,    39,   149,    39,   150,    39,    41,
   151,    41,   152,    41,   153,    80,   154,   154,   155,   155,
    42,    42,    42,    43,    43,    43,    43,    43,    43,    43,
    43,    43,    43,    44,    44,    45,   156,    45,   157,   157,
    47,   158,    47,   159,   159,   159,   160,    48,    49,    49,
   161,   162,   163,    50,    51,   164,    51,   165,   165,   166,
    52,    95,   167,    95,    53,   168,    53,   169,   170,   172,
    55,   171,   171,   173,   175,   176,    54,   174,   174,    74,
    74,    74,    74,    74,    74,    74,    74,    74,    74,   177,
   178,   179,   180,    56,    57,    57,    92,   181,    92,    58,
    58,    58,   182,   183,    59,    60,    60,   184,    60,   185,
   185,    61,    62,   186,    62,    63,    63,    64,    64,    65,
   187,    65,   188,   188,    66,   189,    66,    66,    67,    68,
    68,    69,    69,    70,    70,    78,    78,    78,    78,    78,
   190,    79,    71,    71,    71,    71,    71,    71,    71,    71,
    71,    71,    71,    71,    71,    71,    71,    71,    71,    71,
    71,    71,    71,    71,    71,    71,    71,    71,    71,    71,
    71,   191,    71,    72,    72,    72,    72,    72,    93,    85,
    85,    85,    85,    85,    85,    85,    83,    82,    84,    94,
    86,    86,    90,    90,    81,    91,    87,    87,   192,    87,
   193,   193,   194,   194,   195,   195,     5,     7,     7,     7,
     7,     7,     7,    88,    88,    88,    88,    88,    88,     8,
     8,     9,    10,    96,    96,    96,    11,    12,    14,    14,
    13,   196,    73,   105 };
yytabelem yyr2[]={

     0,     1,    25,     3,     1,     1,     7,     3,     3,     7,
     1,     7,     1,     5,     3,     7,     3,     3,     1,     3,
     3,     3,     1,     5,     1,     1,     5,     3,     5,     1,
     1,    11,     1,     3,     5,     1,     9,     3,     7,     0,
     5,     2,     0,     1,     1,    11,     3,     7,     5,     1,
     3,     3,     3,     3,     5,     5,     3,     3,     7,     1,
     5,     3,     3,     3,     1,     1,     7,     5,     5,     7,
     5,     7,    17,     1,     3,     1,     3,     1,     7,     3,
     7,     7,     1,     1,     7,     5,     5,     7,     5,     3,
     1,     5,     3,     7,     1,     3,     1,     7,     1,     3,
     1,     7,     1,     3,     1,     7,     1,     5,     1,     9,
     0,     5,     1,     1,    13,     3,     7,     0,     2,     1,
     5,     1,    17,     3,     3,     3,     7,     1,     5,     1,
     5,     1,     7,     1,     7,     1,     1,     7,     9,     2,
     4,     0,     9,     2,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     1,     1,     7,     1,     9,     1,
     1,     7,     1,     9,     1,     5,     0,     2,     7,     9,
     3,     7,     5,     3,     5,     5,     7,     5,     7,     5,
     5,     5,     5,     3,     5,     5,     1,     9,     3,     7,
     1,     1,     9,     0,     3,     7,     1,     7,     1,     5,
     1,     1,     1,    21,     1,     1,     5,     3,     5,     1,
    11,     1,     1,     7,     1,     1,     7,     1,     1,     1,
    17,     0,     5,     1,     1,     1,    15,     3,     7,     3,
     3,     3,     7,     7,     7,     7,     7,     7,     7,     1,
     1,     1,     1,    27,     1,     5,     1,     1,     7,     1,
     9,     5,     1,     1,    13,     1,     5,     1,     9,     3,
     7,     3,     1,     1,     7,     7,     7,     7,     7,     1,
     1,     5,     3,     5,     3,     1,     9,     5,    11,     1,
     3,     3,     3,     1,     7,     3,     3,     3,     3,     3,
     1,     9,     3,     3,     3,     7,     7,     7,     7,     7,
     7,     7,     7,     7,     9,     7,     9,     7,     7,     7,
     7,     7,     7,     7,     7,     7,     5,     5,     5,     5,
     5,     1,    11,     3,     5,     9,     5,     5,     3,     3,
     3,     3,     3,     3,     3,     3,     7,     7,     7,    11,
     3,     3,     7,     7,     5,     5,     1,     5,     1,     9,
     3,     7,     3,     7,     0,     2,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     5,     1,     3,     3,     5,     3,     3,     3,
     3,     1,     9,     1 };
yytabelem yychk[]={

-10000000,    -1,    -2,   326,  -108,   313,   319,   346,  -110,  -109,
  -111,    -4,    -3,    -5,   287,   310,  -112,   291,  -113,   292,
   -97,   287,    -4,  -114,    -6,    -5,    -7,    -8,    -9,   -10,
   -11,   -12,   -14,   303,   304,   284,   -96,   288,   286,   357,
   268,   269,   -47,   300,   293,   283,   285,   -15,   336,  -158,
    -6,   -21,   329,   -14,  -159,   -48,   287,   -65,  -187,  -124,
  -112,   301,   293,  -160,   -75,  -115,  -188,   -66,   294,  -125,
   -22,   -97,   -48,   -49,   302,   -92,   331,   -17,   -16,   322,
   -66,   -18,   -89,   298,   -22,  -112,   -46,   -45,   300,   -44,
   -97,   317,  -181,   -16,  -116,  -189,   299,  -119,  -112,   317,
   -23,   340,   301,  -156,   -45,   -80,  -153,   -18,   -89,  -131,
  -101,   -97,  -102,  -103,   328,   338,  -120,    -5,   -24,   320,
  -126,  -157,   -43,   -97,   319,   346,   290,   333,  -154,  -155,
  -105,  -117,   293,   -98,   -14,   -99,   -14,   299,   293,   -27,
   348,  -128,  -112,  -127,   -76,  -101,   301,   293,   -45,   -97,
   -97,   -10,    -5,   -96,    -5,   311,  -105,   -42,   -71,    -5,
   -88,   -73,   -85,   280,   269,   268,   276,   278,   -93,   277,
    -8,    -9,   283,   285,   -12,   -14,   295,   -83,   -82,   -84,
   311,   343,   -81,   -94,   275,  -118,  -101,    -5,   -28,   339,
  -132,  -129,   -25,   -89,   293,   307,   -43,   -45,   -45,   -42,
  -112,   268,   269,   270,   271,   272,   273,   274,   261,   259,
   258,   260,   267,   265,   266,   264,   263,   262,   -93,   292,
   -87,   280,   -71,    -5,   -71,   -71,   -71,   -71,   -71,  -191,
  -196,   279,   279,   279,   -19,  -121,   -29,   345,  -133,  -131,
   -25,  -112,   -26,   282,  -130,   -76,  -101,  -112,   -71,   -71,
   -71,   -71,   -71,   -71,   -71,   -71,   347,   -71,   315,   -71,
   -71,   -71,   -71,   -71,   -71,   -71,   -71,   -71,   -71,   297,
  -192,   297,   280,  -195,  -194,   -71,   -86,   -90,   -91,    -5,
   -86,   -86,  -104,  -100,  -123,   324,   317,  -134,  -131,  -112,
  -131,   -71,   -71,  -193,   -72,   -71,   306,   279,  -140,  -138,
    -5,   296,   293,   279,   -87,  -122,   293,  -101,  -131,   297,
   293,  -101,   280,   311,   343,   -86,   297,   293,   -71,   -91,
   -90,   -20,   -30,   280,  -100,   -72,   -71,    -5,  -112,   -31,
   292,   297,  -135,   297,  -107,   332,   -43,  -136,  -106,    -7,
   349,   -32,   -15,   297,   -77,  -137,  -141,  -138,   -39,   341,
  -139,   -38,   334,  -149,   315,   292,   -33,   -37,   -34,   313,
   314,   337,   321,  -146,   -80,  -150,   -43,   -41,   318,  -143,
  -145,   -35,  -142,  -136,   -80,  -112,   -62,   342,  -151,   347,
  -144,  -147,  -148,  -144,   -36,   281,   -13,   286,   317,  -186,
   -80,  -152,  -105,   291,   -13,  -144,   -80,   -40,   -67,   -78,
   -63,   -64,   -50,   -55,   -56,   -59,   -79,   -61,   289,   -81,
   -82,   -84,   -83,   -94,    -5,   343,  -161,  -169,  -177,  -182,
  -190,   344,   311,   280,  -148,   -68,   -43,   308,   305,   308,
   305,   325,   330,   323,   312,   309,   -71,   289,   -71,   -71,
   -71,   -71,   -71,   -71,  -178,   -60,   280,   -80,   297,   -69,
    -5,   343,   347,  -170,  -144,  -183,   297,  -184,   317,   -70,
   279,  -162,  -171,   -54,   352,  -179,  -144,  -185,   -13,    -5,
  -144,  -172,  -171,  -173,   -57,   331,   317,   297,   293,   -87,
  -163,   -95,   315,  -174,   -74,   -10,    -9,    -5,   -58,   351,
   -80,   -13,   -51,  -164,   317,  -167,  -175,   293,   257,   257,
   257,   350,    -5,   -71,   -53,   315,  -165,   -52,   316,  -144,
   347,   -74,   -10,    -5,    -9,    -5,   -10,    -5,    -9,   -71,
   292,   317,  -168,   -52,   -71,  -176,   335,   -71,  -144,   347,
  -144,  -180,  -166,  -144,  -144,   317 };
yytabelem yydef[]={

     4,    -2,    18,    -2,     1,    19,    20,    21,    12,     0,
    -2,     8,    10,     0,   356,     0,    12,    41,   373,    13,
   190,     3,     9,    11,    14,    16,    17,   357,   358,   359,
   360,   361,   362,   369,   370,   371,     0,   377,   378,   379,
   374,   375,    22,   191,   373,   372,   376,    64,     0,   193,
    15,    -2,    -2,    23,     0,   194,   196,    -2,     0,     0,
    67,   192,     0,   198,   246,     0,   271,   272,    -2,    66,
    42,    73,   195,   197,     0,     0,   247,    26,    27,    29,
   273,   275,    -2,    35,    42,    68,    -2,    74,   186,   199,
   183,     2,   164,    28,    32,     0,    34,     0,    69,    71,
    82,    -2,   185,     0,   184,   248,    -2,    30,    33,   276,
    92,    51,    52,    53,     0,     0,     0,    37,    94,    -2,
     0,     0,   188,   173,     0,     0,   373,     0,   165,    -2,
     0,    39,     0,    54,    56,    55,    57,    36,     0,    98,
    -2,     0,    85,    78,    79,     0,   187,     0,   174,   175,
   177,   179,   180,     0,   181,   182,     0,    42,   170,   346,
   292,   293,   294,     0,     0,     0,     0,     0,     0,   321,
   363,   364,   365,   366,   367,   368,   381,   329,   330,   331,
   332,   333,   334,   335,   328,    -2,    93,    38,   102,    -2,
     0,    84,    42,    90,     0,     0,   189,   176,   178,    42,
   168,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   172,
   344,   348,     0,   346,   316,   317,   318,   319,   320,     0,
   354,     0,     0,     0,    40,    49,     0,    -2,     0,    97,
    42,    86,    88,    89,     0,    80,    81,   169,   296,   297,
   298,   299,   300,   301,   302,   303,     0,   305,     0,   307,
   308,   309,   310,   311,   312,   313,   314,   315,   171,   347,
     0,   295,   117,     0,   355,   352,   336,   340,   341,   346,
   337,   338,    44,    46,     0,    50,    72,     0,   101,    87,
    91,   304,   306,     0,   350,   323,     0,     0,     0,   118,
   115,   382,     0,     0,   345,   106,    49,    48,   105,   349,
     0,   324,     0,   326,   327,   339,   322,     0,   353,   342,
   343,    42,   119,   108,    47,   351,     0,   116,    45,    59,
     0,   107,   110,   325,    58,    -2,   120,   112,    60,    61,
    62,    63,   121,   109,   111,     0,   154,   113,   135,   155,
     0,     0,   136,   164,   157,     0,   159,   123,   124,   125,
   131,   133,   127,   110,   156,   164,    42,   262,   160,   141,
   141,   129,     0,    -2,   158,   114,     0,   263,   164,   162,
   132,   383,    -2,   134,   126,     0,   128,   380,   122,   141,
   161,   164,    -2,   140,   130,   264,   163,   141,   144,   145,
   146,   147,   148,   149,   150,   151,   152,   153,   279,   285,
   286,   287,   288,   289,   346,     0,     0,     0,     0,     0,
     0,   261,     0,     0,    -2,     0,   280,     0,     0,     0,
     0,     0,     0,   240,   255,   164,     0,     0,   265,   267,
   266,   268,     0,   218,   141,   253,   257,     0,     0,   283,
   281,   282,   201,   221,   241,   141,   256,     0,   291,   278,
     0,   141,   219,   221,   223,   244,     0,     0,   259,   346,
   202,   211,   222,   373,   249,   164,   254,   258,     0,   284,
    -2,     0,   212,   224,   227,   229,   230,   231,     0,     0,
   245,   260,   214,     0,   220,   141,     0,   373,   373,     0,
   373,     0,   346,   251,     0,   215,   206,   207,     0,   213,
   225,   228,   232,   233,   236,   238,   234,   235,   237,     0,
     0,   203,   141,   208,     0,   141,   242,   250,   216,   209,
   226,   141,   141,     0,   210,   243 };
typedef struct
#ifdef __cplusplus
	yytoktype
#endif
{ char *t_name; int t_val; } yytoktype;
#ifndef YYDEBUG
#	define YYDEBUG	0	/* don't allow debugging */
#endif

#if YYDEBUG

yytoktype yytoks[] =
{
	"TE_DOTDOT",	257,
	"TE_IMPLIES",	258,
	"TE_OR",	259,
	"TE_XOR",	260,
	"TE_AND",	261,
	"TE_NE",	262,
	"TE_EQ",	263,
	"TE_LT",	264,
	"TE_GT",	265,
	"TE_LE",	266,
	"TE_GE",	267,
	"TE_PLUS",	268,
	"TE_MINUS",	269,
	"TE_STAR",	270,
	"TE_SLASH",	271,
	"TE_MOD",	272,
	"TE_DIV",	273,
	"TE_POWER",	274,
	"TE_FREE",	275,
	"TE_NOT",	276,
	"TE_STRIP",	277,
	"TE_OLD",	278,
	"TE_DOT",	279,
	"TE_LPARAN",	280,
	"TE_ALIAS",	281,
	"TE_ALL",	282,
	"TE_INTEGER",	283,
	"TE_CHAR",	284,
	"TE_REAL",	285,
	"TE_STRING",	286,
	"TE_ID",	287,
	"TE_A_BIT",	288,
	"TE_BANG",	289,
	"TE_BIT",	290,
	"TE_SEMICOLON",	291,
	"TE_COLON",	292,
	"TE_COMMA",	293,
	"TE_CREATION",	294,
	"TE_LARRAY",	295,
	"TE_RARRAY",	296,
	"TE_RPARAN",	297,
	"TE_LCURLY",	298,
	"TE_RCURLY",	299,
	"TE_LSQURE",	300,
	"TE_RSQURE",	301,
	"TE_CONSTRAIN",	302,
	"TE_FALSE",	303,
	"TE_TRUE",	304,
	"TE_ACCEPT",	305,
	"TE_ADDRESS",	306,
	"TE_AS",	307,
	"TE_ASSIGN",	308,
	"TE_CHECK",	309,
	"TE_CLASS",	310,
	"TE_CURRENT",	311,
	"TE_DEBUG",	312,
	"TE_DEFERRED",	313,
	"TE_DO",	314,
	"TE_ELSE",	315,
	"TE_ELSEIF",	316,
	"TE_END",	317,
	"TE_ENSURE",	318,
	"TE_EXPANDED",	319,
	"TE_EXPORT",	320,
	"TE_EXTERNAL",	321,
	"TE_FEATURE",	322,
	"TE_FROM",	323,
	"TE_FROZEN",	324,
	"TE_IF",	325,
	"TE_INDEXING",	326,
	"TE_IN_END",	327,
	"TE_INFIX",	328,
	"TE_INHERIT",	329,
	"TE_INSPECT",	330,
	"TE_INVARIANT",	331,
	"TE_IS",	332,
	"TE_LIKE",	333,
	"TE_LOCAL",	334,
	"TE_LOOP",	335,
	"TE_OBSOLETE",	336,
	"TE_ONCE",	337,
	"TE_PREFIX",	338,
	"TE_REDEFINE",	339,
	"TE_RENAME",	340,
	"TE_REQUIRE",	341,
	"TE_RESCUE",	342,
	"TE_RESULT",	343,
	"TE_RETRY",	344,
	"TE_SELECT",	345,
	"TE_SEPARATE",	346,
	"TE_THEN",	347,
	"TE_UNDEFINE",	348,
	"TE_UNIQUE",	349,
	"TE_UNTIL",	350,
	"TE_VARIANT",	351,
	"TE_WHEN",	352,
	"EIF_ERROR2",	353,
	"EIF_ERROR3",	354,
	"EIF_ERROR4",	355,
	"EIF_ERROR5",	356,
	"EIF_ERROR6",	357,
	"EIF_ERROR7",	358,
	"-unknown-",	-1	/* ends search */
};

char * yyreds[] =
{
	"-no such reduction-",
	"Class_declaration : Indexing Header_mark",
	"Class_declaration : Indexing Header_mark TE_CLASS Pushing_id Formal_generics Obsolete Inheritance Creators Features Class_invariant TE_END",
	"Pushing_id : TE_ID",
	"Indexing : /* empty */",
	"Indexing : TE_INDEXING",
	"Indexing : TE_INDEXING Index_list",
	"Indexing : TE_INDEXING",
	"Index_list : Index_clause",
	"Index_list : Index_list ASemi Index_clause",
	"Index_clause : Index",
	"Index_clause : Index Index_terms",
	"Index : /* empty */",
	"Index : Identifier TE_COLON",
	"Index_terms : Index_value",
	"Index_terms : Index_terms TE_COMMA Index_value",
	"Index_value : Identifier",
	"Index_value : Manifest_constant",
	"Header_mark : /* empty */",
	"Header_mark : TE_DEFERRED",
	"Header_mark : TE_EXPANDED",
	"Header_mark : TE_SEPARATE",
	"Obsolete : /* empty */",
	"Obsolete : TE_OBSOLETE Manifest_string",
	"Features : /* empty */",
	"Features : /* empty */",
	"Features : Feature_clause_list",
	"Feature_clause_list : Feature_clause",
	"Feature_clause_list : Feature_clause_list Feature_clause",
	"Feature_clause : TE_FEATURE",
	"Feature_clause : TE_FEATURE Clients",
	"Feature_clause : TE_FEATURE Clients Feature_declaration_list",
	"Clients : /* empty */",
	"Clients : Client_list",
	"Client_list : TE_LCURLY TE_RCURLY",
	"Client_list : TE_LCURLY",
	"Client_list : TE_LCURLY Class_list TE_RCURLY",
	"Class_list : Identifier",
	"Class_list : Class_list TE_COMMA Identifier",
	"Feature_declaration_list : /* empty */",
	"Feature_declaration_list : Feature_declaration_list Feature_declaration",
	"ASemi : TE_SEMICOLON",
	"ASemi : /* empty */",
	"Feature_declaration : /* empty */",
	"Feature_declaration : New_feature_list",
	"Feature_declaration : New_feature_list Declaration_body ASemi",
	"New_feature_list : New_feature",
	"New_feature_list : New_feature_list TE_COMMA New_feature",
	"New_feature : Feature_name_mark Feature_name",
	"Feature_name_mark : /* empty */",
	"Feature_name_mark : TE_FROZEN",
	"Feature_name : Pushing_id",
	"Feature_name : Infix",
	"Feature_name : Prefix",
	"Infix : TE_INFIX Infix_operator",
	"Prefix : TE_PREFIX Prefix_operator",
	"Infix_operator : Manifest_string",
	"Prefix_operator : Manifest_string",
	"Declaration_body : Formal_arguments Type_mark Constant_or_routine",
	"Constant_or_routine : /* empty */",
	"Constant_or_routine : TE_IS Feature_value",
	"Feature_value : Manifest_constant",
	"Feature_value : TE_UNIQUE",
	"Feature_value : Routine",
	"Inheritance : /* empty */",
	"Inheritance : TE_INHERIT",
	"Inheritance : TE_INHERIT Parent_list",
	"Inheritance : TE_INHERIT ASemi",
	"Parent_list : Parent ASemi",
	"Parent_list : Parent_list Parent ASemi",
	"Parent : Pushing_id Actual_generics",
	"Parent : Pushing_id Actual_generics TE_END",
	"Parent : Pushing_id Actual_generics Rename New_exports Undefine Redefine Select TE_END",
	"Actual_generics : /* empty */",
	"Actual_generics : Existing_generics",
	"Rename : /* empty */",
	"Rename : TE_RENAME",
	"Rename : TE_RENAME",
	"Rename : TE_RENAME Rename_list",
	"Rename_list : Rename_pair",
	"Rename_list : Rename_list TE_COMMA Rename_pair",
	"Rename_pair : Feature_name TE_AS Feature_name",
	"New_exports : /* empty */",
	"New_exports : TE_EXPORT",
	"New_exports : TE_EXPORT New_export_list",
	"New_exports : TE_EXPORT ASemi",
	"New_export_list : New_export_item ASemi",
	"New_export_list : New_export_list New_export_item ASemi",
	"New_export_item : Client_list Feature_set",
	"Feature_set : TE_ALL",
	"Feature_set : /* empty */",
	"Feature_set : Feature_list",
	"Feature_list : Feature_name",
	"Feature_list : Feature_list TE_COMMA Feature_name",
	"Undefine : /* empty */",
	"Undefine : TE_UNDEFINE",
	"Undefine : TE_UNDEFINE",
	"Undefine : TE_UNDEFINE Feature_list",
	"Redefine : /* empty */",
	"Redefine : TE_REDEFINE",
	"Redefine : TE_REDEFINE",
	"Redefine : TE_REDEFINE Feature_list",
	"Select : /* empty */",
	"Select : TE_SELECT",
	"Select : TE_SELECT",
	"Select : TE_SELECT Feature_list",
	"Formal_arguments : /* empty */",
	"Formal_arguments : TE_LPARAN TE_RPARAN",
	"Formal_arguments : TE_LPARAN",
	"Formal_arguments : TE_LPARAN Entity_declaration_list TE_RPARAN",
	"Entity_declaration_list : /* empty */",
	"Entity_declaration_list : Entity_declaration_list Entity_declaration_group",
	"Entity_declaration_group : /* empty */",
	"Entity_declaration_group : Identifier_list",
	"Entity_declaration_group : Identifier_list TE_COLON Type ASemi",
	"Identifier_list : Identifier",
	"Identifier_list : Identifier_list TE_COMMA Identifier",
	"Strip_identifier_list : /* empty */",
	"Strip_identifier_list : Identifier_list",
	"Type_mark : /* empty */",
	"Type_mark : TE_COLON Type",
	"Routine : Obsolete",
	"Routine : Obsolete Precondition Local_declarations Routine_body Postcondition Rescue TE_END",
	"Routine_body : Internal",
	"Routine_body : External",
	"Routine_body : TE_DEFERRED",
	"External : TE_EXTERNAL External_language External_name",
	"External_language : /* empty */",
	"External_language : Non_empty_string",
	"External_name : /* empty */",
	"External_name : TE_ALIAS Non_empty_string",
	"Internal : TE_DO",
	"Internal : TE_DO Compound",
	"Internal : TE_ONCE",
	"Internal : TE_ONCE Compound",
	"Local_declarations : /* empty */",
	"Local_declarations : TE_LOCAL",
	"Local_declarations : TE_LOCAL Entity_declaration_list",
	"Compound : Instructionl Set_position Instruction1 Opt_Semi",
	"Compound : Opt_Semi",
	"Opt_Semi : Opt_Semi TE_SEMICOLON",
	"Opt_Semi : /* empty */",
	"Instructionl : Instructionl Set_position Instruction1 Opt_Semi",
	"Instructionl : Opt_Semi",
	"Instruction1 : Creation",
	"Instruction1 : Call",
	"Instruction1 : Assignment",
	"Instruction1 : Reverse_assignment",
	"Instruction1 : Conditional",
	"Instruction1 : Multi_branch",
	"Instruction1 : Loop",
	"Instruction1 : Debug",
	"Instruction1 : Check",
	"Instruction1 : Retry",
	"Precondition : /* empty */",
	"Precondition : TE_REQUIRE",
	"Precondition : TE_REQUIRE Assertion",
	"Precondition : TE_REQUIRE TE_ELSE",
	"Precondition : TE_REQUIRE TE_ELSE Assertion",
	"Postcondition : /* empty */",
	"Postcondition : TE_ENSURE",
	"Postcondition : TE_ENSURE Assertion",
	"Postcondition : TE_ENSURE TE_THEN",
	"Postcondition : TE_ENSURE TE_THEN Assertion",
	"Assertion : /* empty */",
	"Assertion : Assertion_list",
	"Assertion_list : /* empty */",
	"Assertion_list : Assertion_list_non_empty",
	"Assertion_list_non_empty : Set_position Assertion_clause ASemi",
	"Assertion_list_non_empty : Assertion_list_non_empty Set_position Assertion_clause ASemi",
	"Assertion_clause : Expression",
	"Assertion_clause : Identifier TE_COLON Expression",
	"Assertion_clause : Identifier TE_COLON",
	"Type : Pushing_id",
	"Type : Pushing_id Existing_generics",
	"Type : TE_EXPANDED Pushing_id",
	"Type : TE_EXPANDED Pushing_id Existing_generics",
	"Type : TE_SEPARATE Pushing_id",
	"Type : TE_SEPARATE Pushing_id Existing_generics",
	"Type : TE_BIT Integer_constant",
	"Type : TE_BIT Identifier",
	"Type : TE_LIKE Identifier",
	"Type : TE_LIKE TE_CURRENT",
	"Class_type : Pushing_id",
	"Class_type : Pushing_id Existing_generics",
	"Existing_generics : TE_LSQURE TE_RSQURE",
	"Existing_generics : TE_LSQURE",
	"Existing_generics : TE_LSQURE Type_list TE_RSQURE",
	"Type_list : Type",
	"Type_list : Type_list TE_COMMA Type",
	"Formal_generics : /* empty */",
	"Formal_generics : TE_LSQURE",
	"Formal_generics : TE_LSQURE Formal_generic_list TE_RSQURE",
	"Formal_generic_list : /* empty */",
	"Formal_generic_list : Formal_generic",
	"Formal_generic_list : Formal_generic_list TE_COMMA Formal_generic",
	"Formal_generic : TE_ID",
	"Formal_generic : TE_ID Constraint",
	"Constraint : /* empty */",
	"Constraint : TE_CONSTRAIN Class_type",
	"Conditional : /* empty */",
	"Conditional : TE_IF Expression TE_THEN",
	"Conditional : TE_IF Expression TE_THEN Compound",
	"Conditional : TE_IF Expression TE_THEN Compound Elsif Else_part TE_END",
	"Elsif : /* empty */",
	"Elsif : /* empty */",
	"Elsif : Elsif_list",
	"Elsif_list : Elsif_part",
	"Elsif_list : Elsif_list Elsif_part",
	"Elsif_part : TE_ELSEIF Expression TE_THEN",
	"Elsif_part : TE_ELSEIF Expression TE_THEN Compound",
	"Inspect_default : /* empty */",
	"Inspect_default : TE_ELSE",
	"Inspect_default : TE_ELSE Compound",
	"Else_part : /* empty */",
	"Else_part : TE_ELSE",
	"Else_part : TE_ELSE Compound",
	"Multi_branch : /* empty */",
	"Multi_branch : TE_INSPECT Expression",
	"Multi_branch : TE_INSPECT Expression When_part_list",
	"Multi_branch : TE_INSPECT Expression When_part_list Inspect_default TE_END",
	"When_part_list : /* empty */",
	"When_part_list : When_part When_part_list",
	"When_part : TE_WHEN",
	"When_part : TE_WHEN Choices",
	"When_part : TE_WHEN Choices TE_THEN",
	"When_part : TE_WHEN Choices TE_THEN Compound",
	"Choices : Choice",
	"Choices : Choices TE_COMMA Choice",
	"Choice : Integer_constant",
	"Choice : Character_constant",
	"Choice : Identifier",
	"Choice : Integer_constant TE_DOTDOT Integer_constant",
	"Choice : Integer_constant TE_DOTDOT Identifier",
	"Choice : Identifier TE_DOTDOT Integer_constant",
	"Choice : Identifier TE_DOTDOT Identifier",
	"Choice : Character_constant TE_DOTDOT Character_constant",
	"Choice : Identifier TE_DOTDOT Character_constant",
	"Choice : Character_constant TE_DOTDOT Identifier",
	"Loop : /* empty */",
	"Loop : TE_FROM",
	"Loop : TE_FROM Compound",
	"Loop : TE_FROM Compound Invariant Variant TE_UNTIL Expression TE_LOOP",
	"Loop : TE_FROM Compound Invariant Variant TE_UNTIL Expression TE_LOOP Compound TE_END",
	"Invariant : /* empty */",
	"Invariant : TE_INVARIANT Assertion",
	"Class_invariant : /* empty */",
	"Class_invariant : TE_INVARIANT",
	"Class_invariant : TE_INVARIANT Assertion",
	"Variant : /* empty */",
	"Variant : TE_VARIANT Identifier TE_COLON Expression",
	"Variant : TE_VARIANT Expression",
	"Debug : /* empty */",
	"Debug : TE_DEBUG Debug_keys",
	"Debug : TE_DEBUG Debug_keys Compound TE_END",
	"Debug_keys : /* empty */",
	"Debug_keys : TE_LPARAN TE_RPARAN",
	"Debug_keys : TE_LPARAN",
	"Debug_keys : TE_LPARAN Debug_key_list TE_RPARAN",
	"Debug_key_list : Non_empty_string",
	"Debug_key_list : Debug_key_list TE_COMMA Non_empty_string",
	"Retry : TE_RETRY",
	"Rescue : /* empty */",
	"Rescue : TE_RESCUE",
	"Rescue : TE_RESCUE Compound",
	"Assignment : Identifier TE_ASSIGN Expression",
	"Assignment : TE_RESULT TE_ASSIGN Expression",
	"Reverse_assignment : Identifier TE_ACCEPT Expression",
	"Reverse_assignment : TE_RESULT TE_ACCEPT Expression",
	"Creators : /* empty */",
	"Creators : /* empty */",
	"Creators : Creation_clause_list",
	"Creation_clause_list : Creation_clause",
	"Creation_clause_list : Creation_clause_list Creation_clause",
	"Creation_clause : TE_CREATION",
	"Creation_clause : TE_CREATION Clients",
	"Creation_clause : TE_CREATION Clients Feature_list",
	"Creation_clause : TE_CREATION Client_list",
	"Creation : TE_BANG Creation_type TE_BANG Creation_target Creation_call",
	"Creation_type : /* empty */",
	"Creation_type : Type",
	"Creation_target : Identifier",
	"Creation_target : TE_RESULT",
	"Creation_call : /* empty */",
	"Creation_call : TE_DOT Identifier Parameters",
	"Call : A_feature",
	"Call : Call_on_result",
	"Call : Call_on_feature",
	"Call : Call_on_current",
	"Call : Call_on_expression",
	"Check : /* empty */",
	"Check : TE_CHECK Assertion TE_END",
	"Expression : Expression_constant",
	"Expression : Manifest_array",
	"Expression : Feature_call",
	"Expression : TE_LPARAN Expression TE_RPARAN",
	"Expression : Expression TE_PLUS Expression",
	"Expression : Expression TE_MINUS Expression",
	"Expression : Expression TE_STAR Expression",
	"Expression : Expression TE_SLASH Expression",
	"Expression : Expression TE_MOD Expression",
	"Expression : Expression TE_DIV Expression",
	"Expression : Expression TE_POWER Expression",
	"Expression : Expression TE_AND Expression",
	"Expression : Expression TE_AND TE_THEN Expression",
	"Expression : Expression TE_OR Expression",
	"Expression : Expression TE_OR TE_ELSE Expression",
	"Expression : Expression TE_IMPLIES Expression",
	"Expression : Expression TE_XOR Expression",
	"Expression : Expression TE_GE Expression",
	"Expression : Expression TE_GT Expression",
	"Expression : Expression TE_LE Expression",
	"Expression : Expression TE_LT Expression",
	"Expression : Expression TE_EQ Expression",
	"Expression : Expression TE_NE Expression",
	"Expression : Expression Free_operator Expression",
	"Expression : TE_MINUS Expression",
	"Expression : TE_PLUS Expression",
	"Expression : TE_NOT Expression",
	"Expression : TE_OLD Expression",
	"Expression : Free_operator Expression",
	"Expression : TE_STRIP",
	"Expression : TE_STRIP TE_LPARAN Strip_identifier_list TE_RPARAN",
	"Actual_parameter : Expression",
	"Actual_parameter : TE_ADDRESS Feature_name",
	"Actual_parameter : TE_ADDRESS TE_LPARAN Expression TE_RPARAN",
	"Actual_parameter : TE_ADDRESS TE_CURRENT",
	"Actual_parameter : TE_ADDRESS TE_RESULT",
	"Free_operator : TE_FREE",
	"Feature_call : Call_on_current",
	"Feature_call : Call_on_result",
	"Feature_call : Call_on_feature",
	"Feature_call : TE_CURRENT",
	"Feature_call : TE_RESULT",
	"Feature_call : A_feature",
	"Feature_call : Call_on_expression",
	"Call_on_current : TE_CURRENT TE_DOT Remote_call",
	"Call_on_result : TE_RESULT TE_DOT Remote_call",
	"Call_on_feature : A_feature TE_DOT Remote_call",
	"Call_on_expression : TE_LPARAN Expression TE_RPARAN TE_DOT Remote_call",
	"Remote_call : Call_on_feature_access",
	"Remote_call : Feature_access",
	"Call_on_feature_access : Feature_access TE_DOT Feature_access",
	"Call_on_feature_access : Feature_access TE_DOT Call_on_feature_access",
	"A_feature : Identifier Parameters",
	"Feature_access : Identifier Parameters",
	"Parameters : /* empty */",
	"Parameters : TE_LPARAN TE_RPARAN",
	"Parameters : TE_LPARAN",
	"Parameters : TE_LPARAN Parameter_list TE_RPARAN",
	"Parameter_list : Actual_parameter",
	"Parameter_list : Parameter_list TE_COMMA Actual_parameter",
	"Expression_list : Expression",
	"Expression_list : Expression_list TE_COMMA Expression",
	"Manifest_expression_list : /* empty */",
	"Manifest_expression_list : Expression_list",
	"Identifier : TE_ID",
	"Manifest_constant : Boolean_constant",
	"Manifest_constant : Character_constant",
	"Manifest_constant : Integer_constant",
	"Manifest_constant : Real_constant",
	"Manifest_constant : Bit_constant",
	"Manifest_constant : Manifest_string",
	"Expression_constant : Boolean_constant",
	"Expression_constant : Character_constant",
	"Expression_constant : TE_INTEGER",
	"Expression_constant : TE_REAL",
	"Expression_constant : Bit_constant",
	"Expression_constant : Manifest_string",
	"Boolean_constant : TE_FALSE",
	"Boolean_constant : TE_TRUE",
	"Character_constant : TE_CHAR",
	"Integer_constant : Sign TE_INTEGER",
	"Sign : /* empty */",
	"Sign : TE_PLUS",
	"Sign : TE_MINUS",
	"Real_constant : Sign TE_REAL",
	"Bit_constant : TE_A_BIT",
	"Manifest_string : TE_STRING",
	"Manifest_string : EIF_ERROR6",
	"Non_empty_string : TE_STRING",
	"Manifest_array : TE_LARRAY",
	"Manifest_array : TE_LARRAY Manifest_expression_list TE_RARRAY",
	"Set_position : /* empty */",
};
#endif /* YYDEBUG */
/*
 * Copyright (c) 1993 by Sun Microsystems, Inc.
 */

/*#pragma ident	"@(#)yaccpar	6.12	93/06/07 SMI"*/

/*
** Skeleton parser driver for yacc output
*/

/*
** yacc user known macros and defines
*/
#define YYERROR		goto yyerrlab
#define YYACCEPT	return(0)
#define YYABORT		return(1)
#define YYBACKUP( newtoken, newvalue )\
{\
	if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
	{\
		yyerror( "syntax error - cannot backup" );\
		goto yyerrlab;\
	}\
	yychar = newtoken;\
	yystate = *yyps;\
	yylval = newvalue;\
	goto yynewstate;\
}
#define YYRECOVERING()	(!!yyerrflag)
#define YYNEW(type)	malloc(sizeof(type) * yynewmax)
#define YYCOPY(to, from, type) \
	(type *) memcpy(to, (char *) from, yynewmax * sizeof(type))
#define YYENLARGE( from, type) \
	(type *) realloc((char *) from, yynewmax * sizeof(type))
#ifndef YYDEBUG
#	define YYDEBUG	1	/* make debugging available */
#endif

/*
** user known globals
*/
int yydebug;			/* set to 1 to get debugging */

/*
** driver internal defines
*/
#define YYFLAG		(-10000000)

/*
** global variables used by the parser
*/
YYSTYPE *yypv;			/* top of value stack */
int *yyps;			/* top of state stack */

int yystate;			/* current state */
int yytmp;			/* extra var (lasts between blocks) */

int yynerrs;			/* number of errors */
int yyerrflag;			/* error recovery flag */
int yychar;			/* current input token number */



#ifdef YYNMBCHARS
#define YYLEX()		yycvtok(yylex())
/*
** yycvtok - return a token if i is a wchar_t value that exceeds 255.
**	If i<255, i itself is the token.  If i>255 but the neither 
**	of the 30th or 31st bit is on, i is already a token.
*/
#if defined(__STDC__) || defined(__cplusplus)
int yycvtok(int i)
#else
int yycvtok(i) int i;
#endif
{
	int first = 0;
	int last = YYNMBCHARS - 1;
	int mid;
	wchar_t j;

	if(i&0x60000000){/*Must convert to a token. */
		if( yymbchars[last].character < i ){
			return i;/*Giving up*/
		}
		while ((last>=first)&&(first>=0)) {/*Binary search loop*/
			mid = (first+last)/2;
			j = yymbchars[mid].character;
			if( j==i ){/*Found*/ 
				return yymbchars[mid].tvalue;
			}else if( j<i ){
				first = mid + 1;
			}else{
				last = mid -1;
			}
		}
		/*No entry in the table.*/
		return i;/* Giving up.*/
	}else{/* i is already a token. */
		return i;
	}
}
#else/*!YYNMBCHARS*/
#define YYLEX()		yylex()
#endif/*!YYNMBCHARS*/

/*
** yyparse - return 0 if worked, 1 if syntax error not recovered from
*/
#if defined(__STDC__) || defined(__cplusplus)
int yyparse(void)
#else
int yyparse()
#endif
{
	register YYSTYPE *yypvt;	/* top of value stack for $vars */

#if defined(__cplusplus) || defined(lint)
/*
	hacks to please C++ and lint - goto's inside switch should never be
	executed; yypvt is set to 0 to avoid "used before set" warning.
*/
	static int __yaccpar_lint_hack__ = 0;
	switch (__yaccpar_lint_hack__)
	{
		case 1: goto yyerrlab;
		case 2: goto yynewstate;
	}
	yypvt = 0;
#endif

	/*
	** Initialize externals - yyparse may be called more than once
	*/
	yypv = &yyv[-1];
	yyps = &yys[-1];
	yystate = 0;
	yytmp = 0;
	yynerrs = 0;
	yyerrflag = 0;
	yychar = -1;

#if YYMAXDEPTH <= 0
	if (yymaxdepth <= 0)
	{
		if ((yymaxdepth = YYEXPAND(0)) <= 0)
		{
			yyerror("yacc initialization error");
			YYABORT;
		}
	}
#endif

	{
		register YYSTYPE *yy_pv;	/* top of value stack */
		register int *yy_ps;		/* top of state stack */
		register int yy_state;		/* current state */
		register int  yy_n;		/* internal state number info */
	goto yystack;	/* moved from 6 lines above to here to please C++ */

		/*
		** get globals into registers.
		** branch to here only if YYBACKUP was called.
		*/
	yynewstate:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;
		goto yy_newstate;

		/*
		** get globals into registers.
		** either we just started, or we just finished a reduction
		*/
	yystack:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;

		/*
		** top of for (;;) loop while no reductions done
		*/
	yy_stack:
		/*
		** put a state and value onto the stacks
		*/
#if YYDEBUG
		/*
		** if debugging, look up token value in list of value vs.
		** name pairs.  0 and negative (-1) are special values.
		** Note: linear search is used since time is not a real
		** consideration while debugging.
		*/
		if ( yydebug )
		{
			register int yy_i;

			printf( "State %d, token ", yy_state );
			if ( yychar == 0 )
				printf( "end-of-file\n" );
			else if ( yychar < 0 )
				printf( "-none-\n" );
			else
			{
				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( yytoks[yy_i].t_val == yychar )
						break;
				}
				printf( "%s\n", yytoks[yy_i].t_name );
			}
		}
#endif /* YYDEBUG */
		if ( ++yy_ps >= &yys[ yymaxdepth ] )	/* room on stack? */
		{
			/*
			** reallocate and recover.  Note that pointers
			** have to be reset, or bad things will happen
			*/
			int yyps_index = (yy_ps - yys);
			int yypv_index = (yy_pv - yyv);
			int yypvt_index = (yypvt - yyv);
			int yynewmax;
#ifdef YYEXPAND
			yynewmax = YYEXPAND(yymaxdepth);
#else
			yynewmax = 2 * yymaxdepth;	/* double table size */
			if (yymaxdepth == YYMAXDEPTH)	/* first time growth */
			{
				char *newyys = (char *)YYNEW(int);
				char *newyyv = (char *)YYNEW(YYSTYPE);
				if (newyys != 0 && newyyv != 0)
				{
					yys = YYCOPY(newyys, yys, int);
					yyv = YYCOPY(newyyv, yyv, YYSTYPE);
				}
				else
					yynewmax = 0;	/* failed */
			}
			else				/* not first time */
			{
				yys = YYENLARGE(yys, int);
				yyv = YYENLARGE(yyv, YYSTYPE);
				if (yys == 0 || yyv == 0)
					yynewmax = 0;	/* failed */
			}
#endif
			if (yynewmax <= yymaxdepth)	/* tables not expanded */
			{
				yyerror( "yacc stack overflow" );
				YYABORT;
			}
			yymaxdepth = yynewmax;

			yy_ps = yys + yyps_index;
			yy_pv = yyv + yypv_index;
			yypvt = yyv + yypvt_index;
		}
		*yy_ps = yy_state;
		*++yy_pv = yyval;

		/*
		** we have a new state - find out what to do
		*/
	yy_newstate:
		if ( ( yy_n = yypact[ yy_state ] ) <= YYFLAG )
			goto yydefault;		/* simple state */
#if YYDEBUG
		/*
		** if debugging, need to mark whether new token grabbed
		*/
		yytmp = yychar < 0;
#endif
		if ( ( yychar < 0 ) && ( ( yychar = YYLEX() ) < 0 ) )
			yychar = 0;		/* reached EOF */
#if YYDEBUG
		if ( yydebug && yytmp )
		{
			register int yy_i;

			printf( "Received token " );
			if ( yychar == 0 )
				printf( "end-of-file\n" );
			else if ( yychar < 0 )
				printf( "-none-\n" );
			else
			{
				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( yytoks[yy_i].t_val == yychar )
						break;
				}
				printf( "%s\n", yytoks[yy_i].t_name );
			}
		}
#endif /* YYDEBUG */
		if ( ( ( yy_n += yychar ) < 0 ) || ( yy_n >= YYLAST ) )
			goto yydefault;
		if ( yychk[ yy_n = yyact[ yy_n ] ] == yychar )	/*valid shift*/
		{
			yychar = -1;
			yyval = yylval;
			yy_state = yy_n;
			if ( yyerrflag > 0 )
				yyerrflag--;
			goto yy_stack;
		}

	yydefault:
		if ( ( yy_n = yydef[ yy_state ] ) == -2 )
		{
#if YYDEBUG
			yytmp = yychar < 0;
#endif
			if ( ( yychar < 0 ) && ( ( yychar = YYLEX() ) < 0 ) )
				yychar = 0;		/* reached EOF */
#if YYDEBUG
			if ( yydebug && yytmp )
			{
				register int yy_i;

				printf( "Received token " );
				if ( yychar == 0 )
					printf( "end-of-file\n" );
				else if ( yychar < 0 )
					printf( "-none-\n" );
				else
				{
					for ( yy_i = 0;
						yytoks[yy_i].t_val >= 0;
						yy_i++ )
					{
						if ( yytoks[yy_i].t_val
							== yychar )
						{
							break;
						}
					}
					printf( "%s\n", yytoks[yy_i].t_name );
				}
			}
#endif /* YYDEBUG */
			/*
			** look through exception table
			*/
			{
				register int *yyxi = yyexca;

				while ( ( *yyxi != -1 ) ||
					( yyxi[1] != yy_state ) )
				{
					yyxi += 2;
				}
				while ( ( *(yyxi += 2) >= 0 ) &&
					( *yyxi != yychar ) )
					;
				if ( ( yy_n = yyxi[1] ) < 0 )
					YYACCEPT;
			}
		}

		/*
		** check for syntax error
		*/
		if ( yy_n == 0 )	/* have an error */
		{
			/* no worry about speed here! */
			switch ( yyerrflag )
			{
			case 0:		/* new error */
				yyerror( "syntax error" );
				goto skip_init;
			yyerrlab:
				/*
				** get globals into registers.
				** we have a user generated syntax type error
				*/
				yy_pv = yypv;
				yy_ps = yyps;
				yy_state = yystate;
			skip_init:
				yynerrs++;
				/* FALLTHRU */
			case 1:
			case 2:		/* incompletely recovered error */
					/* try again... */
				yyerrflag = 3;
				/*
				** find state where "error" is a legal
				** shift action
				*/
				while ( yy_ps >= yys )
				{
					yy_n = yypact[ *yy_ps ] + YYERRCODE;
					if ( yy_n >= 0 && yy_n < YYLAST &&
						yychk[yyact[yy_n]] == YYERRCODE)					{
						/*
						** simulate shift of "error"
						*/
						yy_state = yyact[ yy_n ];
						goto yy_stack;
					}
					/*
					** current state has no shift on
					** "error", pop stack
					*/
#if YYDEBUG
#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
					if ( yydebug )
						printf( _POP_, *yy_ps,
							yy_ps[-1] );
#	undef _POP_
#endif
					yy_ps--;
					yy_pv--;
				}
				/*
				** there is no state on stack with "error" as
				** a valid shift.  give up.
				*/
				YYABORT;
			case 3:		/* no shift yet; eat a token */
#if YYDEBUG
				/*
				** if debugging, look up token in list of
				** pairs.  0 and negative shouldn't occur,
				** but since timing doesn't matter when
				** debugging, it doesn't hurt to leave the
				** tests here.
				*/
				if ( yydebug )
				{
					register int yy_i;

					printf( "Error recovery discards " );
					if ( yychar == 0 )
						printf( "token end-of-file\n" );
					else if ( yychar < 0 )
						printf( "token -none-\n" );
					else
					{
						for ( yy_i = 0;
							yytoks[yy_i].t_val >= 0;
							yy_i++ )
						{
							if ( yytoks[yy_i].t_val
								== yychar )
							{
								break;
							}
						}
						printf( "token %s\n",
							yytoks[yy_i].t_name );
					}
				}
#endif /* YYDEBUG */
				if ( yychar == 0 )	/* reached EOF. quit */
					YYABORT;
				yychar = -1;
				goto yy_newstate;
			}
		}/* end if ( yy_n == 0 ) */
		/*
		** reduction by production yy_n
		** put stack tops, etc. so things right after switch
		*/
#if YYDEBUG
		/*
		** if debugging, print the string that is the user's
		** specification of the reduction which is just about
		** to be done.
		*/
		if ( yydebug )
			printf( "Reduce by (%d) \"%s\"\n",
				yy_n, yyreds[ yy_n ] );
#endif
		yytmp = yy_n;			/* value to switch over */
		yypvt = yy_pv;			/* $vars top of value stack */
		/*
		** Look in goto table for next state
		** Sorry about using yy_state here as temporary
		** register variable, but why not, if it works...
		** If yyr2[ yy_n ] doesn't have the low order bit
		** set, then there is no action to be done for
		** this reduction.  So, no saving & unsaving of
		** registers done.  The only difference between the
		** code just after the if and the body of the if is
		** the goto yy_stack in the body.  This way the test
		** can be made before the choice of what to do is needed.
		*/
		{
			/* length of production doubled with extra bit */
			register int yy_len = yyr2[ yy_n ];

			if ( !( yy_len & 01 ) )
			{
				yy_len >>= 1;
				yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
				yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
					*( yy_ps -= yy_len ) + 1;
				if ( yy_state >= YYLAST ||
					yychk[ yy_state =
					yyact[ yy_state ] ] != -yy_n )
				{
					yy_state = yyact[ yypgo[ yy_n ] ];
				}
				goto yy_stack;
			}
			yy_len >>= 1;
			yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
			yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
				*( yy_ps -= yy_len ) + 1;
			if ( yy_state >= YYLAST ||
				yychk[ yy_state = yyact[ yy_state ] ] != -yy_n )
			{
				yy_state = yyact[ yypgo[ yy_n ] ];
			}
		}
					/* save until reenter driver code */
		yystate = yy_state;
		yyps = yy_ps;
		yypv = yy_pv;
	}
	/*
	** code supplied by user is placed in this switch
	*/
	switch( yytmp )
	{
		
case 1:
# line 189 "parser.y"
{click_list_init();} break;
case 2:
# line 191 "parser.y"
{
			/* node is set at the Eiffel level for root class */
			rn_ast = create_class(click_list_elem (yypvt[-7].value),deferred,expanded,separate,yypvt[-11].node,yypvt[-6].node,yypvt[-5].node,yypvt[-4].node,yypvt[-3].node,yypvt[-2].node,yypvt[-1].node,click_list_new(),
start_position);
		} break;
case 3:
# line 200 "parser.y"
{
		yyval.value = click_list_push ();
		click_list_set (create_id (token_str), yyval.value);
		} break;
case 4:
# line 211 "parser.y"
{yyval.node = NULL;} break;
case 5:
# line 212 "parser.y"
{list_init();} break;
case 6:
# line 213 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);} break;
case 7:
# line 215 "parser.y"
{yyval.node = NULL;} break;
case 8:
# line 219 "parser.y"
{list_push(yypvt[-0].node);} break;
case 9:
# line 221 "parser.y"
{list_push(yypvt[-0].node);} break;
case 10:
# line 224 "parser.y"
{list_init();} break;
case 11:
# line 225 "parser.y"
{yyval.node = create_node2(INDEX_AS,yypvt[-2].node,list_new(CONSTRUCT_LIST_AS));} break;
case 12:
# line 229 "parser.y"
{yyval.node = NULL;} break;
case 13:
# line 231 "parser.y"
{yyval.node = yypvt[-1].node;} break;
case 14:
# line 235 "parser.y"
{list_push(yypvt[-0].node);} break;
case 15:
# line 237 "parser.y"
{list_push(yypvt[-0].node);} break;
case 16:
# line 241 "parser.y"
{yyval.node = yypvt[-0].node;} break;
case 17:
# line 243 "parser.y"
{yyval.node = yypvt[-0].node;} break;
case 18:
# line 251 "parser.y"
{deferred = FALSE; expanded = FALSE; separate = FALSE;} break;
case 19:
# line 253 "parser.y"
{deferred = TRUE; expanded = FALSE; separate = FALSE;} break;
case 20:
# line 255 "parser.y"
{expanded = TRUE; deferred = FALSE; separate = FALSE;} break;
case 21:
# line 257 "parser.y"
{expanded = FALSE; deferred = FALSE; separate = TRUE;} break;
case 22:
# line 266 "parser.y"
{yyval.node = NULL;} break;
case 23:
# line 268 "parser.y"
{yyval.node = yypvt[-0].node;} break;
case 24:
# line 277 "parser.y"
{yyval.node = NULL;} break;
case 25:
# line 278 "parser.y"
{list_init();} break;
case 26:
# line 279 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);} break;
case 27:
# line 284 "parser.y"
{list_push(yypvt[-0].node);} break;
case 28:
# line 286 "parser.y"
{list_push(yypvt[-0].node);} break;
case 29:
# line 290 "parser.y"
{yyval.value = start_position;} break;
case 30:
# line 290 "parser.y"
{list_init();} break;
case 31:
# line 291 "parser.y"
{
		yyval.node = list_new(CONSTRUCT_LIST_AS);
		yyval.node = (yyval.node == NULL)?NULL:create_fclause_as(yypvt[-2].node,yyval.node,yypvt[-3].value);
		} break;
case 32:
# line 299 "parser.y"
{yyval.node = NULL;} break;
case 33:
# line 301 "parser.y"
{yyval.node = create_node1(CLIENT_AS,yypvt[-0].node);} break;
case 34:
# line 305 "parser.y"
{	list_init();
								list_push(create_id("none"));
								yyval.node = list_new(CONSTRUCT_LIST_AS);
							} break;
case 35:
# line 309 "parser.y"
{list_init();} break;
case 36:
# line 310 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);} break;
case 37:
# line 314 "parser.y"
{
							list_push(yypvt[-0].node);
							} break;
case 38:
# line 318 "parser.y"
{
							list_push(yypvt[-0].node);
							} break;
case 40:
# line 325 "parser.y"
{list_push(yypvt[-0].node);} break;
case 43:
# line 332 "parser.y"
{list_init();} break;
case 44:
# line 332 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);} break;
case 45:
# line 333 "parser.y"
{
		yyval.node = create_feature_as(yypvt[-2].node,yypvt[-1].node,click_list_start(yypvt[-3].value),start_position);
		click_list_set (yyval.node, yypvt[-3].value);
		} break;
case 46:
# line 341 "parser.y"
{
		yyval.value = yypvt[-0].value;
		list_push(click_list_elem(yyval.value));
		} break;
case 47:
# line 346 "parser.y"
{
		yyval.value = yypvt[-2].value;
		list_push(click_list_elem(yypvt[-0].value));
		} break;
case 48:
# line 354 "parser.y"
{
		yyval.value = yypvt[-0].value;
		} break;
case 49:
# line 360 "parser.y"
{
		is_frozen = FALSE;
		} break;
case 50:
# line 364 "parser.y"
{
		is_frozen = TRUE;
		} break;
case 51:
# line 371 "parser.y"
{
		yyval.value = yypvt[-0].value;
		click_list_set (create_feature_name(FEAT_NAME_ID_AS,click_list_elem(yyval.value),is_frozen), yyval.value);
		} break;
case 52:
# line 376 "parser.y"
{
		yyval.value = yypvt[-0].value;
		} break;
case 53:
# line 380 "parser.y"
{
		yyval.value = yypvt[-0].value;
		} break;
case 54:
# line 387 "parser.y"
{
		yyval.value = yypvt[-0].value;
		click_list_set (create_feature_name(INFIX_AS,click_list_elem(yyval.value),is_frozen), yyval.value);
		} break;
case 55:
# line 396 "parser.y"
{
		yyval.value = yypvt[-0].value;
		click_list_set (create_feature_name(PREFIX_AS,click_list_elem(yyval.value),is_frozen), yyval.value);
		} break;
case 56:
# line 404 "parser.y"
{
		extern int is_infix(char *s);

		yyval.value = click_list_push ();
		click_list_set (yypvt[-0].node, yyval.value);

		if (0 == is_infix(token_str))	/* Check infixed declaration */
			yyerror((char *) 0);
		} break;
case 57:
# line 417 "parser.y"
{
		extern int is_prefix(char *s);

		yyval.value = click_list_push ();
		click_list_set (yypvt[-0].node, yyval.value);

		if (0 == is_prefix(token_str))	/* Check prefixed declaration */
			yyerror((char *) 0);
		} break;
case 58:
# line 429 "parser.y"
{yyval.node = create_node3(BODY_AS,yypvt[-2].node,yypvt[-1].node,yypvt[-0].cr_node.cr_node);
	/* Validity test for feature declaration */
		if 	(
			/* either arguments or type or body */
			((yypvt[-2].node == NULL) && (yypvt[-1].node == NULL) && (yypvt[-0].cr_node.cr_node == NULL))
			||
			/* constant implies no argument but type */
			((yypvt[-0].cr_node.cr_type == CR_CONSTANT) && ((yypvt[-2].node != NULL) || (yypvt[-1].node == NULL)))
			||
			/* arguments implies non-void routine */
			((yypvt[-2].node != NULL) && ((yypvt[-0].cr_node.cr_type != CR_ROUTINE) || (yypvt[-0].cr_node.cr_node == NULL)))
			)
		{
			yyerror((char *) 0);
		}
	} break;
case 59:
# line 449 "parser.y"
{yyval.cr_node.cr_node = NULL; yyval.cr_node.cr_type = CR_EMPTY;} break;
case 60:
# line 451 "parser.y"
{yyval.cr_node.cr_node = yypvt[-0].cr_node.cr_node;yyval.cr_node.cr_type = yypvt[-0].cr_node.cr_type;} break;
case 61:
# line 455 "parser.y"
{yyval.cr_node.cr_node = create_node1(CONSTANT_AS,create_node1(VALUE_AS,yypvt[-0].node));yyval.cr_node.cr_type = CR_CONSTANT;} break;
case 62:
# line 457 "parser.y"
{yyval.cr_node.cr_node = create_node1(CONSTANT_AS,create_node1(VALUE_AS,create_node(UNIQUE_AS)));yyval.cr_node.cr_type = CR_CONSTANT;} break;
case 63:
# line 459 "parser.y"
{yyval.cr_node.cr_node = yypvt[-0].node;yyval.cr_node.cr_type = CR_ROUTINE;} break;
case 64:
# line 468 "parser.y"
{yyval.node = NULL;} break;
case 65:
# line 469 "parser.y"
{list_init();} break;
case 66:
# line 470 "parser.y"
{
		yyval.node = list_new(CONSTRUCT_LIST_AS);
		} break;
case 67:
# line 474 "parser.y"
{ yyval.node = NULL;} break;
case 68:
# line 479 "parser.y"
{list_push(yypvt[-1].node);} break;
case 69:
# line 481 "parser.y"
{list_push(yypvt[-1].node);} break;
case 70:
# line 486 "parser.y"
{
		rn_ast = create_node2(CLASS_TYPE_AS,click_list_elem(yypvt[-1].value),yypvt[-0].node);
		yyval.node = create_node6(PARENT_AS,rn_ast,NULL,NULL,NULL,NULL,NULL);
		click_list_set (rn_ast, yypvt[-1].value);
		} break;
case 71:
# line 492 "parser.y"
{
		inherit_context = 1;
		rn_ast = create_node2(CLASS_TYPE_AS,click_list_elem(yypvt[-2].value),yypvt[-1].node);
		yyval.node = create_node6(PARENT_AS,rn_ast,NULL,NULL,NULL,NULL,NULL);
		click_list_set (rn_ast, yypvt[-2].value);
		} break;
case 72:
# line 499 "parser.y"
{
		inherit_context = (yypvt[-5].node==NULL)&&(yypvt[-4].node==NULL)&&(yypvt[-3].node==NULL)&&(yypvt[-2].node==NULL)&&(yypvt[-1].node==NULL);
		rn_ast = create_node2(CLASS_TYPE_AS,click_list_elem(yypvt[-7].value),yypvt[-6].node);
		yyval.node = create_node6(PARENT_AS,rn_ast,yypvt[-5].node,yypvt[-4].node,yypvt[-3].node,yypvt[-2].node,yypvt[-1].node);
		click_list_set (rn_ast, yypvt[-7].value);
		} break;
case 73:
# line 508 "parser.y"
{yyval.node = NULL;} break;
case 74:
# line 510 "parser.y"
{yyval.node = yypvt[-0].node;} break;
case 75:
# line 514 "parser.y"
{yyval.node = NULL;} break;
case 76:
# line 516 "parser.y"
{yyval.node = NULL;} break;
case 76:
#line 516 "parser.y"
{yyval.node = NULL;}
break;
case 77:
#line 517 "parser.y"
{list_init();}
break;
case 78:
#line 518 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 79:
#line 523 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 80:
#line 525 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 81:
#line 530 "parser.y"
{
		yyval.node = create_node2(RENAME_AS,click_list_elem(yyvsp[-2].value),click_list_elem(yyvsp[0].value));
		click_list_set (click_list_elem(yyvsp[0].value), yyvsp[-2].value);
		}
break;
case 82:
#line 537 "parser.y"
{yyval.node = NULL;}
break;
case 83:
#line 538 "parser.y"
{list_init();}
break;
case 84:
#line 539 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 85:
#line 541 "parser.y"
{yyval.node = NULL;}
break;
case 86:
#line 546 "parser.y"
{list_push(yyvsp[-1].node);}
break;
case 87:
#line 548 "parser.y"
{list_push(yyvsp[-1].node);}
break;
case 88:
#line 552 "parser.y"
{	yyval.node = create_node1(CLIENT_AS,yyvsp[-1].node);
			yyval.node = create_node2(EXPORT_ITEM_AS,yyval.node,yyvsp[0].node);
		}
break;
case 89:
#line 559 "parser.y"
{yyval.node = create_node(ALL_AS);}
break;
case 90:
#line 560 "parser.y"
{list_init();}
break;
case 91:
#line 561 "parser.y"
{yyval.node = create_node1 (FEATURE_LIST_AS,list_new(CONSTRUCT_LIST_AS));}
break;
case 92:
#line 566 "parser.y"
{list_push(click_list_elem(yyvsp[0].value));}
break;
case 93:
#line 568 "parser.y"
{list_push(click_list_elem(yyvsp[0].value));}
break;
case 94:
#line 572 "parser.y"
{yyval.node = NULL;}
break;
case 95:
#line 574 "parser.y"
{yyval.node = NULL;}
break;
case 96:
#line 575 "parser.y"
{list_init();}
break;
case 97:
#line 576 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 98:
#line 580 "parser.y"
{yyval.node = NULL;}
break;
case 99:
#line 582 "parser.y"
{yyval.node = NULL;}
break;
case 100:
#line 583 "parser.y"
{list_init();}
break;
case 101:
#line 584 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 102:
#line 588 "parser.y"
{yyval.node = NULL;}
break;
case 103:
#line 590 "parser.y"
{yyval.node = NULL;}
break;
case 104:
#line 591 "parser.y"
{list_init();}
break;
case 105:
#line 592 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 106:
#line 600 "parser.y"
{yyval.node = NULL;}
break;
case 107:
#line 602 "parser.y"
{yyerror((char *)0);}
break;
case 108:
#line 603 "parser.y"
{list_init();}
break;
case 109:
#line 604 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 111:
#line 609 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 112:
#line 612 "parser.y"
{list_init();}
break;
case 113:
#line 612 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 114:
#line 613 "parser.y"
{yyval.node = create_node2(TYPE_DEC_AS,yyvsp[-3].node,yyvsp[-1].node);}
break;
case 115:
#line 617 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 116:
#line 619 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 119:
#line 627 "parser.y"
{yyval.node = NULL;}
break;
case 120:
#line 629 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 121:
#line 633 "parser.y"
{yyval.value = start_position;}
break;
case 122:
#line 636 "parser.y"
{yyval.node = create_routine_as(yyvsp[-7].node,yyvsp[-6].value,yyvsp[-5].node,yyvsp[-4].node,yyvsp[-3].node,yyvsp[-2].node,yyvsp[-1].node);}
break;
case 123:
#line 640 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 124:
#line 642 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 125:
#line 644 "parser.y"
{yyval.node = create_node(DEFERRED_AS);}
break;
case 126:
#line 648 "parser.y"
{yyval.node = create_node2(EXTERNAL_AS,yyvsp[-1].node,yyvsp[0].node);}
break;
case 127:
#line 651 "parser.y"
{SET_POS(start_position);}
break;
case 128:
#line 652 "parser.y"
{yyval.node = create_node1(EXTERNAL_LANG_AS, yyvsp[0].node);}
break;
case 129:
#line 656 "parser.y"
{yyval.node = NULL;}
break;
case 130:
#line 658 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 131:
#line 661 "parser.y"
{list_init();}
break;
case 132:
#line 662 "parser.y"
{yyval.node = create_node1(DO_AS,list_new(CONSTRUCT_LIST_AS));}
break;
case 133:
#line 663 "parser.y"
{list_init();}
break;
case 134:
#line 664 "parser.y"
{yyval.node =
create_node1(ONCE_AS,list_new(CONSTRUCT_LIST_AS));}
break;
case 135:
#line 670 "parser.y"
{yyval.node = NULL;}
break;
case 136:
#line 671 "parser.y"
{list_init();}
break;
case 137:
#line 672 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 138:
#line 676 "parser.y"
{list_push(yyvsp[-1].node);}
break;
case 142:
#line 683 "parser.y"
{list_push(yyvsp[-1].node);}
break;
case 144:
#line 688 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 145:
#line 690 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 146:
#line 692 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 147:
#line 694 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 148:
#line 696 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 149:
#line 698 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 150:
#line 700 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 151:
#line 702 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 152:
#line 704 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 153:
#line 706 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 154:
#line 710 "parser.y"
{yyval.node = NULL;}
break;
case 155:
#line 711 "parser.y"
{id_level = ASSERT_LEVEL;}
break;
case 156:
#line 712 "parser.y"
{	id_level = NORMAL_LEVEL;
									yyval.node = create_node1(REQUIRE_AS,yyvsp[0].node);
								}
break;
case 157:
#line 715 "parser.y"
{id_level = ASSERT_LEVEL;}
break;
case 158:
#line 716 "parser.y"
{	id_level = NORMAL_LEVEL;
									yyval.node = create_node1(REQUIRE_ELSE_AS,yyvsp[0].node);
								}
break;
case 159:
#line 722 "parser.y"
{yyval.node = NULL;}
break;
case 160:
#line 723 "parser.y"
{id_level = ASSERT_LEVEL;}
break;
case 161:
#line 724 "parser.y"
{	id_level = NORMAL_LEVEL;
									yyval.node = create_node1(ENSURE_AS,yyvsp[0].node);
								}
break;
case 162:
#line 727 "parser.y"
{id_level = ASSERT_LEVEL;}
break;
case 163:
#line 728 "parser.y"
{	id_level = NORMAL_LEVEL;
									yyval.node = create_node1(ENSURE_THEN_AS,yyvsp[0].node);
								}
break;
case 164:
#line 734 "parser.y"
{list_init();}
break;
case 165:
#line 735 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 168:
#line 742 "parser.y"
{list_push(yyvsp[-1].node);}
break;
case 169:
#line 744 "parser.y"
{list_push(yyvsp[-1].node);}
break;
case 170:
#line 748 "parser.y"
{
									yyval.node = create_node2(TAGGED_AS,NULL,yyvsp[0].node);
								}
break;
case 171:
#line 752 "parser.y"
{
									yyval.node = create_node2(TAGGED_AS,yyvsp[-2].node,yyvsp[0].node);
								}
break;
case 172:
#line 756 "parser.y"
{ yyval.node = NULL;}
break;
case 173:
#line 766 "parser.y"
{
		yyval.node = create_type_class(click_list_elem(yyvsp[0].value),NULL);
		click_list_set (yyval.node, yyvsp[0].value);
		}
break;
case 174:
#line 771 "parser.y"
{
		yyval.node = create_type_class(click_list_elem(yyvsp[-1].value),yyvsp[0].node);
		click_list_set (yyval.node, yyvsp[-1].value);
		}
break;
case 175:
#line 776 "parser.y"
{
		yyval.node = create_exp_class_type(click_list_elem(yyvsp[0].value),NULL);
		click_list_set (yyval.node, yyvsp[0].value);
		}
break;
case 176:
#line 781 "parser.y"
{
		yyval.node = create_exp_class_type(click_list_elem(yyvsp[-1].value),yyvsp[0].node);
		click_list_set (yyval.node, yyvsp[-1].value);
		}
break;
case 177:
#line 786 "parser.y"
{
		yyval.node = create_separate_class_type(click_list_elem(yyvsp[0].value),NULL);
		click_list_set (yyval.node, yyvsp[0].value);
		}
break;
case 178:
#line 791 "parser.y"
{
		yyval.node = create_separate_class_type(click_list_elem(yyvsp[-1].value),yyvsp[0].node);
		click_list_set (yyval.node, yyvsp[-1].value);
		}
break;
case 179:
#line 796 "parser.y"
{
		yyval.node = create_node1(BITS_AS,yyvsp[0].node);
		}
break;
case 180:
#line 800 "parser.y"
{
		yyval.node = create_node1(BITS_SYMBOL_AS,yyvsp[0].node);
		}
break;
case 181:
#line 804 "parser.y"
{
		yyval.node = create_node1(LIKE_ID_AS, yyvsp[0].node);
		}
break;
case 182:
#line 808 "parser.y"
{
		yyval.node = create_node(LIKE_CUR_AS);
		}
break;
case 183:
#line 815 "parser.y"
{
        yyval.node = create_type_class(click_list_elem(yyvsp[0].value),NULL);
        click_list_set (yyval.node, yyvsp[0].value);
        }
break;
case 184:
#line 820 "parser.y"
{
        yyval.node = create_type_class(click_list_elem(yyvsp[-1].value),yyvsp[0].node);
        click_list_set (yyval.node, yyvsp[-1].value);
        }
break;
case 185:
#line 828 "parser.y"
{yyval.node = NULL;}
break;
case 186:
#line 829 "parser.y"
{list_init();}
break;
case 187:
#line 830 "parser.y"
{
		yyval.node = list_new(CONSTRUCT_LIST_AS);
		}
break;
case 188:
#line 837 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 189:
#line 839 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 190:
#line 847 "parser.y"
{
		yyval.node = NULL;
		}
break;
case 191:
#line 850 "parser.y"
{list_init();}
break;
case 192:
#line 851 "parser.y"
{
		yyval.node = list_new(CONSTRUCT_LIST_AS);
		}
break;
case 194:
#line 859 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 195:
#line 861 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 196:
#line 865 "parser.y"
{strcpy(generic_name, token_str);}
break;
case 197:
#line 866 "parser.y"
{generic_inc(); yyval.node = create_generic(generic_name, yyvsp[0].node);}
break;
case 198:
#line 870 "parser.y"
{yyval.node = NULL;}
break;
case 199:
#line 872 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 200:
#line 879 "parser.y"
{yyval.value = start_position;}
break;
case 201:
#line 879 "parser.y"
{list_init();}
break;
case 202:
#line 879 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 203:
#line 880 "parser.y"
{SET_POS(yyvsp[-9].value); yyval.node = create_node4(IF_AS,yyvsp[-7].node,yyvsp[-3].node,yyvsp[-2].node,yyvsp[-1].node);}
break;
case 204:
#line 884 "parser.y"
{yyval.node = NULL;}
break;
case 205:
#line 885 "parser.y"
{list_init();}
break;
case 206:
#line 886 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 207:
#line 890 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 208:
#line 892 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 209:
#line 895 "parser.y"
{list_init();}
break;
case 210:
#line 896 "parser.y"
{yyval.node = create_node2(ELSIF_AS,yyvsp[-3].node,list_new(CONSTRUCT_LIST_AS));}
break;
case 211:
#line 900 "parser.y"
{yyval.node = NULL;}
break;
case 212:
#line 901 "parser.y"
{list_init();}
break;
case 213:
#line 902 "parser.y"
{yyval.node = inspect_else();}
break;
case 214:
#line 906 "parser.y"
{yyval.node = NULL;}
break;
case 215:
#line 907 "parser.y"
{list_init();}
break;
case 216:
#line 908 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 217:
#line 911 "parser.y"
{yyval.value = start_position;}
break;
case 218:
#line 912 "parser.y"
{list_init();}
break;
case 219:
#line 912 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 220:
#line 914 "parser.y"
{SET_POS(yyvsp[-7].value); yyval.node = create_node3(INSPECT_AS,yyvsp[-5].node,yyvsp[-2].node,yyvsp[-1].node);}
break;
case 222:
#line 927 "parser.y"
{list_push(yyvsp[-1].node);}
break;
case 223:
#line 930 "parser.y"
{list_init();}
break;
case 224:
#line 930 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 225:
#line 930 "parser.y"
{list_init();}
break;
case 226:
#line 931 "parser.y"
{yyval.node = create_node2(CASE_AS,yyvsp[-3].node,list_new(CONSTRUCT_LIST_AS));}
break;
case 227:
#line 935 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 228:
#line 937 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 229:
#line 941 "parser.y"
{yyval.node = create_node2(INTERVAL_AS,yyvsp[0].node,NULL);}
break;
case 230:
#line 943 "parser.y"
{yyval.node = create_node2(INTERVAL_AS,yyvsp[0].node,NULL);}
break;
case 231:
#line 945 "parser.y"
{yyval.node = create_node2(INTERVAL_AS,yyvsp[0].node,NULL);}
break;
case 232:
#line 947 "parser.y"
{yyval.node = create_node2(INTERVAL_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 233:
#line 949 "parser.y"
{yyval.node = create_node2(INTERVAL_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 234:
#line 951 "parser.y"
{yyval.node = create_node2(INTERVAL_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 235:
#line 953 "parser.y"
{yyval.node = create_node2(INTERVAL_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 236:
#line 955 "parser.y"
{yyval.node = create_node2(INTERVAL_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 237:
#line 957 "parser.y"
{yyval.node = create_node2(INTERVAL_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 238:
#line 959 "parser.y"
{yyval.node = create_node2(INTERVAL_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 239:
#line 962 "parser.y"
{yyval.value = start_position;}
break;
case 240:
#line 962 "parser.y"
{list_init();}
break;
case 241:
#line 962 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 242:
#line 962 "parser.y"
{list_init();}
break;
case 243:
#line 963 "parser.y"
{SET_POS(yyvsp[-12].value); yyval.node = create_node5(LOOP_AS,yyvsp[-8].node,yyvsp[-7].node,yyvsp[-6].node,yyvsp[-4].node,list_new(CONSTRUCT_LIST_AS));}
break;
case 244:
#line 967 "parser.y"
{yyval.node = NULL;}
break;
case 245:
#line 969 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 246:
#line 973 "parser.y"
{yyval.node = NULL;}
break;
case 247:
#line 974 "parser.y"
{id_level = INVARIANT_LEVEL;}
break;
case 248:
#line 975 "parser.y"
{
		id_level = NORMAL_LEVEL;
		yyval.node = create_node1(INVARIANT_AS,yyvsp[0].node);
		}
break;
case 249:
#line 983 "parser.y"
{yyval.node = NULL;}
break;
case 250:
#line 985 "parser.y"
{yyval.node = create_node2(VARIANT_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 251:
#line 987 "parser.y"
{yyval.node = create_node2(VARIANT_AS,NULL,yyvsp[0].node);}
break;
case 252:
#line 990 "parser.y"
{yyval.value = start_position; }
break;
case 253:
#line 990 "parser.y"
{list_init();}
break;
case 254:
#line 991 "parser.y"
{SET_POS(yyvsp[-5].value); yyval.node = create_node2(DEBUG_AS,yyvsp[-3].node,list_new(CONSTRUCT_LIST_AS));}
break;
case 255:
#line 995 "parser.y"
{yyval.node = NULL;}
break;
case 256:
#line 997 "parser.y"
{yyval.node = NULL;}
break;
case 257:
#line 998 "parser.y"
{list_init();}
break;
case 258:
#line 999 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 259:
#line 1003 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 260:
#line 1005 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 261:
#line 1009 "parser.y"
{yyval.node = create_node(RETRY_AS);}
break;
case 262:
#line 1013 "parser.y"
{yyval.node = NULL;}
break;
case 263:
#line 1014 "parser.y"
{list_init();}
break;
case 264:
#line 1015 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 265:
#line 1032 "parser.y"
{yyval.node = create_node2(ASSIGN_AS,create_node2(ACCESS_ID_AS,yyvsp[-2].node,NULL),yyvsp[0].node);}
break;
case 266:
#line 1034 "parser.y"
{yyval.node = create_node2(ASSIGN_AS,create_node(RESULT_AS),yyvsp[0].node);}
break;
case 267:
#line 1038 "parser.y"
{yyval.node = create_node2(REVERSE_AS,create_node2(ACCESS_ID_AS,yyvsp[-2].node,NULL),yyvsp[0].node);}
break;
case 268:
#line 1040 "parser.y"
{yyval.node = create_node2(REVERSE_AS,create_node(RESULT_AS),yyvsp[0].node);}
break;
case 269:
#line 1045 "parser.y"
{yyval.node = NULL;}
break;
case 270:
#line 1046 "parser.y"
{list_init();}
break;
case 271:
#line 1047 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 272:
#line 1051 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 273:
#line 1053 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 274:
#line 1057 "parser.y"
{yyval.node = create_node2(CREATE_AS,NULL,NULL);}
break;
case 275:
#line 1058 "parser.y"
{list_init();}
break;
case 276:
#line 1059 "parser.y"
{yyval.node = create_node2(CREATE_AS,yyvsp[-2].node,list_new(CONSTRUCT_LIST_AS));}
break;
case 277:
#line 1061 "parser.y"
{
									yyval.node = create_node1(CLIENT_AS,yyvsp[0].node);
									yyval.node = create_node2(CREATE_AS,yyval.node,NULL);								}
break;
case 278:
#line 1067 "parser.y"
{yyval.node = create_node3(CREATION_AS,yyvsp[-3].node,yyvsp[-1].node,yyvsp[0].node);}
break;
case 279:
#line 1071 "parser.y"
{yyval.node = NULL;}
break;
case 280:
#line 1073 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 281:
#line 1077 "parser.y"
{yyval.node = create_node2(ACCESS_ID_AS,yyvsp[0].node,NULL);}
break;
case 282:
#line 1079 "parser.y"
{yyval.node = create_node(RESULT_AS);}
break;
case 283:
#line 1083 "parser.y"
{yyval.node = NULL;}
break;
case 284:
#line 1085 "parser.y"
{yyval.node = create_node2(ACCESS_INV_AS,yyvsp[-1].node,yyvsp[0].node);}
break;
case 285:
#line 1093 "parser.y"
{yyval.node = create_node1(INSTR_CALL_AS,yyvsp[0].node);}
break;
case 286:
#line 1095 "parser.y"
{yyval.node = create_node1(INSTR_CALL_AS,yyvsp[0].node);}
break;
case 287:
#line 1097 "parser.y"
{yyval.node = create_node1(INSTR_CALL_AS,yyvsp[0].node);}
break;
case 288:
#line 1099 "parser.y"
{yyval.node = create_node1(INSTR_CALL_AS,yyvsp[0].node);}
break;
case 289:
#line 1101 "parser.y"
{yyval.node = create_node1(INSTR_CALL_AS,yyvsp[0].node);}
break;
case 290:
#line 1104 "parser.y"
{yyval.value = start_position; }
break;
case 291:
#line 1105 "parser.y"
{SET_POS(yyvsp[-3].value); yyval.node = create_node1(CHECK_AS,yyvsp[-1].node);}
break;
case 292:
#line 1113 "parser.y"
{yyerrok;yyval.node = create_node1(VALUE_AS,yyvsp[0].node);}
break;
case 293:
#line 1115 "parser.y"
{yyerrok;yyval.node = create_node1(VALUE_AS,yyvsp[0].node);}
break;
case 294:
#line 1117 "parser.y"
{yyval.node = create_node1(EXPR_CALL_AS, yyvsp[0].node);}
break;
case 295:
#line 1119 "parser.y"
{yyval.node = create_node1(PARAN_AS, yyvsp[-1].node);}
break;
case 296:
#line 1121 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_PLUS_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 297:
#line 1123 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_MINUS_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 298:
#line 1125 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_STAR_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 299:
#line 1127 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_SLASH_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 300:
#line 1129 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_MOD_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 301:
#line 1131 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_DIV_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 302:
#line 1133 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_POWER_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 303:
#line 1135 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_AND_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 304:
#line 1137 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_AND_THEN_AS,yyvsp[-3].node,yyvsp[0].node);}
break;
case 305:
#line 1139 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_OR_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 306:
#line 1141 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_OR_ELSE_AS,yyvsp[-3].node,yyvsp[0].node);}
break;
case 307:
#line 1143 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_IMPLIES_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 308:
#line 1145 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_XOR_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 309:
#line 1147 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_GE_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 310:
#line 1149 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_GT_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 311:
#line 1151 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_LE_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 312:
#line 1153 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_LT_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 313:
#line 1155 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_EQ_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 314:
#line 1157 "parser.y"
{yyerrok;yyval.node = create_node2(BIN_NE_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 315:
#line 1159 "parser.y"
{	yyerrok;
									yyval.node = create_node3(BIN_FREE_AS,yyvsp[-2].node,yyvsp[-1].node,yyvsp[0].node);}
break;
case 316:
#line 1162 "parser.y"
{yyerrok;yyval.node = create_node1(UN_MINUS_AS,yyvsp[0].node);}
break;
case 317:
#line 1164 "parser.y"
{yyerrok;yyval.node = create_node1(UN_PLUS_AS,yyvsp[0].node);}
break;
case 318:
#line 1166 "parser.y"
{yyerrok;yyval.node = create_node1(UN_NOT_AS, yyvsp[0].node);}
break;
case 319:
#line 1168 "parser.y"
{yyerrok;yyval.node = create_node1(UN_OLD_AS,yyvsp[0].node);}
break;
case 320:
#line 1170 "parser.y"
{yyerrok;yyval.node = create_node2(UN_FREE_AS,yyvsp[-1].node,yyvsp[0].node);}
break;
case 321:
#line 1171 "parser.y"
{yyerrok;list_init();}
break;
case 322:
#line 1172 "parser.y"
{yyerrok;yyval.node = create_node1(UN_STRIP_AS,list_new(CONSTRUCT_LIST_AS));}
break;
case 323:
#line 1176 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 324:
#line 1178 "parser.y"
{
								yyerrok;
								yyval.node = create_node1(ADDRESS_AS,click_list_elem(yyvsp[0].value));
								}
break;
case 325:
#line 1183 "parser.y"
{
								yyerrok;
								yyval.node = create_node1(EXPR_ADDRESS_AS,yyvsp[-1].node);
								}
break;
case 326:
#line 1188 "parser.y"
{yyerrok;yyval.node = create_node(ADDRESS_CURRENT_AS);}
break;
case 327:
#line 1190 "parser.y"
{yyerrok;yyval.node = create_node(ADDRESS_RESULT_AS);}
break;
case 328:
#line 1194 "parser.y"
{yyval.node = create_id(token_str);}
break;
case 329:
#line 1202 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 330:
#line 1204 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 331:
#line 1206 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 332:
#line 1208 "parser.y"
{yyval.node = create_node(CURRENT_AS);}
break;
case 333:
#line 1210 "parser.y"
{yyval.node = create_node(RESULT_AS);}
break;
case 334:
#line 1212 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 335:
#line 1214 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 336:
#line 1218 "parser.y"
{yyval.node = create_node2(NESTED_AS,create_node(CURRENT_AS),yyvsp[0].node);}
break;
case 337:
#line 1222 "parser.y"
{yyval.node = create_node2(NESTED_AS,create_node(RESULT_AS),yyvsp[0].node);}
break;
case 338:
#line 1226 "parser.y"
{yyval.node = create_node2(NESTED_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 339:
#line 1230 "parser.y"
{yyval.node = create_node2(NESTED_EXPR_AS,yyvsp[-3].node,yyvsp[0].node);}
break;
case 340:
#line 1234 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 341:
#line 1236 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 342:
#line 1240 "parser.y"
{yyval.node = create_node2(NESTED_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 343:
#line 1242 "parser.y"
{yyval.node = create_node2(NESTED_AS,yyvsp[-2].node,yyvsp[0].node);}
break;
case 344:
#line 1246 "parser.y"
{	switch(id_level) {
							case NORMAL_LEVEL:
								yyval.node = create_node2(ACCESS_ID_AS, yyvsp[-1].node,yyvsp[0].node);
								break;
							case ASSERT_LEVEL:
								yyval.node = create_node2(ACCESS_ASSERT_AS,yyvsp[-1].node,yyvsp[0].node);
								break;
							case INVARIANT_LEVEL:
								yyval.node = create_node2(ACCESS_INV_AS,yyvsp[-1].node,yyvsp[0].node);
								break;
							}
						}
break;
case 345:
#line 1261 "parser.y"
{yyval.node = create_node2(ACCESS_FEAT_AS,yyvsp[-1].node,yyvsp[0].node);}
break;
case 346:
#line 1265 "parser.y"
{yyval.node = NULL;}
break;
case 347:
#line 1267 "parser.y"
{yyval.node = NULL;}
break;
case 348:
#line 1268 "parser.y"
{list_init();}
break;
case 349:
#line 1269 "parser.y"
{yyval.node = list_new(CONSTRUCT_LIST_AS);}
break;
case 350:
#line 1273 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 351:
#line 1275 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 352:
#line 1279 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 353:
#line 1281 "parser.y"
{list_push(yyvsp[0].node);}
break;
case 356:
#line 1293 "parser.y"
{
				yyval.node = create_id(token_str);
				}
break;
case 357:
#line 1299 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 358:
#line 1301 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 359:
#line 1303 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 360:
#line 1305 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 361:
#line 1307 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 362:
#line 1309 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 363:
#line 1313 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 364:
#line 1315 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 365:
#line 1317 "parser.y"
{yyval.node = create_int(token_str,0);}
break;
case 366:
#line 1319 "parser.y"
{yyval.node = create_real(token_str,0);}
break;
case 367:
#line 1321 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 368:
#line 1323 "parser.y"
{yyval.node = yyvsp[0].node;}
break;
case 369:
#line 1327 "parser.y"
{yyval.node = create_bool(0);}
break;
case 370:
#line 1329 "parser.y"
{yyval.node = create_bool(1);}
break;
case 371:
#line 1333 "parser.y"
{yyval.node = create_char(token_str);}
break;
case 372:
#line 1337 "parser.y"
{yyval.node = create_int(token_str,yyvsp[-1].value);}
break;
case 373:
#line 1341 "parser.y"
{yyval.value = 0;}
break;
case 374:
#line 1343 "parser.y"
{yyval.value = 0;}
break;
case 375:
#line 1345 "parser.y"
{yyval.value = 1;}
break;
case 376:
#line 1349 "parser.y"
{yyval.node = create_real(token_str,yyvsp[-1].value);}
break;
case 377:
#line 1353 "parser.y"
{yyval.node = create_node1(BIT_CONST_AS,create_id(token_str));}
break;
case 378:
#line 1357 "parser.y"
{yyval.node = create_string(token_str);}
break;
case 379:
#line 1359 "parser.y"
{yyval.node = create_string(token_str);}
break;
case 380:
#line 1363 "parser.y"
{yyval.node = create_string(token_str);}
break;
case 381:
#line 1366 "parser.y"
{list_init();}
break;
case 382:
#line 1367 "parser.y"
{yyval.node = create_node1(ARRAY_AS,list_new(CONSTRUCT_LIST_AS));}
break;
case 383:
#line 1370 "parser.y"
{yyval.value = SET_POS(start_position);}
break;
#line 3632 "y.tab.c"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("yydebug: after reduction, shifting from state 0 to\
 state %d\n", YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("yydebug: state %d, reading %d (%s)\n",
                        YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("yydebug: after reduction, shifting from state %d \
to state %d\n", *yyssp, yystate);
#endif
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
