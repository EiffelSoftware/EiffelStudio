<document title="Initialization" output="studio">
	<meta_data/>
	<paragraph>
		<paragraph>This document details how to setup preferences for your application.</paragraph>
		<heading>
			<size>2</size>Initializating the preferences
		</heading>
		<paragraph>The first thing you must do to setup preferences for your application is create a 
			<class_name>PREFERENCES</class_name> object.  Ideally any access to preference information should be done through this object.  There are 3 creation routines available to initialize the preferences:
			<list ordered="false">
				<item>
					<feature_name>make</feature_name>
				</item>
				<item>
					<feature_name>make_with_location</feature_name>
				</item>
				<item>
					<feature_name>make_with_defaults_and_location</feature_name>
				</item>
			</list>
			<paragraph>The first and most simple option (
				<feature_name>make</feature_name>) will create a 
				<class_name>PREFERENCE</class_name> object for you with no specific underlying datastore location, and no default preference values.  In this scenario an underlying data store location will be created for you automatically based on the current system settings.  For example, if you are using the Windows Registry as your data store, and your program is is called 
				<italic>my_program.exe</italic>, then a registry key will be created in 
				<italic>HKEY_CURRENT_USER\Software\myprogram.exe</italic>.  In between user sessions the preference name-value pairs will be stored in this key location.  This particular method of creating preferences is ideal if you are not particularly concerned where the values are stored, and if you do not need to specify any default values for the preferences.  You may think of it as the "it just works" mode, and it is ideal for development and simple use.
			</paragraph>
			<paragraph>The second option (
				<feature_name>make_with_location</feature_name>) will take a location value to use for the underlying data store.  Values will be stored to and retrieved from this location between sessions.  As with 
				<feature_name>make</feature_name> no defaults values are provided.
			</paragraph>
			<paragraph>The final option 
				<feature_name>make_with_defaults_and_location</feature_name> is similar to 
				<feature_name>make_with_location</feature_name> except an additional parameter is given to retrieve one or more default file locations. This will be one or more XML files on disk containing the default values to use for some or all of your preferences.  It is a convenient way to initialize your application with all the default values required `out of the box' for correct or preferred functioning.  Those files also contain additional attributes for preference configuration such a more detailed description of the preference. If two files list the same preference,
			   the last one to mention it takes precedence. Please read the section below for details of the format of this default file.
			</paragraph>
			<heading>
				<size>2</size>Managers
			</heading>
			<paragraph>Once you have created a 
				<class_name>PREFERENCES</class_name> object using one of the creation routines described above you will create a 
				<class_name>PREFERENCE_MANAGER</class_name> to store related preference values.  For example, if your application is a web browser control that has preferences for user favorites and also a user browsing history you could create 2 managers, one for the favorites and one for the history.  It is not mandatory that you create 2 managers and you could just create one and have all preferences stored therein, but for reasons of management 2 would be better.  Each separate manager must have a unique name to distinguish it from the other managers in the system.  We may have one called "favorites" and one called "history".  
			</paragraph>
			<heading>
				<size>2</size>Creating preferences
			</heading>
			<paragraph>Now you have your preferences and at least one manager to put them in you can create the actual preferences.  Preferences are generic, and all preferences inherit the class TYPED_PREFERENCE [G].  G denotes the type of the preference, for example INTEGER for a preference containing an integer value.  Depending on the type you will use a factory class to actually create the new preference.  By default the library supports 6 types of preferences, 4 basic type ones and 2 graphical types.  The table below clearly indicates the currently available preferences and the factory class you should use to create them:
				<table>
					<row>
						<cell>
							<bold>Preference type</bold>
						</cell>
						<cell>
							<bold>Description</bold>
						</cell>
						<cell>
							<bold>Factory class</bold>
						</cell>
						<cell>
							<bold>Factory method</bold>
						</cell>
					</row>
					<row>
						<cell>
							<class_name>BOOLEAN_PREFERENCE</class_name>
						</cell>
						<cell>Stores boolean value (true or false)</cell>
						<cell>
							<class_name>BASIC_PREFERENCE_FACTORY</class_name>
						</cell>
						<cell>
							<feature_name>new_boolean_resource_value</feature_name>
						</cell>
					</row>
					<row>
						<cell>
							<class_name>INTEGER_PREFERENCE</class_name>
						</cell>
						<cell>Stores an integer value</cell>
						<cell>
							<class_name>BASIC_PREFERENCE_FACTORY</class_name>
						</cell>
						<cell>
							<feature_name>new_integer_resource_value</feature_name>
						</cell>
					</row>
					<row>
						<cell>
							<class_name>STRING_PREFERENCE</class_name>
						</cell>
						<cell>Stores a string value</cell>
						<cell>
							<class_name>BASIC_PREFERENCE_FACTORY</class_name>
						</cell>
						<cell>
							<feature_name>new_string_resource_value</feature_name>
						</cell>
					</row>
					<row>
						<cell>
							<class_name>ARRAY_PREFERENCE</class_name>
						</cell>
<cell>Stores a list of string values</cell>
						<cell>
							<class_name>BASIC_PREFERENCE_FACTORY</class_name>
						</cell>
						<cell>
							<feature_name>new_array_resource_value</feature_name>
						</cell>
					</row>
<row>
						<cell>
							<class_name>COLOR_PREFERENCE</class_name>
						</cell>
<cell>Stores a color value (rgb)</cell>
						<cell>
							<class_name>GRAPHICAL_PREFERENCE_FACTORY</class_name>
						</cell>
						<cell>
							<feature_name>new_color_resource_value</feature_name>
						</cell>
					</row>
<row>
						<cell>
							<class_name>FONT_PREFERENCE</class_name>
						</cell>
<cell>Stores a font value (font name, face, height, etc)</cell>
						<cell>
							<class_name>GRAPHICAL_PREFERENCE_FACTORY</class_name>
						</cell>
						<cell>
							<feature_name>new_font_resource_value</feature_name>
						</cell>
					</row>
				</table>
			As you can see creating preferences is very easy.  Also you will notice that color and font preferences use the <class_name>GRAPHICAL_PREFERENCE_FACTORY</class_name>.  If you wish to use these preferences in your application you will need to use EiffelVision2 since these preference values are stored as <class_name>EV_COLOR</class_name> and <class_name>EV_FONT</class_name> types.  If you wish to store preference value that are different to those offered by the 6 available preferences it also very easy to extend the design and add your own custom types.  Simply inherit TYPED_PREFERENCE [G] and implement the deferred features for your specific preference.  There is an example of this in the sample application.
			</paragraph>
<heading><size>2</size>Default Values</heading>
<paragraph>When you create a preference using a factory class you will provide a manager, a name for the preference, and a value.  For example, in <class_name>BASIC_PREFERENCE_FACTORY</class_name> you create an integer preference by calling <feature_name>new_integer_resource_value</feature_name>:
<code_block>
	new_integer_resource_value <symbol>(</symbol>a_manager<symbol>:</symbol> <class_name>PREFERENCE_MANAGER</class_name>; a_name<symbol>:</symbol> <class_name>STRING</class_name>; a_fallback_value<symbol>:</symbol> <class_name>INTEGER</class_name><symbol>)</symbol><symbol>:</symbol> <class_name>INTEGER_PREFERENCE</class_name> <keyword>is</keyword>
			<comment>-- Add a new integer resource with name `a_name'.  If preference cannot be found in
			-- underlying datastore or in a default values then `a_fallback_value' is used for the value.</comment>
		<keyword>require</keyword>
			name_valid<symbol>:</symbol> a_name /<symbol>=</symbol> Void 
			name_not_empty<symbol>:</symbol> <keyword>not</keyword> <feature_name>a_name</feature_name>.<feature_name>is_empty</feature_name>
			not_has_resource<symbol>:</symbol> <keyword>not</keyword> <feature_name>a_manager</feature_name>.<feature_name>known_resource</feature_name> <symbol>(</symbol>a_name<symbol>)</symbol>
		<keyword>ensure</keyword>
			has_result<symbol>:</symbol> Result /<symbol>=</symbol> Void
			resource_name_set<symbol>:</symbol> <feature_name>Result</feature_name>.<feature_name>name</feature_name>.<feature_name>is_equal</feature_name> <symbol>(</symbol>a_name<symbol>)</symbol>
			resource_added<symbol>:</symbol> <feature_name>a_manager</feature_name>.<feature_name>preferences</feature_name>.<feature_name>has_resource</feature_name> <symbol>(</symbol>a_name<symbol>)</symbol>
		<keyword>end</keyword>	
</code_block>An appropriate example in code of this could be:
<code_block>

<feature_name>window_width_preference</feature_name><symbol>:</symbol> <class_name>INTEGER_PREFERENCE</class_name>
		<comment>-- Preference holding value for width of application main window</comment>

<feature_name>initialize_my_preferences</feature_name> <keyword>is</keyword>
		<comment>-- Initialize the application preferences	</comment>
	<keyword>local</keyword>
		factory<symbol>:</symbol> <class_name>BASIC_PREFERENCE_FACTORY</class_name>
	<keyword>do</keyword>
		<keyword>create</keyword> factory
		window_width_preference <symbol>:</symbol><symbol>=</symbol> <feature_name>factory</feature_name>.<feature_name>new_integer_resource_value</feature_name> <symbol>(</symbol>my_manager, "window_width", 480<symbol>)</symbol>
	<keyword>end</keyword></code_block>

	This will create a new preference, which you can then use in your application to get, set and save the corresponding value when necessary.  The issue to be aware of here though involves the value that the preference will contain when it is created.  You see in the code above we pass the integer value 480.  <bold>This does not mean, however, the initial value of the preference will be 480</bold>.  This may sound odd, so let me explain...
<paragraph>The value of a preference when initialized is determined by a number of factors.  The first of these is the underlying data store value.  If a preference value was changed in a previous session, by the user or by the application directly, and was saved to the underlying data store, then this value will be given priority.  This makes sense, since if a user changes their preferences they don't want to have to do it every time they use your program.  So, if they want the default window width to be larger, say 600, then this will be the value of the preference named "window_width" when initialized next time.
  Following this, if there is no previously saved value then the library will look for a default value to use.  If a default file was given when the preferences were created (see above), and this default specifies a default value of 240 for the integer preference called "window_width", then this will be used.  Finally, if no preference value was previously stored <italic>and</italic> no value is provided as a default value then the supplied value in the code is used - our 480 value from the example above.  Although this process may seem confusing it is infact very simple and intuitive way to initialze the preferences.  The process chart below illustrates more clearly the various permutations.
</paragraph>
<image><url>value_chart.png</url></image>
</paragraph>
<paragraph><heading><size>2</size>Using and Manipulating Preferences</heading>
Now you have preferences created you may use them from your application.  Using the example preference above, window_width_preference, you can query the value of the preferences by simply querying the preference directly:
<code_block>window_width := window_width_preference.value</code_block>
Or for a value which should always be associated to the preference:
<code_block>window_width: INTEGER is
		-- Width of window
	do
		Result := window_width_preference.value
	end</code_block>
If you need to react when a preference value is changed you can hook up an agent to the <feature_name>change_actions</feature_name> of the preference:
<code_block>window_width_preference.change_actions.extend (agent my_agent_routine)</code_block>
To manually set the value of the preference call <feature_name>set_value</feature_name> or <feature_name>set_value_from_string</feature_name>, and to set a value for the default value call <feature_name>set_default_value</feature_name>.  To reset a preference value back to it's original default value use <feature_name>reset</feature_name>.
<paragraph>To save the current preference to the underlying data store you must call <feature_name>save_resource</feature_name> on the PREFERENCES object.  This will persist the value to the data store for retrieval in the next session.  Remeber, if you change a preference value during execution and do not save it then the value will be lost when execution has finished.  The preference window interface provided with the library will allow users to set theie own preference values and will save the values upon confirmation.  However, if you re using preferences in your code and do not wish to provide an interface for preference modification you must remeber to manually save the preferences.  You can save all preferences at once my calling <feature_name>save_resources</feature_name> in <class_name>PREFERENCES</class_name>, or individually with <feature_name>save_resource</feature_name>.</paragraph>
</paragraph>
		</paragraph>
	</paragraph></document>
