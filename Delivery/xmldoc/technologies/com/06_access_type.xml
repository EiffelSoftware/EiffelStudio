<document title="Access Type" output="studio">
	<meta_data/>
	<paragraph>Regardless of its location, a COM components can be accessed either directly through interface's virtual table or through OLE Automation.
		<heading>
			<size>2</size>Automation
		</heading>Accessing a COM component through Automation means using a well known interface to access to a group of methods and properties. This interface is called IDispatch, and it includes the method 
		<code>
			<feature_name>invoke</feature_name>
		</code> that allows to call a method, set or get a property on the Automation server. One advantage of that approach is that the interface has a known virtual table layout. As a result, Windows can include a built-in marshaler for that interface (See 
		<link>
			<url>07_deeper_into_com.xml</url><anchor_name></anchor_name>
			<label>Marshaling</label>
		</link> for information on what a marshaler is). The supported types (known as Automation types) and their Eiffel equivalents are listed in the following table:
		<table>
			<row>
				<cell>
					<paragraph>COM Type</paragraph>
				</cell>
				<cell>
					<paragraph>Eiffel equivalent</paragraph>
				</cell>
				<cell>
					<paragraph>Description</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph> VARIANT_BOOL</paragraph>
				</cell>
				<cell>
					<paragraph>BOOLEAN</paragraph>
				</cell>
				<cell>
					<paragraph>Standard boolean</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph>unsigned char</paragraph>
				</cell>
				<cell>
					<paragraph>CHARACTER</paragraph>
				</cell>
				<cell>
					<paragraph>Standard character</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph>double</paragraph>
				</cell>
				<cell>
					<paragraph>DOUBLE</paragraph>
				</cell>
				<cell>
					<paragraph>Standard double</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph>float</paragraph>
				</cell>
				<cell>
					<paragraph>REAL</paragraph>
				</cell>
				<cell>
					<paragraph>2 bytes real</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph>int</paragraph>
				</cell>
				<cell>
					<paragraph>INTEGER</paragraph>
				</cell>
				<cell>
					<paragraph>Standard integer</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph>long</paragraph>
				</cell>
				<cell>
					<paragraph>INTEGER</paragraph>
				</cell>
				<cell>
					<paragraph>Standard integer</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph>short</paragraph>
				</cell>
				<cell>
					<paragraph>INTEGER</paragraph>
				</cell>
				<cell>
					<paragraph>2 bytes integer</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph>BSTR</paragraph>
				</cell>
				<cell>
					<paragraph>STRING</paragraph>
				</cell>
				<cell>
					<paragraph>Standard string</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph>CURRENCY</paragraph>
				</cell>
				<cell>
					<paragraph>ECOM_CURRENCY</paragraph>
				</cell>
				<cell>
					<paragraph>Currency value</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph>DATE</paragraph>
				</cell>
				<cell>
					<paragraph>DATE_TIME</paragraph>
				</cell>
				<cell>
					<paragraph>Standard date</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph>SCODE</paragraph>
				</cell>
				<cell>
					<paragraph>INTEGER</paragraph>
				</cell>
				<cell>
					<paragraph>Return status</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph>Interface IDispatch *</paragraph>
				</cell>
				<cell>
					<paragraph> ECOM_INTERFACE</paragraph>
				</cell>
				<cell>
					<paragraph>Automation interface</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph>Interface IUnknown *</paragraph>
				</cell>
				<cell>
					<paragraph> ECOM_INTERFACE</paragraph>
				</cell>
				<cell>
					<paragraph>Generic interface</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph>dispinterface</paragraph>
				</cell>
				<cell>
					<paragraph> ECOM_INTERFACE</paragraph>
				</cell>
				<cell>
					<paragraph>Automation interface</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph>Coclass Typename </paragraph>
				</cell>
				<cell>
					<paragraph>TYPE_NAME</paragraph>
				</cell>
				<cell>
					<paragraph>Component main class</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph>SAFEARRAY(TypeName)</paragraph>
				</cell>
				<cell>
					<paragraph> ECOM_ARRAY [TypeName]</paragraph>
				</cell>
				<cell>
					<paragraph>Array</paragraph>
				</cell>
			</row>
			<row>
				<cell>
					<paragraph>TypeName*</paragraph>
				</cell>
				<cell>
					<paragraph>CELL [TypeName]</paragraph>
				</cell>
				<cell>
					<paragraph>Pointer to type</paragraph>
				</cell>
			</row>
			<row>
				<cell>VARIANT</cell>
				<cell>ECOM_VARIANT</cell>
				<cell>Variant value</cell>
			</row>
			<row>
				<cell>enum</cell>
				<cell>INTEGER</cell>
				<cell>Enumeration</cell>
			</row>
			<row>
				<cell>
					<paragraph>Decimal</paragraph>
				</cell>
				<cell>
					<paragraph>ECOM_DECIMAL</paragraph>
				</cell>
				<cell>
					<paragraph> Decimal value</paragraph>
				</cell>
			</row>
		</table>The other advantage is a more dynamic discovery of the methods and properties of a component at runtime. Indeed the IDispatch interface also includes methods to check whether a method or property is available and, in that case, get its identifier. This process is called late binding and allows component to discover at runtime what are other components functionality.
		<paragraph>This approach has also a lot of drawbacks: first, late binding is not an efficient way of calling a function on an interface since its identifier must first be requested and then the function called. That's two round trips which can be expensive in a distributed environment. Second, since the marshaler is built-in, it has to know in advance all the possible types that a function can accept to be able to marshal the corresponding data. There are consequently a limitation on the number of types that one can use in signatures of functions on an Automation compatible interface. The set of available types is called Variant and cover most of the standard types. It does not allow however the passing of complex user defined data types. For these reasons Automation is mostly used in scripting environments (where speed is not an important factor) to accomplish simple tasks. </paragraph>
		<heading>
			<size>2</size>Direct Access
		</heading>Direct interface access is the preferred way to access remote servers where speed becomes a concern and data types are specific to the application. The first interface pointer on the component is obtained through the class object (see 
		<link>
			<url>04_coclass.xml</url>
			<label>Class Object</label>
		</link> ). Other interfaces on the component are obtained by calling the QueryInterface function.
		<paragraph>As information on any interface cannot be accessed dynamically, the description of the interfaces must be provided to tools that need to handle the components such as the EiffelCOM wizard. The official way of describing components and interfaces is through IDL. Once an IDL file has been written to describe a component it can be compiled with MIDL to generate both a type library and the code for the marshaller specific to that interface. </paragraph>
		<heading>
			<size>2</size>EiffelCOM
		</heading>The idea in EiffelCOM is the way a component is accessed is implementation detail that the user should not have to deal with. Of course he should be able to choose what kind of access he wants to use but this choice should have no impact on the design of the Eiffel system itself. For that reason, the Eiffel code generated by the wizard follows the same architecture independently of the choice made for interface access and marshalling. The difference lies in the runtime where the actual calls to the components are implemented. 
		<seealso>
			<bold>See Also</bold>
			<line_break/>
			<link>
				<url>../../tools/wizards/com/index.xml</url>
				<label>EiffelCOM wizard</label>
			</link>
			<line_break/>
			<link>
				<url>../../libraries/com/index.xml</url>
				<label> EiffelCOM library</label>
			</link>
			<line_break/>
			<link>
				<url>01_introduction.xml</url>
				<label> Introduction</label>
			</link>
			<line_break/>
			<link>
				<url>02_generalities.xml</url>
				<label>Generalities</label>
			</link>
			<line_break/>
			<link>
				<url>03_interfaces.xml</url>
				<label> COM Interfaces</label>
			</link>
			<line_break/>
			<link>
				<url>04_coclass.xml</url>
				<label> Coclasses</label>
			</link>
			<line_break/>
			<link>
				<url>05_component_location.xml</url>
				<label> Component Location</label>
			</link>
			<line_break/>
			<link>
				<url>07_deeper_into_com.xml</url>
				<label> Deeper into COM</label>
			</link>
		</seealso>
	</paragraph></document>
