<!DOCTYPE HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">

<HTML>
	<HEAD>
		<TITLE>EiffelBase Data Structures, Tables</TITLE>
		<LINK REL=StyleSheet HREF="../../../../default.css">
	</HEAD>

	<BODY>
        <h1>Hash Tables</h1>
        <p>Hash tables are a convenient mechanism to store and retrieve objects
        identified by unique keys.
        <h2>Why use hash tables?</h2>
        The main advantage of hash tables is the efficiency of the basic
        operations: store (<a HREF="../../reference/10_kernel/hash_table.html#f_put">put</a>)
        and retrieve (<a HREF="../../reference/10_kernel/hash_table.html#f_item">item</a>,
        <a HREF="../../reference/10_kernel/hash_table.html#f_remove">remove</a>).<br>
        The idea behind hash tables is to try to emulate the data structure that
        provides the ultimate in efficiency: the array. On an array <span CLASS="elocal">a</span>,
        for some integer <span CLASS="elocal">i</span> whose value lies within
        the bounds of<span CLASS="elocal">a</span>, the basic operations are
        <p CLASS="code"><span CLASS="elocal">a</span><span CLASS="esymbol">.</span><a CLASS="efeature" HREF="../../reference/10_kernel/hash_table.html#f_put">put</a>
        <span CLASS="esymbol">(</span><span CLASS="elocal">x</span><span CLASS="esymbol">,</span>
        <span CLASS="elocal">i</span><span CLASS="esymbol">)</span><br>
        <span CLASS="elocal">x</span> <span CLASS="esymbol">:=</span> <span CLASS="elocal">a</span><span CLASS="esymbol">.</span><a CLASS="efeature" HREF="../../reference/10_kernel/hash_table.html#f_item">item</a>
        <span CLASS="esymbol">(</span><span CLASS="elocal">i</span><span CLASS="esymbol">)</span><br>
        <span CLASS="elocal">x</span> <span CLASS="esymbol">:=</span> <span CLASS="elocal">a</span>
        <a CLASS="efeature" HREF="../../reference/10_kernel/hash_table.html#f__infix_@">@</a>
        <span CLASS="elocal">i</span></p>
        <p>The first causes the value of a at index <span CLASS="elocal">i</span>
        to be <span CLASS="elocal">x</span>; the second (and the third, which is
        simply a syntactical variant) access the value at index <span CLASS="elocal">i</span>
        and assign it to <span CLASS="elocal">x</span>. With the usual computer
        architectures, these operations are very fast: because arrays items are
        stored contiguously in memory, a computer will need just one addition
        (base address plus index) and one memory access to perform a <a CLASS="elocal" HREF="../../reference/10_kernel/hash_table.html#f_put">put</a>
        or <a CLASS="elocal" HREF="../../reference/10_kernel/hash_table.html#f_item">item</a>.<br>
        Not only are the operation times small; they are constant (or more
        precisely bounded by a constant). This is a great advantage over
        structures such as lists or trees which you must traverse at least in
        part to retrieve an item, so that access and modification times grow
        with the number of items. With an array, disregarding the influence of
        other factors such as memory paging, the time for a put or item is for
        all practical purposes the same whether the array has five items or five
        hundred thousand. These properties make arrays excellent data structures
        for keeping objects. Unfortunately, they are only applicable if the
        objects satisfy three requirements:
        <ul>
          <li><b>A1</b>. For each object there must be an associated integer,
            which for the purpose of this discussion we may call the object’s
            index (since it will serve as index for the object in the array.)
          <li><b>A2</b>. No two objects may have the same index.
          <li><b>A3</b>. If we want to avoid wasting huge amount of storage, all
            the indices must lie in a contiguous or almost contiguous range.
        </ul>
        <p>Hash tables may be viewed as a rehabilitation mechanism for objects
        that do not naturally possess these three properties. If we are unable
        to find a natural index, we can sometimes devise an artificial one. To
        do so we must be able to find a key. Each key must uniquely identify the
        corresponding object; this is the same as property <b>A2</b>, making
        keys similar to indices. But keys are not necessarily integers
        (violating property <b>A1</b>), although it must be possible to
        associate an integer with each key. The mechanism that maps keys to
        integers is called the hashing function.<br>
        Thanks to the hashing mechanism we will indeed be able to store suitable
        objects into arrays, approaching the optimal efficiency of this data
        structure. The efficiency will not be quite as good, however, for two
        reasons:
        <ul>
          <li>We must pay the price of computing the hash function whenever we
            store or retrieve an object.
          <li>Different keys may hash into the same integer value, requiring
            extra processing to find an acceptable index.
        </ul>
        <p>With good implementations, however, it is possible to use hash tables
        with a performance that is not much worse than that of arrays and, most
        importantly, may be treated as if the time for a put, an item or a
        remove were constant. This will mean that you can consider operations
        such as
        <p CLASS="code"><span CLASS="elocal">h</span><span CLASS="esymbol">.</span><a CLASS="efeature" HREF="../../reference/10_kernel/hash_table.html#f_put">put</a>
        <span CLASS="esymbol">(</span><span CLASS="elocal">x</span><span CLASS="esymbol">,</span>
        <span CLASS="elocal">k</span><span CLASS="esymbol">)</span><br>
        <span CLASS="elocal">h</span> <span CLASS="esymbol">:=</span> <span CLASS="elocal">a</span><span CLASS="esymbol">.</span><a CLASS="efeature" HREF="../../reference/10_kernel/hash_table.html#f_item">item</a>
        <span CLASS="esymbol">(</span><span CLASS="elocal">k</span><span CLASS="esymbol">)</span></p>
        <p>where <span CLASS="elocal">h</span> is a hash-table and <span CLASS="elocal">k</span>
        is a key (for example a string) as conceptually equivalent to the array
        operations mentioned above.<br>
        The quality of a hashed implementation will depend both on the data
        structure that will store the objects, and on the choice of hashing
        function. Class <a HREF="../../reference/10_kernel/hash_table_chart.html">HASH_TABLE</a>
        attempts to address the first concern; for the second, client developers
        will be responsible for choosing the proper hashing function, although
        Base provides a few predefined functions, in particular for class <a HREF="../../reference/10_kernel/string_chart.html">STRING</a>.
        <h2>When hash tables are appropriate</h2>
        <p>You may keep objects in a hash table if for each one of these objects
        you can find a key that uniquely identifies it. The objects and their
        keys may be of many possible kinds:
        <ul>
          <li><b>H1</b>. In a simple example, the objects are integers; each
            integer serves as its own key. (More precisely we will use its
            absolute value, since it is convenient to have non-negative keys
            only.) This case is of more than theoretical interest, since it
            makes hash tables appropriate for storing a set of integers with
            widely scattered values, for which simple array storage would be a
            waste of space (see requirement <b>A3</b> above).
          <li><b>H2</b>. Frequently, the objects will be composite, that is to
            say, instances of a developer-defined class, and one of the
            attributes of that class, of type <a HREF="../../reference/10_kernel/string_chart.html">STRING</a>,
            can serve as the key. For example if you were writing an Eiffel
            compiler you would probably need to keep a data structure that
            includes information about classes of the system. Each class is
            represented by an object with several fields describing the
            properties of the class; one of these fields, the class name,
            corresponding to an attribute of type <a HREF="../../reference/10_kernel/string_chart.html">STRING</a>,
            will serve as key.
          <li><b>H3</b>. Instead of being the full object (as in case <b>H1</b>)
            or one of the object’s fields (as in case <b>H2</b>), the key may
            have to be computed through a function of the generating class,
            which will take into account several attributes of the class (that
            is to say, for each object, several fields).
        </ul>
        <p>What this practically means is that in all cases you will need, in
        the generating class of the objects to be stored, a query (attribute or
        function) that gives the key.
        <h2>Using hash tables</h2>
        <p>Class <a HREF="../../reference/10_kernel/hash_table_chart.html">HASH_TABLE</a>
        takes two generic parameters:
        <p CLASS="code"><span CLASS="ekeyword">class</span> <a HREF="../../reference/10_kernel/hash_table_chart.html">HASH_TABLE</a>
        [G, H ] ...</p>
        <p>G represents the type of the objects to be stored in the hash table,
        H the type of their keys.<br>
        When viewed as an implementation of containers, <a HREF="../../reference/10_kernel/hash_table_chart.html">HASH_TABLE</a>,
        in a strict sense, represents bags rather than sets: unlike the other
        classes in this chapter, it allows an object to have two or more
        distinct occurrences in a single container. But this is only true if we
        consider a hash table as a repository of objects of type G. In reality
        each item of the table is identified by a pair of values, one from G and
        one from H. Because the keys must uniquely identify objects, the hash
        table viewed as a container of such pairs is indeed a set. The creation
        procedure <a CLASS="efeature" HREF="../../reference/10_kernel/hash_table.html#f_make">make</a>
        takes an integer argument, as in<p CLASS="code"><span CLASS="ekeyword">create</span> <span CLASS="elocal">my_table</span><span CLASS="esymbol">.</span><a CLASS="efeature" HREF="../../reference/10_kernel/hash_table.html#f_make">make</a>
        <span CLASS="esymbol">(</span><span CLASS="elocal">n</span><span CLASS="esymbol">)</span></p>
        <p>The value of <span CLASS="elocal">n</span> indicates how many items
        the hash table is expected to have to accommodate. This number of items
        is not a hardwired size, just information passed to the class. In
        particular:
        <ul>
          <li>The actual size of the underlying array representation will be
            higher than n since efficient operation of hash table algorithms
            require the presence of enough breathing space - unoccupied
            positions.
          <li>If the number of items in the table grows beyond the initial
            allocation, the table will automatically be resized.
        </ul>
        <p>It is useful, however, to use a reasonable <span CLASS="elocal">n</span>
        upon creation: not too large to avoid wasting space, but not too small
        to avoid frequent applications of resizing, an expensive operation.
	</BODY>
</HTML>
