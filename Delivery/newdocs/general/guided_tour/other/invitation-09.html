<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="tour.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE> 8  EVENT-DRIVEN PROGRAMMING AND AGENTS</TITLE>
</HEAD>
<!--------------------------------------------------->
<SCRIPT LANGUAGE="Javascript">
	// Default values
	var oNewWindow = 0;

	function ImageClick( oImage )
	{
		if( oNewWindow == 0 || oNewWindow.closed )
		{
			oNewWindow = window.open (oImage.src,"", "status=no, toolbar=no, menubar=no, location=no, resizable=yes");
		}
		else
		{
			oNewWindow.location = oImage.src;
		}
	}
</SCRIPT>
<!--------------------------------------------------->
<body bgcolor="#faf0e6">
<DIV>
<p class="top" align="center"><a href="http://www.eiffel.com">Eiffel Home Page (Web)</a> -- <a href="../index.html">Getting started with Eiffel (local)</a>

<img src="power.gif" ALT="Eiffel Home Page" align="right" border="0"  usemap="#eiffel"><map name="eiffel"><area shape="RECT" alt="Eiffel Home Page" coords="0,0,109,226" HREF="http://www.eiffel.com"><area shape="default" nohref></map>

<p class="top" ALIGN="left"><IMG SRC="normaldoc.gif" ALT="Previous, Up, Next" BORDER="0" WIDTH="300" HEIGHT="40" USEMAP="#navigation"><map name="navigation"><AREA SHAPE="RECT" alt="Previous section" COORDS="0,0,95,40" HREF="invitation-08.html"><AREA SHAPE="RECT" alt="Up" COORDS="96,0,199,40" HREF="invitation.html"><AREA SHAPE="RECT" alt="Next section" COORDS="200,0,300,40" HREF="invitation-10.html"><area shape="default" nohref></MAP>
</DIV>
<H1 CLASS="aa-sec2">
<A NAME="pgfId-512753"></A>8  EVENT-DRIVEN PROGRAMMING AND AGENTS</H1>
<P CLASS="nn-first">
<A NAME="pgfId-512754"></A>The division of roles in object technology is clear: of the two principal constituents of a system, <SPAN CLASS="ff-italics">
object types</SPAN>
 and <SPAN CLASS="ff-italics">
operations</SPAN>
, the first dominates. Classes, representing object types, determines the structure of the software; every routine, representing an operations, belongs to a class.
<P CLASS="nn-normal">
<A NAME="pgfId-512769"></A>In some circumstances it is useful to define an <SPAN CLASS="ff-italics">
object</SPAN>
 that denotes an <SPAN CLASS="ff-italics">
operation</SPAN>
. This is especially useful if you want to build an object structure that refers to operations, so that you can later traverse the structure and execute the operations encountered. A typical application is <SPAN CLASS="ff-bold">
event-driven programming</SPAN>
 for Graphical User Interfaces (GUI), including Web programming. In GUI programming you will want to record properties of the form
<p><ul><table bgcolor="#cfffcf" width="79%" BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltext">
<A NAME="pgfId-512772"></A>&quot;When the user clicks on this OK button, the system must update the file&quot;
</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-512773"></A>each involves a <SPAN CLASS="ff-bold">
control</SPAN>
 (here the OK button), an <SPAN CLASS="ff-bold">
event</SPAN>
 (mouse click) and an <SPAN CLASS="ff-bold">
operation</SPAN>
 (update the file). This can be programmed by having an &quot;event loop&quot;, triggered for each event, which performs massive decision-making (<SPAN CLASS="ee-keyword">
if</SPAN>
 <SPAN CLASS="ee-comment">
&quot;The latest event was `left mouse click on button 23&quot;</SPAN>
<SPAN CLASS="ee-keyword">
 then </SPAN>
<SPAN CLASS="ee-comment">
&quot;Appropriate instructions&quot; </SPAN>
<SPAN CLASS="ee-keyword">
else if</SPAN>
<SPAN CLASS="tt-nsymbol">
 &#8230;</SPAN>
 and so on with many branches); but this leads to bulky software architectures where introducing any new control or event requires updating a central part of the code. It's preferable to let any element of the system that encounters a new control-event-operation association
<p><ul><table bgcolor="#cfffcf" width="79%" BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-512798"></A><SPAN CLASS="ee-comment">
[</SPAN>
control, event, operation<SPAN CLASS="ee-comment">
]</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-512799"></A>store it as a triple of objects into an object structure, such as an array or a list. Triples in that structure may come from different parts of the system; there is no central know-it-all structure. The only central element is a simple mechanism which can explore the object structure to execute each <SPAN CLASS="ee-text">
operation</SPAN>
 associated with a certain <SPAN CLASS="ee-text">
control</SPAN>
 and a certain <SPAN CLASS="ee-text">
event</SPAN>
. The mechanism is not just simple; it's also independent of your application, since it doesn't need to know about any particular control, event or operation (it will find them in the object structure). So it can be programmed once and for all, as part of a library such as ISE's EiffelVision 2 for platform-independent graphics.
<P CLASS="nn-normal">
<A NAME="pgfId-513045"></A>To build an object structure, we need objects. A <SPAN CLASS="ee-text">
control</SPAN>
, an <SPAN CLASS="ee-text">
event</SPAN>
 are indeed objects. But an <SPAN CLASS="ee-text">
operation</SPAN>
 is not: it's program code -- a routine of a certain class.
<P CLASS="nn-normal">
<A NAME="pgfId-513046"></A>Agents address this issue. An agent is an <SPAN CLASS="ff-italics">
object</SPAN>
 that represents a <SPAN CLASS="ff-italics">
routine</SPAN>
, which can then be kept in an object structure. The simplest form of agent is written <SPAN CLASS="ee-keyword">
agent</SPAN>
<SPAN CLASS="ee-text">
 r</SPAN>
, where <SPAN CLASS="ee-text">
r</SPAN>
 is a routine. This denotes an object. If <SPAN CLASS="ee-text">
your_agent</SPAN>
 is such an agent object, the call
<p><ul><table bgcolor="#cfffcf" width="79%" BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-513049"></A>your_agent<SPAN CLASS="ee-dot">
.</SPAN>
<SPAN CLASS="ee-text">
call </SPAN>
<SPAN CLASS="ee-comment">
([</SPAN>
<SPAN CLASS="ee-text">
a, b</SPAN>
<SPAN CLASS="ee-comment">
])</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-512835"></A>where <SPAN CLASS="ee-text">
a</SPAN>
 and <SPAN CLASS="ee-text">
b</SPAN>
 are valid arguments for <SPAN CLASS="ee-text">
r</SPAN>
, will have the same effect as a direct call to <SPAN CLASS="ee-text">
r </SPAN>
with arguments <SPAN CLASS="ee-text">
a</SPAN>
 and <SPAN CLASS="ee-text">
b</SPAN>
. Of course, if you know that you want to call <SPAN CLASS="ee-text">
r</SPAN>
 with those arguments, you don't need any agents; just use the direct call <SPAN CLASS="ee-text">
r </SPAN>
<SPAN CLASS="ee-comment">
(</SPAN>
<SPAN CLASS="ee-text">
a, b</SPAN>
<SPAN CLASS="ee-comment">
)</SPAN>
. The benefit of using an agent is that you can store it into an object structure to be called <SPAN CLASS="ff-bold">
later</SPAN>
, for example when an event-driven mechanism finds the agent in the object structure, associated with a certain control and a certain event. For this reason agents are also called <SPAN CLASS="ff-bold">
delayed calls</SPAN>
.
<P CLASS="jj-small">
<A NAME="pgfId-512966"></A>The notation <SPAN CLASS="ee-comment">
[</SPAN>
<SPAN CLASS="ee-text">
a, b</SPAN>
<SPAN CLASS="ee-comment">
]</SPAN>
 denotes a sequence of elements, or <SPAN CLASS="ff-bold">
tuple</SPAN>
. The reason <SPAN CLASS="ee-text">
call</SPAN>
 needs a tuple as argument, whereas the direct call <SPAN CLASS="ee-text">
r </SPAN>
<SPAN CLASS="ee-comment">
(</SPAN>
<SPAN CLASS="ee-text">
a, b</SPAN>
<SPAN CLASS="ee-comment">
)</SPAN>
 doesn't, is that <SPAN CLASS="ee-text">
call</SPAN>
 is a general routine (from the EiffelBase class <SPAN CLASS="ee-text">
ROUTINE</SPAN>
, representing agents) applicable to any agent, whereas the direct call refers explicitly to <SPAN CLASS="ee-text">
r</SPAN>
 and hence requires arguments <SPAN CLASS="ee-text">
a</SPAN>
 and <SPAN CLASS="ee-text">
b</SPAN>
 of specific types. The agent mechanism, however, is statically typed like the rest of the language; when you call <SPAN CLASS="ee-text">
call</SPAN>
, the type checking mechanism ensures that the tuple you pass as argument contains elements <SPAN CLASS="ee-text">
a</SPAN>
 and <SPAN CLASS="ee-text">
b</SPAN>
 of the appropriate types.
<P CLASS="nn-first">
<A NAME="pgfId-512841"></A>A typica use of agents with EiffelVision 2 is
<p><ul><table bgcolor="#cfffcf" width="79%" BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-512853"></A>ok_button<SPAN CLASS="ee-keyword">
.</SPAN>
 click_actions<SPAN CLASS="ee-keyword">
.</SPAN>
extend <SPAN CLASS="ee-comment">
(</SPAN>
<SPAN CLASS="ee-keyword">
agent</SPAN>
 your_routine<SPAN CLASS="ee-comment">
)</SPAN>

</TD>
</TR>
</table></ul><p>
<P CLASS="nn-first">
<A NAME="pgfId-512897"></A>which says: &quot;add <SPAN CLASS="ee-text">
your_routine</SPAN>
 to the list of operations to be performed whenever the event <SPAN CLASS="ee-text">
click</SPAN>
 happens on <SPAN CLASS="ee-text">
ok_button</SPAN>
&quot;. <SPAN CLASS="ee-text">
ok_button</SPAN>
<SPAN CLASS="ee-dot">
.</SPAN>
<SPAN CLASS="ee-text">
click_actions</SPAN>
 is the list of agents associated with the button and the event; in list classes, procedure <SPAN CLASS="ee-text">
extend</SPAN>
 adds an item at the end of a list. Here, the object to be added is the agent.
<P CLASS="nn-normal">
<A NAME="pgfId-512900"></A>This enables the EiffelVision event-handling mechanism to find the appropriate agent when it processes an event, and call <SPAN CLASS="ee-text">
call</SPAN>
 on that agent to trigger the appropriate routine. EiffelVision doesn't know that it's <SPAN CLASS="ee-text">
your_routine</SPAN>
; in fact, it doesn't know anything about your application. It simply finds an agent in the list, and calls <SPAN CLASS="ee-text">
call</SPAN>
 on it. For your part, as the author of a graphical application, you don't need to know how EiffelVision handles events; you simply associate the desired agents with the desired controls and events, and let EiffelVision 2 do the rest.
<P CLASS="nn-normal">
<A NAME="pgfId-513079"></A>Agents extend to many areas beyond GUIs. In <SPAN CLASS="ff-bold">
numerical computation</SPAN>
, you may use an agent to pass to an &quot;integrator&quot; object a numerical function to be integrated over a certain interval. In yet another area, you can use agents (as in the iteration library of EiffelBase) to program <SPAN CLASS="ff-bold">
iterators</SPAN>
: mechanisms that repetitively apply an arbitrary operation -- represented by an agent -- to every element of a list, tree or other object structure. More generally, agent embody properties of the associated routines, opening the way to mechanism for <SPAN CLASS="ff-bold">
reflection</SPAN>
, also called &quot;introspection&quot;: the ability, during software execution, to discover properties of the software itself.
<p class="bottom" ALIGN="left"><IMG SRC="normaldoc.gif" ALT="Previous, Up, Next" BORDER="0" WIDTH="300" HEIGHT="40" USEMAP="#navigation"><map name="navigation"><AREA SHAPE="RECT" alt="Previous section" COORDS="0,0,95,40" HREF="invitation-08.html"><AREA SHAPE="RECT" alt="Up" COORDS="96,0,199,40" HREF="invitation.html"><AREA SHAPE="RECT" alt="Next section" COORDS="200,0,300,40" HREF="invitation-10.html"><area shape="default" nohref></MAP>

<p class="bottom" align="center"><a href="http://www.eiffel.com">Eiffel Home Page (Web)</a> -- <a href="../index.html">Getting started with Eiffel (local)</a>

<p class="copyright" align="center">Copyright Interactive Software Engineering, 2001
</BODY>
</HTML>
