<document title="Thread library overview">
	<meta_data>
		<help>
			<toc>				
				<envision_pseudo_name>10</envision_pseudo_name>
				<envision_title>Overview</envision_title>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph>This is only a quick overview of the 
			<link>
				<url>/libraries/thread/index.xml</url>
				<label>Thread library</label>
			</link>. The reference of this library should give all its content.
		</paragraph>
		<heading>
			<size>2</size>Creating and launching threads: the class THREAD (deferred)
		</heading>
		<paragraph>The class of the thread object you want to create should inherit the 
			<class_name>THREAD</class_name> class.
			<line_break/>Your thread is represented by a class which inherits from 
			<class_name>THREAD</class_name> (deferred class).
			<line_break/>
			<paragraph>
<code_block>
	<keyword>class</keyword>
		<class_name>MY_THREAD</class_name>

	<keyword>inherit</keyword>
		<class_name>THREAD</class_name>
		...

	<keyword>feature</keyword>

		<feature_name>execute</feature_name> <keyword>is</keyword>
				<comment>-- define the deferred feature from THREAD.</comment>
			<keyword>do</keyword>
				...
			<keyword>end</keyword>
		...

	<keyword>end</keyword> -- <keyword>class</keyword> <class_name>MY_THREAD</class_name>
</code_block>
Creating a thread is like creating an Eiffel object:
<code_block>
	<feature_name>my_thread</feature_name><symbol>:</symbol> <class_name>MY_THREAD</class_name>
		<comment>-- MY_THREAD inherits from THREAD and defines</comment>
		<comment>-- the deferred procedure `execute'</comment>

	<keyword>create</keyword><feature_name> my_thread</feature_name>
</code_block>
				<note>
					<bold>Note</bold>: You have created a thread object but have not started the thread itself yet.
					<line_break/>To run the thread, use the feature 
					<feature_name>launch</feature_name> from 
					<class_name>THREAD</class_name>.
				</note>
				<code_block>	<feature_name>my_thread</feature_name>.<feature_name>launch</feature_name></code_block>On the Eiffel side, the procedure 
				<feature_name>execute</feature_name> will be launched. This procedures deferred in class 
				<class_name>THREAD</class_name>, you have to define it in 
				<class_name>MY_THREAD</class_name>.
				<paragraph>On the C side, a C thread will be created and launched.
					<warning>
						<bold>Caution</bold>: you may call 
						<feature_name>join_all</feature_name> and the end of the execution of the parent thread if you do not want it to die before its child, otherwise they may prematurely terminate.
						<heading>
							<size>2</size>The class MUTEX
						</heading>
						<paragraph>The implementation of the class 
							<class_name>MUTEX</class_name> is mapped on the C standard thread library. An instance of class 
							<class_name>MUTEX</class_name> can be shared between different thread.
							<paragraph>
								<feature_name>my_mutex.pointer</feature_name> is the pointer to the nested C mutex of <feature_name>my_mutex</feature_name>.
								<list ordered="false">
									<item>Declaration of the mutex:
										<code_block>	<feature_name>my_mutex</feature_name><symbol>:</symbol> <class_name>MUTEX</class_name></code_block>
									</item>
									<item>Creation of mutex:
										<code_block>	<keyword>create</keyword> <feature_name>my_mutex</feature_name>.<feature_name>make</feature_name></code_block>
									</item>
									<item>Locking the mutex:
										<code_block>	<feature_name>my_mutex</feature_name>.<feature_name>lock</feature_name></code_block>
									</item>
									<item>Unlocking the mutex:
										<code_block>	<feature_name>my_mutex</feature_name>.<feature_name>unlock</feature_name></code_block>
									</item>
									<item>
										<feature_name>try_lock</feature_name>: if it is not locked yet, lock the mutex and return True, otherwise it returns False.
										<code_block>	<feature_name>my_mutex</feature_name>.<feature_name>lock</feature_name></code_block>
									</item>
									<item>Is my mutex initialized?
										<code_block>	<feature_name>my_mutex</feature_name>.<feature_name>is_set</feature_name></code_block>
									</item>
								</list>
								<note>
									<bold>Note</bold>: on Windows: The 
									<class_name>MUTEX</class_name> objects on Windows are recursive while they are not on Unix. A recursive mutex can be locked twice by the same thread.
								</note>
								<warning>
									<bold>Caution</bold>: be sure that a mutex is unlocked when it is disposed.
								</warning>
								<heading>
									<size>2</size>The class SEMAPHORE
								</heading>
								<paragraph>Like 
									<class_name>MUTEX</class_name>, the features of this class are mapped on the C thread library. An instance of class 
									<class_name>SEMAPHORE</class_name> can be shared between thread.
									<list ordered="false">
										<item>Declaration of the semaphore :
											<paragraph>
												<code_block>	<local_variable>my_sem</local_variable><symbol>: </symbol><class_name>SEMAPHORE</class_name></code_block>
											</paragraph>Creation of semaphore: initialize semaphore with nb_tokens, it requires nb_tokens &gt; = 0
											<code_block>	<keyword>create</keyword> <feature_name>my_sem</feature_name>.<feature_name>make</feature_name> <symbol>(</symbol><feature_name>nb_tokens</feature_name><symbol>)</symbol></code_block>
										</item>
										<item>Wait for a token:
											<code_block>	<feature_name>my_sem</feature_name>.<feature_name>wait</feature_name></code_block>
										</item>
										<item>Give back a token:
											<code_block>	<feature_name>my_sem</feature_name>.<feature_name>post</feature_name></code_block>
										</item>
										<item>
											<feature_name>try_wait</feature_name>, similar to try_lock from 
											<class_name>MUTEX</class_name>, if a token is available, take it and return 
											<code>
												<symbol>True</symbol>
											</code>, otherwise return 
											<code>
												<symbol>False</symbol>
											</code>.
											<code_block>	<feature_name>my_sem</feature_name>.<feature_name>try_wait</feature_name></code_block>
										</item>
									</list>
									<warning>
										<bold>Caution</bold>: be sure that a semaphore does not wait for a token when it is disposed
									</warning>
									<heading>
										<size>2</size>The class CONDITION_VARIABLE
									</heading>
									<paragraph>This class allows to use condition variables in Eiffel. An instance of class 
										<class_name>CONDITION_VARIABLE</class_name> can be shared between threads.
										<list ordered="false">
											<item>Declaration of the condition variable
												<code_block>	<feature_name>my_cond</feature_name><symbol>:</symbol> <class_name>CONDITION_VARIABLE</class_name></code_block>
											</item>
											<item>Creation:
												<code_block>	<keyword>create</keyword> <feature_name>my_cond</feature_name>.<feature_name>make</feature_name></code_block>
											</item>
											<item>Wait for a signal (send by 
												<feature_name>signal</feature_name>). You need to use a mutex.
<code_block>
	<feature_name>my_mutex</feature_name><symbol>:</symbol> <class_name>MUTEX</class_name>

	<keyword>create</keyword> <feature_name>my_mutex</feature_name>.<feature_name>make</feature_name>
</code_block>
												<paragraph>
													<code>
														<local_variable>my_mutex</local_variable>
													</code> must be locked by the calling thread so as 
													<feature_name>wait</feature_name> can be called. 
													<feature_name>wait</feature_name> atomically unlocks 
													<code>
														<local_variable>my_mutex</local_variable>
													</code> and waits for the condition variable 
													<code>
														<local_variable>my_mutex</local_variable>
													</code> to receive a signal. As soon as it received a signal, 
													<code>
														<local_variable>my_cond</local_variable>
													</code> locks 
													<code>
														<local_variable>my_mutex</local_variable>
													</code>;
<code_block>
	<feature_name>my_mutex</feature_name>.<feature_name>lock</feature_name>
		<comment>-- You must lock `my_mutex' before calling wait.</comment>

	<feature_name>my_cond</feature_name>.<feature_name>wait</feature_name> <symbol>(</symbol><feature_name>my_mutex</feature_name><symbol>)</symbol>
		<comment>-- Here the critical code to execute when `my_cond' received a signal.</comment>

	<feature_name>my_mutex</feature_name>.<feature_name>unlock</feature_name>
		<comment>-- Unlock the mutex at the end of the critical section.</comment>
</code_block>
												</paragraph>
											</item>
											<item>Send a signal one thread blocked on the condition variable `my_cond'.
												<code_block>	<feature_name>my_cond</feature_name>.<feature_name>signal</feature_name></code_block>
											</item>
											<item>Send a signal to all the threads blocked on the condition variable `my_cond'.
												<code_block>	<feature_name>my_cond</feature_name>.<feature_name>broadcast</feature_name></code_block>
											</item>
											<item>
												<warning>
													<bold>Caution</bold>: be sure that a condition variable is unblocked when it is disposed.
												</warning>
											</item>
										</list>
										<heading>
											<size>2</size>Miscellaneous classes
										</heading>
										<paragraph>class 
											<class_name>THREAD_ATTRIBUTES</class_name>: defines the attributes of an Eiffel Thread regarding the thread scheduling policy and priority.
											<heading>
												<size>2</size>Controlling execution: THREAD_CONTROL
											</heading>
											<list ordered="false">
												<item>
													<feature_name>yield</feature_name>: the calling thread yields its execution in favor of an other thread of same priority.
												</item>
												<item>
													<feature_name>join_all</feature_name>: the calling thread waits for all other threads to finished (all its children).
												</item>
												<item>A parent thread can wait for the termination of a child process through the feature 
													<feature_name>join</feature_name> of class 
													<class_name>THREAD_CONTROL</class_name> (inherited by 
													<class_name>THREAD</class_name>):
<code_block>
	<feature_name>thr</feature_name><symbol>:</symbol> <class_name>MY_THREAD</class_name>
	...
	<feature_name>thr</feature_name>.<feature_name>launch</feature_name>
	...
	<feature_name>thr</feature_name>.<feature_name>join</feature_name>
</code_block>
												</item>
											</list>
										</paragraph>
									</paragraph>
								</paragraph>
							</paragraph>
						</paragraph>
					</warning>
				</paragraph>
			</paragraph>
		</paragraph>
	</paragraph></document>
