<document title="7 CLASS VIEWS" output="studio">
	<meta_data></meta_data>
	<paragraph>
		<paragraph>
			<link>
				<url>tour-help.xml</url>
				<label>Help reading this manual</label>
			</link>
		</paragraph>
		<paragraph>We haven't even looked at a class text yet, but it's important anyway to see how EiffelStudio provides you with numerous, complementary 
			<span>views</span> of your software. The Context Tool is the primary place to look for such views.
		</paragraph>
		<paragraph>We'll need just one Development Window for the moment, the one that was targeted to 
			<code>
				<string>LIST</string>
			</code>. You can get rid of the others by closing their windows (through the top right cross mark on Windows and the equivalent in other window managers), or through 
			<code>
				<keyword>File</keyword>
			</code>
			<code>
				<symbol>--&gt;</symbol>
			</code>
			<code>
				<keyword>Close</keyword>
			</code> -- but don't select "Exit" which would take you out of EiffelStudio altogether!
		</paragraph>
		<note>
			<italic>If you don't see a tool targeted to </italic>
			<code>
				<string>LIST</string>
			</code>
			<italic>, just retarget one, as you know how to do this now, for example by typing the name followed by Enter in the Class Field at the top left.</italic>
		</note>
		<paragraph>First let's give ourselves more space. Right now we don't need the Cluster Tree, Feature Tree and Properties panes. Get rid of them by clicking the close buttons on the top right corner of the panes.</paragraph>
		<paragraph>You can get these panes back later by clicking the buttons in the toolbar or by going to the View, Tools Menu.</paragraph>
		<note>
			<italic>Another way to hide a pane is to click on the button in the toolbar or by unselecting them in the View, Tools Menu.</italic>
		</note>
		<paragraph>Two panes remain, showing the Editing Tool and the Context Tool.</paragraph>
		<div>
			<image_link>
				<url>index-26.png</url>
				<target>screenshots</target>
				<image>
					<url>index-26.png</url>
					<width>100</width>
				</image>
			</image_link>
		</div>
		<paragraph>Make sure the Context Tool pane is large enough; you can resize the window and, if necessary, narrow down the Editing Tool pane since we don't need it for the moment. Don't worry, though, if the Context Tool shows only part of the diagram, as it does on the last figure, since we will now use the Context Tool to display information other than the diagram, by selecting the corresponding tabs.</paragraph>
		<heading>
			<size>2</size>
			<content>The Class Tab</content>
		</heading>
		<paragraph>The first tab we'll look at is the Class Tab. You'll find it at the bottom of the Context Tool.</paragraph>
		<paragraph>This gives you access to many forms of information about the current class -- the target of the Development Window. A set of buttons at the top of the Context Tool enables you to display a number of 
			<bold>views</bold> of the class. The currently highlighted button indicates the default view: 
			<code>
				<keyword>Ancestors</keyword>
			</code>. You can see the others' names by moving the cursor over the various view icons, 
			<bold>without clicking</bold>, and reading the tooltips.
		</paragraph>
		<paragraph>The view currently displayed, 
			<code>
				<keyword>Ancestors</keyword>
			</code>, shows the inheritance structure that leads to the current target, 
			<code>
				<string>LIST</string>
			</code> :
		</paragraph>
		<div>
			<image_link>
				<url>index-29.png</url>
				<target>screenshots</target>
				<image>
					<url>index-29.png</url>
					<width>100</width>
				</image>
			</image_link>
		</div>
		<paragraph>This shows that 
			<code>
				<string>LIST</string>
			</code> is an heir of 
			<code>
				<string>CHAIN</string>
			</code> which itself, as an example of multiple inheritance, is an heir of 
			<code>
				<string>CURSOR_STRUCTURE</string>
			</code>, 
			<code>
				<string>INDEXABLE</string>
			</code>, and -- twice, as an example of 
			<span>repeated</span> inheritance -- 
			<code>
				<string>SEQUENCE</string>
			</code>. If, because of direct or indirect repeated inheritance, a class appears more than once, the display doesn't repeat its ancestry the second and subsequent times; the omitted repetition appears as just three dots, 
			<bold>...</bold>, as illustrated here for the second occurrences of 
			<code>
				<string>BAG</string>
			</code>, 
			<code>
				<string>ACTIVE</string>
			</code> and others.
		</paragraph>
		<paragraph>As you may have guessed, all the class names that appear on this display, by default in blue, can function as hyperlinks: you can use any one of them to retarget the Development Window to the corresponding class. This will be another major retargeting mechanism. But let's not pursue it for the moment and instead continue looking at the documentation views.</paragraph>
		<paragraph>Next to 
			<code>
				<keyword>Ancestors</keyword>
			</code> button is 
			<code>
				<keyword>Descendants</keyword>,
			</code>which will give you the descendants of a class in a similar format:
		</paragraph>
		<image_link>
			<url>index-30.png</url>
			<target>screenshots</target>
			<image>
				<url>index-30.png</url>
				<width>100</width>
			</image>
		</image_link>
		<paragraph>The progeny of 
			<code>
				<string>LIST</string>
			</code>, as you can see, is just as impressive as its ancestry.
		</paragraph>
		<paragraph>Let's now look at the other formats, starting from the left. The first button, 
			<code>
				<keyword>Clickable</keyword>
			</code>, gives the class text. It's essentially the same information as appears in the top Editing Tool (whose pane was reduced to its bare minimum in the last few pictures, showing only the first three lines or so), but with some differences:
		</paragraph>
		<list ordered="false">
			<item>The top Text view is editable. In fact it's EiffelStudio's primary tool for entering software texts. The bottom 
				<code>
					<keyword>Clickable</keyword>
				</code> view is just a view; you can't change it.
			</item>
			<item>The Text view retains the formatting of the class text the way it was typed in; the 
				<code>
					<keyword>Clickable</keyword>
				</code> view is automatically formatted -- "pretty-printed" -- according to the standard Eiffel layout rules.
			</item>
			<item>The 
				<code>
					<keyword>Clickable</keyword>
				</code> view does not include comments inside routine implementations ( 
				<code>
					<keyword>do</keyword>
				</code> and 
				<code>
					<keyword>once</keyword>
				</code> clauses), although it does retain features' header comments.
			</item>
			<item>As part of the pretty-printing, the 
				<code>
					<keyword>Clickable</keyword>
				</code> view uses colors and fonts to distinguish keywords, identifiers, comments and other syntactical elements. You can change the fonts and colors, like many other elements of the interface, through 
				<code>
					<keyword>Tools</keyword>
				</code>
				<code>
					<symbol>--&gt;</symbol>
				</code>
				<code>
					<keyword>Preferences</keyword>
				</code>. (Now is not the time.)
			</item>
		</list>
		<paragraph>This view is called "clickable" because, as we'll see later, every syntactical element on it is a hyperlink, which you can use for browsing. </paragraph>
		<paragraph>After 
			<code>
				<keyword>Clickable</keyword>
			</code> comes the 
			<code>
				<keyword>Flat</keyword>
			</code> view button. The layout of the result is similar. The flat form of a class is the reconstructed class text including not only what's declared in the class itself but also everything that it inherits from its ancestors, direct or indirect. This applies to the flat form's features, which include ancestor features, but also to contracts: the flat form's invariant includes all clauses from ancestors' invariants, and the preconditions are expanded to take 
			<code>
				<keyword>require else</keyword>
			</code> and 
			<code>
				<keyword>ensure then</keyword>
			</code> clauses into consideration. (The 
			<span>
				<link>
					<url>../language/tutorial-00.xml</url>
					<label>Eiffel Tutorial</label>
				</link>
			</span> explains these notions in detail.)
		</paragraph>
		<paragraph>As a result, the 
			<code>
				<keyword>Flat</keyword>
			</code> view shows the class text as it might have come out had inheritance (what a horrible thought even to contemplate!) 
			<span>not</span> been available to write it.
		</paragraph>
		<paragraph>The first two features appearing in the above display, 
			<code>
				<string>cursor</string>
			</code> and 
			<code>
				<string>first</string>
			</code>, are indeed inherited from ancestors, rather than declared in 
			<code>
				<string>LIST</string>
			</code> itself. Note how EiffelStudio, when producing the flat form, adds a line of the form
		</paragraph>
		<code_block>
	<comment>-- (From CLASS_OF_ORIGIN)</comment>
</code_block>
		<paragraph>to the header comments of inherited routines, to document where they come from.</paragraph>
		<paragraph>The flat form is an important notion of object technology, making it possible to understand a class by itself, regardless of the possibly rich inheritance structure that led to it. Looking at the Flat view of 
			<code>
				<string>LIST</string>
			</code>, you may note how few of its properties come from the class itself; most of the interesting work has been done in ancestors, and 
			<code>
				<string>LIST</string>
			</code> just adds a few details.
		</paragraph>
		<note>
			<italic>If at any time you want to search for a certain pattern in the views displayed, click the </italic>
			<code>
				<keyword>Search</keyword>
			</code>
			<italic> button at the top of the window, or type CTRL-</italic>
			<code>
				<keyword>F</keyword>
			</code>. 
			<italic>A self-explanatory Search Tool will come up, with various options such as </italic>
			<span>
				<italic>Match case</italic>
			</span>
			<italic> and </italic>
			<span>
				<italic>Whole word</italic>
			</span>
		</note>
		<paragraph>Next come two essential documentation views: 
			<code>
				<keyword>Contract</keyword>
			</code> and 
			<code>
				<keyword>Flat Contract</keyword>
			</code>. Based on Eiffel's principles of Design by Contract, they document the interface properties of a class. Unlike the previous two, they do not show actual Eiffel texts, but information useful for client classes.
		</paragraph>
		<paragraph>The contract form (also known as the 
			<bold>short form</bold> of a class) is the class text deprived of any internal detail to retain interface information only. It discards any feature that's not exported (available to all clients); for the retained features, it discards the implementation -- 
			<code>
				<keyword>do</keyword>
			</code> or 
			<code>
				<keyword>once</keyword>
			</code> clause -- but retains the header (feature name, arguments, results), the header comment, and the contracts (precondition, postcondition, invariant) minus any contract clause that refers to a non-exported feature and hence would be useless to clients.
		</paragraph>
		<paragraph>As you will know, particularly if you have read the book 
			<span>
				<link>
					<label>Object-Oriented Software Construction</label>
					<url>http://eiffel.com/doc/oosc/</url>
				</link>
			</span>
			, the contract form is the preferred way of documenting software elements, especially reusable components, as it provides clients with just the right level of abstraction: precise enough thanks to the type signature and the contracts; clear enough thanks to the header comments; and general enough since it omits implementation details that are irrelevant to client programmers (and might lead them to write client code that won't work any more if the implementation changes).
		</paragraph>
		<paragraph>In practice you will often want to use, instead of the 
			<code>
				<keyword>Contract</keyword>
			</code> view, the next one, 
			<code>
				<keyword>Flat Contract</keyword>
			</code>, also known as "flat-short form" and "interface form", which applies the same rules to the flat form rather than to the original class. This means it shows information on all the features of the class, immediate (defined in the class itself) as well as inherited, whereas the short form, non-flat, only considers immediate features. The 
			<code>
				<keyword>Flat Contract</keyword>
			</code> view provides the complete interface information for the class. Try it now on class 
			<code>
				<string>LIST</string>
			</code>.
		</paragraph>
		<paragraph>The next two buttons are for the 
			<code>
				<keyword>Ancestors</keyword>
			</code> and 
			<code>
				<keyword>Descendants</keyword>
			</code> views, which we have already seen, showing classes connected with the target through one of the two inter-class relations, inheritance. After them come 
			<code>
				<keyword>Clients</keyword>
			</code> and 
			<code>
				<keyword>Suppliers</keyword>
			</code>, to list the classes connected through the other relation, client. Clicking the 
			<code>
				<keyword>Clients</keyword>
			</code> button shows the (empty) list of clients of 
			<code>
				<string>LIST</string>
			</code>.
		</paragraph>
		<paragraph>No class of this system directly uses 
			<code>
				<string>LIST</string>
			</code> as client, although some use its descendant 
			<code>
				<string>ARRAYED_LIST</string>
			</code>. Now click the next button to see the 
			<code>
				<keyword>Suppliers</keyword>
			</code> of 
			<code>
				<string>LIST</string>
			</code>.
		</paragraph>
		<paragraph>The only two classes that 
			<code>
				<string>LIST</string>
			</code> needs for its own algorithms are basic types from the Kernel Library, 
			<code>
				<string>BOOLEAN</string>
			</code> and 
			<code>
				<string>INTEGER_32</string>
			</code>. In Eiffel, as you may remember, all types are defined by classes, even those describing such elementary values as integers and booleans.
		</paragraph>
		<heading>
			<size>2</size>
			<content>Feature information in the Class View</content>
		</heading>
		<paragraph>Let's resist the natural urge to go see now what the classes 
			<code>
				<string>INTEGER_32</string>
			</code> and 
			<code>
				<string>BOOLEAN</string>
			</code> look like, and instead continue our survey of views. The remaining views will all display information about the 
			<bold>features</bold> of the class. The first of them, 
			<code>
				<keyword>Attributes</keyword>
			</code>, lists the attributes. It's not very interesting for 
			<code>
				<string>LIST</string>
			</code>, a deferred class with only one attribute -- you can check this for yourself by clicking the 
			<code>
				<keyword>Attributes</keyword>
			</code> button -- so let's look at the next one. Click the 
			<code>
				<keyword>Routines</keyword>
			</code> button now to display information about the routines of class 
			<code>
				<string>LIST</string>
			</code> :
		</paragraph>
		<div>
			<image_link>
				<url>index-36.png</url>
				<target>screenshots</target>
				<image>
					<url>index-36.png</url>
					<width>100</width>
				</image>
			</image_link>
		</div>
		<paragraph>The sections of this display group routines according to the ancestors of 
			<code>
				<string>LIST</string>
			</code> -- including 
			<code>
				<string>LIST</string>
			</code> itself -- that first introduced them; for example (second and third sections) 
			<code>
				<string>extendible</string>
			</code> originally comes from 
			<code>
				<string>COLLECTION</string>
			</code> and 
			<code>
				<string>extend</string>
			</code> from 
			<code>
				<string>BAG</string>
			</code>. Much of the benefit of this display comes from its support for browsing: all the colored elements, representing classes and features, will be "clickable" hyperlinks.
		</paragraph>
		<paragraph>The remaining Class View buttons all display information in the same format. Each selects a specific subset of the target class's features. The last two selected attributes and routines. You can now try any of the others by clicking the corresponding button:</paragraph>
		<list ordered="false">
			<item>
				<code>
					<keyword>Deferred</keyword>
				</code> features: abstract features which don't have an implementation in the current class, only in eventual descendants. Try this for 
				<code>
					<string>LIST</string>
				</code> ; you'll see that this deferred class indeed has a number of deferred features.
			</item>
			<item>
				<code>
					<keyword>Once and constants</keyword>
				</code> : constant attributes, "once functions" which provide shared objects (close to the "singleton" pattern), and once procedures which provide a convenient initialization mechanism. 
				<code>
					<string>LIST</string>
				</code> has 'Operating_environment' and 'Io' inherited from the parent class ANY.
			</item>
			<item>
				<code>
					<keyword>External</keyword>
				</code> features, implemented as calls to routines, macros or other elements implemented in other languages. 
				<code>
					<string>LIST</string>
				</code> hasn't any.
			</item>
			<item>
				<code>
					<keyword>Exported</keyword>
				</code> features: those available to all clients. 
				<code>
					<string>LIST</string>
				</code> has quite a few.
			</item>
		</list>
		<paragraph>
			<link>
				<url>index-07.xml</url>
				<label>&lt;&lt; Previous</label>
			</link> 
			<link>
				<url>index-09.xml</url>
				<label>Next &gt;&gt;</label>
			</link>
		</paragraph>
	</paragraph></document>
