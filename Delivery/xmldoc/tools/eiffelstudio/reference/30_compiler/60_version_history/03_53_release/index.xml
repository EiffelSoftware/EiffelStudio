<document title="Major changes between ISE Eiffel 5.2 and ISE Eiffel 5.3">
	<meta_data>
		<help>
			<toc>
				<envision_location>EiffelEnvision\Introduction to EiffelEnvision\History and Known Issues\Compiler History</envision_location>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<heading>
			<size>2</size>What's new
		</heading>
		<list ordered="false">
			<item>Finalized executable with option `exception trace' enabled will now display the instruction number (usually equivalent to the line number in the routine) being executed when a failure occurred. It was already displaying this information in workbench/melted mode, we have just extended this feature to finalize mode.</item>
			<item>Incremental compilation is now available for .NET code generation.  Meaning that if you modify one class, only this class is being recompiled. It dramatically improves development time when targeting .NET.</item>
			<item>In .NET code generation, assertions can be turned on or off on a class per class basis without having to recompile those classes.</item>
			<item>Implemented 
				<link>
					<url>../../../../../../libraries/base/content/10_kernel/index.xml</url><anchor_name>Recoverable_storable</anchor_name>
					<label>recoverable storable</label>
				</link> to enable the retrieval of slightly different version of an object. It only applies for classic           Eiffel.
			</item>
		</list>
		<heading>
			<size>2</size>Improvements
		</heading>
		<list ordered="false">
			<item>Enabled support for Borland C compiler in .NET.</item>
			<item>Removed too many warnings during C compilation on Tru64.</item>
			<item>Improved formatting of exception traces so that class names, feature names, exception tags are not truncated. Display limit has been pushed at about 256 characters.</item>
		</list>
		<heading>
			<size>2</size>Changes
		</heading>
		<list ordered="false">
			<item>Made `\\' follow the balancing rules for various integer types.</item>
			<item>Precompiled libraries now precompiles all classes reachable from clusters defined in project settings only if root class is ANY, otherwise it will only precompile classes reachable from the root class. In 5.1 and prior version it was precompiling all classes           reachable from clusters.</item>
		</list>
		<heading>
			<size>2</size>Bug fixes
		</heading>
		<heading>
			<size>3</size>Language issues
		</heading>
		<list ordered="false">
			<item>Fixed semantic of object creations to strictly follow definition given in "Eiffel: The Language". Namely, if you have x of           type 
				<class_name>X</class_name>:
				<code_block><keyword>create</keyword> x.<feature_name>make</feature_name>	is equivalent to	x := <keyword>create</keyword> {<class_name>X</class_name>}.<feature_name>make</feature_name></code_block>
				It implies some bug fixes which might break existing code. For example:
				<code_block>
x: <class_name>X</class_name> <keyword>is</keyword>
	<keyword>once</keyword>
			<comment>-- If </comment><feature_name>make</feature_name><comment> calls back to x then it used to return</comment>
			<comment>-- a non-Void value for x, where it should have been Void.</comment>
		<keyword>create</keyword> Result.<feature_name>make</feature_name>
	<keyword>end</keyword>

x: <class_name>X</class_name>

	<comment>-- If </comment><feature_name>make </feature_name><comment>accesses back the x attribute then it used to return</comment>
	<comment>-- new value of x rather than the old value.</comment>
<keyword>create</keyword> x.<feature_name>make</feature_name></code_block>
			Or in melted code only the following code now works properly, i.e. 
				<feature_name>make</feature_name> gets the old value of x, not the new one
				<line_break/>
				<code_block><keyword>create</keyword> x.<feature_name>make</feature_name> (x)</code_block>
			</item>
			<item>Fixed undetected 
				<code><compiler_error>VDRD(3)</compiler_error></code> errors: compiler was not strict enough and accepted 
				<code>
					<keyword>ensure</keyword>
				</code> where only 
				<code>
					<keyword>ensure then</keyword>
				</code> was valid.
			</item>
		</list>
		<heading>
			<size>3</size>Store/Retrieve issues
		</heading>
		<list ordered="false">
			<item>Fixed issue in storable mechanism when retrieving expanded objects.</item>
			<item>Fixed issue with independent_store where storing arrays of objects whose count was greater than 65536 will cause a memory corruption.</item>
			<item>Added 
				<feature_name>correct_mismatch</feature_name> on 
				<class_name>HASH_TABLE</class_name> to enable retrieval of the 5.1 and older version of 
				<class_name>HASH_TABLE</class_name>.
			</item>
		</list>
		<heading>
			<size>3</size>Runtime/code generation issues
		</heading>
		<list ordered="false">
			<item>Fixed incorrect C code generation in final mode when creating an 
				<class_name>ARRAY</class_name> of expanded type.
			</item>
			<item>Fixed incorrect C code generation in final mode when creating a complex object which contains expanded objects that have expanded           objects.</item>
			<item>Fixed random crash issue in finalized applications due to incorrect memory management when you have code similar to:
				<code_block>	f (g: <class_name>STRING</class_name>): <class_name>ANY</class_name> <keyword>is</keyword>
		<keyword>do</keyword>
			<keyword>Result</keyword> := <keyword>create</keyword> {<class_name>STRING</class_name>}.<feature_name>make_from_string</feature_name> (g)
		<keyword>end</keyword></code_block>
			</item>
			<item>Fixed issue with
				<feature_name>deep_equal</feature_name> on 
				<class_name>ARRAY</class_name> of expanded types which was returning 
				<code>
					<keyword>False</keyword>
				</code> where it should have returned 
				<code>
					<keyword>True</keyword>
				</code>.
			</item>
			<item>Fixed code generation issue with double constants where code below was not producing the expected result of 1e+030: <code_block>	<feature_name>value</feature_name>: <class_name>DOUBLE</class_name> is 1.0e15
	<feature_name>print</feature_name> (<feature_name>value</feature_name> * <feature_name>value</feature_name>) </code_block>
				
			</item>
			<item>Fixed issue in melted code where computation such as 
				<class_name>INTEGER_X</class_name> // 
				<class_name>INTEGER_Y</class_name> will either crash or give an incorrect computation where X and Y represents integers that are either 8, 16, 32 or 64 bits long and X &lt; Y.
			</item>
			<item>Fixed incorrect C code generation of finalized code when your project configuration includes a precompiled library and that you cancel finalization process at degree -2, and then restart a finalization.</item>
			<item>Fixed issue with incorrect C code generation of inspect instruction based on character values above 128.</item>
			<item>Fixed compilation crash at degree 3 with following code: <code_block>	<keyword>local</keyword>
		i: <class_name>INTEGER</class_name>
	<keyword>do</keyword>
		i := &lt;&lt; 1 &gt;&gt; @ 2
	<keyword>end</keyword></code_block>
			</item>
			<item>Fixed a crash in finalized mode with invariant checking enabled with following code and when checking the invariant triggers a garbage           collection cycle:
				<line_break/>
				<code_block>	<feature_name>value</feature_name>: <class_name>INTEGER</class_name>
	<feature_name>is_value_required</feature_name>: <class_name>BOOLEAN</class_name> <keyword>is</keyword>
		<keyword>do</keyword>
			Result := <feature_name>value</feature_name> = 1
		<keyword>end</keyword>
</code_block>
			</item>
			<item>Fixed crash of compiler at degree 4 while trying to compile this incorrect class:
				<code_block><keyword>class</keyword> <class_name>CRASH</class_name>

<keyword>inherit</keyword>
	<class_name>CHAIN</class_name>	<comment>-- Missing generic parameter</comment>

<keyword>create</keyword>
	make

<keyword>feature </keyword><comment>-- Initialization</comment>

	<feature_name>make</feature_name> <keyword>is</keyword>
		<keyword>do</keyword>
		<keyword>end</keyword>

	<feature_name>index</feature_name>:<class_name> INTEGER</class_name> <keyword>is</keyword>
		<keyword>do</keyword>
		<keyword>end</keyword>

	<feature_name>duplicate</feature_name> (n: <class_name>INTEGER</class_name>): <keyword>like</keyword> <keyword>Current</keyword> <keyword>is</keyword>
		<keyword>do</keyword>
		<keyword>end</keyword>

<keyword>end</keyword></code_block>
			</item>
			<item>Fixed issue with pathological memory allocation scheme that could trigger an `out of memory' exception where enough memory is still available.</item>
			<item>Fixed incorrect allocation of expanded arrays where creation routine of expanded class was not called on all items of the newly created array.</item>
			<item>Fixed incorrect creation type of attribute where attribute's type has some generic parameter. In some cases, instead of creating an 
				<class_name>ARRAY [B2 [C]]</class_name> it would create an 
				<class_name>ARRAY [B2 [STRING]]</class_name>.
			</item>
		</list>
		<heading>
			<size>3</size>.NET issues
		</heading>
		<list ordered="false">
			<item>Fixed issue in IL code generation where having a class that inherits from a non-Eiffel .NET class. And the class has the following           features: <code_block>	<feature_name>a</feature_name>: <feature_name>ARRAY</feature_name> [<keyword>like</keyword> <feature_name>f</feature_name>]
	<feature_name>f</feature_name>: <class_name>STRING</class_name>  <keyword>is</keyword>
		<keyword>do</keyword>
		<keyword>end</keyword></code_block>Then you could neither load nor execute the generated code.
			</item>
			<item>Fixed incorrect C file naming when generating a .NET system that uses a C++ external (it should be .cpp, not just .c).</item>
			<item>Fixed incorrect .NET code generation with following assignment attempts whose source is expanded:
				<code_block>	<keyword>local</keyword>
		a: <class_name>ANY</class_name>
		o: <class_name>SYSTEM_OBJECT</class_name>
	<keyword>do</keyword>
		a ?= 12
		o ?= 12
	<keyword>end</keyword></code_block>
			</item>
			<item>Fixed incorrect code generation in .NET for assertions checking with following code where precondition of
				<feature_name>test</feature_name> will not be checked although it should:
				<code_block>	<feature_name>make</feature_name> <keyword>is</keyword>
		<keyword>do</keyword>
			<feature_name>test_which_fail_and_rescued</feature_name>
			<feature_name>test</feature_name>
		<keyword>end</keyword>

	<feature_name>test </feature_name><keyword>is</keyword>
		<keyword>require</keyword>
			should_be_checked: False
		<keyword>do</keyword>
		<keyword>end</keyword>
	
	<feature_name>test_which_fail_and_rescued</feature_name> <keyword>is</keyword>
		<keyword>local</keyword>
			retried: BOOLEAN
		<keyword>do</keyword>
			<keyword>if</keyword> <keyword>not </keyword>retried <keyword>then</keyword>
				<feature_name>failure</feature_name>
			<keyword>end</keyword>
		<keyword>rescue</keyword>
			retried := true;
			retry
		<keyword>end</keyword>

	<feature_name>failure</feature_name> <keyword>is</keyword>
		<keyword>require</keyword>
			should_be_checked: False	
		<keyword>do</keyword>
		<keyword>end</keyword></code_block>
			</item>
			<item>Fixed .NET verification issue where sometimes you could get the following message when checking an Eiffel assembly against peverify:           [IL]: Error: Unverifiable PE Header/native stub.</item>
			<item>Fixed incorrect code generation when creating and accessing a 
				<class_name>NATIVE_ARRAY</class_name> of expanded type.
			</item>
			<item>Fixed incorrect metadata heap generation to use standard CLI tables.</item>
			<item>Fixed bug where content of 
				<class_name>NATIVE_ARRAY</class_name> could not be looked up in .NET debuggers (cordbg, DbgClr or Visual Studio)
			</item>
		</list>
	</paragraph></document>
