<document output="studio" title="1 OVERVIEW AND PREREQUISITES">
	<meta_data/>
	<paragraph>
		<paragraph>
			<link>
				<url>tour-help.xml</url>
				<label>Help reading this manual</label>
			</link>
		</paragraph>
		<paragraph>EiffelStudio is the central tool of ISE Eiffel, letting you design, develop, debug, document, measure, maintain, revise and expand systems using the full power of object technology and Design by Contract 
			<span>TM</span>.  
		</paragraph>
		<paragraph>This presentation introduces the essential properties of EiffelStudio.  It will take you through a tour of the environment, using a pre-existing example system.  </paragraph>
		<heading>
			<size>2</size>
			<content>What will I achieve?</content>
		</heading>
		<paragraph>Although it skips many specific or advanced facilities, this Tour will help you quickly become familiar with the way you can use the environment for your work.  After reading it you will know the basics of working with EiffelStudio:</paragraph>
		<list ordered="false">
			<item>Starting a project and retrieving an existing project.  </item>
			<item>Entering new software elements -- clusters, classes and features.  </item>
			<item>Compiling your software.  </item>
			<item>Making changes and having them immediately recompiled using the Melting Ice Technology 
				<span>TM</span>.  
			</item>
			<item>Displaying a graphical representation of your software elements, and modifying the software through the graphical views (as well as through its text).  </item>
			<item>Producing extensive documentation of your system, textual or graphical, under many different formats such as HTML, RTF, Postscript, XMI (for e.  g.  Rational Rose) and others.  </item>
			<item>Browsing through simple or complex software systems, to find out their various components, properties and relationships.  </item>
			<item>Measuring quantitative properties of the software, by applying metrics predefined in EiffelStudio as well as new ones that you define.  </item>
			<item>Executing a compiled system, and controlling its execution through the debugging mechanisms of EiffelStudio.  </item>
		</list>
		<heading>
			<size>2</size>
			<content>About the scope of EiffelStudio</content>
		</heading>
		<paragraph>The most important property to keep in mind as you are discovering EiffelStudio is that it is neither just a "programming environment" nor just a "CASE tool" (Computer-Aided Software Engineering) for analysis and design.  It encompasses both of these functions and many others.  Most system builders today are used to a dichotomy between the high end and the low end:</paragraph>
		<list ordered="false">
			<item>At the analysis and design levels, graphical tools help you clarify your thinking about the system, interacting with customers and end users, and devise high-level system architectures, usually in diagrammatic form.  </item>
			<item>At the low end, programming tools help you edit, compile and debug your programs.  </item>
		</list>
		<paragraph>Keeping these tools separate is, however, detrimental to the quality of the software process and the resulting products.  If they are in the hands of different teams, communication problems may arise, leading to discrepancies between need and realization; this can be a source of bugs or even project failure.  If it's the same people using tools of both kinds, they have to keep switching notations, tools and modes of thinking.  The use of different frameworks at both ends makes it difficult to keep the high-level model and the implementation consistent; too often, a change decided at the implementation level is not reflected back in the higher model.  After a while, the system gets into the state of disorder and inconsistency that good tools are precisely meant to avoid.  </paragraph>
		<paragraph>EiffelStudio, in line with the principles of 
			<span>seamless development</span> and 
			<span>reversibility</span> of the Eiffel method, removes the gap by providing a single set of tools that accompany you throughout a project, from the most high-level initial stages to the most low-level aspects of implementation and maintenance.  
		</paragraph>
		<paragraph>This generality is reflected throughout the environment by, for example, the dual use of text and graphics.  As another example, you should think of the EiffelStudio 
			<span>compiler</span>, not just as a tool for executing Eiffel software in its final form, but also, thanks to its extensive 
			<span>validity checking</span> facilities, as a design consistency tool that performs many verifications commonly associated with CASE tools.  
		</paragraph>
		<paragraph>Depending on your project needs, you may take advantage of EiffelStudio's versatility to address specific purposes:</paragraph>
		<list ordered="false">
			<item>You may use EiffelStudio as a programming environment, with advanced tools for compiling, browsing and debugging.  </item>
			<item>Some people use EiffelStudio as a 
				<span>modeling</span> tool only, building system descriptions consisting only of 
				<span>deferred</span> (abstract) classes with no implementation, and relying on the Diagram Tool to build, present and discuss these descriptions through graphical views.  
			</item>
			<item>You may use EiffelStudio in both capacities, taking advantage of the seamlessness between all the affected phases.  </item>
		</list>
		<heading>
			<size>2</size>Learning by doing
		</heading>
		<paragraph>If you have access to EiffelStudio as you read this Tour, the most effective technique is to execute all the suggested operations as you read about them.  </paragraph>
		<paragraph>Please execute user actions, such as clicking, only when asked to do so.  </paragraph>
		<heading>
			<size>2</size>What should I already know?
		</heading>
		<paragraph>This Tour assumes very little about what you know and what you don't.  </paragraph>
		<paragraph>It does assume that you can do simple manipulations on your platform of choice, such as: on Windows, finding and drag-and-dropping folders and files in the Windows Explorer; on Unix, changing to a certain directory ( 
			<code>
				<keyword>cd</keyword>
			</code> ) and listing the files of a directory ( 
			<code>
				<keyword>ls</keyword>
			</code> ).  
		</paragraph>
		<paragraph>The more you already know about object technology and object-oriented environments, the better.  But remember, if you have used other environments before, keep a fresh outlook; EiffelStudio 
			<span>is</span> different, and it may take a while before you fully understand why it does some things in a certain way.  
		</paragraph>
		<heading>
			<size>2</size>A note on platform differences
		</heading>
		<paragraph>ISE Eiffel is one of the most portable environments in the industry, running in an almost identical fashion on Windows, on the new Microsoft .  NET environment, on many variants of Unix, on Linux, on VMS.  </paragraph>
		<paragraph>Once an EiffelStudio session has been started, you can largely forget about the operating system.  But a few operations -- mostly at the beginning, to launch EiffelStudio -- require platform-dependent mechanisms: starting a program, traversing the file structure, selecting a file.  These cases will be marked accordingly below.  </paragraph>
		<paragraph>Windows users should particularly note thefollowing two conventions of terminology:</paragraph>
		<list ordered="false">
			<item>Operating systems store files into hierarchically nested structures called 
				<span>folders</span> or 
				<span>directories</span> .  Although "folder" is the more common term for Windows, we  ill mostly speak of "directories".  It's exactly the same thing.  
			</item>
			<item>A file has a full 
				<span>path name</span>, used to describe how to reach it from the root of its file system, as in 
				<code>
					<keyword>c:\d1\d2\f</keyword>
				</code> .  This example uses the Windows notation, which separates successive components of a path name by a backward slash character 
				<code>
					<keyword>\</keyword>
				</code> .  On Unix and Linux, the separator is a forward slash 
				<code>
					<keyword>/</keyword>
				</code>, as in 
				<code>
					<keyword>/d1/d2/f</keyword>
				</code> ; this is also the convention on the Internet for denoting addresses (URLs).  Most file names in this manual appear in this Unix/Internet style.  On Windows you will normally have to use the backslash convention, although EiffelStudio also accepts forward slashes.  In any case you must be consistent: don't mix backward and forward slashes in the same path name.  Also note that some names, such as those of object files to be linked with your system, will be passed to outside tools -- C compilers, loaders -- that may not accept the forward slash.  
			</item>
		</list>
		<paragraph>VMS users may similarly use either the Unix convention or the specific VMS path naming convention.  </paragraph>
		<paragraph>If you are a one-platform person, just ignore, for the next few pages, all references to any platform other than your heart's favorite.  They will quickly go away.  </paragraph>
		<heading>
			<size>2</size>What should I have done first?
		</heading>
		<paragraph>To run the example you must have installed ISE Eiffel and set up the environment.  Check in particular the following:</paragraph>
		<list ordered="false">
			<item>On Windows, you must have run the installation procedure; it will have put EiffelStudio in the Programs section of the start menu, subsection "ISE Eiffel version", where version is the version number, e.  g.  5.  0.  </item>
			<item>The environment variable 
				<code>
					<keyword>ISE_EIFFEL</keyword>
				</code> must be set to the installation directory, and the environment variable 
				<code>
					<keyword>PLATFORM</keyword>
				</code> to the platform.  On Windows this is taken care of automatically by the installation procedure, but on Unix/Linux and VMS you must update your path and environment manually.  Throughout this discussion the notations 
				<code>
					<keyword>$ISE_EIFFEL</keyword>
				</code> and 
				<code>
					<keyword>$PLATFORM</keyword>
				</code> will refer to the values of these variables -- the installation directory, and the platform.  (The Windows notation would be 
				<code>
					<keyword>%ISE_EIFFEL%</keyword>
				</code> and 
				<code>
					<keyword>%PLATFORM%</keyword>
				</code>.  )
			</item>
			<item>On Unix/Linux and VMS, your "path" must include the place where EiffelStudio executables reside.  (On Windows the installation procedure takes care of this.  )</item>
			<item>Also, the discussion assumes that as part of the installation you have included the EiffelBase library, in precompiled form.  EiffelBase is automatically included if you have installed another precompiled library, such as WEL, the Windows Eiffel Library.  The installation procedure takes care of precompiling EiffelBase.  </item>
		</list>
		<heading>
			<size>2</size>Locating the example
		</heading>
		<paragraph>Please take a moment to locate the example files on your installation.  They all appear in the following directory, part of the Eiffel delivery:</paragraph>
		<code_block><keyword>$ISE_EIFFEL/examples/studio/tour</keyword></code_block>
		<paragraph>(Windows users: remember that instead of the slash 
			<code>
				<keyword>/</keyword>
			</code> your platform uses a backslash 
			<code>
				<keyword>\</keyword>
			</code> .  VMS users: this is to be replaced by the VMS path naming conventions.  )
		</paragraph>
	</paragraph></document>