<!DOCTYPE HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">

<HTML>
	<HEAD>
		<TITLE>EiffelBase Kernel</TITLE>
		<LINK REL=StyleSheet HREF="../../../../default.css">
	</HEAD>
	<BODY>
		<H1>The Kernel</H1>
			<P>
				In addition to basic concepts close to the language level, the Kernel covers such
				common needs as <B>input</B> and <B>output</B>, <B>storage</B> and
				<B>retrieval</B> of objects on persistent storage, fine control over <B>exception
				handling</B> and <B>memory management</B>, and access to
				<B>operating system facilities</B>. The kernel can be divided into 5 logical
				clusters of classes:
			<UL>
				<LI>The first cluster contains the universal class defining facilities accessible to all
					other classes: <A CLASS="eclass" HREF="../../reference/kernel/any.html">ANY</A>.
					Every developer-defined class is a descendant of this class.
				<LI>The second cluster includes classes whose facilities are directly related to
					language concepts:
					<UL>
						<LI>Classes describing the basic types:
						<A CLASS="eclass" HREF="../../reference/kernel/boolean.html">BOOLEAN</A>,
						<A CLASS="eclass" HREF="../../reference/kernel/character.html">CHARACTER</A>,
						<A CLASS="eclass" HREF="../../reference/kernel/integer.html">INTEGER</A>,
						<A CLASS="eclass" HREF="../../reference/kernel/real.html">REAL</A>
						and
						<A CLASS="eclass" HREF="../../reference/kernel/double.html">DOUBLE</A>
						<LI>Arrays: class <A CLASS="eclass" HREF="../../reference/kernel/array.html">ARRAY</A>
						<LI>Strings: class <A CLASS="eclass" HREF="../../reference/kernel/string.html">STRING</A>
						<LI>Basic facilities: class <A CLASS="eclass" HREF="../../reference/kernel/basic_routines.html">BASIC_ROUTINES</A>
					</UL>
				<LI>The third cluster provides input and output facilities:
					<UL>
						<LI><A CLASS="eclass" HREF="../../reference/kernel/std_files.html">STD_FILES</A>
						offers basic mechanisms, sufficient for simple input and output.
						<LI><A CLASS="eclass" HREF="../../reference/kernel/file.html">FILE</A>
						describes the notion of sequential file, viewed as a sequence of characters
						and fully integrated in the data structure library.
						<LI><A CLASS="eclass" HREF="../../reference/kernel/directory.html">DIRECTORY</A>
						gives properties of directories (files serving as collections of other files).
					</UL>
				<LI>The next cluster, through class <A CLASS="eclass" HREF="../../reference/kernel/storable.html">STORABLE</A>,
				makes it possible to store object structures on persistent storage and retrieve them later. This facility can also be used to
				transmit object structures through pipes or over a network.
				<LI>The last cluster provides access to internal properties of the compiler and environment, useful for applications that need some fine-tuning of the basic mechanisms:
					<UL>
						<LI>Class <A CLASS="eclass" HREF="../../reference/kernel/exceptions.html">EXCEPTIONS</A>
						(complemented by <A CLASS="eclass" HREF="../../reference/kernel/unix_signals.html">UNIX_SIGNALS</A>
						for Unix-type platforms) provides control over the exception handling mechanism, in particular
						for applications that need to handle different types of exception in different ways.
						<LI>Similarly, classes <A CLASS="eclass" HREF="../../reference/kernel/memory.html">MEMORY</A>
						and <A CLASS="eclass" HREF="../../reference/kernel/gc_info.html">GC_INFO</A> provide ways to control the garbage
						collector and tailor it to specific needs.
						<LI>Class <A CLASS="eclass" HREF="../../reference/kernel/arguments.html">ARGUMENTS</A> gives access to the
						command-line arguments.
					</UL>
			</UL>
        <h2>UNIVERSAL CLASS AND ITS FEATURES</h2>
        <p>The Eiffel inheritance mechanism is set up in such a way that every class is a
        descendant of a Kernel Library class called <A CLASS="eclass" HREF="../../reference/kernel/any.html">ANY</A>.
        The features of this class provide a number of generally applicable facilities covering such needs as comparison, copying and
        rudimentary input and output.</p>
        <h3> The structure of universal classes</h3>
        <p>Every class which has no inheritance clause is understood to have an inheritance clause
        of the form<br>
        <code>
        <SPAN CLASS="ekeyword">inherit</SPAN><br>
 		 &nbsp;&nbsp; <A CLASS="eclass" HREF="../../reference/kernel/any.html">ANY</A></p>
 		 </code><br>
        <p>As a result, every developer-defined class is a descendant of <A CLASS="eclass" HREF="../../reference/kernel/any.html">ANY</A>.
        You may introduce your own project specific features in <A CLASS="eclass" HREF="../../reference/kernel/any.html">ANY</A>
        so that all the classes of your system will be able to use these
        features.</p>
        <h3>Using the universal classes</h3>
        <p>If you need to rename or redefine a feature inherited from one of the universal classes,
        you should include an explicit inheritance clause, as in<br>
        <code>
        <SPAN CLASS="ekeyword">class</SPAN><br>
        &nbsp;&nbsp; <SPAN CLASS="eclass">C</SPAN><br>
        <SPAN CLASS="ekeyword">inherit</SPAN><br>
        &nbsp;&nbsp; <A CLASS="eclass" HREF="../../reference/kernel/any.html">ANY</A><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN CLASS="ekeyword">rename</SPAN><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A>
        <SPAN CLASS="ekeyword">as</SPAN> <SPAN CLASS="efeature">basic_out</SPAN><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN CLASS="ekeyword">redefine</SPAN><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_print">print</A><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN CLASS="ekeyword">end</SPAN><br>
        &nbsp;&nbsp;&nbsp;...<br>
        <SPAN CLASS="ekeyword">feature</SPAN><br>
        &nbsp;&nbsp;&nbsp;...<br>
        <SPAN CLASS="ekeyword">end</SPAN>
        </code><br>
        <p>The features of <A CLASS="eclass" HREF="../../reference/kernel/any.html">ANY</A>
        are usable in both qualified and unqualified form. For example, the argumentless function out, which produces a printable representation of any object,
        may be called under either of the forms<br>
        <code>
        <SPAN CLASS="elocal">x</SPAN> <SPAN CLASS="esymbol">:=</SPAN> <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A><br>
        <SPAN CLASS="elocal">x</SPAN> <SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="elocal">a</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A>
        </code><br>
        The first call yields a printable representation of the current object; the second,
        which assumes that a is not void, yields a printable representation of the object attached
        to a.</p>
        <h3>Input and output features</h3>
        <p>Some of the features of <A CLASS="eclass" HREF="../../reference/kernel/any.html">ANY</A>
        cover common input and output needs.<br>
        Feature <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_io">io</A>,
        of type <A CLASS="eclass" HREF="../../reference/kernel/std_files.html">STD_FILES</A>,
        gives access to standard input and output facilities.
        For example,
        <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_io">io</A><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/std_files.html#f_input">input</A>
        is the standard input file and
        <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_io">io</A><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/std_files.html#f_new_line">new_line</A>
        will print a line feed on the standard output. Feature io is declared as a once function which, when first called,
        returns the value of an instance of <A CLASS="eclass" HREF="../../reference/kernel/std_files.html">STD_FILES</A>
        that provides access to the standard input, the standard output and the error output. As a result, io is never void, so that
        operations such as
        <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_io">io</A><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/std_files.html#f_new_line">new_line</A>
        are always possible.<br>
        Function out, of type <A CLASS="eclass" HREF="../../reference/kernel/string.html">STRING</A>,
        is a universal mechanism for obtaining a simple
        external representation of any object. For non-void <SPAN CLASS="elocal">x</SPAN> of any type, the string
        <SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A>
        is a printable representation of <SPAN CLASS="elocal">x</SPAN>. This works for <SPAN CLASS="elocal">x</SPAN> of all types,
        reference or expanded. For example, if <SPAN CLASS="elocal">x</SPAN> is an integer expression,
        <SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A>
        is its string representation, such as <SPAN CLASS="esymbol">-897</SPAN>; if n is a non-void reference,
        <SPAN CLASS="elocal">x</SPAN><SPAN CLASS="symbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A> is (recursively)
        the concatenation of the result of
        applying out to the successive fields of the attached object, each labeled by the name of
        the corresponding attribute. You may redefine <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A>
        in any class to specify any suitable format for displaying instances of the class. To obtain the default representation
        regardless of any redefinition of <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A>, use
        <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_tagged_out">tagged_out</A>, declared as a frozen synonym of
        the original <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A>.<br>
        The call <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_print">print</A>
        <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">)</SPAN>
        will output the value of
        <SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/any.html#f_out">out</A>
        on the default output if <SPAN CLASS="elocal">x</SPAN> is not void, and do nothing otherwise.</p>
        <h3>Copy and comparison routines</h3>
        <p align="left">Procedure copy copies the fields of an object onto those of another. It is used under the
        form<br>
        <code>
        <SPAN CLASS="elocal">target</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/any.html#f_copy">copy</A>
        <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">source</SPAN><SPAN CLASS="esymbol">)</SPAN>
        </code><br>
        Here both target and source must be non-void; this means that copy is only good
        for copying onto an object that already exists. If you need both to allocate a new object
        and to initialize it as a copy of another, use the function clone. For non-void source, the
        assignment<br>
        <code>
        <SPAN CLASS="elocal">target</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
        <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_clone">clone</A>
        <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">source</SPAN><SPAN CLASS="esymbol">)</SPAN>
        </code><br>
        starts by creating a new object. If <SPAN CLASS="elocal">source</SPAN> is void, <SPAN CLASS="elocal">target</SPAN> will be made void too.
        The boolean function
        <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_equal">equal</A>
        compares two objects for field-by-field equality. This is different from the equality operators
        <SPAN CLASS="esymbol">=</SPAN> and <SPAN CLASS="esymbol">/=</SPAN> which, in the case of reference types,
        compare references, not objects.<br>
        The function
        <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_deep_clone">deep_clone</A>
        produces a duplicate of an entire object structure. The boolean function
        <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_deep_equal">deep_equal</a>
        determines whether
        two object structures are recursively
        identical. These routines are the <i>deep</i> counterparts of the shallow copy and equality
        tests provided by
        <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_clone">clone</A>
        and
        <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_equal">equal</A>.<br>
        A class that needs a specific notion of equality and the corresponding copy
        semantics may redefine <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_copy">copy</a>
        and <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_is_equal">is_equal</a>
        (from which
        <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_equal">equal</A>
        follows, since
        <A CLASS="efeature" HREF="../../reference/kernel/any.html#f_equal">equal
        </A><SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">a</SPAN><SPAN CLASS="esymbol">,</SPAN>
        <SPAN CLASS="elocal">b</SPAN><SPAN CLASS="esymbol">)</SPAN> is defined as
        <SPAN CLASS="elocal">a</SPAN><SPAN CLASS="esymbol">.</SPAN><a CLASS="efeature" HREF="../../reference/kernel/any.html#f_is_equal">is_equal</a>
        <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">b</SPAN><SPAN CLASS="esymbol">)</SPAN>  for non-void <SPAN CLASS="elocal">a</SPAN>).
        You will find such redefinitions in a number of classes of the Base libraries. For example an instance of
        <A CLASS="eclass" HREF="../../reference/kernel/string.html">STRING</A> is a string
        descriptor containing a reference to the actual character sequence, not that sequence
        itself, so that what the default equal compares and the default copy copies is the
        descriptor, not the string. Class <A CLASS="eclass" HREF="../../reference/kernel/string.html">STRING</A>
        redefines these routines to yield the semantics
        normally expected by string clients; the frozen variants <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_standard_copy">standard_copy</a>
        and <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_standard_equal">standard_equal</a>, originally declared as synonyms to equal and copy, remain available with the
        default semantics.<br>
        The function <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_clone">clone</a>
        is defined in terms of <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_copy">copy</a>, and so will follow any redefinition
        of <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_copy">copy</a>. This makes it impossible to change the semantics of one but not of the other,
        which would be a mistake. The variant <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_standard_clone">standard_clone</a>
        is defined in terms of <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_standard_copy">standard_copy</a>.</p>
        <h3 align="left">Type information</h3>
        <p align="left">
        The string-valued query <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_generator">generator</a>, applied to any object, returns the name of the
        object’s generating class: the class of which it is an instance. The boolean function
        <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_conforms_to">conforms_to</a>
        makes it possible to test dynamically whether the
        type of an object conforms to that of another - that is to say whether the first one’s
        generator is a descendant of the second one’s.<br>
        These two features enable clients to ascertain the dynamic type of an entity at runtime. They are only useful for low-level components; the normal mechanism for type-dependent operations is dynamic binding.</p>
        <h3 align="left">Miscellaneous</h3>
        <p align="left">
        The query <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_void">Void</a>, of type
        <SPAN CLASS="eclass">NONE</SPAN>, denotes a reference that is always void - not attached to
        any object.<br>
        Procedure <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_do_nothing">do_nothing</a>
        does what its name implies.<br>
        Function <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_default">default</a>
        also has an
        empty body; its result type is <SPAN CLASS="ekeyword">like Current</SPAN>, so what it returns is the default value of the
        current type. This is mostly interesting for expanded types, since for reference types the
        default value is simply a void reference.
        </p>
        <h2 align="left">
        LANGUAGE-RELATED FACILITIES
        </h2>
        <p align="left">
        A number of classes offer facilities which are very close to the language level. Here too
        the book Eiffel: The Language covers the classes in detail, so we can satisfy ourselves
        with a quick summary; the flat-short forms appear in part C.
        </p>
        <h2 align="left">
        Basic types
        </h2>
    <p align="left">The basic types <a CLASS="eclass" HREF="../../reference/kernel/boolean.html">BOOLEAN</a>,
    <a CLASS="eclass" HREF="../../reference/kernel/character.html">CHARACTER</a>,
    <a CLASS="eclass" HREF="../../reference/kernel/integer.html">INTEGER</a>, <a CLASS="eclass" HREF="../../reference/kernel/real.html">REAL</a>
    and <a CLASS="eclass" HREF="../../reference/kernel/double.html">DOUBLE</a> are defined
    by classes of the Kernel library.<br>
    In reading the class specifications for the numeric types <a CLASS="eclass" HREF="../../reference/kernel/integer.html">INTEGER</a>,
    <a CLASS="eclass" HREF="../../reference/kernel/real.html">REAL</a> and <a CLASS="eclass" HREF="../../reference/kernel/double.html">DOUBLE</a>, you might think that the type declarations are too restrictive. For example the
    addition operation in class <a CLASS="eclass" HREF="../../reference/kernel/real.html">REAL</a>
    reads<br>
        <code>
        <SPAN CLASS="ekeyword">infix</SPAN> <SPAN CLASS="esymbol">"+" (</SPAN><SPAN CLASS="elocal">other</SPAN><SPAN CLASS="esymbol">:</SPAN>
        <a CLASS="eclass" HREF="../../reference/kernel/real.html">REAL</a><SPAN CLASS="esymbol">):</SPAN>
        <a CLASS="eclass" HREF="../../reference/kernel/real.html">REAL</a>
        </code><br>
    <p align="left">but there is actually no problem here. A language convention applicable to all arithmetic
    expressions, the Balancing rule, states that in any such expression all operands are
    considered to be converted to the heaviest type, where <a CLASS="eclass" HREF="../../reference/kernel/double.html">DOUBLE</a>
    is heavier than <a CLASS="eclass" HREF="../../reference/kernel/real.html">REAL</a>
    and <a CLASS="eclass" HREF="../../reference/kernel/real.html">REAL</a> is heavier than
    <a CLASS="eclass" HREF="../../reference/kernel/integer.html">INTEGER</a>. So
    mixed-type arithmetic, consistent with common practice, is possible and indeed frequent.
        </p>
        <h3 align="left">
 Arrays
        </h3>
        <p>
        To create and manipulate one-dimensional arrays, use class <a CLASS="eclass" HREF="../../reference/kernel/array.html">ARRAY</a>
        of the Kernel Library. Arrays are not primitive language elements; instead, they are handled through class
        <a CLASS="eclass" HREF="../../reference/kernel/array.html">ARRAY</a>. This class is “normal” in the sense that it may be used just as any other class
        by client and descendant classes. It is also somewhat special, however, in that the Eiffel
        compiler knows about it and uses this knowledge to generate efficient code for array
        operations.<br>
        To create an instance of <a CLASS="eclass" HREF="../../reference/kernel/array.html">ARRAY</a>, use the creation instruction
        <br>
        <code>
        <SPAN CLASS="ekeyword">create</SPAN>
        <SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">.</SPAN><a CLASS="efeature" HREF="../../reference/kernel/array.html#f_make">make</A>
        <SPAN CLASS="esymbol">(1,</SPAN> <SPAN CLASS="elocal">u</SPAN><SPAN CLASS="esymbol">)</SPAN>
        </code>
        <br>
        where the arguments indicate the lower and upper bounds. These bounds will then be
        accessible as <SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">.</SPAN><a CLASS="efeature" HREF="../../reference/kernel/array.html#f_lower">lower</a>
        and <SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">.</SPAN><a CLASS="efeature" HREF="../../reference/kernel/array.html#f_upper">upper</a>. The number of items is
        <SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">.</SPAN><a CLASS="efeature" HREF="../../reference/kernel/array.html#f_count">count</a>;
         feature <a CLASS="efeature" HREF="../../reference/kernel/array.html#f_capacity">capacity</a>
        is a synonym for <a CLASS="efeature" HREF="../../reference/kernel/array.html#f_count">count</a>. The class invariant expresses
        the relation between <a CLASS="efeature" HREF="../../reference/kernel/array.html#f_count">count</a>,
        <a CLASS="efeature" HREF="../../reference/kernel/array.html#f_lower">lower</a>
        and <a CLASS="efeature" HREF="../../reference/kernel/array.html#f_upper">upper</a>.<br>
        To access and change the item at index i in array a, you may use features
        <a CLASS="efeature" HREF="../../reference/kernel/array.html#f_item">item</a>
        and <a CLASS="efeature" HREF="../../reference/kernel/array.html#f_put">put</a>, as in
        <br>
        <code>
        x := <SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">.</SPAN><a CLASS="efeature" HREF="../../reference/kernel/array.html#f_item">item</a>
        <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">i</SPAN><SPAN CLASS="esymbol">)</SPAN><br>
        <SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">.</SPAN><a CLASS="efeature" HREF="../../reference/kernel/array.html#f_put">put</a>
        <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">new_value</SPAN><SPAN CLASS="esymbol">,</SPAN> <SPAN CLASS="elocal">i</SPAN><SPAN CLASS="esymbol">)<br>
        </SPAN>
        </code>
        <br>
        Function
        <a CLASS="efeature" HREF="../../reference/kernel/array.html#f_item">item</a>
        has an infix synonym, <SPAN CLASS="ekeyword">infix</SPAN>
        <SPAN CLASS="esymbol">"</SPAN><A CLASS="efeature" HREF="../../reference/kernel/array.html#f__infix_@">@</A><SPAN CLASS="esymbol">"</SPAN>,
        so that you may also write the first assignment above more concisely as<br>
        <code>x := <SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol"> </SPAN><a CLASS="efeature" HREF="../../reference/kernel/array.html#f_item">@</a>
        <SPAN CLASS="elocal">i</SPAN><br>
        <SPAN CLASS="elocal"></SPAN>
        </code><br>
        Features
        <a CLASS="efeature" HREF="../../reference/kernel/array.html#f_item">item</a>,
        <SPAN CLASS="ekeyword">infix</SPAN>
        <SPAN CLASS="esymbol">"</SPAN><A CLASS="efeature" HREF="../../reference/kernel/array.html#f__infix_@">@</A><SPAN CLASS="esymbol">"
        </SPAN>and <a CLASS="efeature" HREF="../../reference/kernel/array.html#f_put">put</a>
        have preconditions requiring the index
        (<SPAN CLASS="elocal">i</SPAN>in the above calls) to be within the bounds of the array. This means that you can detect
        bounds violations (which correspond to bugs in the client software) by using a version
        of class ARRAY compiled with precondition checking on. The bounds of an array may be changed dynamically through procedure resize.
        Previously entered elements are retained. Rather than an explicit resize, you may use calls to procedure force which has the
        same signature as put but no precondition; if the index is not within the current bounds
        force will perform a resize as necessary.
        <h3>
        Optimizing array computations</h3>
        <p class="warning">
        <b>
        CAUTION</b>: Although <a CLASS="eclass" HREF="../../reference/kernel/array.html">ARRAY</a>
        benefits from an efficient implementation, its more advanced
        facilities such as resizing do not come for free. For extensive computations on large
        arrays, an optimization may be desirable, bypassing these facilities. The technique
        yields loops that run at about the same speed as the corresponding loops written in C or
        Fortran (the usual references for array computations). It is of interest for advanced uses
        only, so that you may safely skip this section on first reading unless your domain of
        application is numerical computation or some other area requiring high-performance
        array manipulations.</p>
        <p>
        The optimization relies on the class <a CLASS="eclass" HREF="../../reference/kernel/special.html">SPECIAL</a>, used internally by
        <a CLASS="eclass" HREF="../../reference/kernel/array.html">ARRAY</a> but of no
        direct interest to client developers in most common uses. With the declarations
        <br>
        <code>
        <SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">:</SPAN> <a CLASS="eclass" HREF="../../reference/kernel/array.html">ARRAY</a>
        <SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">SOME_TYPE</SPAN><SPAN CLASS="esymbol">]</SPAN><br>
        <SPAN CLASS="elocal">direct_access</SPAN><SPAN CLASS="esymbol">:</SPAN>
        <a CLASS="eclass" HREF="../../reference/kernel/special.html">SPECIAL</a>
        <SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">SOME_TYPE</SPAN><SPAN CLASS="esymbol">]</SPAN><br>
        </code>
        <br>
        you may use direct_access in lieu of my_array within a critical loop, provided none of
        the operations may resize the array. Typically, the operations should only include
        <a CLASS="efeature" HREF="../../reference/kernel/special.html#f_put">put</a>
        and <a CLASS="efeature" HREF="../../reference/kernel/special.html#f_item">item</a>. In such a case you can use the following scheme:
        <br>
        <code>
        <SPAN CLASS="elocal">direct_access</SPAN><SPAN CLASS="esymbol">:=</SPAN>
        <SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">.</SPAN><a CLASS="efeature" HREF="../../reference/kernel/array.html#f_area">area</a><br>
        <SPAN CLASS="ecomment">-- The critical loop:</SPAN><br>
        <SPAN CLASS="ekeyword">from</SPAN><br>
        &nbsp;&nbsp; <SPAN CLASS="efeature">some_initialization</SPAN><br>
        &nbsp;&nbsp; <SPAN CLASS="elocal">index</SPAN> <SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="elocal">some_initial_index</SPAN><br>
        <SPAN CLASS="ekeyword">until</SPAN><br>
        &nbsp;&nbsp; <SPAN CLASS="elocal">index</SPAN> <SPAN CLASS="esymbol">=</SPAN> <SPAN CLASS="elocal">some_final_index</SPAN><br>
        <SPAN CLASS="ekeyword">loop</SPAN><br>
        &nbsp;&nbsp; ...<br>
        &nbsp;&nbsp; <SPAN CLASS="elocal">x</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
        <SPAN CLASS="elocal">direct_access</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/special.html#f_item">item</A>
        <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">index</SPAN><SPAN CLASS="esymbol">)</SPAN><br>
        &nbsp;&nbsp; ...<br>
        &nbsp;&nbsp; <SPAN CLASS="elocal">direct_access</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/special.html#f_item">put</A>
        <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">some_value</SPAN><SPAN CLASS="esymbol">,</SPAN>
        <SPAN CLASS="elocal">index</SPAN><SPAN CLASS="esymbol">)</SPAN><br>
        &nbsp;&nbsp; ...<br>
        <SPAN CLASS="ekeyword">end</SPAN><br>
        </code>
        This replaces an original loop where the operations were on <SPAN CLASS="elocal">my_array</SPAN>. Feature area
        of <a CLASS="eclass" HREF="../../reference/kernel/array.html">ARRAY</a> gives direct access to the special object, an instance of
        <a CLASS="eclass" HREF="../../reference/kernel/special.html">SPECIAL</a>, containing
        the array values. Features
        <A CLASS="efeature" HREF="../../reference/kernel/array.html#f_put">put</A>
        and
        <A CLASS="efeature" HREF="../../reference/kernel/array.html#f_item">item</A>
        are available in <a CLASS="eclass" HREF="../../reference/kernel/special.html">SPECIAL</a>
        as in <a CLASS="eclass" HREF="../../reference/kernel/array.html">ARRAY</a>,
        but without the preconditions; in other words, you will not get any bounds checking.
        Instances of <a CLASS="eclass" HREF="../../reference/kernel/special.html">SPECIAL</a>
        are always indexed from zero, in contrast with arrays, whose lower bound is arbitrary, 1 being the most common value. But rather than performing
        index translations (that is to say, subtracting
        <SPAN CLASS="elocal">my_array</SPAN><SPAN CLASS="esymbol">.</SPAN>lower
        from
        <A CLASS="efeature" HREF="../../reference/kernel/array.html#f_index">index</A>
        throughout the loop) it is preferable to use the following simple technique: if the lower bound lb of
        <SPAN CLASS="elocal">my_array</SPAN> is 1 or another small integer, use 0 as lower bound instead when creating
        <SPAN CLASS="elocal">my_array</SPAN>, but only use the positions starting at lb. You will waste a few memory positions
        (0 to lb-1), but will not have to change anything in your algorithm and will avoid costly
        subtractions.<br>
        It is important to note that this optimization, if at all necessary, should at most affect
        a few loops in a large system. You should always begin by writing your software using
        the normal <a CLASS="eclass" HREF="../../reference/kernel/array.html">ARRAY</a>
        facilities; then once you have the certainty that the software is
        correct, if you detect that a large array computation is hampering the efficiency of the
        system, you may apply the above technique to get the fastest performance out of that
        computation. The change to the software will be minimal - a few lines - and will be
        easy to undo if necessary.
        <h3>
        Strings</h3>
        <p>
        Strings are handled by class <a CLASS="eclass" HREF="../../reference/kernel/string.html">STRING</a>, similar in many respects to
        <a CLASS="eclass" HREF="../../reference/kernel/array.html">ARRAY</a>. Strings are of arbitrary size. The make creation procedure takes an integer
        argument, as in<br>
        <code>
        <SPAN CLASS="elocal">s</SPAN><SPAN CLASS="esymbol">,</SPAN>
        <SPAN CLASS="elocal">s1</SPAN><SPAN CLASS="esymbol">,</SPAN>
        <SPAN CLASS="elocal">s2</SPAN><SPAN CLASS="esymbol">,</SPAN>
        <SPAN CLASS="elocal">s3</SPAN><SPAN CLASS="esymbol">:</SPAN>
        <a CLASS="eclass" HREF="../../reference/kernel/string.html">STRING</a><br>
        ...<br>
        <SPAN CLASS="ekeyword">create</SPAN>
        <SPAN CLASS="elocal">s</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/string.html#f_make">make</A>
        <SPAN CLASS="esymbol">(30)</SPAN>
        </code><br>
        The argument indicates the number of characters for the initial allocation. This is
        not an absolute limit: the string will automatically grow or shrink as a result of future
        operations. You may always request a resizing explicitly by calling procedure resize.
        <h3>
        String descriptor</h3>
        <p>
        The object attached at run-time to an entity such declared of type <a CLASS="eclass" HREF="../../reference/kernel/string.html">STRING</a>
        is not the actual sequence of characters but a string descriptor, which contains a
        reference to the actual string contents.<br>
        As a result, four assignment or assignment-like operations are possible:
        <ul>
          <li><b>A1</b> <SPAN CLASS="elocal">s1</SPAN> <SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="elocal">s</SPAN></li>
          <li><b>A2</b> <SPAN CLASS="elocal">s2</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/string.html#f_share">share</A>
          <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">s</SPAN><SPAN CLASS="esymbol">)</SPAN></li>
          <li><b>A3</b> <SPAN CLASS="elocal">s3</SPAN> <SPAN CLASS="esymbol">:=</SPAN> <A CLASS="efeature" HREF="../../reference/kernel/string.html#f_clone">clone</A>
          <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">s</SPAN><SPAN CLASS="esymbol">)</SPAN></li>
          <li><b>A4</b> <SPAN CLASS="elocal">s4</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/string.html#f_copy">copy</A>

          <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">s</SPAN><SPAN CLASS="esymbol">)</SPAN></li>
        </ul>
        <p>As illustrated below, <b> A1</b> is a reference assignment: <SPAN CLASS="elocal">s1</SPAN>
        will be attached to the same
        descriptor as s. <b> A2</b> keeps the descriptors distinct, but make them refer to the same
        sequence of characters. <b> A3</b> uses the redefinition of clone for class STRING:
        <SPAN CLASS="elocal">s3</SPAN>  will be
        attached to a new string, completely distinct from the string attached to
        <SPAN CLASS="elocal">s1</SPAN>  although
        made of identical characters. <b> A4</b> has almost the same effect as <b>A3</b>, but is only
        applicable if <SPAN CLASS="elocal">s4</SPAN> was not void, and will override the existing descriptor rather than
        creating a new one.</p>
    <p><img border="0" src="strings.png"></p>
    <p class="figuretitle">fig. 1: Effect of string assignment and copy
    operations</p>
        <p>
    <a CLASS="eclass" HREF="../../reference/kernel/basic_routines.html">BASIC_ROUTINES</a>
    provides a number of conversion functions, such as <a CLASS="efeature" HREF="../../reference/kernel/basic_routines.html#f_charconv">charconv</a>.</p>
        <h2>FILES, INPUT, OUTPUT</h2>
        <p>A few classes of the Kernel Library support file manipulation, input and output:
        <a CLASS="eclass" HREF="../../reference/kernel/std_files.html">STD_FILES</a>,
        <a CLASS="eclass" HREF="../../reference/kernel/file.html">FILE</a>, <a CLASS="eclass" HREF="../../reference/kernel/directory.html">DIRECTORY</a>
        and <a CLASS="eclass" HREF="../../reference/kernel/unix_file_info.html">UNIX_FILE_INFO</a>. For simple
        applications it suffices to use <a CLASS="eclass" HREF="../../reference/kernel/std_files.html">STD_FILES</a>, but to understand the concepts better it is
        preferable to look first at the other two.</p>
        <h3>General files</h3>
        <p><a CLASS="eclass" HREF="../../reference/kernel/file.html">FILE</a> describes the notion of sequential file viewed as a data structure which fits in the
        general taxonomy of EiffelBase.<br>
        The class declaration defines files as unbounded sequences of characters. This
        means that you will find in <a CLASS="eclass" HREF="../../reference/kernel/file.html">FILE</a>
        all the operations on sequential data structures that you have come to know and love by reading this documentation - at least, all
        that apply. Just as stacks and linked lists, files have put, extend, has, item and so on.
        More specific to files are the typed input and output operations. For output, you will
        find <a CLASS="efeature" HREF="../../reference/kernel/file.html#f_put_character">put_character</a>,
        <a CLASS="efeature" HREF="../../reference/kernel/file.html#f_put_integer">put_integer</a>,
        <a CLASS="efeature" HREF="../../reference/kernel/file.html#f_put_real">put_real</a>,
        <a CLASS="efeature" HREF="../../reference/kernel/file.html#f_put_double">put_double</a>
        and <a CLASS="efeature" HREF="../../reference/kernel/file.html#f_put_string">put_string</a>, as well as
        <a CLASS="efeature" HREF="../../reference/kernel/file.html#f_new_line">new_line</a>. For input you
        will find <a CLASS="efeature" HREF="../../reference/kernel/file.html#f_read_integer">read_integer</a>
        and its co-conspirators.</p>
        <p class="warning">
        <b>CAUTION</b>:
        Note the application to input features of the command-query separation principle.<br>
        The input features such as <a CLASS="efeature" HREF="../../reference/kernel/file.html#f_read_integer">read_integer</a>
        do not by themselves return a result; they set the
        values of queries such as <a CLASS="efeature" HREF="../../reference/kernel/file.html#f_last_integer">last_integer</a>. So the normal way to read is through two operations:<br>
        <br>
        <SPAN CLASS="elocal">my_ file</SPAN><SPAN CLASS="esymbol">.</SPAN>
        <a CLASS="efeature" HREF="../../reference/kernel/file.html#f_read_integer">read_integer</a><br>
        <SPAN CLASS="elocal">new_value</SPAN> <SPAN CLASS="esymbol">:=</SPAN>
        <SPAN CLASS="elocal">my_ file</SPAN><SPAN CLASS="esymbol">.</SPAN><a CLASS="efeature" HREF="../../reference/kernel/file.html#f_last_integer">last_integer</a>
        </p>
        <p>
        Queries are available to determine the status of a file, in particular exists,
        <a CLASS="efeature" HREF="../../reference/kernel/file.html#f_is_readable">is_readable</a>,
        <a CLASS="efeature" HREF="../../reference/kernel/file.html#f_is_executable">is_executable</a>,
        <a CLASS="efeature" HREF="../../reference/kernel/file.html#f_is_writable">is_writable</a>,
        <a CLASS="efeature" HREF="../../reference/kernel/file.html#f_is_creatable">is_creatable</a>,
        <a CLASS="efeature" HREF="../../reference/kernel/file.html#f_is_closed">is_closed</a>,
        <a CLASS="efeature" HREF="../../reference/kernel/file.html#f_is_open_read">is_open_read</a>
        and so on.
        </p>
        <p class="warning">
        <b>CAUTION</b>:
        You will notice in the flat-short form that all these queries except the first have
        <A CLASS="efeature" HREF="../../reference/kernel/file.html#f_exists">exists</a>
        as a precondition. This precondition is good for efficiency since it saves an
        existence test - a relatively expensive operation - when you know that a certain file
        exists. But it also means that if you have any doubt about the file’s existence you must
        use the queries in the style<br>
        <br>
        <SPAN CLASS="ekeyword">if</SPAN>
        <SPAN CLASS="elocal">my_ file</SPAN><SPAN CLASS="esymbol">.</SPAN><A CLASS="efeature" HREF="../../reference/kernel/file.html#f_exists">exists</a>
        <SPAN CLASS="ekeyword">and then</SPAN>
        <SPAN CLASS="elocal">my_ file</SPAN><SPAN CLASS="esymbol">.</SPAN><a CLASS="efeature" HREF="../../reference/kernel/file.html#f_is_readable">is_readable</a>
        <SPAN CLASS="ekeyword">then</SPAN>...</p>
        <p>
        <a CLASS="eclass" HREF="../../reference/kernel/file.html">FILE</a> is a deferred class. Various implementations are possible. A quite detailed one is
        <a CLASS="eclass" HREF="../../reference/kernel/file.html">PLAIN_TEXT_FILE</a>, which adds many features for accessing
        reading and writing data from/to a file.<br>
        <a CLASS="eclass" HREF="../../reference/kernel/unix_file_info.html">UNIX_FILE_INFO</a>
        describes objects that contain internal information, such as protection mode and size, about a file.<br>
        The class <a CLASS="eclass" HREF="../../reference/kernel/directory.html">DIRECTORY</a>
        describes those files which are directories - nodes in the tree describing the file structure.</p>
        <h3>
        Basic input and output</h3>
        <p>
        Regardless of the operating system that you use, for simple input and output
        <a CLASS="eclass" HREF="../../reference/kernel/std_files.html">STD_FILES</a>
        is sufficient. You may inherit from that class to gain direct access to its features;
        or you may declare an entity of type <a CLASS="eclass" HREF="../../reference/kernel/std_files.html">STD_FILES</a>. But remember that a feature of this
        type is always available: <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_io">io</a>, from class
        <a CLASS="eclass" HREF="../../reference/kernel/any.html">ANY</a>. Thanks to this feature you may include
        simple input and output in any class, with instructions such as<br>
        <code>
        <a CLASS="efeature" HREF="../../reference/kernel/any.html#f_io">io</a><SPAN CLASS="esymbol">.</SPAN><a CLASS="efeature" HREF="../../reference/kernel/io_medium.html#f_put_string">put_string</a>
        <SPAN CLASS="esymbol">(&quot;</SPAN><SPAN CLASS="estring">My message</SPAN><SPAN CLASS="esymbol">")</SPAN>
        </code><br>
        <p><a CLASS="eclass" HREF="../../reference/kernel/std_files.html">STD_FILES</a>
        defines three default files through features <a CLASS="efeature" HREF="../../reference/kernel/std_files.html#f_input">input</a>,
        <a CLASS="efeature" HREF="../../reference/kernel/std_files.html#f_output">output</a>and
        <a CLASS="efeature" HREF="../../reference/kernel/std_files.html#f_error">error</a>.
        These features are Once functions, so that the first reference to any one of them will
        automatically create the corresponding file descriptor and open the associated file.<br>
        To simplify the writing of common input and output operations, the most frequently
        used features of class <a CLASS="eclass" HREF="../../reference/kernel/file.html">FILE</a>
        - for reading and writing integers, reals and so on, as discussed next - have been repeated in
        <a CLASS="eclass" HREF="../../reference/kernel/std_files.html">STD_FILES</a>
        so as to apply to the default input and output. Procedure <a CLASS="efeature" HREF="../../reference/kernel/io_medium.html#f_put_string">put_string</a>
        in the example at the beginning of this section is typical: it writes its output on the standard output. More generally,
        <a CLASS="eclass" HREF="../../reference/kernel/std_files.html">STD_FILES</a>
        has all the <SPAN CLASS="efeature">put_xxx</SPAN>, <SPAN CLASS="efeature">read_xxx</SPAN> and <SPAN CLASS="efeature">last_xxx</SPAN> features of <a CLASS="eclass" HREF="../../reference/kernel/file.html">FILE</a>.</p>
        <h2>PERSISTENCE, STORAGE AND RETRIEVAL</h2>
        <p>Most object-oriented applications need the ability to store object structures on persistent
        storage for later retrieval, and to transfer such object structures to other applications.<br>
        Class <a CLASS="eclass" HREF="../../reference/kernel/storable.html">STORABLE</a>
        addresses this need.</p>
        <h3>Persistence completeness</h3>
        <p>A fundamental requirement on object persistence mechanisms is the <i> Persistence
        Completeness</i> rule, stated as follows in Eiffel: The Language:<br>
        Whenever a routine of class <a CLASS="eclass" HREF="../../reference/kernel/storable.html">STORABLE</a>
        stores an object into an external file, it stores with it the dependents of that object. Whenever
        one of the associated retrieval routines retrieves a previously stored object, it also retrieves all its dependents.<br>
        Storing an object just by itself would usually result in wrong semantics: most
        objects contain references to other objects, which must also be stored and retrieved with
        it. The persistence completeness rule ensures that this is always the case. It also means,
        of course, that the features of <a CLASS="eclass" HREF="../../reference/kernel/storable.html">STORABLE</a>
        must do much more than simple input and&nbsp; output; they must perform complete traversals of object structures.</p>
        <h3>Using the storage and retrieval facilities</h3>
        <p>Class <a CLASS="eclass" HREF="../../reference/kernel/storable.html">STORABLE</a>
        is meant to be used as ancestor. You can use its features in any descendant <SPAN CLASS="eclass">C</SPAN>; for example a routine of <SPAN CLASS="eclass">C</SPAN> may contain a call of the form
        <A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_basic_store">basic_store</A>
        <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">my_descriptor</SPAN><SPAN CLASS="esymbol">).<br>
        </SPAN>The effect of this call will be to store the current object and all its dependents into
        the file denoted by my_descriptor.<br>
        Although
        <A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_basic_store">basic_store</A>
        and other procedures of <a CLASS="eclass" HREF="../../reference/kernel/storable.html">STORABLE</a>will in general process
        objects of many different types, only the generating class of the structure’s initial object,
        <SPAN CLASS="eclass">C</SPAN> in our example, needs to be a descendant of
        <a CLASS="eclass" HREF="../../reference/kernel/storable.html">STORABLE</a>.</p>
        <h3>Varieties of store operations</h3>
        <p>Two variants of the store operation are supported: basic store and general store. Basic
        store produces more compact structures in the resulting files, and is slightly faster; but
        the resulting structure is dependent on the system which executes the store
        operation (“System” is taken here, as elsewhere in this
        documentation, in its Eiffel sense of an executable assembly of classes, compiled together with the help of an Ace specification.) This
        means that you can use procedure <A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_basic_store">basic_store</A>
        to store an object structure during an execution of a system if you will only retrieve it later in that execution, or in a<br>
        subsequent execution of the same system. If you need to store objects from a certain system and then retrieve them from a
        different system, possibly running on a different computer, use <a CLASS="efeature" HREF="../../reference/kernel/storable.html#f_general_store">general_store</a>.
        The result of <a CLASS="efeature" HREF="../../reference/kernel/storable.html#f_general_store">general_store</a>
        is still platform-dependent; the representation of numbers, in particular, is determined by the underlying machine architecture. A third variant called
        <a CLASS="efeature" HREF="../../reference/kernel/storable.html#f_independent_store">independent_store</a>
        will be added in the future to <a CLASS="eclass" HREF="../../reference/kernel/storable.html">STORABLE</a>, using an entirely platform-independent
        storage format; then a system running on a computer with a certain architecture
        will be able to retrieve, without any explicit conversion operation, object structures stored by a
        system running on a machine of a completely different architecture. With
        <a CLASS="efeature" HREF="../../reference/kernel/storable.html#f_general_store">general_store</a>
        the<br>
        storing and retrieving computers must have compatible architectures.</p>
        <h3>Retrieval</h3>
        <p>You only need to be aware of the difference between basic and general store at storage
        time. The stored structure will always be available through feature retrieved; this feature
        will figure out, from the format of the stored structure, whether it was stored by
        <A CLASS="efeature" HREF="../../reference/kernel/storable.html#f_basic_store">basic_store</A>
        or <a CLASS="efeature" HREF="../../reference/kernel/storable.html#f_general_store">general_store</a>, and will decode it accordingly.<br>
        Feature retrieved returns a result of type <a CLASS="eclass" HREF="../../reference/kernel/storable.html">STORABLE</a>
        and is typically used through an assignment attempt of the form<br>
        <code>
        <SPAN CLASS="local">x</SPAN> <SPAN CLASS="esymbol">?=</SPAN>
        <a CLASS="efeature" HREF="../../reference/kernel/storable.html#f_retrieved">retrieved</a>
        <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">my_descriptor</SPAN><SPAN CLASS="esymbol">)</SPAN>
        </code><br>
        <p>The assignment attempt is necessary because <a CLASS="efeature" HREF="../../reference/kernel/storable.html#f_retrieved">retrieved</a>
        returns a result of type
        <a CLASS="eclass" HREF="../../reference/kernel/storable.html">STORABLE</a>&nbsp;
        whereas the type of <SPAN CLASS="elocal">x</SPAN> will be based on a proper descendant of <a CLASS="eclass" HREF="../../reference/kernel/storable.html">STORABLE</a>.
        If the structure in the file has been corrupted and retrieved is unable to do its job, it
        will trigger an exception. The code for that exception in class <a CLASS="eclass" HREF="../../reference/kernel/exceptions.html">EXCEPTIONS</a>
        (which inherits it from <a CLASS="eclass" HREF="../../reference/kernel/excep_const.html">EXCEP_CONST</a>
        and is discussed in the next section, together with the notion of exception code) is
        <SPAN CLASS="efeature">Retrieve_exception</SPAN>.</p>
        <h2>ACCESS TO INTERNAL PROPERTIES</h2>
        <p>In some applications you may need to fine-tune the exception handling and memory
        management mechanisms. You may also need a simple way to access command-line
        arguments. In less common cases you may require low-level access to internal
        properties of objects.</p>
        <h3>Exception handling</h3>
        <p>Class <a CLASS="eclass" HREF="../../reference/kernel/exceptions.html">EXCEPTIONS</a>
        enables you to control the handling of exceptions. <a CLASS="eclass" HREF="../../reference/kernel/unix_signals.html">UNIX_SIGNALS</a>, discussed next, complements it for the special case of fine-grain signal
        handling on Unix or Unix-like platforms. Both are meant to be inherited by any class
        that needs their facilities.<br>
        The basic exception mechanism treats all exceptions in the same way. In some cases
        it may be useful to discriminate in a Rescue clause between the various possible causes.<br>
        Class <a CLASS="eclass" HREF="../../reference/kernel/exceptions.html">EXCEPTIONS</a>
        provides the features to do this. Each kind of exception has an integer code, which you can use through several features:</p>
        <ul>
          <li>The integer-valued query <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_exception">exception</a>
            which gives the code of the latest exception.</li>
          <li>Queries which determine the general nature of the latest exception:
            <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_is_signal">is_signal</a>
            which determines whether the exception was an operating system signal;
            <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_is_developer_exception">is_developer_exception</a>
            which determines whether it was explicitly caused by a
            raise, as explained next; <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_assertion_violation">assertion_violation</a>.</li>
          <li>Query <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_recipient_name">recipient_name</a>
            which gives the name of the exception’s recipient - the
            routine that was interrupted by the exception.</li>
        </ul>
        <p>The class also provides a set of constant integer-valued attributes which denote the
        various possible codes, such as No_more_memory, Routine_ failure and Precondition_violation. So you can test the value of exception against these codes if you need to
        ascertain the precise nature of an exception. To keep <a CLASS="eclass" HREF="../../reference/kernel/exceptions.html">EXCEPTIONS</a>
        simple these constant attributes are declared in a class <a CLASS="eclass" HREF="../../reference/kernel/excep_const.html">EXCEP_CONST</a>, of which
        <a CLASS="eclass" HREF="../../reference/kernel/exceptions.html">EXCEPTIONS</a>
        is an heir.<br>
        Another occasional requirement is for a mechanism to trigger an exception
        explicitly. Procedure <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_raise">raise</a>
        answers this needs; the argument, a string, is the tag chosen for the exception. The code in this case is Developer_exception; the query
        <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_is_developer_exception">is_developer_exception</a>
        will return true; and the tag is accessible through feature <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_tag_name">tag_name</a>.<br>
        You will notice in the interface specification for <a CLASS="eclass" HREF="../../reference/kernel/exceptions.html">EXCEPTIONS</a>
        that for some properties of the latest exception there are two features, one with a name such as
        <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_exception">exception</a>
        or <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_recipient_name">recipient_name</a>
        as seen above and the other with a name prefixed by original_: <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_original_exception">original_exception</a>,
        <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_original_recipient_name">original_r</a><a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_recipient_name">ecipient_name</a>.</p>
        <p><b>
        CAUTION</b>: The reason for the presence of these pairs is that the immediately visible cause of a
        routine interruption may not be the real one. Assume that routine <SPAN CLASS="efeature">r</SPAN> from class <SPAN CLASS="eclass">C</SPAN>, which
        has a Rescue clause, calls <SPAN CLASS="efeature">s</SPAN> from <SPAN CLASS="eclass">D</SPAN> with no Rescue clause, and that some call executed
        by <SPAN CLASS="efeature">s</SPAN> causes a precondition violation. Because <SPAN CLASS="efeature">s</SPAN> has no Rescue clause of its own, <SPAN CLASS="efeature">s</SPAN> will fail. Up the call chain, the first
        routine that has a Rescue clause - <SPAN CLASS="efeature">r</SPAN> itself, or one of its own direct or indirect callers -
        may process the exception; but if it examines the exception code through attribute
        exception it will get the value of Routine_failure. This may be what you want; but to
        handle the situation in a finer way you will usually need to examine the code for the
        original exception, the one that interrupted <SPAN CLASS="efeature">s</SPAN>. This code will be accessible through the
        attribute <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_original_exception">original_exception</a>, which in this case will have the value of
        <SPAN CLASS="efeature">Precondition</SPAN>, the
        exception code for precondition violations. So you have the choice between exploring
        the properties of the original exception, or those of the resulting routine failures. Just
        make sure you know what you are looking for.</p>
        <p>As you will see from the header comments in the flat-short form of class <a CLASS="eclass" HREF="../../reference/kernel/exceptions.html">EXCEPTIONS</a>, the queries that return detailed information about an exception, such as
        <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_assertion_violation">assertion_violation</a>, all give an answer determined by
        <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_original_exception">original_exception</a>
        rather than <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_exception">exception</a>, since when the two are different (that is to say, when you handle the
        exception in a routine other than the original recipient) the value of <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_exception">exception</a>
        is always
        <SPAN CLASS="efeature">Routine_failure</SPAN> and there is nothing more to say about it.</p>
        <h3>Signal handling</h3>
        <p>The features of class <a CLASS="eclass" HREF="../../reference/kernel/exceptions.html">EXCEPTIONS</a>
        enable you to determine whether a certain
        exception is a signal - an operating system event such as may result from a child
        process that disappears, a window that is resized, a user that hits the Break key and
        many others. But they do not give you more details because the exact set of possible
        signals is highly platform-dependent.<br>
        Class <a CLASS="eclass" HREF="../../reference/kernel/unix_signals.html">UNIX_SIGNALS</a>
        complements <a CLASS="eclass" HREF="../../reference/kernel/excep_const.html">EXCEP_CONST</a>
        by providing codes for the signals of Unix and similar systems, such as Sigkill for the “kill” signal and Sigbus for
        bus error.<br>
        Query <a CLASS="efeature" HREF="../../reference/kernel/exceptions.html#f_is_defined">is_defined</a>
        <SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">some_signal</SPAN><SPAN CLASS="esymbol">)</SPAN>, where
        <SPAN CLASS="elocal">some_signal</SPAN> is an integer code, will
        determine whether some_signal is supported on the platform.<br>
        A class whose routines need to perform specific processing depending on the nature
        of signals received should inherit from <a CLASS="eclass" HREF="../../reference/kernel/unix_signals.html">UNIX_SIGNALS</a>, or a similar class for another
        platform.<br>
        Because signal codes are platform-dependent, the features of <a CLASS="eclass" HREF="../../reference/kernel/unix_signals.html">UNIX_SIGNALS</a>
        are
        implemented as once functions - computed on the first call - rather than constants,
        although this makes no difference to clients.</p>
        <h3>Memory management</h3>
        <p>Class <a CLASS="eclass" HREF="../../reference/kernel/memory.html">MEMORY</a>, like <a CLASS="eclass" HREF="../../reference/kernel/exceptions.html">EXCEPTIONS</a>, is meant to be used as an ancestor by classes that
        need its facilities. It offers a number of features for controlling memory management
        and fine-tuning the garbage collection mechanism, a key component of the ISE Eiffel
        environment.<br>
        One of the most useful features in this class is dispose. This procedure describes
        actions to be applied to an unreachable object just before the garbage collector reclaims
        it. By default, as declared in <a CLASS="eclass" HREF="../../reference/kernel/memory.html">MEMORY</a>, the procedure does nothing; but you may
        redefine it in a proper descendant of <a CLASS="eclass" HREF="../../reference/kernel/memory.html">MEMORY</a>
        to describe dispose actions. Normally such actions will involve freeing external resources: for example a class describing file
        descriptors may redefine dispose so that whenever a descriptor object is garbage-collected
        the corresponding file will be closed.</p>
        <p class="warning"><b>CAUTION</b>: This example is typical of proper uses of dispose.In
        a dispose procedure you should not include any instruction that could modify the Eiffel object structure, especially if some objects in that
        structure may themselves have become unreachable: these instructions could conflict with the
        garbage collector’s operations and cause catastrophic behavior. The legitimate use of dispose
        redefinitions is for disposing of non-Eiffel resources.</p>
        <p>Other features of <a CLASS="eclass" HREF="../../reference/kernel/memory.html">MEMORY</a>
        provide direct control over the operation of the garbage collector. You can in particular stop garbage collection through a call to
        <A CLASS="efeature" HREF="../../reference/kernel/memory.html#f_collection_off">collection_off</A>,
        and restart it through a call to
        <A CLASS="efeature" HREF="../../reference/kernel/memory.html#f_collection_on">collection_on</A>.
        By default, garbage collection is always on (a testimony to its authors’ trust in its efficiency).
        Garbage collection is normally incremental, so as not to disrupt the application in a
        perceptible way. To start a complete garbage collection mechanism - reclaiming all
        unused objects - call procedure full_collect. The remaining features of <a CLASS="eclass" HREF="../../reference/kernel/memory.html">MEMORY</a>
        enable finer control of the collection<br>
        mechanism and are useful in special cases only. You will even find a free procedure
        providing brave (and competent) developers with a mechanism for reclaiming
        individual objects manually.<br>
        <a CLASS="eclass" HREF="../../reference/kernel/mem_info.html">MEM_INFO</a>, the result type for query
        <a CLASS="efeature" HREF="../../reference/kernel/memory.html#f_memory_statistics">memory_statistics</a>
        in
        <a CLASS="eclass" HREF="../../reference/kernel/memory.html">MEMORY</a>, describes objects
        containing information collected about memory usage. The features of <a CLASS="eclass" HREF="../../reference/kernel/gc_info.html">GC_INFO</a>
        provide statistics about the garbage collector’s operation.</p>
        <h3>Command-line arguments</h3>
        <p>Writing, assembling and compiling a system yields an executable command. The
        system’s users will call that command with arguments. These are normally provided in
        textual form on the command line, as in<br>
        <code>
        <b>your_system</b> arg1 arg2 arg3
        </code><br>
        although one may conceive of other ways of entering the command arguments, such as
        tabular or graphical form-filling. In any case the software must be able to access the
        values passed as command arguments.<br>
        A language mechanism is available for that purpose: the Root Class rule indicates
        that the creation procedure of the root class may have a single argument (in the Eiffel
        sense of argument to a routine) of type <a CLASS="eclass" HREF="../../reference/kernel/array.html">ARRAY</a>
        [<a CLASS="eclass" HREF="../../reference/kernel/string.html">STRING</a><SPAN CLASS="esymbol">]</SPAN>. The corresponding array of
        strings will be initialized at the beginning of the system’s execution with the values
        entered as arguments to that execution of the command.<br>
        Although this facility suffices in many cases, it is not always convenient if you
        suddenly need to access the command arguments in a class that is far-away from the
        root. An alternative mechanism, class <a CLASS="eclass" HREF="../../reference/kernel/arguments.html">ARGUMENTS</a>, is available. Once again, this is a
        class from which you should inherit if you need its facilities. It has just two exported
        features:</p>
        <ul>
          <li><a CLASS="efeature" HREF="../../reference/kernel/arguments.html#f_argument_count">argument_count</a>, a non-negative integer, is the number of command arguments.</li>
          <li><a CLASS="efeature" HREF="../../reference/kernel/arguments.html#f_argument">argument</a>
            (i), a string, is the i-th command argument. Here <SPAN CLASS="elocal">i</SPAN> must be between <SPAN CLASS="esymbol">0</SPAN>
            and <a CLASS="efeature" HREF="../../reference/kernel/arguments.html#f_argument_count">argument_count</a>; the convention is that for
            <SPAN CLASS="elocal">i</SPAN> <SPAN CLASS="esymbol">= 0</SPAN> the result is the name of the command
            itself.</li>
        </ul>
	</BODY>
</HTML>
