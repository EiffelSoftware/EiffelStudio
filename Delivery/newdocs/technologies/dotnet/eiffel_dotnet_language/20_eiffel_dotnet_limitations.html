<HTML>
	<HEAD>
		<TITLE>Eiffel.NET Limitations</TITLE>
		<LINK REL=StyleSheet HREF="../../../default.css">
	</HEAD>

<body>

<h1>Differences between Eiffel, Eiffel for .NET and .NET</h1>

<h2>Differences between Eiffel and Eiffel for .NET</h2>

<h3>Limitation of Eiffel for .NET in version 5.1</h3>

<p>Most of the Eiffel mechanisms are supported in 5.1. All missing features listed below are planned for
addition in 5.2:</p>

<ul>
  <li>No expanded class support</li>
  <li>No generic parameter creation</li>
  <li>No correct creation of object whose type is anchored to another one.</li>
  <li>Partial implementation of generic conformance (same as what was supported
  up to and including ISE Eiffel 4.2).</li>
  <li>Eiffel classes cannot inherit from .NET classes, they can only be clients</li>
  <li>Compiler performances are poor (both in terms of memory usage and speed)</li>
</ul>

<p>Eiffel for .NET supports:</p>

<ul>
  <li>Multiple Inheritance</li>
  <li>Design By Contract</li>
  <li>Exception handling</li>
  <li>Genericity</li>
  <li>Covariance</li>
  <li>Compilation of any existing Eiffel libraries as long as it does not include C externals that
  call into the ISE C runtime</li>
</ul>

<h3>Added to Eiffel and Eiffel for .NET</h3>

<p>The following syntax can be used to declare .NET custom attributes on Eiffel
entities (features and classes):</p>

<pre><span class=efeature>empty</span>: <span class=eclass>BOOLEAN</span> is
	<span class=ekeyword>indexing</span>
		<span class="etag">description:</span> &quot;Is Current empty?&quot;
		<span class="etag"><span style="background-position: 0 0">attribute</span>:</span> <span class=ekeyword>create </span>{<span class=eclass>SYSTEM_OBSOLETEATTRIBUTE</span><span class="esymbol">}.</span><span class="efeature">make_obsoleteattribute_1</span> <span class="esymbol">(</span><span class="estring">&quot;Use `is_empty' instead&quot;</span><span class="esymbol">)</span> <span class=ekeyword>end</span>
	<span class=ekeyword>obsolete</span>
		<span class="ecomment">&quot;Use <span class=efeature>is_empty</span> instead&quot;</span>
	<span class=ekeyword>do</span>
		<span class=ekeyword>Result </span>:= <span class=efeature>is_empty</span>
	<span class=ekeyword>end</span>
</pre>

<p>The previous example shows the declaration of the obsolete feature <span class=efeature>empty
</span>. The custom attribute defined by <span class=eclass>SYSTEM_OBSOLETEATTRIBUTE.</span> is used to ensure
that any consumer of the resulting assembly will see the feature as being obsolete.</p>

<h2>Differences between Eiffel for .NET and .NET</h2>

<h3>Covariance</h3>
<p>The CLR (Common Language Runtime) does not support covariance due to the type safety issue that
full covariance implies (known as polymorphic CATCALLS
in Eiffel). Although very rare, CATCALLS are not suitable to .NET where safety is
one of the primary goals.</p>
<p>Eiffel for .NET implements a safe variant of covariance that will always perform a
check on the types to avoid a CATCALL. So when a CATCALL is going to be
performed a `Invalid Cast Exception' will be raised by the CLR instead of an
unexpected behavior as it is currently done in Eiffel.</p>
<p>Another advantage of Eiffel for .NET's implementation of covariance is that it can be
easily understood by CLS compliant consumer tools. These tools will actually benefit from the
Eiffel for .NET covariance.</p>

<h3>Genericity</h3>

<p>The CLR does not support generics at all, so that the following Eiffel for
.NET classes:</p>
<ul>
  <li>
    <span class="eclass">LIST [ANY]</span></li>
  <li><span class="eclass">LIST [INTEGER]</span></li>
</ul>

<p>will actually be generated as:</p>
<ul>
  <li><span class="eclass">LIST_ANY</span></li>
  <li><span class="eclass">LIST_Int32</span></li>
</ul>
<p>Meaning that if one wants to reuse an Eiffel generic class from another
language than Eiffel for .NET, one has to use either <span class="eclass">LIST_ANY</span> or <span class="eclass">
LIST_Int32</span>.</p>

<h3>Enum types</h3>
<p>Eiffel for .NET supports .NET enum types implicitly. From the point of view
of Eiffel, they are just considered as expanded classes. The only difference is
in the code generation. Eiffel for .NET cannot declare new enum types yet.</p>

<h3>ByRef</h3>
<p>Eiffel does not have the notion of `byref' argument passing. At the moment,
Eiffel for .NET cannot call nor can it redefine a feature that has a byref argument.</p>

</body>

</html>