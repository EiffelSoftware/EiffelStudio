<!DOCTYPE HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<HTML>
	<HEAD>
		<TITLE>Thread library overview</TITLE>
		<META NAME="MS-HKWD" CONTENT="thread library overview">
		<LINK REL=Stylesheet HREF="/default.css" TYPE="text/css">
	</HEAD>

	<BODY>
<H1>Thread library overview</H1> 
<p>This is only a quick overview of the <A HREF="/libraries/thread/reference/introduction.html">Thread library</a>. The <A HREF="../reference/index.html">reference</a> of this
library gives all its content.</p> 
<h2>Creating and launching threads: the class THREAD (deferred)</h2>
<p>The class of the thread object you want to create should inherit the THREAD class.<br>
Your thread is represented by a class which inherits from THREAD (deferred
class).
<pre>	class
		MY_THREAD

	inherit
		THREAD
		...

	feature

		execute is
			-- define the deferred feature from THREAD.
		do
			...
		end
		...

	end --class MY_THREAD

</pre>
Creating a thread is like creating an Eiffel object:
<pre>	my_thread: MY_THREAD
		-- MY_THREAD inherits from THREAD and defines
		-- the deferred procedure `execute'

	create my_thread (or my_thread.make if there is a creation feature).</pre>
<p class="note"><b>Note</b>: You have created a thread object but not yet launched it.<br>
To run the thread, use the feature `launch' from THREAD.</P>
<pre>	my_thread.launch</pre>
On the Eiffel side, the procedure `execute' will be launched. This procedure
is deferred in class THREAD, you have to define it in MY_THREAD.&nbsp;
<p>On the C side, a C thread will be created and launched.
<p>IMPORTANT: you may call `join_all' and the end of the exceution of the
creator thread if you do not want it to die before its child threads, otherwise
they may prematurily terminate.
<h2>Sharing objects between threads: the class PROXY</h2>
<p>A recurrent problem while programming multithreaded application is the
management of objects shared between several threads: the threads cannot
access to these objects at the same time. the synchronization tools CONDITION_VARIABLE,
MUTEX, SEMAPHORE are implemented
in this purpose.
<p>Another problem specific to Eiffel lies on the Eiffel Garbage Collector
(GC). Eiffel has one GC per thread: the Eiffel Threads do not interact
during allocation and collection. This implies that an Eiffel object cannot be
shared easily between thread, since each Eiffel GC moves and collect
asynchronously the objects. To share an object between thread, you must create a
proxy object, which encapsulates it. Then, you can share the object by passing
the proxy to the other thread and access it with the function `item'.
<p>To declare a proxy of object SHARED_TYPE:
<pre>	my_proxy: PROXY [SHARED_TYPE]</pre>
To create it: (be sure your object `my_item' is already created. )
<pre>	create my_proxy.put (my_item)</pre>
During the execution of your thread (take it literally: it means when&nbsp;the
procedure execute is running), you will access the shared object throughout the
proxy:
<pre>	`my_proxy.item' corresponds to the encapsulated shared object.</pre>
NOTE:
<p>When a THREAD object is launched, it is duplicated. The new thread uses this
copy as the root object for&nbsp; its execution. The THREAD object in the father
thread and in the child thread are two different objects.&nbsp;
<p>What kind of object can we put into a PROXY?
<p>For the moment only flat Eiffel objects, i.e any Eiffel objects which do not
contain any sub-references. You cannot put any expanded object. If you want to
share an object of basic type, use INTEGER_REF, BOOLEAN_REF, POINTER_REF,
CHARACTER_REF, BIT_REF, DOUBLE_REF, or REAL_REF instead.
<p>There is no need to use a proxy to share an instance of MUTEX,
CONDITION_VARIABLE or SEMAPHORE.
<h2>The class MUTEX</h2>
<p>The implementation of the class MUTEX is mapped on the C standard thread
library. An instance of class MUTEX can be shared between different thread
without putting it into a PROXY object.
<p>my_mutex.pointer is the pointer to the nested C mutex of my_mutex.
<p>Declaration of the mutex :
<pre>	my_mutex: MUTEX</pre>
Creation of mutex :
<pre>	create my_mutex.make</pre>
Locking&nbsp; the mutex :&nbsp;
<pre>	my_mutex.lock</pre>
Unlocking the mutex :
<pre>	my_mutex.unlock</pre>
try_lock: if it is not locked yet, lock the mutex and return True, otherwise
it returns False.
<pre>	my_mutex.try_lock</pre>
Is my mutex initialized?
<pre>	my_mutex.is_set</pre>
NOTE: on Windows:
<p>The MUTEX objects on Windows are recursive while they are not on Unix. A
recursive mutex can be locked twice by the same thread.&nbsp;
<p>IMPORTANT: be sure that a mutex is unlocked when it is disposed.
<h2>The class SEMAPHORE</h2>
<p>Like MUTEX, the features of this class are mapped on the C thread library. An
instance of class SEMAPHORE can be shared between thread without putting into a
PROXY object.
<p>Declaration of the semaphore :
<pre>	my_sem: SEMAPHORE</pre>
Creation of semaphore: initialize semaphore with nb_tokens, it requires
nb_tokens &gt;= 0
<pre>	create my_sem.make (nb_tokens)</pre>
<p>Wait for a token:
<pre>	my_sem.wait</pre>
Give back a token:
<pre>	my_sem.post</pre>
try_wait, similar to try_lock from MUTEX, if a token is available, take
it and return True, otherwise return False.
<pre>	my_sem.try_wait</pre>
<p>IMPORTANT: be sure that a semaphore does not wait for a token when it is
disposed</p>
<h2>The class CONDITION_VARIABLE</h2>
<p>This class allows to use condition variables in Eiffel. An instance of class
CONDITION_VARIABLE can be shared between threads without putting into a PROXY
object.<br>
<br>
Declaration of the condition variable
<pre>	my_cond: CONDITION_VARIABLE</pre>
Creation:
<pre>	create my_cond.make</pre>
Wait for a signal (send by `signal'). You need to use a mutex.
<pre>	my_mutex: MUTEX

	create my_mutex.make</pre>
<p>`my_mutex' must be locked by the calling thread so as `wait' can be called.
`wait' atomically unlocks `my_mutex' and waits for the condition variable
`my_cond' to receive a signal. As soon as it received a signal, `my_cond' locks
`my_mutex;
<pre>	my_mutex.lock
		-- You must lock `my_mutex' before calling `wait'.

	my_cond.wait (my_mutex)
		-- Here the critical code to execute when `my_cond' received a signal.

	my_mutex.unlock
		-- Unlock the mutex at the end of the critical section.

	</pre>
Send a signal one thread blocked on the condition variable `my_cond'.
<pre>	my_cond.signal</pre>
Send a signal to all the threads blocked on the condition variable `my_cond'.
<pre>	my_cond.broadcast</pre>
<p>IMPORTANT: be sure that a condition variable is unblocked when it is
disposed.</p>
<h2>The class OBJECT_OWNER</h2>
<p>Used by MUTEX, SEMAPHORE, PROXY,
and CONDITION_VARIABLE, this class prevents an
object from being disposed by a thread, which is not its creator thread.
<p>You do not need to know how to use it.
<p>Only the thread which has created an instance of OBJECT_OWNER can dispose
it.
<h2>Miscellaneous classes</h2>
<p>class THREAD_ATTRIBUTES: defines the
attributes of an Eiffel Thread.<br>
class OBJECT_CONTROL: control over objects meant
to be used within different threads. To use with care: it can allow to
share non falt objects between thread.<br>
(refer to the implementation and comments in the code of these classes)
<h2>Controlling execution: THREAD_CONTROL</h2>
<p>yield: the calling thread yields its execution in favor of&nbsp;an other
thread of same priority.
<p>join_all: the calling thread waits for all other threads to finished (all
its children).
<p>-&gt; A parent thread can wait for the termination of a child process through
the feature `join' of class THREAD_CONTROL (inherited by THREAD):<br>
<pre>	thr: MY_THREAD
	...
	thr.launch
	...
	thr.join</pre>
<br>
<p>&nbsp;</p> 

</BODY>
</HTML>
