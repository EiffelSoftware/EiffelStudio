Eiffel Vision prerelease notes. 14-Feb-2000
===========================================

This document describes the current prerelease of Eiffel Vision and changes
since the last version of 16-Nov-1999. 

 Status
 ------
  A number of design changes are described below, implementation of these
 changes is nearing completion with the GTK+ implementation slightly more
 complete than the Win32. This prerelease is intended to give selected users a
 preview of the library, it should be considered Alpha quality. Some widgets
 from previous releases have been omitted pending their review but will be back
 in coming releases.
  Bug reports should be sent through the normal channels. If you have comments
 or requests regarding the interface please send mail to Sam O'Connor
 oconnor@eiffel.com

 You will find the distribution archives at:
 ftp://ftp.eiffel.com/deliv/vision_prerelease-180271

 Please note the following:
  - This directory name should not be publicized.
  - The directory will be removed in a few days.
  - Make sure to go directly to the given directory as you will
    not be able to do an 'ls' on ftp/deliv.
  - Remember use binary mode if transferring binary files.

 Creation
 --------
  All Vision objects can now be created without arguments. This removes previous
 constraints on order of creation. `default_create' has replaced `make' so to
 create an object: EV_FOO simply write "create object".
  Convenience creation features that take initialization parameters still exist
 and are all named make_with_*. Features previously named make_from_ or make_by_
 have been renamed for consistency.

 Packing 
 -------
  The mechanism for putting widgets in containers has been revised. Containers
 are now modeled after familiar ADTs from Eiffel Base as appropriate.
 All Vision containers inherit BOX and COLLECTION. EV_WINDOW and EV_FRAME
 inherit CELL. Containers of multiple widgets or items like EV_BOX, EV_NOTEBOOK,
 EV_MENU and EV_LIST inherit DYNAMIC_LIST and SET.
  Previously a_widget.set_parent (a_container) would have been used and no
 facility was available to query the contents of a container. The revised system
 reuses base library code to take advantage proven code with strong contracts
 and a familiar interface. The standard way to put a widget into a container is
 now a_container.extend (a_widget). The full range of standard features can be
 used to manipulate widgets in containers:
 first, after, forth, item, exhausted, linear_representation, search, empty,
 fill, full, append, prune, force, extend, finish, go_i_th, has, i_th, index_of,
 isfirst, islast, last, off, put, put_i_th, start, swap, valid_cursor_index,
 valid_index, before, prunable, prune_all, merge_left, merge_right, put_left,
 wipe_out and more.

 Events 
 ------
  The new Eiffel Agent mechanism has allowed event handling to be simplified.
 Previously command classes were created to perform different tasks and command
 objects were associated with certain widget events. There was no mechanism
 for querying what commands were attached to a certain event or to manipulate
 them after the initial association.
  Replacing this is a new class ACTION_SEQUENCE. An action sequence is an
 sequence of agents that is called in order when an event occurs. Connecting a
 feature to an event is a simple matter of creating an agent on the feature and
 putting the agent into the appropriate action sequence. Any data associated
 with the event is passed through the open operands of the agent and any other
 required data may be passed through the closed operands.
  ACTION_SEQUENCE inherits LINKED_LIST [PROCEDURE] so, as with containers, the
 standard base library list manipulation features are used to manage action
 sequences. Action sequences may also be blocked to stop them responding to
 events, paused to cause them to buffer incoming events until unpaused, and
 aborted mid way through calling the sequence of actions.
  eg: To make a "Quit" button that end the application:
   qb: EV_BUTTON
   create qb
   qb.set_text ("Quit!")
   qb.press_actions.extend (application~destroy)
  or using a convenience feature
   create qb.make_with_text_and_action ("Quit!", application~destroy)

 Note:
  There is also provision for inserting agents that do not strictly conform to
 the expected type into an action sequence.
 eg EV_POINTER_MOTION_ACTION_SEQUENCE expects agents that take (x, y, x_tilt,
 y_tilt, pressure, screen_x, screen_y) but you may have some existing feature
 that only takes (x,y) that you want to call when the pointer moves.
 eg if you have set_foo_position (x, y: INTEGER) and you want it called from
 bar.pointer_motion_actions then
 a_widget.pointer_motion_actions.extend (~set_foo_position) 
 will fail because ~set_foo_position is of type PROCEDURE [ANY, TUPLE [INTEGER,
 INTEGER]] while extend was expecting PROCEDURE [ANY, TUPLE [INTEGER, INTEGER,
 DOUBLE, DOUBLE, DOUBLE, INTEGER, INTEGER]]
 so instead force_extend may be used to avoid the type checking:
 a_widget.pointer_motion_actions.force_extend (~set_foo_position)
 When `set_foo_position' is called, although all seven event data are available,
 only the first two will be passed to `set_foo_position'.

 Color
 -----
  Color was previously represented as three integers with range [0,255].
 It now uses three reals with range [0,1]. Convenience features are available
 to access color in terms of 8, 16 and 24 bit values.

 Drawing
 -------
  Drawing code is substantially complete. Drawing primitives are simplified.
 It is now possible to draw primitive figures directly without the need to
 first create a figure object. eg a_drawing_area.draw_segment (x1, y1, x2, y2).
  A new system has been added to manage more complex drawing. It separates the
 construction of a drawing from the actual act of drawing it. A world can be
 modeled using a set of abstract figures, these may be positioned relative to
 either the world or each other. A world can be inspected and modified
 dynamically. The world can then be projected onto a suitable medium such as a
 pixmap or a drawing area. A projector examines a world and draws it onto a
 medium. A standard projector and a basic set of figures are provided but this
 architecture can be extended to support any desired drawing optimizations or
 output media (printer, file etc). Modification of the model can be temporally
 decoupled from updating the display to reduce unneeded redraws. Updates can
 be triggered by a timer totally independently of the model changing. From the
 users point of view they are simply manipulating a model. The projector takes
 care of putting it on the screen for them.

 Fonts
 -----
  Fonts have been revised to support a more abstract way of describing them.
 Fonts were previously specified by a formatted string and were platform
 dependent. Fonts are now specified in terms of family (roman|sans|typewriter|
 modern|screen), weight (thin|regular|bold|black), shape (regular|italic) and
 height in pixels. The actual font displayed will be the closest match available
 on the system at runtime. An exact typeface name may be specified using
 set_preferred_face (a_preferred_face: STRING), the named face will be used if
 it is available, otherwise a best match to the specifications will be used.

 Pick and drop
 -------------
  Pick and drop has been simplified to take advantage of agents and Eiffel's
 typing system. Previously each pick and drop pebble and hole has an enumerated
 type that had to match for a pebble to be dropped in a hole. The new mechanism
 uses an attribute pebble: ANY and an action sequence `drop_actions' for the
 hole. `drop_actions' contains agents that will be called and passed a pebble
 when it is dropped. If the type of the pebble conforms to the type of the open
 argument of one of the drop_actions then the pebble may be dropped. Pebbles
 are automatically accepted by holes with conforming agents, there is no longer
 any need to set up a second typing system.
 eg:
  load_foo (a_foo: FOO) is do ... end
  load_bar (a_bar: BAR) is do ... end
  b1, b2, b3: EV_BUTTON;
  data: FOO
  b1.set_pebble (data)
  b2.drop_actions.extend (~load_foo)
  b3.drop_actions.extend (~load_bar)
 Picking from b1 and dropping on b2 will cause load_foo to be called.
 Picking from b1 and dropping on b3 will fail because the pebble doesn't match
 the hole.
  There is also a new event for holes. When a pebble is picked up that fits a
 certain hole, that hole is notified. Agents in `conforming_pick_actions' will
 be called for all holes that will accept the pebble. This may be used for
 instance to change the appearance of a hole to indicate that it will accept the
 current pebble.

 Naming conventions:
 -------------------
  - Features taking a boolean argument (set_capture (v: BOOLEAN)) are replaced
    by a pair (enable_capture, disable_capture).
  - make_from_foo, make_by_foo, make_set_foo, make_fooed, etc are replaced by
    make_with_foo.
  - Standard base library names are used wherever applicable.
    (start, forth, after, back, prune, item, has, count, empty, off, etc...)
  
 Internals
 ---------
   GTK+ memory management has been completely rewritten. The GTK+ reference
  counting system now cooperates with the eiffel garbage collector. This ensures
  that neither a GTK+ object or its shadow Eiffel object will be destroyed if
  either is accessible from Eiffel or C and that both will be destroyed when
  neither is accessible.

   Contracts have been added and revised throughout the library. Where
  previously there were few invariants and postconditions now there are many.
  Preconditions have been added wherever possible.

 End of file
 -----------
