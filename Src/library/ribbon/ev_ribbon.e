note
	description: "[
					This class is generated by EiffelRibbon Tool
					Don't modify it manually, since it would be generated again
																					]"
	date: "$Date$"
	revision: "$Revision$"

deferred class
	EV_RIBBON

inherit
	EV_ANY_HANDLER

feature -- Command

	init_with_window (a_window: EV_WINDOW)
			-- Creation method
		do
			if attached {EV_WINDOW_IMP} a_window.implementation as l_imp then
				com_initialize
				set_object_and_function_address
				item := create_ribbon_com_framework (l_imp.wel_item)
				ui_application := get_ui_application
				associated_window := l_imp
			end
		end

	set_modes (a_modes: ITERABLE [NATURAL_32])
			-- Set application mode for current ribbon framework
		require
			exists: exists
		local
			l_new_cursor: ITERATION_CURSOR [NATURAL_32]
			l_modes: NATURAL_32
		do
			from
				l_new_cursor := a_modes.new_cursor
			until
				l_new_cursor.after
			loop
				l_modes := l_modes | c_ui_make_app_node(l_new_cursor.item)
				l_new_cursor.forth
			end

			c_set_modes (l_modes, item)
		end

	c_ui_make_app_node (a_mode: NATURAL_32): NATURAL_32
			--
		external
			"C inline use <ribbon.h>"
		alias
			"[
			{
				return UI_MAKEAPPMODE((INT32) $a_mode);
			}
			]"
		end

	set_background_color (a_color: EV_RIBBON_HSB_COLOR)
			-- Set global background color with `a_color'
		require
			exists: exists
			not_void: a_color /= Void
		local
			l_key: EV_PROPERTY_KEY
		do
			create l_key.make_global_background_color
			c_set_ribbon_color (item, l_key.item, a_color.value)
		end

	set_highlight_color (a_color: EV_RIBBON_HSB_COLOR)
			-- Set global highlight color with `a_color'
		require
			not_void: a_color /= Void
		local
			l_key: EV_PROPERTY_KEY
		do
			create l_key.make_global_highlight_color
			c_set_ribbon_color (item, l_key.item, a_color.value)
		end

	set_text_color (a_color: EV_RIBBON_HSB_COLOR)
			-- Set global text color with `a_color'
		require
			not_void: a_color /= Void
		local
			l_key: EV_PROPERTY_KEY
		do
			create l_key.make_global_text_color
			c_set_ribbon_color (item, l_key.item, a_color.value)
		end

	show_contextual_ui (a_point: EV_COORDINATE; a_command_id: NATURAL_32)
			-- Show context menu or minitoolbar at
		local
			l_result: NATURAL_32
		do
			l_result := c_show_contextual_ui (a_point.x, a_point.y, item, a_command_id)
			check success: l_result = {EV_RIBBON_HRESULT}.s_ok end
		end

	destroy
			-- Clean up all ribbon related COM objects and resources
		require
			exists: exists
		do
			destroy_ribbon_com_framwork (item)
			item := default_pointer
			com_uninitialize
		end

feature {EV_RIBBON_ITEM, EV_RIBBON_TEXTABLE, EV_RIBBON_TOOLTIPABLE, EV_RIBBON_APPLICATION_MENU_RECENT_ITEMS} -- Commands

	get_command_property (a_command_id: NATURAL_32; a_key: EV_PROPERTY_KEY; a_variant: EV_PROPERTY_VARIANT)
		require
			exists: exists
			a_key_not_void: a_key /= Void
			a_key_exists: a_key.exists
			a_variant_not_void: a_variant /= Void
		do
			c_get_ui_command_property (item, a_command_id, a_key.item, a_variant.item)
		end

	set_command_property (a_command_id: NATURAL_32; a_key: EV_PROPERTY_KEY; a_variant: EV_PROPERTY_VARIANT)
		require
			exists: exists
			a_key_not_void: a_key /= Void
			a_key_exists: a_key.exists
			a_variant_not_void: a_variant /= Void
		do
			c_set_ui_command_property (item, a_command_id, a_key.item, a_variant.item)
		end

	invalidate (a_command_id: NATURAL_32; a_flags: INTEGER_32; a_key: EV_PROPERTY_KEY)
		require
			exists: exists
			a_key_not_void: a_key /= Void
			a_key_exists: a_key.exists
			valid: (create {EV_UI_INVALIDATIONS_ENUM}).is_valid (a_flags)
		do
			c_invalidate_ui_command (item, a_command_id, a_flags, a_key.item)
		end

feature -- Status Report

	tabs: ARRAYED_LIST [EV_RIBBON_TAB]
			-- All tabs in current tool bar

	height: INTEGER
			-- Get current ribbon height
		require
			exists: exists
		do
			Result := c_height (item)
		end

	exists: BOOLEAN
			-- Does current still exist?
		do
			Result := item /= default_pointer
		end

feature -- Status Report

	item: POINTER
			-- Ribbon framework object

	ui_application: POINTER
			-- IUIApplication object

	command_handler: POINTER
			-- Command handler C object

feature {NONE} -- Access

	associated_window: detachable EV_WINDOW_IMP
			-- Window associated with Current ribbon.

feature {EV_RIBBON_TITLED_WINDOW_IMP} -- Externals

	com_initialize
			-- Initialize COM
		external
			"C inline use %"Objbase.h%""
		alias
			"CoInitialize (0);"
		end

	com_uninitialize
			-- Clean up COM resources
		external
			"C inline use %"Objbase.h%""
		alias
			"CoUninitialize();"
		end

	create_ribbon_com_framework (a_hwnd: POINTER): POINTER
			-- Create Ribbon framework, attach ribbon to `a_hwnd'
		external
			"C++ inline use <ribbon.h>"
		alias
			"return InitializeFramework ((HWND) $a_hwnd);"
		end

	destroy_ribbon_com_framwork (a_framework: POINTER)
			-- Destroy ribbon framwork
		require
			a_framework_exists: a_framework /= default_pointer
		external
			"C++ inline use <ribbon.h>"
		alias
			"{
				HRESULT hr = S_OK;
				hr = ((IUIFramework *) $a_framework)->Destroy ();
			}"
		end

	c_height (a_framework: POINTER): INTEGER
			-- Get ribbon height
		require
			a_framework_exists: a_framework /= default_pointer
		external
			"C++ inline use <ribbon.h>"
		alias
			"{
				UINT32 val;
				HRESULT hr = S_OK;

				IUIRibbon* pRibbon = NULL;
				if (SUCCEEDED(((IUIFramework *) $a_framework)->GetView(0, IID_IUIRIBBON, (void **) &pRibbon))) {
					hr = pRibbon->GetHeight(&val);
					pRibbon->Release();
				}
				return (EIF_INTEGER) val;
			}"
		end

	c_show_contextual_ui (a_x, a_y: INTEGER_32; a_framework: POINTER; a_command_id: NATURAL_32): NATURAL_32
			--
		require
			a_framework_exists: a_framework /= default_pointer
		external
			"C++ inline use <ribbon.h>"
		alias
			"{
					HRESULT hr = E_FAIL;

					IUIContextualUI* pContextualUI = NULL;

					if (SUCCEEDED(((IUIFramework *)$a_framework)->GetView(
												(UINT32)$a_command_id,
												IID_PPV_ARGS(&pContextualUI))))
					{
					hr = pContextualUI->ShowAtLocation((INT32)$a_x, (INT32)$a_y);
					pContextualUI->Release();
					}

				return hr;
			}"
		end

	c_set_modes (a_mode: NATURAL_32; a_framework: POINTER)
			-- Set application mode
		require
			a_framework_exists: a_framework /= default_pointer
		external
			"C++ inline use <ribbon.h>"
		alias
			"{
				HRESULT hr = S_OK;
				hr = ((IUIFramework *) $a_framework)->SetModes($a_mode);
			}"
		end

	get_ui_application: POINTER
			-- Get Ribbon IUIApplication C object
		external
			"C inline use <ribbon.h>"
		alias
			"return GetUIApplication ();"
		end

feature {NONE} -- Implementation

	c_get_ui_command_property (a_framework: POINTER; a_command_id: NATURAL_32; a_key, a_variant: POINTER)
		require
			a_framework_not_null: a_framework /= default_pointer
			a_key_not_null: a_key /= default_pointer
			a_variant_not_null: a_variant /= default_pointer
		external
			"C++ inline use <ribbon.h>"
		alias
			"{
				HRESULT hr = S_OK;
				hr = ((IUIFramework *) $a_framework)->GetUICommandProperty(
					(UINT32) $a_command_id,
					(REFPROPERTYKEY) *(PROPERTYKEY *) $a_key,
					(PROPVARIANT *) $a_variant);
			}"
		end

	c_set_ui_command_property (a_framework: POINTER; a_command_id: NATURAL_32; a_key, a_variant: POINTER)
			--
		require
			a_framework_exists: a_framework /= default_pointer
		external
			"C++ inline use <ribbon.h>"
		alias
			"{
				HRESULT hr = S_OK;
				hr = ((IUIFramework *) $a_framework)->SetUICommandProperty(
					(UINT32) $a_command_id,
					(REFPROPERTYKEY) *(PROPERTYKEY *)$a_key,
					(REFPROPVARIANT) *(PROPVARIANT *)$a_variant);
			}"
		end

	c_invalidate_ui_command (a_framework: POINTER; a_command_id: NATURAL_32; a_flags: INTEGER; a_key: POINTER)
			--
		require
			a_framework_exists: a_framework /= default_pointer
		external
			"C++ inline use <ribbon.h>"
		alias
			"{
				HRESULT hr = S_OK;
				hr = ((IUIFramework *) $a_framework)->InvalidateUICommand(
					(UINT32) $a_command_id,
					(UI_INVALIDATIONS) $a_flags,
					(PROPERTYKEY *) $a_key);
			}"
		end

	c_set_ribbon_color (a_ribbon_framework: POINTER; a_key: POINTER; a_color_value: NATURAL_32)
			-- Set ribbon color
		external
			"C++ inline use <Propvarutil.h>"
		alias
			"[
			{			
				IPropertyStore *l_spPropertyStore;
				IUIFramework *l_framework = (IUIFramework *) $a_ribbon_framework;

				PROPVARIANT propvarBackground;
				PROPERTYKEY *property_key = (PROPERTYKEY *)$a_key;
				UI_HSBCOLOR BackgroundColor = (UI_HSBCOLOR) $a_color_value;
				InitPropVariantFromUInt32(BackgroundColor, &propvarBackground);

				if (SUCCEEDED(l_framework->QueryInterface(__uuidof(IPropertyStore), (void **)&l_spPropertyStore)))
				{
					 l_spPropertyStore->SetValue(*(property_key), propvarBackground);
 					 l_spPropertyStore->Commit();
 					 l_spPropertyStore->Release();
				}

			}
			]"
		end

feature {EV_RIBBON} -- Externals callbacks

	on_create_ui_command (a_iui_application: POINTER; a_command_id: NATURAL_32; a_ui_command_type: INTEGER; a_iui_command_handler: POINTER): NATURAL_32
			--
		local
			l_pointer: POINTER
			l_res: EV_RIBBON_RESOURCES
			l_list: ARRAYED_LIST [EV_RIBBON]
		do
			if ui_application = default_pointer then
				-- Set `ui_application' for first time
				ui_application := a_iui_application
			end
			if ui_application = a_iui_application then
				if command_handler = default_pointer then
					l_pointer := c_create_ui_command_handler (a_iui_command_handler)
					command_handler := l_pointer
				else
					c_set_command_handler (command_handler, a_iui_command_handler)
				end
			else
				-- Delegate it to other EV_RIBBON instances
				create l_res
				l_list := l_res.ribbon_list
				from
					l_list.start
				until
					l_list.after
				loop
					if l_list.item /= Current and then l_list.item.ui_application = a_iui_application then
						Result := l_list.item.on_create_ui_command (a_iui_application, a_command_id, a_ui_command_type, a_iui_command_handler)
					end
					l_list.forth
				end
			end
			Result := {EV_RIBBON_HRESULT}.s_ok;--HRESULT S_OK, must return S_OK, otherwise IUICommandHandler.updateProperty and execute will not be called
		end

	on_view_changed (a_iui_application: POINTER; a_view_id: NATURAL_32; a_type_id: INTEGER; a_view: POINTER; a_verb, a_reason_code: INTEGER): NATURAL_32
			--
		do
			Result := {EV_RIBBON_HRESULT}.e_notimpl
			if a_type_id = {EV_VIEW_TYPE}.ribbon then
				inspect a_verb
				when {EV_VIEW_VERB}.create_ then
				when {EV_VIEW_VERB}.size then
						-- We trigger a resizing of the window content associated manually.
					if attached {EV_RIBBON_TITLED_WINDOW_IMP} associated_window as l_window and then not l_window.exists then
						l_window.on_size (0, l_window.width, l_window.height)
					end

				when {EV_VIEW_VERB}.destroy then

				else

				end

				Result := {EV_RIBBON_HRESULT}.s_ok
			end
		end

	c_set_command_handler (a_iui_command_handler: POINTER; a_pointer_pointer: POINTER)
			-- Call COM queryInterface to initialize `a_pointer_pointer'
		external
			"C++ inline use %"eiffel_ribbon.h%""
		alias
			"[
			{
				HRESULT hr;
				IUICommandHandler *pCommandHandler = (IUICommandHandler *)$a_iui_command_handler;	
				IUICommandHandler ** l_command_handler = (IUICommandHandler **)$a_pointer_pointer;
				hr = pCommandHandler->QueryInterface(IID_IUICommandHandler, (void **)l_command_handler);
			}
			]"
		end

	set_object_and_function_address
			-- Set object and function addresses
			-- This set callbacks in C codes, so `execute' and `update_property' can be called in C codes.
		do
			c_set_ribbon_object ($Current)
			c_set_on_create_ui_command_address ($on_create_ui_command)
			c_set_on_view_changed_address ($on_view_changed)
		end

	c_set_ribbon_object (a_object: POINTER)
			-- Set Current object address.
		external
			"C signature (EIF_REFERENCE) use %"eiffel_ribbon.h%""
		end

	c_release_ribbon_object
			-- Release Current pointer in C
		external
			"C use %"eiffel_ribbon.h%""
		end

	c_set_on_create_ui_command_address (a_address: POINTER)
			-- Set on_create_ui_command function address
		external
			"C use %"eiffel_ribbon.h%""
		end

	c_set_on_view_changed_address (a_address: POINTER)
			-- Set on_create_ui_command function address
		external
			"C use %"eiffel_ribbon.h%""
		end

	c_create_ui_command_handler (a_iui_command_handler: POINTER): POINTER
			--
		external
			"C use %"Uiribbon.h%""
		end
end

