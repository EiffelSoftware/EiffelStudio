-- System level real body id counter.

class REAL_BODY_ID_COUNTER

inherit
	COMPILER_COUNTER
		rename
			make as old_make
		redefine
			next_id, current_subcounter, init_counter, append
		end

creation

	make

feature -- Initialization

	make is
			-- Create a new real body id counter.
		do
			old_make;
			!! debug_subcounter.make;
		end

	init_counter is
			-- Renumber ids already generated so far and continue
			-- generation from there.
		local
			compilation_id: INTEGER
			new_offset: INTEGER
		do
			compilation_id := System.compilation_id;
			new_offset := total_count
			current_subcounter := new_subcounter (compilation_id);
			current_subcounter.set_offset (new_offset)
			put (current_subcounter, compilation_id)
		end

	new_subcounter (compilation_id: INTEGER): REAL_BODY_ID_SUBCOUNTER is
			-- New real body id counter associated with `compilation_id'
		do
			if Compilation_modes.is_precompiling then
				!P_REAL_BODY_ID_SUBCOUNTER! Result.make (compilation_id)
			else
				!REAL_BODY_ID_SUBCOUNTER! Result.make
			end
		end

	append (other: like Current) is
			-- Append ids generated by `other' to `Current' and
			-- renumber the resulting set of ids.
		do
			{COMPILER_COUNTER} Precursor (other);
			frozen_level := total_count;
			set_levels
		end

feature -- Access

	next_id: REAL_BODY_ID is
			-- Next real body id
		do
			Result := current_subcounter.next_id
		end

	debuggable_body_id (old_id: REAL_BODY_ID): REAL_BODY_ID is
			-- New real body id for debuggable byte array
		require
			old_id_not_void: old_id /= Void
		do
			if old_id.id <= frozen_level then
					-- The routine was frozen in the static system.
					-- Generate a new id in the static melted area.
				Result := debug_subcounter.next_id
			else
					-- The routine was melted in the static system.
					-- Keep the same id.
				Result := old_id
			end
		ensure
			new_id_not_void: Result /= Void
		end

feature -- Levels

	frozen_level: INTEGER;
			-- Melted/Frozen limit

feature -- Setting

	set_frozen_level (i: INTEGER) is
			-- Set `frozen_level' to `i'.
		do
			frozen_level := i
		end

	set_levels is
			-- Keep track of the different levels after each compilation.
		local
			nb: INTEGER
		do
			nb := total_count;
			debug_subcounter.set_offset (nb);
		end

	reset_debug_counter is
			-- Reset `debug_counter'.
		do
			debug_subcounter.reset;
		end

feature -- Generation

	generate_offsets (buffer: GENERATION_BUFFER) is
			-- Generate `offset' declarations into `buffer'.
		require
			file_not_void: buffer /= Void;
		local
			real_body_id_subcounter: REAL_BODY_ID_SUBCOUNTER
		do
			from start until after loop
				real_body_id_subcounter ?= item_for_iteration;
				real_body_id_subcounter.generate_offset (buffer);
				forth
			end
		end

	generate_extern_offsets (buffer: GENERATION_BUFFER) is
			-- Generate `offset' extern declarations into `buffer'.
		require
			file_not_void: buffer /= Void;
		local
			real_body_id_subcounter: REAL_BODY_ID_SUBCOUNTER
		do
			from start until after loop
				real_body_id_subcounter ?= item_for_iteration;
				real_body_id_subcounter.generate_extern_offset (buffer);
				forth
			end
		end

feature {NONE} -- Implementation

	current_subcounter: REAL_BODY_ID_SUBCOUNTER;
			-- Current body id subcounter

feature {DEBUG_BODY_ID} -- Implementation

	debug_subcounter: DEBUG_BODY_ID_SUBCOUNTER;
			-- Supermelted body id subcounter

invariant

	debug_subcounter_not_void: debug_subcounter /= Void;

end -- class REAL_BODY_ID_COUNTER
