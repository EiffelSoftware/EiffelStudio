<document title="Eiffel Classes">
	<meta_data>
		<help>
			<toc>
				<envision_location>Eiffel\Eiffel for .NET</envision_location>
				<envision_pseudo_name>10</envision_pseudo_name>
				<envision_title>Eiffel Classes</envision_title>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph>The unit of software reuse in Eiffel is the
			<link>
				<url/>
				<label>class</label>
			</link>.
		</paragraph>
		<paragraph>The unit of
			<link>
				<url/>
				<label>modularity</label>
			</link> in Eiffel is the class.
		</paragraph>
		<paragraph>The unit of
			<link>
				<url/>
				<label>type</label>
			</link> modeling in Eiffel is the class.
		</paragraph>
		<paragraph>All Eiffel code must exist within the context of a class.</paragraph>
		<paragraph>In Eiffel, application systems, or simply
			<link>
				<url/>
				<label>systems,</label>
			</link> are created by assembling a set of related classes. The classes in a system will be related only by one or both of the two allowable
			<link>
				<url/>
				<label>relationships</label>
			</link> in object-oriented design.
		</paragraph>
		<paragraph>Having read the above, you should be convinced that the concept of class is important and far-reaching. The fact that we have precise rules about classes simplifies life a lot. The only kind of module in Eiffel is a class. Each class exists in one source file (which contains only that class), and contains the code necessary to provide a static definition of a data type. Every runtime entity, i.e. every object, must be an instance of a class. Because we can depend upon these things in Eiffel, we have consistency and predictabililty in the inherently complex world of software development.</paragraph>
		<paragraph>Let's take a look at how classes are structured.</paragraph>
		<heading>
			<size>2</size>Structure of a Class
		</heading>
		<paragraph>The code that makes up an Eiffel class is divided into the following parts:</paragraph>
		<list ordered="false">
			<item>
				<link>
					<url>#indexing</url>
					<label>Indexing</label>
				</link>
			</item>
			<item>
				<link>
					<url>#class header</url>
					<label>Class header</label>
				</link>
			</item>
			<item>
				<link>
					<url>#formal generics</url>
					<label>Formal generics</label>
				</link>
			</item>
			<item>
				<link>
					<url>#obsolete</url>
					<label>Obsolete</label>
				</link>
			</item>
			<item>
				<link>
					<url>#inheritance</url>
					<label>Inheritance</label>
				</link>
			</item>
			<item>
				<link>
					<url>#creators</url>
					<label>Creators</label>
				</link>
			</item>
			<item>
				<link>
					<url>#features</url>
					<label>Features</label>
				</link>
			</item>
			<item>
				<link>
					<url>#invariant</url>
					<label>Invariant</label>
				</link>
			</item>
		</list>
		<paragraph>All of the above, except Class header, are optional.  So the simplest Eiffel class you could build would look like this:</paragraph>
		<code_block>
class
	SIMPLE
end
</code_block>
		<paragraph>Okay, so class SIMPLE is only interesting in its simplicity. Let's look at a more useful example:</paragraph>
		<code_block>
indexing
    description: Objects that model lists
    revision: $Revision$

class
    OLD_FASHIONED_LIST [G]

obsolete "This class is obsolete, use LINKED_LIST [G] instead"

inherit
    DYNAMIC_LIST [G]

create
    make

feature -- Initialization

    make is
            -- Create an empty list.
        do
            before := True
        ensure is_before: before
        end

feature -- Access

    item: G is
            -- Current item
        do
            Result := active.item
        end

    first: like item is
            -- Item at first position
        do
            Result := first_element.item
        end
                (other features omitted)

invariant
    before_constraint: before implies (active = first_element)
    after_constraint: after implies (active = last_element)
</code_block>Here is a class that, although somewhat contrived, utilizes all of the required and optional parts of the class. Let's look at each part individually.
		<heading>
			<size>3</size>Indexing
		</heading>
		<code_block>
indexing
    description: Objects that model lists
    revision: $Revision$
</code_block>
		<paragraph>The indexing part of a class is there to allow you as a producer to record information of your choice which will help you or other reuse consumers at some later time to locate understand the class. This important in Eiffel because we try to treat every class as if someday it will become reusable. </paragraph>
		<paragraph>Information in indexing does not change the semantics of the class.</paragraph>
		<paragraph>The indexing in the class above is typical. It is introduced with the language keyword
			<code>
				<keyword>indexing</keyword>
			</code>, and contains two index clauses, each of which is comprised of an index and a single index value. You can code index clauses with indexes that you devise yourself, so there is nothing inherently special about "
			<code>
				<indexing_tag>description</indexing_tag>
			</code>" and "
			<code>
				<indexing_tag>revision</indexing_tag>
			</code>" as used above. But, these indexes could be special to tools which analyze libraries of classes use them. Although these clauses have only one index value each, it is permissible to put more, separated by commas.
		</paragraph>
		<heading>
			<size>3</size>Class Header
		</heading>
		<code_block>
class
    OLD_FASHIONED_LIST [G]
</code_block>
		<paragraph>The class header is introduced by the keyword "class", which in turn can be preceded by one of three keywords which mark the class as
			<code>
				<keyword>deferred</keyword>
			</code>,
			<code>
				<keyword>expanded</keyword>
			</code>, or
			<code>
				<keyword>external</keyword>
			</code>. In our example, the class has none of these markings, so it is an
			<link>
				<url/>
				<label>effective class</label>
			</link> whose instances are access by
			<link>
				<url/>
				<label>reference</label>
			</link>.
		</paragraph>
		<paragraph>The keyword class is followed by the class name, in this case "
			<code>
				<class_name>OLD_FASHIONED_LIST</class_name>
			</code>".
		</paragraph>
		<paragraph>Of the three keywords for header marks, the one which you will encounter most often is
			<code>
				<keyword>deferred</keyword>
			</code>. A class is
			<link>
				<url/>
				<label>deferred</label>
			</link> if it contains one or more
			<link>
				<url/>
				<label>features that are deferred</label>
			</link>, that is, features which have been specified in the class but for which no implementation has been provided.
			<link>
				<url/>
				<label>Proper descendants</label>
			</link> of a deferred class will provide implementations for its deferred features.
		</paragraph>
		<heading>
			<size>3</size>Formal Generics
		</heading>
		<code_block>
class
    OLD_FASHIONED_LIST [G]
</code_block>
		<paragraph>In this example the class name is followed by the specification of one formal generic parameter "
			<code>
				<generics>G</generics>
			</code>". The presence of one or more formal generic parameters will designate a class as a
			<link>
				<url/>
				<label>generic class</label>
			</link>. The formal generic parameter is a place holder for a class name which will be provided by reuse consumers. For example if we wrote a class which was a client to
			<code>
				<class_name>OLD_FASHIONED_LIST</class_name>
			</code> we would substitute the class name for the type of objects that we would want to build an
			<code>
				<class_name>OLD_FASHIONED_LIST</class_name>
			</code> of. We might make this declaration:
		</paragraph>
		<code_block>
	my_list_of_cats: OLD_FASHION_LIST [CAT]
</code_block>
		<paragraph>The entity
			<code>
				<feature_name>my_list_of_cats</feature_name>
			</code> could then be attached at runtime to an
			<code>
				<class_name>OLD_FASHIONED_LIST</class_name>
			</code> of objects of type
			<code>
				<class_name>CAT</class_name>
			</code>. So the class
			<code>
				<class_name>CAT</class_name>
			</code> becomes an actual generic parameter and substitutes for
			<code>
				<generics>G</generics>
			</code> in the declaration.
		</paragraph>
		<paragraph>Of course formal generic parameters cannot be the same name as a class name in the same universe. If multiple formal generic parameters are used, they are separated by commas.</paragraph>
		<paragraph>You will learn more about generic classes in the section titled
			<link>
				<url>40_genericity.xml</url>
				<label>Genercity</label>
			</link>.
		</paragraph>
		<heading>
			<size>3</size>Obsolete
		</heading>
		<code_block>
obsolete "This class is obsolete, use LINKED_LIST [G] instead"
</code_block>
		<paragraph>
			<code>
				<class_name>OLD_FASHION_LIST</class_name>
			</code>s are obsolete ... and the class is marked as such by include the line above. The manifest string contains an explanation, instructions, and/or recommended alternatives. Compilers and other language tools can deliver this message to potential reuse consumers. As with indexing, obsolete has no effect on the semantics of the class.
		</paragraph>
		<paragraph>Obsolete is rarely used because of the nature of certain elements of the Eiffel methodology. For example, if implementations are well-hidden behind implementation-independent specifications, then those implementations may be changed to adapt the class to changing execution environments in such a way that clients are unaffected.</paragraph>
		<heading>
			<size>3</size>Inheritance
		</heading>
		<code_block>
inherit
    DYNAMIC_LIST [G]
</code_block>
		<paragraph>One of the two possible
			<link>
				<url/>
				<label>relationships</label>
			</link> between classes,
			<link>
				<url/>
				<label>inheritance</label>
			</link> is also a powerful software reuse mechanism. In this example class
			<code>
				<class_name>OLD_FASHIONED_LIST</class_name>
			</code> declares itself to be a
			<link>
				<url/>
				<label>proper descendant</label>
			</link> of class
			<code>
				<class_name>DYNAMIC_LIST</class_name>
			</code>.
		</paragraph>
		<paragraph>There will be more in the section called . For now though, be aware of two important implications of this declaration:</paragraph>
		<list ordered="false">
			<item>Every feature of
				<code>
					<class_name>DYNAMIC_LIST</class_name>
				</code> is available to
				<code>
					<class_name>OLD_FASHIONED_LIST</class_name>
				</code> and potentially available to its clients.
			</item>
			<item>Whenever an instance of
				<code>
					<class_name>DYNAMIC_LIST</class_name>
				</code> is called for, then an instance of
				<code>
					<class_name>OLD_FASHIONED_LIST</class_name>
				</code> will suffice.
			</item>
		</list>
		<heading>
			<size>3</size>Creators
		</heading>
		<code_block>
create
    make
</code_block>
		<paragraph>The creators part of a class declares a procedure as being a
			<link>
				<url/>
				<label>creation procedure</label>
			</link>. In this case the procedure in question is the one named
			<code>
				<feature_name>make</feature_name>
			</code>. By convention, creation procedure names begin with the word "
			<code>
				<feature_name>make</feature_name>
			</code>".
		</paragraph>
		<paragraph>Let's take a quick look at object creation. Consider this declaration:</paragraph>
		<code_block>
	my_list_of_cats: OLD_FASHION_LIST [CAT]
</code_block>
		<paragraph>Here the entity
			<code>
				<feature_name>my_list_of_cats</feature_name>
			</code> can be attached to an object of type
			<code>
				<class_name>OLD_FASHION_LIST</class_name>
			</code> [
			<code>
				<class_name>CAT</class_name>
			</code>] at runtime. The process of converting
			<code>
				<feature_name>my_list_of_cats</feature_name>
			</code> from holding a void reference to holding a reference to a object modeling a list of cats, starts when a creation instruction is executed. The creation instruction creates the instance and may apply a creation procedure to initialize the instance. A creation instruction for the declaration above would look like this:
		</paragraph>
		<code_block>
	create my_list_of_cats.make
</code_block>
		<paragraph>The
			<code>
				<keyword>create</keyword>
			</code> keyword is used to introduce a creation instruction. This instruction causes the following four things to happen:
		</paragraph>
		<list ordered="false">
			<item>A shell of a new instance of
				<code>
					<class_name>OLD_FASHION_LIST</class_name>
				</code> [
				<code>
					<class_name>CAT</class_name>
				</code>] is created in memory with a memory field for every
				<link>
					<url/>
					<label>attribute</label>
				</link>
			</item>
			<item>Each field is initialized with standard default values
				<list ordered="false">
					<item>False for type
						<code>
							<class_name>BOOLEAN</class_name>
						</code>
					</item>
					<item>Null character for type
						<code>
							<class_name>CHARACTER</class_name>
						</code>
					</item>
					<item>The appropriate form of zero for number types</item>
					<item>
						<code>
							<keyword>Void</keyword>
						</code> for reference types
					</item>
				</list>
			</item>
			<item>Attach the new instance to the entity
				<code>
					<feature_name>my_list_of_cats</feature_name>
				</code>
			</item>
			<item>Apply the creation procedure
				<code>
					<feature_name>make</feature_name>
				</code>
			</item>
		</list>
		<paragraph>Once these steps complete successfully,
			<code>
				<feature_name>my_list_of_cats</feature_name>
			</code> will be attached to a valid instance (i.e., an instance in which the
			<link>
				<url/>
				<label>class invariant</label>
			</link> is true) of
			<code>
				<class_name>OLD_FASHIONED_LIST</class_name>
			</code> [
			<code>
				<class_name>CAT</class_name>
			</code>].
		</paragraph>
		<heading>
			<size>3</size>Features
		</heading>
		<code_block>
feature -- Initialization

    make is
            -- Create an empty list.
        do
            before := True
        ensure is_before: before
        end


feature -- Access

    item: G is
            -- Current item
        do
            Result := active.item
        end

    first: like item is
            -- Item at first position
        do
            Result := first_element.item
        end
</code_block>
		<paragraph>The features part of a class is the area in which we feel that most of the "programming" is done. It is here that we define those things that instances of a class have and can do. We will learn more about features in the next section
			<link>
				<url>../../eiffel_dotnet_language/20_language/20_adding_class_features.xml</url>
				<label>Adding Class Features</label>
			</link>.
		</paragraph>
		<paragraph>Until then let's just take a quick look at how features fit into a class. Notice that in our example the features part is introduced by the keyword "
			<code>
				<keyword>feature</keyword>
			</code>". In fact there are two occurrences of
			<code>
				<keyword>feature</keyword>
			</code> in this example, each followed by a comment.
		</paragraph>
		<paragraph>You may declare multiple
			<code>
				<keyword>feature</keyword>
			</code> statements. This helps you group features in a manner that makes sense. Here we see the first group contains those features which are listed as creation procedures in the creators part of the class. The second group of features labeled "
			<code>
				<comment>Access</comment>
			</code>" contains a set of queries available to clients of the class.
		</paragraph>
		<paragraph>Although the words "
			<code>
				<comment>Initialization</comment>
			</code>" and "
			<code>
				<comment>Access</comment>
			</code>" are actually in comments after the
			<code>
				<keyword>feature</keyword>
			</code> keyword, some language processing tools apply some significance to these, for example, ordering the groups in "pretty-printed" views of a class. Also, some tools allow you to build templates for creating new classes which have
			<code>
				<keyword>feature</keyword>
			</code> clauses already in place for predetermined groups.
		</paragraph>
		<paragraph>
			<tip>
				<bold>Tip:</bold> There is not a technical requirement governing the grouping or ordering of features in a class. It is the option of the producer of a class to group and order the features in some fashion that has some meaning. Many years of Eiffel development experience are reflected in the classes in the Eiffel Base Library. This is a good place to look for examples of well constructed classes.
			</tip>
		</paragraph>
		<heading>
			<size>3</size>Invariant
		</heading>
		<code_block>
invariant
    before_constraint: before implies (active = first_element)
    after_constraint: after implies (active = last_element)
</code_block>
		<paragraph>Here's the last word in a class definition ... both literally and figuratively. The invariant part, introduced not surprisingly by the keyword "
			<code>
				<keyword>invariant</keyword>
			</code>", is that portion of the class in which we can state what it means for an object to be a valid instance of this class.
		</paragraph>
		<paragraph>We will learn more about
			<link>
				<url/>
				<label>class invariants</label>
			</link> in the section titled
			<link>
				<url>../../eiffel_dotnet_language/20_language/50_design_by_contract.xml</url>
				<label>Design by Contract and Assertions</label>
			</link>.
		</paragraph>
	</paragraph></document>