NAME

build_ace - generates Ace-Files for eiffel programms

SYNOPSIS

build_ace [ -h ] [ OPTIONS ]

DESCRTIPTION

build_ace generates an ace-file for a project written in Eiffel.

FLAGS

-h	prints out a helpscreen and does nothing else

OPTIONS

-C file 
	Select the resource file from which additional information is read

-f file Name of the ace-File. Default Ace.ace

-s name
	Specifies the name of the executable generated by the Eiffel compiler.
	That means you will find the lines

	system
		name
	
	in the generated ace-File.

-c CLASS
	Specifies the name of the root class

-m make
	Specifies the name of the creation procedure of the root class.
	(Default will be "make"; not implemented yet)

	The last three values are the minimum you have to set to get a
	working ace file
		
	Together they result in the lines

        system
                name

	root
		CLASS (start): "make"

-a string
	Sets the value of the assertion clause to string. This causes
        the generation of the lines

        default
                assertion ("string")
-d string
	Adds a line debug("string") to the default clause.
	Can be used more than once.

-p dir
	Sets the value of the precompiled clause to string.

	Together the four parameters

        -a all -d GIOP -d MICOE -p /usr/local/Eiffel4/precomp

        result in the following lines

	default
		assertion("all")
		debug("GIOP")
		debug("MICOE")
		precompiled("/usr/local/Eiffel4/precomp")

-i dir
	Adds clusters entries for "dir/stubs", "dir/skeletons" and
	"dir/implementations" and all subdirectories to the ace file if
	they exist and contain *.e files.
	("dir/servants" and a corresponding switch not impl. yet)

-b path
	Generates cluster entries for additional Eiffel libraries
	(that means a directory and all its subdirectories that
	contain *.e files).
	Can be used more than once.

	Together with any clusters in the working directory the
        two parameters

        -i .. -b /usr/local/Eiffel4/local/lib/micoe/orb

	result in the following lines

	cluster
		start: ".";
		stubs: " "../stubs";
		skeletons: "../skeletons";
                implementations: "../implementations";
		orb: "/usr/local/Eiffel4/local/lib/micoe/orb";
                adapter: "/usr/local/Eiffel4/lib/micoe/orb/adapter";
		.....

-o string
	Sets the value of object clause to string.
	Can be used more than once.

	The parameters

        -o /usr/local/lib/micoe.a -o /usr/local/lib/adt.a

        result in the following lines:

	external
		object: "/usr/local/lib/micoe.a",
                        "/usr/local/lib/adt.a"


	
RCFILE
--------
build_ace searches for the following resource files:

./build_ace_rc
~/build_ace_rc

It uses the one found first. With the option -C you may specify a different
resource file to be used.

Each line of a resource file should contain a keyword and a value.

Lines beginning with # are ignored, as are empty lines.

Parameters given in the command line take precedence over entries in the
resource file with the exception of values that may be repeated such as
`debug', etc.

The following keyword-value pairs are accepted:

      system name
Sets the name of the generated executable to name.

      class CLASS
Sets the name of the root class to CLASS

      creation routine
Sets the name of the creation procedure of the root class to routine.

      assertion value
Sets the value of the assertion clause to value.

      debug string
Adds a line debug("string") to the default clause.There can be arbitrarily
many such pairs.

      precompiled string
Adds a line precompiled("string") to the default clause. There should be
at most one such line. 

      cluster path
adds an addtional cluster. There can be arbitrarily many such pairs.
 
      lib path
adds an additional cluster and all its subclusters. There can be arbitrarily
many such pairs.

      object string
Adds a line Object : "string" to the external clause. There can be arbitrarily
many such pairs.

BUGS
  As of build_ace 0.1  there were exactly 39.342 unidentified bugs. Identified
  bugs have mostly been fixed, though.  Since then 9.34 bugs have been fixed.
  Assuming that there are at least 10 unidentified bugs for every identified
  one, that leaves us with 39.342 - 9.32 + 10 * 9.34 = 123.402 unidentified
  bugs.  If we follow this to its logical conclusion we will have an infinite
  number of unidentified bugs before the number of bugs can start to dimin-
  ish, at which point the program will be bug-free.  Since this is a computer
  program infinity = 3.4028e+38 if you don't insist on double-precision.  At
  the current rate of bug discovery we should expect to achieve this point in
  3.37e+27 years.  I guess I better plan on passing this thing on to my chil-
  dren....

