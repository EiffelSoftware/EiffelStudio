/*
 *	
 * Zip Code Data Model for Hash Table Example
 *	
 *	
 */

// For hash_table
interface HashTableRelationship : "Mt Relationship" : persistent {
};


mt_relationship List<Any> hash_table_of_void_key_value
  inverse HASH_TABLE::void_key_obj_value;
mt_relationship List<Any> hash_table_of_value
  inverse HASH_TABLE::obj_values;
mt_relationship List<Any> hash_table_of_key
  inverse HASH_TABLE::obj_keys;
  
interface HASH_TABLE : persistent {
  attribute {MT_NULL, Array<Octet>, Array<MtS16>, Array<MtU16>, Array<MtS32>, Array<MtU32>, Array<MtFloat>, Array<MtDouble>, Array<MtAsciiString>, Array<MtString>} att_keys;
  attribute {MT_NULL, Array<Octet>, Array<MtS16>, Array<MtU16>, Array<MtS32>, Array<MtU32>, Array<MtFloat>, Array<MtDouble>, Array<MtAsciiString>, Array<MtString>} att_values;
  attribute {MT_NULL, Array<MtS32>} value_index;
  attribute {MT_NULL, MtU8, MtS16, MtU16, MtS32, MtU32, MtFloat, MtDouble, MtAsciiChar, MtChar, MtAsciiString, MtString} void_key_att_value;
  relationship List<Any> obj_keys
    inverse hash_table_of_key;
  relationship List<Any> obj_values
    inverse hash_table_of_value;
  relationship Any void_key_obj_value[0, 1]
    inverse hash_table_of_void_key_value;
  attribute MtBoolean has_default = MT_FALSE;
};

interface ZIP_CODE : persistent
{
	attribute Unsigned Long zip_code;
	attribute List<String> city_names;
	attribute List<String> states;
	attribute List<Long> zip_types;
};

mt_relationship List<ZIP_CODE_TABLE> of_zip_table
	inverse ZIP_CODE_TABLE::zip_table;
		
interface ZIP_CODE_TABLE : persistent
{
	relationship MT_HASH_TABLE <HASH_TABLE> zip_table [0, 1]
  		inverse of_zip_table
		mt_instance_of HashTableRelationship
		mt_container_parameters {ZIP_CODE, INTEGER};
};
