/*
 * PUBLIC DOMAIN PCCTS-BASED C++ GRAMMAR (cplusplus.g, stat.g, expr.g)
 *
 * Authors: Sumana Srinivasan, NeXT Inc.;            sumana_srinivasan@next.com
 *          Terence Parr, Parr Research Corporation; parrt@parr-research.com
 *          Russell Quong, Purdue University;        quong@ecn.purdue.edu
 *
 * VERSION 1.1
 *
 * SOFTWARE RIGHTS
 *
 * This file is a part of the ANTLR-based C++ grammar and is free
 * software.  We do not reserve any LEGAL rights to its use or
 * distribution, but you may NOT claim ownership or authorship of this
 * grammar or support code.  An individual or company may otherwise do
 * whatever they wish with the grammar distributed herewith including the
 * incorporation of the grammar or the output generated by ANTLR into
 * commerical software.  You may redistribute in source or binary form
 * without payment of royalties to us as long as this header remains
 * in all source distributions.
 *
 * We encourage users to develop parsers/tools using this grammar.
 * In return, we ask that credit is given to us for developing this
 * grammar.  By "credit", we mean that if you incorporate our grammar or
 * the generated code into one of your programs (commercial product,
 * research project, or otherwise) that you acknowledge this fact in the
 * documentation, research report, etc....  In addition, you should say nice
 * things about us at every opportunity.
 *
 * As long as these guidelines are kept, we expect to continue enhancing
 * this grammar.  Feel free to send us enhancements, fixes, bug reports,
 * suggestions, or general words of encouragement at parrt@parr-research.com.
 * 
 * NeXT Computer Inc.
 * 900 Chesapeake Dr.
 * Redwood City, CA 94555
 * 12/02/1994
 * 
 * Restructured for public consumption by Terence Parr late February, 1995.
 *
 * Requires PCCTS 1.32b4 or higher to get past ANTLR. 
 * 
 * DISCLAIMER: we make no guarantees that this grammar works, makes sense,
 *             or can be used to do anything useful.
 */
#ifndef W32MSC
#       include <stream.h>
#endif /* W32MSC */

#include "tokens.h"
#include "CPPParser.h"
typedef ANTLRCommonToken ANTLRToken;
#include "CPPSymbol.h"

/*
 * This is an important function, but will be replaced with
 * an enhanced predicate in the future.
 *
 * Scan past the ::T::B:: to see what lies beyond.
 * Return qiType if the qualified item can pose as type name.
 * Note that T::T is NOT a type; it is a constructor.  Also,
 * class T { ... T...} yields the enclosed T as a ctor.  This
 * is probably a type as I separate out the constructor defs/decls,
 * I want it consistent with T::T.
 *
 * T::T outside of a class definition yields qiCtor.
 * T inside of class def for T yields qiCtor.
 * T outside of a class is qiType.
 * List<T>::List yields qiCTor outside of the class def for List
 */
CPPParser::QualifiedItem CPPParser::
qualifiedItemIs(int lookahead_offset)
{
    int k, final_type=0;
	int nbre_diff=0;//###

	k = lookahead_offset + 1;
	if ( LT(k)->getType()==ID && finalQualifier(k) )	// then T
	{
		if ( isTypeName(LT(k)->getText()) )
		{
			if ( strcmp(enclosingClass,LT(k)->getText())==0 ) return qiCtor;
			return qiType;
		}
		return qiID;
	}

	if ( LT(k)->getType()==OPERATOR )	// then operator+
	{
		return qiOperator;
	}

    if ( LT(k)->getType()==SCOPE )
	{
		// handle "::operator+"
		if ( LT(k+1)->getType()==OPERATOR )
		{
			return qiOperator;
		}

		// handle "::T"
		if ( LT(k+1)->getType()==ID && finalQualifier(k+1) )
		{
			if ( isTypeName(LT(k+1)->getText()) ) return qiType;
			return qiID;
		}
		else
			k++;		// skip initial "::"
	}

	// FIND FINAL QUALIFIER
    // scan to end of T::A, T::*, T::~, or T::operator
	// include T<arglist>::A type stuff as well

	if ( LT(k)->getType()!=ID ) return qiInvalid;
	int done = 0, old_k;
	while ( !done )
	{
		old_k = k;
		if ( LT(k)->getType()==ID && LT(k+1)->getType()==SCOPE )
		{
			final_type = k;
			k+=2;
		}
		else if ( LT(k)->getType()==ID && isTypeName(LT(k)->getText()) &&
				  LT(k+1)->getType()==LESSTHAN )
		{
			final_type = k;
			k+=2; 
			nbre_diff=0 ;
			while (( LT(k)->getType()!=GREATERTHAN ) && (nbre_diff==0))	// scan to end of <...>
			{
				if ( LT(k)->getType() == Eof ) return qiInvalid;
				if ( LT(k)->getType()!=LESSTHAN    ) nbre_diff++;
				if ( LT(k)->getType()!=GREATERTHAN ) nbre_diff--;
				k++;	// scan to end of <...>
			}
			k++;	// skip end of <...>
			if ( LT(k)->getType()==SCOPE ) k++;
			else done = 1;
		}
		else done=1;
	}
	k = old_k;		// back up to final qualifier

//	while ( LT(k)->getType()==ID && LT(k+1)->getType()==SCOPE ) { k+=2; }
//	final_type = k - 2;		// back up to final qualifier

	switch ( LT(k)->getType() )
	{
	    case ID :
		  if ( isTypeName(LT(k)->getText()) )
		  {
			  if ( k!=final_type &&
				   strcmp(LT(final_type)->getText(),LT(k)->getText())==0 )
			  {
				  return qiCtor;
			  }
			  return qiType;
		  }
		  return qiID;
	    case OPERATOR :
		  return qiOperator;
	    case TILDE :
		  return qiDtor;
	    case STAR :
		  return qiPtrMember;
		default :
		  return qiInvalid;
	}
}

/* return true if "::blah" or "fu::bar<args>::..." found. */
int CPPParser::
scopedItem(int k)
{
    if ( LT(k)->getType()==SCOPE ) return 1;
	if ( LT(k)->getType()!=ID ) return 0;

	if ( finalQualifier(k) ) return 0;
	return 1;

/*
	if ( LT(k)->getType()==ID && LT(k+1)->getType()==SCOPE ) return 1;
	if ( LT(k)->getType()==ID && isTypeName(LT(k)->getText()) &&
	     LT(k+1)->getType()==LESSTHAN )
	{
		k+=2;
		while ( LT(k)->getType()!=GREATERTHAN ) k++;	// scan to end of <...>
		k++;	// skip end of <...>
		if ( LT(k)->getType()==SCOPE ) return 1;
		else return 0;
	}
*/
}

// return true if T<...> or T is last item in qualified item list
// return false if invalid.  Watch out for "i<3".  ID must be
// a type to check for <...>
int CPPParser::
finalQualifier(int k)
{
	int nbre_diff;
	if ( LT(k)->getType()==ID && isTypeName(LT(k)->getText()) &&
		 LT(k+1)->getType()==LESSTHAN ) // TypeID < ...
	{
		k+=2;
		nbre_diff=0;
		while (( LT(k)->getType()!=GREATERTHAN ) && (nbre_diff==0))
		{
			if ( LT(k)->getType() == Eof ) return 0;
			if ( LT(k)->getType()!=LESSTHAN    ) nbre_diff++;
			if ( LT(k)->getType()!=GREATERTHAN ) nbre_diff--;
			
			k++;	// scan to end of <...>
		}
		k++;	// skip end of <...>
		if ( LT(k)->getType()!=SCOPE ) return 1;
		return 0;
	}
	if ( LT(k)->getType()==ID && LT(k+1)->getType()!=SCOPE ) return 1;
	return 0;
}

/*
 * Return true if 's' can pose as a type name
 */
int CPPParser::
isTypeName(char *s)
{
	CPPSymbol *cs = (CPPSymbol *) symbols->lookup(s);
	if ( cs==NULL ) return 0;
	if ( cs->getType()==CPPSymbol::otTypedef ||
		 cs->getType()==CPPSymbol::otClass ||
		 cs->getType()==CPPSymbol::otEnum ||
		 cs->getType()==CPPSymbol::otUnion ||
		 cs->getType()==CPPSymbol::otStruct ||
		 cs->getType()==CPPSymbol::otNameSpace 	   //###
		 ) return 1;
	return 0;
}

/*
 * Return true if 's' is a class name (or a struct which is a class
 * with all members public).
 */
int CPPParser::
isClassName(char *s)
{
	CPPSymbol *cs = (CPPSymbol *) symbols->lookup(s);
	if ( cs==NULL ) return 0;
	if ( cs->getType()==CPPSymbol::otClass ||
		 cs->getType()==CPPSymbol::otStruct ||
		 cs->getType()==CPPSymbol::otUnion ) return 1;
	return 0;
}

void CPPParser::
StoreQt(char*)
{
}

void CPPParser::
beginDeclaration()
{
}

void CPPParser::
endDeclaration()
{
}

void CPPParser::
beginFunctionDefinition()
{
	functionDefinition = 1;
}

void CPPParser::
endFunctionDefinition()
{
	//fprintf(stderr, "parameter scope(%d):\n",symbols->getCurrentScopeIndex()); 
	//Remove parameter scope
	//symbols->dumpScope(stderr); 
	//symbols->removeScope();	//###
	//symbols->restoreScope();  //### see endParameterList
	functionDefinition = 0;
}

void CPPParser::
beginConstructorDefinition(char *)
{
	functionDefinition = 1;
}

void CPPParser::
endConstructorDefinition()
{
	//fprintf(stderr, "ctor parameter scope(%d):\n",symbols->getCurrentScopeIndex()); //***
	//symbols->dumpScope(stderr); 
	symbols->removeScope();
	symbols->restoreScope();
	functionDefinition = 0;
}

void CPPParser::
beginConstructorDeclaration(char *)
{
}

void CPPParser::
endConstructorDeclaration()
{
}

void CPPParser::
beginDestructorDefinition(char *)
{
	functionDefinition = 1;
}

void CPPParser::
endDestructorDefinition()
{
	// fprintf(stderr, "parameter scope(%d):\n",symbols->getCurrentScopeIndex()); 
	// symbols->dumpScope(stderr); 
	symbols->removeScope();
	symbols->restoreScope();
	functionDefinition = 0;
}

void CPPParser::
beginDestructorDeclaration(char *)
{
}

void CPPParser::
endDestructorDeclaration()
{
}

void CPPParser::
beginParameterDeclaration()
{
}

void CPPParser::
beginFieldDeclaration()
{
}


void CPPParser::
endFieldDeclaration()
{
}


void CPPParser::
declarationSpecifier(StorageClass sc,
					 TypeQualifier tq,
					 TypeSpecifier ts)
{
	_sc = sc;
	_tq = tq;
	_ts = ts;
}


/* Symbols from declarators are added to the symbol table here.  Note
 * that we only care about types for parsing (with semantic predicates)
 * and we don't track variable vs function.  A real C++ front-end would
 * have to, of course.  The symbol is added to whatever the current
 * scope is in the symbol table.
 */
void CPPParser::
declaratorID(char *id)
{
	CPPSymbol *c, *ext_c;
	if ( _sc==scTYPEDEF )
	{
		c = new CPPSymbol(id, CPPSymbol::otTypedef);
		ext_c = new CPPSymbol(id, CPPSymbol::otTypedef);
		if ( ext_c==NULL ) panic("can't alloc CPPSymbol");
		if ( symbols->getCurrentScopeIndex()!=externalScope )
			symbols->defineInScope(id, ext_c, externalScope);
	}
	else c = new CPPSymbol(id);
	if ( c==NULL ) panic("can't alloc CPPSymbol");
	symbols->define(id, c);
}


void CPPParser::
namespaceDeclaration( char *tag)
{
	CPPSymbol *c = NULL;

	// if already in symbol table as a class, don't add
	// of course, this is incorrect as you can rename
	// classes by entering a new scope, but our limited
	// example basically keeps all types globally visible.
	// if ( symbols->lookup(tag)!=NULL ) return;

	c = new CPPSymbol(tag, CPPSymbol::otNameSpace );

	if ( c==NULL ) panic("can't alloc CPPSymbol");
	symbols->define(tag, c);
}


void CPPParser::
declaratorArrayTo()
{
}

void CPPParser::
declaratorPointerTo()
{
}


void CPPParser::
declaratorParameterList(int)
{
	symbols->saveScope();
	 // fprintf(stderr, "entering def parm scope %d\n", symbols->getCurrentScopeIndex()); 
}

void CPPParser::
declaratorEndParameterList(int def)
{
	if ( !def )
	{
		/* this is for a decl only...remove immediately */
		// fprintf(stderr, "parameter scope(%d):\n",symbols->getCurrentScopeIndex()); 
		// symbols->dumpScope(stderr);
		symbols->removeScope();
		symbols->restoreScope();
	}
}

void CPPParser::
functionParameterList()
{
	symbols->saveScope();
	//fprintf(stderr, "entering func parm scope %d\n", 
	//		symbols->getCurrentScopeIndex()); 
}

void CPPParser::
functionEndParameterList()
{
	symbols->removeScope(); //###
	symbols->restoreScope(); //###
	/* The end function thing removes the parameters from scope PROBLEM !!!*/
}

void CPPParser::
enterNewLocalScope()
{
	symbols->saveScope();
	// fprintf(stderr, "entering local scope (%d):\n", symbols->getCurrentScopeIndex()); 
}

void CPPParser::
exitLocalScope()
{
	// fprintf(stderr, "exiting local scope (%d):\n", symbols->getCurrentScopeIndex()); 
	// symbols->dumpScope(stderr);  
	symbols->removeScope();
	symbols->restoreScope();
}

void CPPParser::
enterExternalScope()
{
}

void CPPParser::
exitExternalScope()
{
	// fprintf(stderr, "global scope:\n"); 
	// symbols->dumpScope(stderr); 
	symbols->removeScope();
	symbols->restoreScope();//###
}

void CPPParser::
classForwardDeclaration(TypeSpecifier ts, DeclSpecifier ds, char *tag)
{
	CPPSymbol *c = NULL;

	// if already in symbol table as a class, don't add
	// of course, this is incorrect as you can rename
	// classes by entering a new scope, but our limited
	// example basically keeps all types globally visible.
	if ( symbols->lookup(tag)!=NULL ) return;

	switch ( ts )
	{
	  case tsSTRUCT :
		c = new CPPSymbol(tag, CPPSymbol::otStruct);
		break;
	  case tsUNION :
		c = new CPPSymbol(tag, CPPSymbol::otUnion);
		break;
	  case tsCLASS :
		c = new CPPSymbol(tag, CPPSymbol::otClass);
		break;
	}
	if ( c==NULL ) panic("can't alloc CPPSymbol");
	symbols->define(tag, c);

	// If it's a friend class forward decl, put in global scope also.
	if ( ds==dsFRIEND )
	{
		CPPSymbol *ext_c = new CPPSymbol(tag, CPPSymbol::otClass);
		if ( ext_c==NULL ) panic("can't alloc CPPSymbol");
		if ( symbols->getCurrentScopeIndex()!=externalScope )
			symbols->defineInScope(tag, ext_c, externalScope);
	}
}


void CPPParser::
beginClassDefinition(TypeSpecifier ts, char *tag)
{
	CPPSymbol *c, *ext_c;

	// if already in symbol table as a class, don't add
	// of course, this is incorrect as you can rename
	// classes by entering a new scope, but our limited
	// example basically keeps all types globally visible.

	if ( symbols->lookup(tag)!=NULL )
	{
		symbols->saveScope();	// still have to use scope to collect members
		return;
	}

	switch ( ts )
	{
	  case tsSTRUCT :
		c = new CPPSymbol(tag, CPPSymbol::otStruct);
		ext_c = new CPPSymbol(tag, CPPSymbol::otStruct);
		break;
	  case tsUNION :
		c = new CPPSymbol(tag, CPPSymbol::otUnion);
		ext_c = new CPPSymbol(tag, CPPSymbol::otUnion);
		break;
	  case tsCLASS :
		c = new CPPSymbol(tag, CPPSymbol::otClass);
		ext_c = new CPPSymbol(tag, CPPSymbol::otClass);
		break;
	}
	if ( c==NULL ) panic("can't alloc CPPSymbol");
	if ( ext_c==NULL ) panic("can't alloc CPPSymbol");

	// this one lives only as long as the end '}' of an enclosing class def
	// I don't think I'll use this one to do the symbol look ups
	// I'll prepend the current qualifierPrefix before looking
	// things up.
	symbols->define(tag, c);
	strcat(qualifierPrefix, tag);
	strcat(qualifierPrefix, "::");

	// add all member type symbols into the global scope (not correct, but
	// will work for most code).
	// This symbol lives until the end of the file
	if ( symbols->getCurrentScopeIndex()!=externalScope )
		symbols->defineInScope(tag, ext_c, externalScope);

	symbols->saveScope();	// use the scope to collect list of fields
}

void CPPParser::
endClassDefinition(TypeSpecifier ts)
{
	
	//fprintf(stderr, "list of fields:\n"); //***
	//symbols->dumpScope(stderr); //***
	symbols->removeScope();
	symbols->restoreScope();


	// remove final T:: from A::B::C::T::
	// upon backing out of last class, qualifierPrefix is set to ""
	char *p = &(qualifierPrefix[strlen(qualifierPrefix)-3]);
	while ( p > &(qualifierPrefix[0]) && *p!=':' ) {p--;}
	if ( p > &(qualifierPrefix[0]) ) p++;
	*p = '\0';
	// ***end

}


void CPPParser::
PublicAccess()
{
}

void CPPParser::
ProtectedAccess()
{
}

void CPPParser::
PrivateAccess()
{
}

void CPPParser::
enumElement(char *)
{
}

void CPPParser::
beginEnumDefinition(char *e)
{
	// add all enum tags into the global scope (not correct, but
	// will work for most code).
	// This symbol lives until the end of the file
	CPPSymbol *ext_e = new CPPSymbol(e, CPPSymbol::otEnum);
	symbols->defineInScope(e, ext_e, externalScope);
}

void CPPParser::
endEnumDefinition()
{
}


void CPPParser::
BaseClause(char*, int)
{
}

void CPPParser::
templateTypeParameter(char *t)
{
	// Add as a temporary typedef that we'll remove at the end of the template
	CPPSymbol *a = new CPPSymbol(t, CPPSymbol::otTypedef);
	symbols->defineInScope(t, a, templateParameterScope);
}

void CPPParser::
beginTemplateDefinition()
{
}

void CPPParser::
endTemplateDefinition()
{
	// remove elements from the scope, but don't destroy it; we'll need it again
	//fprintf(stderr, "list of template params:\n"); // ***
	//symbols->dumpScope(stderr,templateParameterScope); // ***
	symbols->removeScope(templateParameterScope);
}

void CPPParser::
beginTemplateParameterList()
{
}

void CPPParser::
endTemplateParameterList()
{
}

void CPPParser::
exceptionBeginHandler()
{
}

void CPPParser::
exceptionEndHandler()
{
	// remove parm elements from the hendler scope
	//fprintf(stderr, "list of handler params:\n"); // ***
	//symbols->dumpScope(stderr); // ***
	symbols->removeScope();
	symbols->restoreScope();
}

void CPPParser::
panic(char *err)
{
	fprintf(stderr, "CPPParser: %s\n", err);
	exit(-1);
}

void CPPParser::
tracein(char *r)
{
	if ( !doTracing ) return;
	for (int i=1; i<=traceIndentLevel; i++) fprintf(stderr, " ");  
	traceIndentLevel++;
	fprintf(stderr , "enter %s('%s %s')%s\n", 
			r,
			LT(1)->getText(),
			LT(2)->getText(),
			guessing?" [guessing]":"");
}

void CPPParser::
traceout(char *r)
{
	if ( !doTracing ) return;
	traceIndentLevel--;
	for (int i=1; i<=traceIndentLevel; i++) fprintf(stderr, " ");
	fprintf(stderr, "exit %s('%s %s')%s\n", 
			r,
			LT(1)->getText(),
			LT(2)->getText(),
			guessing?" [guessing]":"");
}

char *CPPParser::
qualified(char *s)
{
	static char q[CPPParser_MaxQualifiedItemSize+1]; //### static ?
	strcpy(q, qualifierPrefix);
	strcat(q, s);
	return q;
}
