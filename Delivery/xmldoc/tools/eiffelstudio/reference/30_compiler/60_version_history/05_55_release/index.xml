<document output="studio" title="Major changes between ISE Eiffel 5.4 and ISE Eiffel 5.5">
	<meta_data></meta_data>
	<paragraph>
		<heading>
			<size>2</size>What's new
		</heading>
		<list ordered="false">
			<item>Full support for new <code><keyword>convert</keyword></code> keyword.</item>
			<item>Made <code><keyword>Void,</keyword></code> previously a feature of <code><class_name>ANY</class_name></code>, a keyword. This prevents the renaming of <code><feature_name>Void</feature_name></code> into <code><feature_name>not_void</feature_name></code> previously possible when it was a routine of <code><class_name>ANY</class_name></code>.</item>			
			<item>Added support for reference and expanded constraints on a formal generic parameter.</item>
			<item>Added support for Microsoft .NET 2.0 runtime.</item>
			<item>Allowed agent creation on infix or prefix routines.</item>
		</list>
		<heading><size>2</size>Improvements</heading>
		<list ordered="false">
			<item>Reduced, in classic mode, size of finalized executables by 10 to 50%.</item>
			<item>Improved speed of evaluation of global onces, in a multithreaded system, by having a lock-free mechanism after a once has been evaluated.</item>
			<item>Reduced memory usage of special of expanded which do not have any reference attributes. Before there was a 8 bytes (or 16 bytes depending on the platform) overhead per item in the special.</item>
		</list>
		<heading>
			<size>2</size>Changes
		</heading>
		<list ordered="false">
			<item>Compiler is now checking that you cannot redeclare a formal generic parameter into a reference type unless the formal generic parameter is being constraint to be always a reference type.</item>
			<item>Removed obsolete <code><feature_name>eifcid</feature_name></code>, <code><feature_name>eif_expand</feature_name></code> and <code><feature_name>eifexp</feature_name> </code>from the CECIL interface, one has to use <code><feature_name>eif_type_id</feature_name> </code>instead.</item>
			<item>In .NET, changed the naming conventions of resources included in an assembly. The extension `.resources' is appended for resources that are originally provided as `.resx' or `.txt' files. Other files are embedded as is in the assembly and the name of the resource is the name of the file.</item>
			<item>In .NET, now all classes inherit from <code><class_name>ANY</class_name></code>. Before all classes inherited from <code><class_name>SYSTEM_OBJECT</class_name></code>. As a consequence you can now have Eiffel generic classes where the generic parameter is a .NET class.</item>
			<item>Now on .NET the following assignment attempt will succeed whereas it failed before because <code><class_name>SYSTEM_OBJECT</class_name></code> did not inherit from <code><class_name>ANY</class_name></code>:<code_block>a: <class_name>ANY</class_name>
o: <class_name>SYSTEM_OBJECT</class_name>
...
<keyword>check</keyword> o /= Void <keyword>and</keyword> a = Void <keyword>end</keyword>
a ?= o
<keyword>check</keyword> o /= Void <keyword>and</keyword> a /= Void <keyword>end</keyword></code_block></item>
			<item>New format of the independent storable files which takes into account internal changes made for a better generic conformance in classic mode.</item>
		</list>
		<heading>
			<size>2</size>Bug fixes
		</heading>
		<heading>
			<size>3</size>Language issues
		</heading>
		<list ordered="false">
			<item>Fixed issue about conformance checking of type containing a formal generic parameter. We would always evaluate the formal to its constraint, thus allowing the code below to be accepted where it should not have been:
			<code_block>
<keyword>class</keyword> <class_name>A</class_name> <symbol>[</symbol><class_name>G</class_name><symbol>]</symbol>
<keyword>feature</keyword>
	<feature_name>bug</feature_name> <keyword>is</keyword>
		<keyword>local</keyword>
			l_any<symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>ANY</class_name><symbol>]</symbol>
			l_g<symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>G</class_name><symbol>]</symbol>
		<keyword>do</keyword>
			l_any <symbol>:</symbol><symbol>=</symbol> l_g
			l_g <symbol>:</symbol><symbol>=</symbol> l_any
		<keyword>end</keyword>
			</code_block>
			The workaround is to use the <code><keyword>reference</keyword></code> keyword to guarantee that the formal generic parameter will always be instantiated with a reference type. For example the code below is correct:
			<code_block>
<keyword>class</keyword> <class_name>A</class_name> [<keyword>reference</keyword> G]
<keyword>feature</keyword>
	<feature_name>bug</feature_name> <keyword>is</keyword>
		<keyword>local</keyword>
			l_any<symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>ANY</class_name><symbol>]</symbol>
			l_g<symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>G</class_name><symbol>]</symbol>
		<keyword>do</keyword>
			l_any <symbol>:</symbol><symbol>=</symbol> l_g
			l_g <symbol>?</symbol><symbol>=</symbol> l_any
		<keyword>end</keyword>
			</code_block></item>
		</list>
		<heading>
			<size>3</size>Compiler issues
		</heading>
		<list ordered="false">
			<item>Enabled creation of <code><class_name>SPECIAL</class_name></code> instances, no need to create an instance of <code><class_name>TO_SPECIAL</class_name> </code>or <code><class_name>ARRAY</class_name></code> to get a <code><class_name>SPECIAL</class_name> </code>instance. Now you can simply do:<code_block>my_special: <class_name>SPECIAL</class_name> [<class_name>INTEGER</class_name>]
<keyword>create</keyword> my_special.<feature_name>make</feature_name> (10)</code_block>
			</item>
			<item>Fixed incrementality issues with <code><keyword>strip</keyword></code> and static calls on external routines which could fail after a class has been added to or removed from the system.</item>
		</list>
		<heading>
			<size>3</size>Runtime/code generation issues
		</heading>
		<list ordered="false">
			<item>Fixed incorrect code generation which would result in a C compiler error in classic mode when assigning a Void entity to a formal generic parameter that will be instantiated as a basic type.</item>
			<item>In multithreaded mode, fixed dead lock on Unix platforms when evaluating global onces.</item>
			<item>In multithreaded mode, prevented dead lock when a thread is exiting.</item>
			<item>In multithreaded mode, prevented memory corruption which could occur if the first thing that a thread performs when launched is to trigger a GC collection.</item>
			<item>Fixed incorrect generic conformance data when manipulating expanded generic types. For example, the following code:<code_block><keyword>class</keyword> <class_name>A</class_name> [G, H]
<keyword>feature</keyword>
	<feature_name>item</feature_name>: H 
<keyword>end</keyword>

<keyword>class</keyword> <class_name>C</class_name> [G]
<keyword>end</keyword>

<keyword>class</keyword> <class_name>ROOT_CLASS</class_name>
<keyword>create</keyword>
	<feature_name>make</feature_name>
<keyword>feature</keyword>
	<feature_name>make </feature_name><keyword>is</keyword>
		<keyword>local</keyword>
			l_a: <class_name>A</class_name> [<class_name>STRING</class_name>, <keyword>expanded</keyword> <class_name>C</class_name> [<class_name>ANY</class_name>]]
		<keyword>do</keyword>
			<keyword>create</keyword> l_a
			<feature_name>io</feature_name>.<feature_name>put_string</feature_name> (l_a.<feature_name>item</feature_name>.<feature_name>generating_type</feature_name>)
		<keyword>end</keyword>
<keyword>end</keyword>
</code_block>would print<code_block>expanded C [STRING]</code_block>instead of<code_block>expanded C [ANY]</code_block></item>
		</list>
		<heading>
			<size>3</size>.NET issues
		</heading>
		<list ordered="false">
			<item>Fixed incorrect code generation of native arrays which would cause the code to be rejected in newer version of the .NET Framework.</item>
			<item>Fixed incorrect computation of `max_stack' for a routine body which could make the generated code not verifiable.</item>
		</list>
		<heading>	<size>3</size>Store/Retrieve issues</heading>
		<list ordered="false">
			<item>Fix some issues related to the use of recoverable storable when manipulating generic types.</item>
		</list>
	</paragraph></document>
