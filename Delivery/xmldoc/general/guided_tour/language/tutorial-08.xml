<document title="7 Genericity and Arrays">
	<meta_data>
		<help>
			<toc>
				<envision_location>Eiffel\Getting Started</envision_location>
				<envision_pseudo_name>70</envision_pseudo_name>
				<envision_title>Genericity and Arrays</envision_title>
				<studio_location/>
				<studio_title/>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<paragraph>Some of the classes that we will need, particularly in libraries, are 
			<bold>container</bold> classes, describing data structures made of a number of objects of the same or similar types.  Examples of containers include arrays, stacks and lists.  The class 
			<code>
				<string>DEPOSIT_LIST</string>
			</code> posited in earlier examples describes containers.  
		</paragraph>
		<paragraph>It is not hard, with the mechanisms seen so far, to write the class 
			<code>
				<string>DEPOSIT_LIST</string>
			</code>, which would include such features as 
			<code>
				<string>count</string>
			</code> (query returning the number of deposit objects in the list) and 
			<code>
				<string>put</string>
			</code> (command to insert a new deposit object).  
		</paragraph>
		<paragraph>Most of the operations, however, would be the same for lists of objects other than deposits.  To avoid undue replication of efforts and promote reuse, we need a way to describe 
			<bold>generic</bold> container classes, which we can use to describe containers containing elements of many different types.  
		</paragraph>
		<div>
			<heading>
				<size>2</size>
				<content>Making a class generic</content>
			</heading>
			<paragraph>The notation</paragraph>
			<code_block><keyword>class</keyword> <class_name>C</class_name> <symbol>[</symbol><generics>G</generics><symbol>]</symbol> ...The rest as for any other class declaration ...</code_block>
			<paragraph>introduces a generic class.  A name such as 
				<code>
					<string>G</string>
				</code> appearing in brackets after the class name is known as a 
				<bold>formal generic parameter</bold> ; it represents an arbitrary type.  
			</paragraph>
			<paragraph>Within the class text, feature declarations can freely use 
				<code>
					<string>G</string>
				</code> even though it is not known what type 
				<code>
					<string>G</string>
				</code> stands for.  Class 
				<code>
					<string>LIST</string>
				</code> of EiffelBase, for example, includes features
			</paragraph>
			<code_block>
first<symbol>:</symbol> <class_name>G</class_name>    
	<comment>-- Value of first list item</comment>

ext<keyword>end</keyword> <symbol>(</symbol>val<symbol>:</symbol> <class_name>G</class_name><symbol>)</symbol> <keyword>is</keyword>    
	<comment>-- Add a new item of value val at end of list  </comment>  
...
</code_block>
			<paragraph>The operations available on an entity such as 
				<code>
					<string>first</string>
				</code> and 
				<code>
					<string>val</string>
				</code>, whose type is a formal generic parameter, are the operations available on all types: use as source 
				<code>
					<string>y</string>
				</code> of an assignment 
				<code>
					<string>x</string>
				</code> 
				<code>
					<comment>:</comment>
				</code> 
				<code>
					<string>y</string>
				</code>, use as target 
				<code>
					<string>x</string>
				</code> of such an assignment (although not for 
				<code>
					<string>val</string>
				</code>, which as a formal routine argument is not writable), use in equality comparisons 
				<code>
					<string>x</string>
				</code> 
				<code>
					<comment/>
				</code> 
				<code>
					<string>y</string>
				</code> or 
				<code>
					<string>x</string>
				</code> 
				<code>
					<comment>/</comment>
				</code> 
				<code>
					<string>y</string>
				</code>, and application of universal features from 
				<code>
					<string>ANY</string>
				</code> such as 
				<code>
					<string>clone</string>
				</code>, 
				<code>
					<string>equal </string>
				</code>and
				<code>
					<string> copy</string>
				</code>.  
			</paragraph>
			<paragraph>To use a generic class such as list, a client will provide a type name as 
				<bold>actual generic parameter</bold> .  So instead of relying on a special purpose class 
				<code>
					<string>DEPOSIT_LIST</string>
				</code>, the class 
				<code>
					<string>ACCOUNT</string>
				</code> could include the declaration
			</paragraph>
			<code_block><feature_name>all_deposits</feature_name><symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>DEPOSIT</class_name><symbol>]</symbol></code_block>
			<paragraph>using 
				<code>
					<string>LIST</string>
				</code> as a generic class and 
				<code>
					<string>DEPOSIT</string>
				</code> as the actual generic parameter.  Then all features declared in 
				<code>
					<string>LIST</string>
				</code> as working on values of type 
				<code>
					<string>G</string>
				</code> will work, when called on the target 
				<code>
					<string>all_deposits</string>
				</code>, on values of type 
				<code>
					<string>DEPOSIT</string>
				</code> .  With the target
			</paragraph>
			<code_block><feature_name>all_accounts</feature_name><symbol>:</symbol> <class_name>LIST</class_name> <symbol>[</symbol><class_name>ACCOUNT</class_name><symbol>]</symbol></code_block>
			<paragraph>these features would work on values of type 
				<code>
					<string>ACCOUNT</string>
				</code>.  
			</paragraph>
			<info>A note of terminology: to avoid confusion, Eiffel always uses the word 
				<bold>argument</bold> for routine arguments, reserving 
				<bold>parameter</bold> for the generic parameters of classes.  
			</info>
			<paragraph>Genericity reconciles extendibility and reusability with the static type checking demanded by reliability.  A typical error, such as confusing an account and a deposit, will be detected immediately at compile time, since the call 
				<code>
					<string>all_accounts</string>
				</code>.
				<code>
					<string>extend </string>
				</code> 
				<code>
					<comment>(</comment>
				</code> 
				<code>
					<string>dep</string>
				</code> 
				<code>
					<comment>)</comment>
				</code> is invalid for 
				<code>
					<string>dep</string>
				</code> declared of type 
				<code>
					<string>DEPOSIT</string>
				</code> .  What is valid is something like 
				<code>
					<string>all_accounts</string>
				</code>.
				<code>
					<string>extend </string>
				</code> 
				<code>
					<comment>(</comment>
				</code> 
				<code>
					<string>acc</string>
				</code>
				<code>
					<comment>)</comment>
				</code> for 
				<code>
					<string>acc</string>
				</code> of type 
				<code>
					<string>ACCOUNT</string>
				</code> .  In other approaches, the same effect might require costly run-time checks (as in Java, C# or Smalltalk), with the risk of run-time errors.  
			</paragraph>
			<info>This form of genericity is known as 
				<bold>unconstrained</bold> because the formal generic parameter, 
				<code>
					<string>G</string>
				</code> in the example, represents an arbitrary type.  You may also want to use types that are guaranteed to have certai operations available.  This is known as 
				<bold>constrained</bold> genericity and will be studied with inheritance.  
			</info>
		</div>
		<div>
			<heading>
				<size>2</size>
				<content>Arrays</content>
			</heading>
			<paragraph>An example of generic class from the Kernel Library is 
				<code>
					<string>ARRAY </string>
				</code> 
				<code>
					<comment>[</comment>
				</code>
				<code>
					<string>G</string>
				</code> 
				<code>
					<comment>]</comment>
				</code>,  which describes direct-access arrays.  Features include:
			</paragraph>
			<list ordered="false">
				<item>
					<code>
						<string>put</string>
					</code> to replace an element's value, as in 
					<code>
						<string>my_array</string>
					</code>.
					<code>
						<string>put </string>
					</code> 
					<code>
						<comment>(</comment>
					</code>
					<code>
						<string>val</string>
					</code>,
					<code>
						<string> 25</string>
					</code>
					<code>
						<comment>)</comment>
					</code> which replaces by 
					<code>
						<string>val</string>
					</code> the value of the array entry at index 25.  
				</item>
				<item>
					<code>
						<string>item</string>
					</code> to access an entry, as in 
					<code>
						<string>my_array</string>
					</code>.
					<code>
						<string>item </string>
					</code> 
					<code>
						<comment>(</comment>
					</code> 
					<code>
						<string>25</string>
					</code>
					<code>
						<comment>)</comment>
					</code> yielding the entry at index 25.  A synonym is 
					<code>
						<keyword>infix </keyword>
					</code> 
					<code>
						<comment>"@"</comment>
					</code>, so that you may also write more tersely, for the same result, 
					<code>
						<string>my_array</string>
					</code> 
					<code>
						<comment> @ </comment>
					</code> 
					<code>
						<string>25</string>
					</code>.  
				</item>
				<item> 
					<code>
						<string>lower</string>
					</code>, 
					<code>
						<string>upper</string>
					</code>and 
					<code>
						<string>count</string>
					</code> : queries yielding the bounds and the number of entries.  
				</item>
				<item> The creation procedure 
					<code>
						<string>make</string>
					</code>, as in 
					<code>
						<keyword>create </keyword>
					</code> 
					<code>
						<string>my_array</string>
					</code>.
					<code>
						<string>make </string>
					</code>
					<code>
						<comment>(</comment>
					</code> 
					<code>
						<string>1, 50 </string>
					</code> 
					<code>
						<comment>)</comment>
					</code>which creates an array with the given index bounds.  It is also possible to resize an array through 
					<code>
						<string>resize</string>
					</code>, retaining the old elements.  In general, the Eiffel method abhors built-in limits, favoring instead structures that resize themselves when needed, either from explicit client request or automatically.  
				</item>
			</list>
			<paragraph>The comment made about 
				<code>
					<string>INTEGER</string>
				</code> and other basic classes applies to 
				<code>
					<string>ARRAY</string>
				</code> too: Eiffel compilers know about this class, and will be able to process expressions of the form 
				<code>
					<string>my_array</string>
				</code>.
				<code>
					<string>put </string>
				</code> 
				<code>
					<comment>(</comment>
				</code>
				<code>
					<string>val</string>
				</code>,
				<code>
					<string> 25</string>
				</code>
				<code>
					<comment>)</comment>
				</code> and 
				<code>
					<string>my_array</string>
				</code> 
				<code>
					<comment> @ </comment>
				</code>
				<code>
					<string>25</string>
				</code> in essentially the same way as a C or Fortran array access -- 
				<code>
					<string>my_array</string>
				</code>
				<code>
					<comment> [</comment>
				</code> 
				<code>
					<string>25</string>
				</code>
				<code>
					<comment>]</comment>
				</code> in C.  But it is consistent and practical to let developers treat 
				<code>
					<string>ARRAY</string>
				</code> as a class and arrays as objects; many library classes in EiffelBase, for example, inherit from 
				<code>
					<string>ARRAY</string>
				</code>.  Once again the idea is to get the best of both worlds: the convenience and uniformity of the object-oriented way of thinking; and the efficiency of traditional approaches.  
			</paragraph>
			<paragraph>A similar technique applies to another Kernel Library class, that one not generic: 
				<code>
					<string>STRING</string>
				</code>, describing character strings with a rich set of string manipulation features.  
			</paragraph>
		</div>
		<div>
			<heading>
				<size>2</size>
				<content>Generic derivation</content>
			</heading>
			<paragraph>The introduction of genericity brings up a small difference between classes and types.  A generic class 
				<code>
					<string>C</string>
				</code> is not directly a type since you cannot declare an entity as being of type 
				<code>
					<string>C</string>
				</code> :you must use some actual generic parameter 
				<code>
					<string>T</string>
				</code> -- itself a type.  
				<code>
					<string>C</string>
				</code> 
				<code>
					<comment>[</comment>
				</code> 
				<code>
					<string>T</string>
				</code> 
				<code>
					<comment>]</comment>
				</code> is indeed a type, but class 
				<code>
					<string>C</string>
				</code> by itself is only a type template.  
			</paragraph>
			<paragraph>The process of obtaining a type 
				<code>
					<string>C</string>
				</code> 
				<code>
					<comment> [</comment>
				</code> 
				<code>
					<string>T</string>
				</code> 
				<code>
					<comment>]</comment>
				</code> from a general class 
				<code>
					<string>C</string>
				</code> is known as a 
				<bold>generic derivation</bold> ; 
				<code>
					<string>C</string>
				</code> 
				<code>
					<comment>[</comment>
				</code> 
				<code>
					<string>T</string>
				</code> 
				<code>
					<comment>]</comment>
				</code> is a 
				<bold>generically derived type</bold> .  Type 
				<code>
					<string>T</string>
				</code> itself is, recursively, either a non-generic class or again a generically derived type 
				<code>
					<string>D</string>
				</code> 
				<code>
					<comment> [</comment>
				</code> 
				<code>
					<string>U</string>
				</code> 
				<code>
					<comment>]</comment>
				</code> for some 
				<code>
					<string>D</string>
				</code> and 
				<code>
					<string>U</string>
				</code>, as in 
				<code>
					<string>LIST</string>
				</code> 
				<code>
					<comment> [</comment>
				</code> 
				<code>
					<string>ARRAY </string>
				</code>
				<code>
					<comment> [</comment>
				</code> 
				<code>
					<string>INTEGER</string>
				</code> 
				<code>
					<comment>]]</comment>
				</code>.  )
			</paragraph>
			<paragraph>It remains true, however, that every type is based on a class.  The base class of a generically derived type 
				<code>
					<string>C</string>
				</code> 
				<code>
					<comment> [</comment>
				</code>
				<code>
					<string>T</string>
				</code> 
				<code>
					<comment>]</comment>
				</code> is 
				<code>
					<string>C</string>
				</code>.  
			</paragraph>
		</div>
	</paragraph></document>