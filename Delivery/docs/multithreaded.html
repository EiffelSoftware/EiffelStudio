<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>ISE EiffelBench</title>
<link rev="made" href="mailto:webmaster@eiffel.com">
<link rel="stylesheet" href="styles/tech.css">
</head>

<body>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="425">
      <TR>
              <TD><IMG SRC="images/ise-left.gif" width="200" height="65" ALIGN="BOTTOM" ALT="Interactive Software Engineering: tools and components for enterprise applications"
                      BORDER="0"><IMG SRC="images/tech-right.gif" width="225" height="65" ALIGN="BOTTOM" ALT="ISE TECHNOLOGY"
                      BORDER="0"></TD>
      </TR>
</TABLE>

<table cols="1" cellpadding="0" cellspacing="0" border="0">
<tr><td>
<p>

EiffelThread: Multi-threading for O-O development (ISE EIFFEL 4.4)<br>
===================================================================<br>
<br>
 1  INTRODUCTION<br>
 2  SPECIFICATION<br>
 3  OVERVIEW OF THE CLASSES IN EIFFEL-THREAD:<br>
	3.1 SETTINGS<br>
	3.2 COMPILATION<br>
  	3.3  EXTERNAL C FILES:<br>
 4  HOW TO USE THE EIFFEL-THREAD LIBRARY&nbsp;<br>
	4.1  Creating and launching threads: the CLASS THREAD (deferred)<br>
	4.2  Sharing objects between threads: the class PROXY<br>
	4.3  The class MUTEX<br>
	4.4  The class SEMAPHORE<br>
	4.5  The class CONDITION_VARIABLE<br>
	4.6  Disposing C-thread object: class OBJECT_OWNER<br>
	4.7  Miscellaneous classes<br>
	4.8  Controlling execution: THREAD_CONTROL<br>
 5  ONCE FEATURE IN MULTI-THREADED MODE<br>
	5.1  Manipulating Once features in multi-threaded mode<br>
	5.2  Once per Process/Thread<br>
	5.3  Using Once per process/thread features in EIFFEL&nbsp;<br>
	5.4  Limitations<br>
<br>
<br>
1  INTRODUCTION<br>
---------------<br>
<br>
	Multi-threaded applications provide a flexible, exciting way of utilizing<br>
	the power of modern computer systems. ISE Eiffel supports a powerful<br>
	multi-threaded model, simple and easy to use.&nbsp;<br>
<br>
	This document describes the EiffelThread library. EiffelThread is&nbsp;<br>
	included in all current versions of EiffelBench, the Eiffel<br>
	development environment, for Windows, Unix and Linux.&nbsp;<br>
<br>
<br>
2  SPECIFICATION<br>
----------------<br>
<br>
The Eiffel implementation of thread is located in $EIFFEL4/library/thread.<br>
It contains the classes :<br>
<br>
	- object.owner.e&nbsp;<br>
	- condition_variable.e&nbsp;<br>
	- mutex.e&nbsp;<br>
	- object_control.e&nbsp;<br>
	- thread.e&nbsp;<br>
	- precomp.e&nbsp;<br>
	- proxy.e&nbsp;<br>
	- semaphore.e&nbsp;<br>
	- thread_attributes.e&nbsp;<br>
	- thread_control.e&nbsp;<br>
<br>
The thread standard interfaces supported for each platforms are:<br>
<br>
	- Windows: Windows threads&nbsp;<br>
	- Solaris: Solaris threads (threads not supported on sparc) ~POSIX threads&nbsp;<br>
	- Linux: Linuxthreads (POSIX threads)&nbsp;<br>
	- SGI/HP-UX: POSIX threads (not implemented on hp9000 yet)&nbsp;<br>
	- VXWORKS: VXworks threads&nbsp;<br>
	- Cray unicos: POSIX thread&nbsp;<br>
<br>
<br>
3  OVERVIEW OF THE CLASSES IN EIFFEL-THREAD:<br>
--------------------------------------------&nbsp;<br>
<br>
	THREAD (deferred)<br>
	  - Description : class defining an Eiffel thread.<br>
          - Features    : thread_id, launch, launch_with_attributes, exit.<br>
<br>
	THREAD_ATTRIBUTES<br>
	  - Description : class defining thread attributes. Allows the user to<br>
	  				set priority, scheduling policy and detach state of the<br>
	  				thread upon creation.<br>
	  - Features    : set_priority, set_policy, set_detached.<br>
<br>
	THREAD_CONTROL<br>
	  - Description : control over thread execution.<br>
	  - Features    : yield, join_all, join, native_join.<br>
<br>
	SEMAPHORE<br>
	  - Description : semaphore synchronization object, allows threads to<br>
	  				access global data through critical sections.<br>
	  - Features    : post, wait, trywait.<br>
<br>
	CONDITION_VARIABLE<br>
	  - Description : class describing a condition variable.<br>
	  - Features    : wait, signal, broadcast.<br>
<br>
	MUTEX<br>
	  - Description : mutex synchronization object, allows threads to access<br>
	  				global data through critical sections.<br>
	  - Features    : is_set, trylock, has_locked, lock, unlock, destroy.<br>
<br>
	PROXY<br>
	  - Description : indirection proxy allowing share of objects between<br>
	  				threads, without having the garbage collectors intercollect<br>
	  				each-other.<br>
	  - Features    : make, put, item, is_set.<br>
<br>
	OBJECT_OWNER<br>
	  - Description : class meant to record which thread has created a certain<br>
	  				object so that another thread can't call its dispose routine.<br>
	  - Features    : record_owner, has_owner, thread_is_owner.<br>
<br>
	OBJECT_CONTROL<br>
	  - Description : control over objects meant to be used within different threads.<br>
	  - Features    : freeze, unfreeze.<br>
<br>
<br>
<br>
3  COMPILING MULTITHREADED APPLICATION IN EIFFEL<br>
--------------------------------------------------<br>
   3.1 SETTINGS<br>
<br>
	- Add the option multithreaded(yes) in your ace file.<br>
<br>
	- Do not use non-multithreaded precompiled libraries. The corresponding<br>
	  multithreaded libraries of base, WEL and VISION should be located&nbsp;<br>
	  in $EIFFEL4/precomp/spec/$PLATFORM/ with the mt prefix.<br>
<br>
	- If you have no multithreaded precompiled library, check that&nbsp;<br>
	  the cluster thread is in your ace file:<br>
		$EIFFEL4/library/thread<br>
<br>
	+ Note that you have to put it systematically in your ace file in<br>
	  case you would like to freeze or finalized your system.<br>
<br>
<br>
   3.2 COMPILATION<br>
<br>
	The compilation of the generated C-code should be done with<br>
	  the multithreaded flags: mtflags&nbsp;<br>
	- On windows : -D_REENTRANT -MT -DEIF_THREADS<br>
	- On solaris : -D_REENTRANT -DEIF_THREADS -DSOLARIS_THREADS<br>
	  And the link with -lthread.<br>
<br>
	(the flags -D_REENTRANT is not required, but it defines a new<br>
  	 entry for stdout and errno).&nbsp;<br>
<br>
<br>
   3.3  EXTERNAL C FILES:<br>
<br>
	- The C files you link with a multithreaded Eiffel application are bound<br>
	  to BE COMPILED IN MULTI-THREADED MODE either. Particularly, you should<br>
	  follow some basic guidelines.<br>
<br>
	You can find them in any documentation on threads.<br>
	Here are the main requirements:<br>
<br>
	- Check what you are importing is safe or not: you cannot arbitrarily<br>
	  enter non-threaded code in a threaded program. Check your include files,<br>
	  and libraries you use for the linking, if they could be used in mt mode.<br>
<br>
	- Please compile your files with the flag -D_REENTRANT (it defines a new<br>
  	  entry for stdout and errno). Program using TLI or libnsl are bound to<br>
	  be compiled with this flag (redefines _t_errno). Either be sure -D_REENTRANT<br>
	  is defined before any header file is included.<br>
<br>
	- Threaded code can safely refer to unsafe code ONLY from the initial thread.<br>
<br>
	Note: if you use the libraries net and MEL in mt mode, you should use libmtnet.a<br>
	and libmtmel.a .<br>
	When using MEL, you have to be aware that Motif1.2 is not threaded-safe<br>
	(i.e not reentrant). Motif2.0 is mt-safe.<br>
<br>
<br>
<br>
4   HOW TO USE THE EIFFEL-THREAD LIBRARY&nbsp;<br>
----------------------------------------<br>
<br>
   4.1  Creating and launching threads: the CLASS THREAD (deferred)<br>
<br>
	- The class of the thread object you want to create should inherit&nbsp;<br>
	  from the THREAD class.<br>
	- Your thread is represented by a class which inherit from THREAD (deferred class).<br>
<br>
		class<br>
			MY_THREAD<br>
		inherit<br>
			THREAD<br>
		...<br>
		feature&nbsp;<br>
			execute is<br>
			   -- define the deferred feature from THREAD.<br>
			do<br>
				...<br>
			end<br>
		...<br>
		end --class MY_THREAD<br>
<br>
<br>
  	- Creating a thread, it is like creating an Eiffel object:<br>
<br>
	   	my_thread: MY_THREAD&nbsp;<br>
	   		-- MY_THREAD inherit from THREAD and define<br>
	   		-- the deferred procedure `execute'<br>
	   	!! my_thread (or my_thread.make if there is a creation feature).<br>
<br>
<br>
	- Note: - you have created a thread object but not yet launched it.<br>
  		- to run the thread, use the feature `launch' from THREAD.<br>
<br>
		my_thread.launch<br>
<br>
	- On the Eiffel side, the procedure `execute' will be launched.<br>
	  This procedure is deferred in class THREAD, you have to define<br>
	  it in MY_THREAD.&nbsp;<br>
<br>
  	- On the C side, a C-thread will be created and launched.<br>
<br>
   	IMPORTANT: Do not forget to put join_all and the end of<br>
		   the object that created the threads if you do not want<br>
		   the father to die before its children threads, otherwise<br>
		   the execution of the children will be stopped too.<br>
<br>
<br>
<br>
   4.2  Sharing objects between threads: the class PROXY<br>
<br>
	- A critical problem in programming multithreaded application is<br>
	  the management of objects shared between several threads: the threads&nbsp;<br>
	  cannot access to these objects at the same time. CONDITION_VARIABLE,<br>
	  MUTEX, SEMAPHORE have been implemented in this purpose.&nbsp;<br>
<br>
	- An other problem specific to Eiffel lies on the Eiffel GC.&nbsp;<br>
	  When a thread dies, its objects are reclaimed by the run-time,<br>
	  and we do not want it to collect the shared objects which are likely to<br>
	  be used by other threads. Hence, we need an object called proxy to<br>
	  encapsulate the shared object so that the proxy  will be<br>
	  collected instead. A proxy must not be shared and is specific to a thread.<br>
	  The PROXY class was expanded before 4.2, it is not any longer.&nbsp;<br>
<br>
	- To declare a proxy of object SHARED_TYPE:<br>
<br>
	   my_proxy: PROXY [SHARED_TYPE]<br>
<br>
	- To create it:<br>
	   ( be sure your object `my_item' is already created. )<br>
<br>
	   !! my_proxy.put (my_item)<br>
<br>
	- During the execution of your thread (take it literally: it means when&nbsp;<br>
	  the procedure execute is running), you will access the shared object<br>
	  throughout the proxy:<br>
<br>
	   `my_proxy.item' corresponds to the encapsulated shared object.<br>
<br>
  	NOTE:&nbsp;<br>
	  a direct consequence of this mechanism is that encapsulating a pointer<br>
	  to a C object is not systematically necessary because the thread<br>
	  duplicates the pointer to this C object and not the C object itself.&nbsp;<br>
	  That's to say we do not manipulate a copy but the original itself.&nbsp;<br>
	  Note that when reclaiming the thread we have to be sure that the&nbsp;<br>
	  C object will be reclaimed only once. This is the reason why the class&nbsp;<br>
	  OBJECT_OWNER has been implemented.&nbsp;<br>
<br>
  	- What kind of object can we put into a PROXY?<br>
<br>
	  For the moment only references. If you want to put an expanded object,<br>
	  you have to pass its reference (integer_ref, boolean_ref...). If you<br>
	  want to pass a special object (instanced by a generic class you are not<br>
	  allowed to resized it after putting it into a proxy (pb with freeze).<br>
<br>
	  There is no need to use proxy to shared a MUTEX, a CONDITION_VARIABLE&nbsp;<br>
	  or a SEMAPHORE.<br>
<br>
<br>
   4.3  The class MUTEX<br>
<br>
	- The implementation of mutex is based like most of the Eiffelthread&nbsp;<br>
	  object on the C-thread library provided on each platforms that allow<br>
	  this.&nbsp;<br>
	- Then, `lock' `unlock' `make' ... call the C-functions implemented<br>
	  in the C-threads library.<br>
<br>
	- my_mutex.pointer is the pointer to the C-corresponding mutex of my_mutex.<br>
<br>
	- declaration of the mutex :<br>
	   my_mutex: MUTEX<br>
<br>
	- Creation of mutex :<br>
	   !! my_mutex.make<br>
<br>
    	- Locking mutex :&nbsp;<br>
	   my_mutex.lock<br>
<br>
    	- unlocking mutex :<br>
	   my_mutex.unlock<br>
<br>
    	- Has client been successful in locking the mutex without waiting?<br>
	   my_mutex.try_lock<br>
<br>
    	- Is my mutex initialized?<br>
	   my_mutex.is_set<br>
<br>
	NOTE: on Windows:<br>
	  While a thread has ownership of a mutex, it can specify the same mutex<br>
	  in additional wait-function calls without blocking its execution. This prevents a<br>
      thread from deadlocking itself while waiting for a mutex that it already owns.<br>
      However, to release its ownership, the thread must call ReleaseMutex<br>
      once for each time that the mutex satisfied a wait.&nbsp;<br>
<br>
<br>
   4.4  The class SEMAPHORE<br>
<br>
	Like MUTEX, the features of this class call the C-thread corresponding<br>
	function.<br>
<br>
	- Declaration of the semaphore :<br>
<br>
		my_sem: SEMAPHORE<br>
<br>
	- Creation of semaphore:<br>
	   initialize semaphore with nb_tokens<br>
	   require nb_tokens >= 0<br>
<br>
		!!my_sem.make (nb_tokens)&nbsp;<br>
<br>
	- Wait for an available token:<br>
<br>
		my_sem.wait<br>
<br>
	- Give back a token:<br>
<br>
		my_sem.post<br>
<br>
	- try_wait : similar to try_lock from MUTEX<br>
<br>
		my_sem.try_wait&nbsp;<br>
<br>
<br>
<br>
   4.5  The class CONDITION_VARIABLE<br>
<br>
  	This class allows to use condition variables in Eiffel.<br>
<br>
	-- Declaration of the condition variable<br>
<br>
		my_cond: CONDITION_VARIABLE<br>
<br>
	-- Creation:<br>
<br>
		!! my_cond.make<br>
<br>
	-- Wait for a signal (send by `signal').<br>
	   You need to use a mutex, because when we call the `wait' feature<br>
	   the number of waiters on this condition variable is incremented.&nbsp;<br>
<br>
	   	my_mutex: MUTEX<br>
		!! my_mutex.make<br>
<br>
	   my_mutex must be locked by the calling thread so as `wait' can be called.<br>
<br>
		my_mutex.lock<br>
		   ...<br>
	   	my_cond.wait (my_mutex)&nbsp;<br>
		   ...<br>
	   	my_mutex.unlock<br>
<br>
    	-- Unblock one thread blocked on the current condition variable.<br>
<br>
		my_cond.signal<br>
<br>
    	-- Unblock all the threads blocked on the current condition variable.<br>
<br>
		my_cond.broadcast<br>
<br>
<br>
   4.6  Disposing C-thread object: class OBJECT_OWNER<br>
<br>
    	- Used by MUTEX, SEMAPHORE, PROXY, and CONDITION_VARIABLE.&nbsp;<br>
	  By inheriting from OBJECT_OWNER, only the thread that has created the<br>
	  object_owner object could remove it. This was at first implemented<br>
	  for PROXY (since it was no longer expanded), but we finally used it<br>
	  for MUTEX, SEMAPHORE, and CONDITION_VARIABLE. This way, we do not<br>
	  have to put it in a proxy (pointer, see the note on mutex above).<br>
<br>
    	- You do not need to know how to use it (as a user).<br>
<br>
	- So, if you want to have a more readable code (and a faster execution):<br>
	  No need to put the MUTEX, SEMAPHORE, CONDITION_VARIABLE in a PROXY.<br>
<br>
	- However, we assume that only the thread which has created these<br>
	  objects can removed it. Hence, if this thread dies, the objects<br>
	  will be removed with it.&nbsp;<br>
<br>
   4.7  Miscellaneous classes<br>
<br>
	- class THREAD_ATTRIBUTES : defines the attributes of thread.<br>
	- class OBJECT_CONTROL    : control over objects meant to be used&nbsp;<br>
   	  within different threads. Not bound to be called by the common user.&nbsp;<br>
	- class THREAD_CONTROL    : control over thread execution&nbsp;<br>
<br>
	(see comments in the class).<br>
<br>
<br>
<br>
   4.8  Controlling execution: THREAD_CONTROL<br>
<br>
	- yield: the calling thread yields its execution in favor of&nbsp;<br>
	  	 an other thread of same priority.<br>
<br>
	- join_all: the calling thread waits for all other threads to<br>
		    finished (all its children).<br>
<br>
<br>
	-> A parent thread can wait for the termination of a child<br>
	   process through the feature `join' of class THREAD_CONTROL<br>
	   (inherited by THREAD):<br>
<br>
		thr: MY_THREAD<br>
		...<br>
		thr.launch<br>
		...<br>
		thr.join<br>
<br>
	The implementation uses condition variables. For platforms that<br>
	don't support them, an alternative implementation is used, but<br>
	much costly in terms of CPU (active loops). If the platform supports<br>
	a thread_yield function, then it's almost as good as the implementation<br>
	with condition variables.<br>
<br>
	-> A parent thread can wait for the termination of all its child<br>
	   processes through the feature `join_all' of THREAD_CONTROL. It<br>
	   used to be supported only on Solaris, but it is now supported<br>
	   by every platform. As with `join', it works better with platforms<br>
	   supporting condition variables.<br>
<br>
	-> For platforms that support a thread_join function, an Eiffel<br>
	   interface to it is `native_join' (in case anybody wants to use it).<br>
<br>
<br>
5   ONCE FEATURE IN MULTI-THREADED MODE<br>
---------------------------------------<br>
<br>
   5.1  Manipulating Once features in multi-threaded mode<br>
<br>
	Eiffel introduced the powerful mechanism of once routines. A once<br>
	routine has a body that will be executed only once, for the first call;<br>
	subsequent calls will have no further effect and, in the case of a<br>
	function, will return the same result as the first. This provides a&nbsp;<br>
	simple way of sharing objects in an object-oriented context.&nbsp;<br>
<br>
	For multi-threaded applications, the appropriate semantics is that once<br>
	routines must be called once per thread (rather than once per<br>
	process). This is the semantics supported by EiffelThread.&nbsp;<br>
<br>
	Then the once feature is not initialized once per process but once&nbsp;<br>
	per thread. Your once feature will be reinitialized in any new thread execution.&nbsp;<br>
<br>
<br>
   5.2  Once per Process/Thread<br>
<br>
	- Current once features in Eiffel have within once per thread&nbsp;<br>
	  implementation. This means that when a once feature is called&nbsp;<br>
	  in a thread, Eiffel run-time will check whether it has been already&nbsp;<br>
	  computed IN this thread. If not, the once feature will be initialized&nbsp;<br>
	  and computed. This seems to be a relevant way of managing once features<br>
	  in multithreaded mode: most of time, a once called in a thread&nbsp;<br>
	  is not bound to share its result.&nbsp;<br>
	- Besides, for reasons we do not want to detail here, current&nbsp;<br>
	  implementation of threads with a non once per thread implementation&nbsp;<br>
	  would require to encapsulate each once feature, which could&nbsp;<br>
	  be called by several threads, in a proxy.&nbsp;<br>
	- That would mean heavy signatures in thread creation procedures and&nbsp;<br>
	  inelegant lines of code. However, in some case, we need to share&nbsp;<br>
	  once features. For example, features such as a once function returning&nbsp;<br>
	  a STD_FILES where we want to put all the output of our execution&nbsp;<br>
	  should not be initialized in each thread but once during a process.&nbsp;<br>
	- Moreover, an Eiffel programmer should be able to have an alternative&nbsp;<br>
	  between a once per thread or per process implementation.&nbsp;<br>
<br>
<br>
   5.3  Using Once per process/thread features in EIFFEL&nbsp;<br>
<br>
	- Keeping the default management of the once features in EIFFEL,&nbsp;<br>
	  a once per process could be implemented by calling the external&nbsp;<br>
	  C function 'eif_global_function' as described below:<br>
<br>
<br>
	class&nbsp;<br>
		TEST_ONCE_PER_PROCESS<br>
	inherit<br>
		ONCE_CONTROL -- contains global_once_function<br>
	...<br>
<br>
		file_per_thread: STD_FILES is<br>
				-- former implementation of 'io'<br>
				-- (once per thread)<br>
			once<br>
				!! Result.make<br>
				Result.set_output_default<br>
			end<br>
<br>
		file_per_process: STD_FILES is<br>
				-- new 'file' (once per process)<br>
				-- that could be shared between threads<br>
				-- without reinitializing it<br>
			once<br>
				Result ?= global_once_function (Current, $file_per_thread<br>
			end<br>
	...<br>
<br>
	end -- class TEST_ONCE_PER_PROCESS<br>
<br>
<br>
	class&nbsp;<br>
		ONCE_CONTROL<br>
	...<br>
<br>
		global_once_function (Currt: ANY; once_func: POINTER): ANY is<br>
				-- returns the result of the once feature<br>
				-- pointed by 'once_func' which will be&nbsp;<br>
				-- evaluated once per process<br>
			external<br>
				"C [macro %"eif_once.h%"]"<br>
			alias<br>
				"eif_global_function"<br>
			end<br>
<br>
	...<br>
<br>
	end -- class ONCE_CONTROL&nbsp;<br>
<br>
<br>
<br>
<br>
	- Note that file_per_thread is passed through a pointer so as&nbsp;<br>
	  not to be computed once more, at the first call in a new thread.<br>
	- We admit that passing 'Current' as a formal argument of global_once&nbsp;<br>
	  is not very elegant, but this is necessary to evaluate 'file_per_thread'.<br>
<br>
	- In the same way, there is a once_per_process procedure mechanism:<br>
<br>
<br>
<br>
 	procedure_per_process is&nbsp;<br>
 		once<br>
 			global_once_procedure (Current, $procedure_per_thread)<br>
 		end<br>
<br>
 	procedure_per_thread is<br>
 		once<br>
 			-- do something --<br>
 		end<br>
<br>
 	in class ONCE_CONTROL:<br>
<br>
 	...<br>
	global_once_procedure (Currt: ANY; once_proc: POINTER) is<br>
 		external<br>
 			"C [macro %"eif_once.h%"]"<br>
 		alias<br>
 			"eif_global_procedure"&nbsp;<br>
 		end<br>
 	...<br>
<br>
<br>
     5.4  Limitations:<br>
<br>
	At the moment, we have to call the once_per_process for the first&nbsp;<br>
	time in the process in the root_thread. If we did it in a thread,&nbsp;<br>
	it will work until this thread dies (because it will reclaim&nbsp;<br>
	the once_per_process object that belongs to its private memory).&nbsp;<br>
<br>
	Using interwoven once per process functions could cause<br>
	a deadlock (the once per process table is protected by a mutex: if<br>
	you call a once per process in another once per process&nbsp;<br>
	for the first time in a process or a thread, this will raise a deadlock.<br>
	This can happen in some tricky situation<br>
<br>
	Ex:<br>
<br>
	Do not write:<br>
<br>
	my_opp1: A_TYPE is<br>
		once<br>
			Result ?= global_function (Current, $my_opt) &nbsp;<br>
			-- lock access to&nbsp;<br>
			-- the once per process functions table<br>
		end<br>
<br>
	my oppt: A_TYPE is<br>
		once&nbsp;<br>
			!! Result.make (my_opp2) &nbsp;<br>
		end<br>
<br>
<br>
	my_opp2: A_TYPE2 is<br>
		once<br>
			global_once (Current, $my_opt2)&nbsp;<br>
			-- will fail in attempting to lock the once<br>
			-- per process functions table<br>
		end<br>
<br>
	my_opt2: A_TYPE2 is<br>
		once<br>
			!! Result.make<br>
		end&nbsp;<br>
<br>
<br>
	note:&nbsp;<br>
		Nevertheless, you can call on once per process procedure in a once per<br>
		process function  and vice versa since  they do not lock the same once&nbsp;<br>
		per process table.
<p>

&nbsp;

<h2>I've launched several threads and they do not seem to be executed:</h2>
<blockquote>
<p>The calling thread/root thread that has launched the threads may be dead before its children. On the platform which support condition variable,
you can prevent it by putting a `join_all' in the calling thread: this way, it will wait for the death of its children threads.</p>
</blockquote>
<p>&nbsp;</p>
<h2>Two threads can lock the same mutex, however none of them unlock it:</h2>
<blockquote>
<p>Same problem as above. May be the first thread that locked the shared mutex died before the second has tried to lock it: then, the 1rst one has
automatically unlock it when dying. You should put a join_all or a infinite loop.</p>
</blockquote>
<p>&nbsp;</p>
<h2>I've added the option multithreaded (yes) in my ace file and it crashes:</h2>
<blockquote>
<p>If you have already compiled your system in non-MT mode, you cannot change the mode of compilation in your ace file and relaunch your compilation
(the generated C-code would be incompatible). Delete all your object files in your W_code or F_code directory and freeze the system again.</p>
</blockquote>
<p>&nbsp;</p>
<h2>My once function changed during my MT-Eiffel-program:</h2>
<blockquote>
<p>The once functions are once per thread in Multithreaded mode. Hence, each once function is thread specific and is initialized the first
time it is called in a thread.</p>
<p>You can create a once per process functions by two ways:</p>
<ul>
  <li>Using the external functions provided in ONCE_CONTROL. (MT-safe)</li>
  <li>Putting the once function in a proxy, the threads other than its creator will have to access to it through `item'. (not MT-safe: you should call the  once in mutual exclusion).<br>
  </li>
</ul>

</blockquote>

</td></tr></table>
</body>

</html>
