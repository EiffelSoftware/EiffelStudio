<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML XMLNS:MSHelp="http://msdn.microsoft.com/mshelp">
	<XML>
		<MSHelp:Keyword Index="K" Term="Eiffel Tutorial, Inheritance" />
		<MSHelp:Attr Name="Product" Value="Eiffel"/>
		<MSHelp:Attr Name="Locale" Value="kbEnglish"/>
	</XML>
	<HEAD>
		<TITLE>An Eiffel Tutorial, Inheritance</TITLE>
		<LINK HREF="../../../default.css" TYPE="text/css" REL="STYLESHEET">
	</HEAD>
	<BODY>
		<TABLE CLASS="HEADER">
			<TR>
				<TD CLASS="HEADER">Eiffel ENViSioN!</TD>
			</TR>
			<TR>
				<TD CLASS="SUBHEADER">An Eiffel Tutorial, Inheritance</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FRAME">
			<TR>
				<TD>
					<A NAME="pgfId-515052"></A>

					<P>Inheritance is a powerful and attractive technique. A look
					at either the practice or literature shows, however, that it
					is not always well applied. Eiffel has made a particular
					effort to tame inheritance for the benefit of modelers and
					software developers. Many of the techniques are original with
					Eiffel. Paul Dubois has written
					(<SPAN CLASS="italics">comp.lang.python</SPAN> Usenet
					newsgroup, 23 March 1997):</P>

					<P><SPAN CLASS="italics">there are two things that [Eiffel]
					got right that nobody else got right anywhere else: support
					for Design by Contract&#153, and multiple inheritance.
					Everyone should understand these &quot;correct answers&quot;
					if only to understand how to work around the limitations in
					other languages</SPAN>.</P>

					<H2>Basic inheritance structure</H2>

					<P>To make a class inherit from another, simply use an
					<SPAN CLASS="ekeyword">inherit</SPAN> clause:</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">indexing</SPAN>&#8230;</P>

						<P><SPAN CLASS="ekeyword">class</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">D</SPAN></P>

						<P><SPAN CLASS="ekeyword">inherit</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">A</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">B</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&#8230;</P>

						<P><SPAN CLASS="ekeyword">feature</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&#8230;
					</CODE>

					<P>This makes <SPAN CLASS="eclass">D</SPAN> an heir of
					<SPAN CLASS="eclass">A</SPAN>, <SPAN CLASS="eclass">B</SPAN>
					and any other class listed. Eiffel supports
					<SPAN CLASS="bold">multiple</SPAN> inheritance: a class may
					have as many parents as it needs. Later sections
					(<A HREF="tutorial-10.html#21906">&quot;Multiple inheritance and renaming&quot;</A>
					and <A HREF="tutorial-10.html#69912">&quot;Repeated inheritance and selection&quot;</A>)
					will explain how to handle possible conflicts between parent
					features.</P>

					<P CLASS=note>This discussion will rely on the terminology
					introduced in <A HREF="tutorial-06.html#INHERITANCE AND CLIENT TERMS">Inheritance And Client Terms</A>:
					<SPAN CLASS="italics">descendants</SPAN> of a class are the
					class itself, its heirs, the heirs of its heirs and so on.
					<SPAN CLASS="italics">Proper descendants</SPAN> exclude the
					class itself. The reverse notions are
					<SPAN CLASS="italics">ancestors</SPAN> and
					<SPAN CLASS="italics">proper ancestors</SPAN>.</P>

					<P>By default <SPAN CLASS="eclass">D</SPAN> will simply
					include all the original features of
					<SPAN CLASS="eclass">A</SPAN>, <SPAN CLASS="eclass">B</SPAN>,
					&#8230;, to which it may add its own through its
					<SPAN CLASS="ekeyword">feature</SPAN> clauses if any. But the
					inheritance mechanism is more flexible, allowing
					<SPAN CLASS="eclass">D</SPAN> to adapt the inherited features
					in many ways. Each parent name --
					<SPAN CLASS="eclass">A</SPAN>, <SPAN CLASS="eclass">B</SPAN>,
					&#8230; in the example -- can be followed by a Feature
					Adaptation clause, with subclauses, all optional, introduced
					by keywords <SPAN CLASS="ekeyword">rename</SPAN>,
					<SPAN CLASS="ekeyword">export</SPAN>,
					<SPAN CLASS="ekeyword">undefine</SPAN>,
					<SPAN CLASS="ekeyword">redefine</SPAN> and
					<SPAN CLASS="ekeyword">select</SPAN>, enabling the author of
					<SPAN CLASS="eclass">A</SPAN> to make the best use of the
					inheritance mechanism by tuning the inherited features to the
					precise needs of <SPAN CLASS="eclass">D</SPAN>. This makes
					inheritance a principal tool in the Eiffel process, mentioned
					earlier, of carefully crafting each individual class, like a
					machine, for the benefit of its clients. The next sections
					review the various Feature Adaptation subclauses.</P>

					<H2>Redefinition</H2>

					<P>The first form of feature adaptation is the ability to
					change the implementation of an inherited feature.</P>

					<P>Assume a class <SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN>
					that specializes the notion of account. It is probably
					appropriate to define it as an heir to class
					<SPAN CLASS="eclass">ACCOUNT</SPAN>, to benefit from all
					the features of <SPAN CLASS="eclass">ACCOUNT </SPAN> still
					applicable to savings accounts, and to reflect the conceptual
					relationship between the two types: every savings account,
					apart from its own specific properties, also &quot;is&quot;
					an account. But we may need to produce a different effect for
					procedure <SPAN CLASS="efeature">deposit</SPAN> which, besides
					recording the deposit and updating the balance, may also need,
					for example, to update the interest.</P>

					<P>This example is typical of the form of reuse promoted by
					inheritance and crucial to effective reusability in software:
					the case of <SPAN CLASS="italics">reuse with adaptation</SPAN>.
					Traditional forms of reuse are all-or-nothing: either you take
					a component exactly as it is, or you build your own.
					Inheritance will get us out of this &quot;reuse or redo&quot;
					dilemma by allowing us to reuse <SPAN CLASS="italics">and</SPAN>
					redo. The mechanism is feature redefinition:</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">indexing</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eitag">description:</SPAN>
						<SPAN CLASS="estring">&quot;Savings accounts&quot;</SPAN></P>

						<P><SPAN CLASS="ekeyword">class</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN></P>

						<P><SPAN CLASS="ekeyword">inherit</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">ACCOUNT</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">redefine</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">deposit</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="ecomment">-- Element change</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">deposit</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">sum</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Add <SPAN CLASS="elocal">sum</SPAN> to account.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						&#8230; New implementation (see below) &#8230;</P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&#8230; Other features &#8230;</P>

						<P><SPAN CLASS="ekeyword">end</SPAN>
						<SPAN CLASS="ecomment">-- class</SPAN>
						<SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN></P>
					</CODE>

					<P>Without the <SPAN CLASS="ekeyword">redefine</SPAN>
					subclause, the declaration of <SPAN CLASS="efeature">deposit</SPAN>
					would be invalid, yielding two features of the same name,
					the inherited one and the new one. The subclause makes this
					valid by specifying that the new declaration will override
					the old one.</P>

					<P>In a redefinition, the original version -- such as the
					<SPAN CLASS="eclass">ACCOUNT</SPAN> implementation of
					<SPAN CLASS="efeature">deposit</SPAN> in this example -- is
					called the <SPAN CLASS="ekeyword">precursor</SPAN> of the new
					version. It is common for a redefinition to rely on the
					precursor's algorithm and add some other actions; the
					reserved word <SPAN CLASS="ekeyword">Precursor</SPAN> helps
					achieve this goal simply. Permitted only in a routine
					redefinition, it denotes the parent routine being redefined.
					So here he body of the new <SPAN CLASS="efeature">deposit</SPAN>
					(called &quot;<SPAN CLASS="ecomment">New implementation</SPAN>&quot;
					above) could be of the form</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">Precursor</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">sum</SPAN><SPAN CLASS="esymbol">)</SPAN>
						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Apply</SPAN>
						<SPAN CLASS="eclass">ACCOUNT</SPAN><SPAN CLASS="ecomment">'s
						version of</SPAN>
						<SPAN CLASS="efeature">deposit</SPAN></P>

						<P>&#8230; Instructions to update the interest &#8230;</P>
					</CODE>

					<P>Besides changing the implementation of a routine, a
					redefinition can turn an argument-less function into an
					attribute; for example a proper descendant of
					<SPAN CLASS="eclass">ACCOUNT</SPAN> could redefine
					<SPAN CLASS="efeature">deposits_count</SPAN>, originally a
					function, as an attribute. The
					<A HREF="tutorial-07.html#UNIFORM_ACCESS">Uniform
					Access Principle</A> guarantees that the redefinition
					makes no change for clients, which will continue to use
					the feature under the form
					<SPAN CLASS="elocal">acc</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">deposits_count</SPAN>.

					<A NAME="65123"></A><H2>Polymorphism</H2>

					<P>The inheritance mechanism is relevant to both roles of
					classes: module and type. Its application as a mechanism to
					reuse, adapt and extend features from one class to another,
					as just seen, covers its role as a
					<SPAN CLASS="bold">module extension</SPAN> mechanism. But
					it's also a <SPAN CLASS="bold">subtyping</SPAN> mechanism.
					To say that <SPAN CLASS="eclass">D</SPAN> is an heir of
					<SPAN CLASS="eclass">A</SPAN>, or more generally a
					descendant of <SPAN CLASS="eclass">A</SPAN>, is to express
					that instances of <SPAN CLASS="eclass">D</SPAN> can be
					viewed as instances of <SPAN CLASS=eclass>A</SPAN>.</P>

					<P><SPAN CLASS="bold">Polymorphic assignment</SPAN> supports
					this second role. In an assignment
					<SPAN CLASS="elocal">x</SPAN>
					<SPAN CLASS="esymbol">:=</SPAN>
					<SPAN CLASS="efeature">y</SPAN>, the types of
					<SPAN CLASS="elocal">x</SPAN> and <SPAN CLASS="efeature">y</SPAN>
					do not have, with inheritance, to be identical; the rule is
					that the type of <SPAN CLASS="efeature">y </SPAN> must simply
					<SPAN CLASS="bold">conform</SPAN> to the type of
					<SPAN CLASS="elocal">x</SPAN>. A class
					<SPAN CLASS="eclass">D</SPAN> conforms to a class
					<SPAN CLASS="eclass">A</SPAN> if and only if it is a
					descendant of <SPAN CLASS="eclass">A</SPAN> (which includes
					the case in which <SPAN CLASS="eclass">A</SPAN> and
					<SPAN CLASS="eclass">D</SPAN> are the same class); if these
					classes are generic, conformance of <SPAN CLASS="eclass">D</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">U</SPAN><SPAN CLASS="esymbol">]</SPAN>
					to <SPAN CLASS="eclass">C</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">T</SPAN><SPAN CLASS="esymbol">]</SPAN>
					requires in addition that type <SPAN CLASS="eclass">U</SPAN>
					conform to type <SPAN CLASS="eclass">T</SPAN> (through the
					recursive application of the same rules).</P>

					<P CLASS=note>In addition, it follows from the discussion of tuples
					(<A HREF="tutorial-11.html#36752">&quot;Tuple types&quot;</A>),
					that <SPAN CLASS="eclass">TUPLE</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">X</SPAN><SPAN CLASS="esymbol">]</SPAN>
					conforms to <SPAN CLASS="eclass">TUPLE</SPAN>,
					<SPAN CLASS="eclass">TUPLE</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">X</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="eclass">Y</SPAN><SPAN CLASS="esymbol">]</SPAN>
					to <SPAN CLASS="eclass">TUPLE</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">X</SPAN><SPAN CLASS="esymbol">]</SPAN>
					and so on.</P>

					<P>So with the inheritance structure that we have seen,
					the declarations</P>

					<CODE>
						<P><SPAN CLASS="elocal">acc</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">ACCOUNT</SPAN><SPAN CLASS="esymbol">;</SPAN>
						<SPAN CLASS="elocal">sav</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN></P>
					</CODE>

					<P>make it valid to write the assignment</P>

					<CODE>
						<P><SPAN CLASS="elocal">acc</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="elocal">sav</SPAN></P>
					</CODE>

					<P>which will assign to <SPAN CLASS="elocal">acc</SPAN>
					a reference attached (if not void) to a direct instance of
					type <SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN>, not
					<SPAN CLASS="eclass">ACCOUNT</SPAN>.</P>

					<P>Such an assignment, where the source and target types
					are different, is said to be polymorphic. An entity such
					as <SPAN CLASS="elocal">acc</SPAN>, which as a result of
					such assignments may become attached at run time to objects
					of types other than the one declared for it, is itself called
					a polymorphic entity.</P>

					<P>For polymorphism to respect the reliability requirements
					of Eiffel, it must be controlled by the type system and
					enable static type checking. We certainly do not want an
					entity of type <SPAN CLASS="eclass">ACCOUNT</SPAN> to become
					attached to an object of type
					<SPAN CLASS="eclass">DEPOSIT</SPAN>. Hence the second typing
					rule:</P>

					<P CLASS="tip"><SPAN CLASS="bold">Type Conformance rule</SPAN><BR />
					An assignment <SPAN CLASS="elocal">x</SPAN>
					<SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="elocal">y</SPAN>,
					or the use of <SPAN CLASS="elocal">y</SPAN> as actual
					argument corresponding to the formal argument
					<SPAN CLASS="elocal">x</SPAN> in a routine call, is only
					valid if the type of <SPAN CLASS="elocal">y</SPAN> conforms
					to the the type of <SPAN CLASS="elocal">x</SPAN>.</P>

					<P>The second case listed in the rule is a call such as
					<SPAN CLASS="elocal">target</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">routine</SPAN>
					<SPAN CLASS="esymbol">(</SPAN>&#8230;, <SPAN CLASS="elocal">y</SPAN>,
					&#8230;<SPAN CLASS="esymbol">)</SPAN> where the routine
					declaration is of the form
					<SPAN CLASS="efeature">routine</SPAN>
					<SPAN CLASS="esymbol">(</SPAN>&#8230;,
					<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">:</SPAN>
					<SPAN CLASS="eclass">SOME_TYPE</SPAN>,
					&#8230;<SPAN CLASS="esymbol">)</SPAN>. The relationship
					between <SPAN CLASS="elocal">y</SPAN>, the actual argument
					in the call, and the corresponding formal argument
					<SPAN CLASS="elocal">x</SPAN>, is exactly the same as in
					an assignment <SPAN CLASS="elocal">x</SPAN>
					<SPAN CLASS="esymbol">:=</SPAN>
					<SPAN CLASS="elocal">y</SPAN>: not just the type rule, as
					expressed by Type Conformance (the type of
					<SPAN CLASS="elocal">y</SPAN> must conform to
					<SPAN CLASS="eclass">SOME_TYPE</SPAN>), but also the actual
					run-time effect which, as for assignments, will be either a
					reference attachment or, for expanded types, a copy.</P>

					<P>The ability to accept the assignment
					<SPAN CLASS="elocal">x</SPAN>
					<SPAN CLASS="esymbol">:=</SPAN> <SPAN CLASS="efeature">Void</SPAN>
					for <SPAN CLASS="elocal">x</SPAN> of any reference type
					(<A HREF="tutorial-07.html#12485">&quot;Basic operations&quot;</A>)
					is a consequence of the Type Conformance rule, since
					<SPAN CLASS="efeature">Void</SPAN> is of type
					<SPAN CLASS="eclass">NONE</SPAN> which by construction
					(<A HREF="tutorial-06.html#GLOBAL">&quot;The global inheritance structure&quot;</A>)
					conforms to all types.</P>

					<P>Polymorphism also yields a more precise definition of
					&quot;instance&quot;. A <SPAN CLASS="bold">direct
					instance</SPAN> of a type <SPAN CLASS="eclass">A</SPAN>
					is an object created from the exact pattern defined by the
					declaration of <SPAN CLASS="eclass">A</SPAN>'s base class,
					with one field for each of the class attributes; you will
					obtain it through a creation instruction of the form
					<SPAN CLASS="ekeyword">create</SPAN>
					<SPAN CLASS="elocal">x</SPAN>&#8230;, for
					<SPAN CLASS="elocal">x</SPAN> of type
					<SPAN CLASS="eclass">A</SPAN>, or by cloning an existing
					direct instance. An <SPAN CLASS="bold">instance</SPAN> of
					<SPAN CLASS="eclass">A</SPAN> is a direct instance of any
					type conforming to <SPAN CLASS="eclass">A</SPAN>:
					<SPAN CLASS="eclass">A</SPAN> itself, but also any type
					based on descendant classes. So an instance of
					<SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN> is also an
					instance, although not a direct instance, of
					<SPAN CLASS="eclass">ACCOUNT</SPAN>.</P>

					<P>A consequence of polymorphism is the ability to define
					<SPAN CLASS="bold">polymorphic data structures</SPAN>.
					With a declaration such as</P>

					<CODE>
						<P><SPAN CLASS="efeature">accounts</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">LIST</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">ACCOUNT</SPAN><SPAN CLASS="esymbol">]</SPAN>
						</P>
					</CODE>

					<P>the procedure call
					<SPAN CLASS="efeature">accounts</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">extend</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">acc</SPAN><SPAN CLASS="esymbol">)</SPAN>,
					because it uses a procedure <SPAN CLASS="efeature">extend</SPAN>
					which in this case expects an argument of any type
					conforming to <SPAN CLASS="eclass">ACCOUNT</SPAN>, will be
					valid not only if <SPAN CLASS="elocal">acc</SPAN> is of type
					<SPAN CLASS="eclass">ACCOUNT</SPAN> but also if it is of a
					descendant type such as <SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN>.
					Successive calls of this kind make it possible to construct a
					data structure that, at run-time, might contain objects of
					several types, all conforming to
					<SPAN CLASS="eclass">ACCOUNT</SPAN>:</P>

					<IMG SRC="tutorial-10.png">
					<IMG SRC="tutorial-11.png">

					<P>Such polymorphic data structures combine the flexibility
					and safety of genericity and inheritance. You can make them
					more or less general by choosing for the actual generic
					parameter, here <SPAN CLASS="eclass">ACCOUNT</SPAN>, a type
					higher or lower in the inheritance hierarchy. Static typing
					is again essential here, prohibiting for example a mistaken
					insertion of the form
					<SPAN CLASS="efeature">accounts</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">extend </SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">dep</SPAN><SPAN CLASS="esymbol">)</SPAN>
					where <SPAN CLASS="elocal">dep</SPAN> is of type
					<SPAN CLASS="eclass">DEPOSIT</SPAN>, which does not conform
					to <SPAN CLASS="eclass">ACCOUNT</SPAN>.</P>

					<P>At the higher (most abstract) end of the spectrum, you can
					produce an unrestrictedly polymorphic data structure
					<SPAN CLASS="efeature">general_list</SPAN>:
					<SPAN CLASS="eclass">LIST</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">ANY</SPAN><SPAN CLASS="esymbol">]</SPAN>
					which makes the call
					<SPAN CLASS="efeature">general_list</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">extend</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">)</SPAN>
					valid for any <SPAN CLASS="elocal">x</SPAN>. The price to pay
					is that retrieving an element from such a structure will
					yield an object on which the only known applicable operations
					are the most general ones, valid for all types: assignment,
					copy, clone, equality comparison and others from
					<SPAN CLASS="eclass">ANY</SPAN>. Assignment attempt, studied
					below, will make it possible to apply more specific
					operations after checking dynamically that a retrieved object
					is of the appropriate type.

					<H2>Dynamic binding</H2>

					<P>The complement of polymorphism is dynamic binding, the
					answer to the question &quot;What version of a feature will
					be applied in a call whose target is polymorphic?&quot;.</P>

					<P>Consider <SPAN CLASS="elocal">acc</SPAN> is of type
					<SPAN CLASS="eclass">ACCOUNT</SPAN>. Thanks to polymorphism,
					an object attached to <SPAN CLASS="elocal">acc</SPAN> may be
					a direct instance not just of
					<SPAN CLASS="eclass">ACCOUNT</SPAN> but also of
					<SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN> or other
					descendants. Some of these descendants, indeed
					<SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN> among them,
					redefine features such as
					<SPAN CLASS="efaeture">deposit</SPAN>. Then we have to ask
					what the effect will be for a call of the form</P>

					<CODE>
						<P><SPAN CLASS="elocal">acc</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">deposit</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">some_value</SPAN><SPAN CLASS="esymbol">)</SPAN>
						</P>
					</CODE>

					<P>Dynamic binding is the clearly correct answer: the call
					will execute the version of
					<SPAN CLASS="efeature">deposit</SPAN> from the generating
					class of the object attached to
					<SPAN CLASS="elocal">acc</SPAN> at run time. If
					<SPAN CLASS="elocal">acc</SPAN> is attached to a direct
					instance of <SPAN CLASS="eclass">ACCOUNT</SPAN>, execution
					will use the original <SPAN CLASS="eclass">ACCOUNT</SPAN>
					version; if <SPAN CLASS="elocal">acc</SPAN> is attached to
					a direct instance of
					<SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN>, the call will
					execute the version redefined in that class.</P>

					<P>This is a clear correctness requirement. A policy of
					<SPAN CLASS="italics">static binding</SPAN> (as available
					for example in C++ or Delphi, for non-virtual functions)
					would take the declaration of
					<SPAN CLASS="elocal">acc</SPAN> as an
					<SPAN CLASS="eclass">ACCOUNT</SPAN> literally. But that
					declaration is only meant to ensure generality, to enable
					the use of a single entity <SPAN CLASS="elocal">acc</SPAN>
					in many different cases: what counts at execution time is
					the object that <SPAN CLASS="elocal">acc</SPAN> represents.
					Applying the <SPAN CLASS="eclass">ACCOUNT</SPAN> version to
					a <SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN> object would
					be wrong, possibly leading in particular to objects that
					violate the invariant of their own generating class (since
					there is no reason a routine of
					<SPAN CLASS="eclass">ACCOUNT</SPAN> will preserve the
					specific invariant of a proper descendant such as
					<SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN>, which it does
					not even know about).</P>

					<P>In some cases, the choice between static and dynamic
					binding does not matter: this is the case for example if a
					call's target is not polymorphic, or if the feature of the
					call is redefined nowhere in the system. In such cases the
					use of static binding permits slightly faster calls (since
					the feature is known at compile time). This application of
					static binding should, however, be treated as a
					<SPAN CLASS="bold">compiler optimization</SPAN>. The
					Eiffel compiler, under its optimized
					mode, which performs extensive optimization, will detect
					some of these cases and process them accordingly -- unlike
					approaches that make developers responsible for specifying
					what should be static and what dynamic (a tedious and error
					prone task, especially delicate because a minute change in
					the software can make a static call, in a far-away module of
					a large system, suddenly become dynamic). Eiffel programmers
					don't need to worry about such aspects; they can rely on the
					semantics of dynamic binding in all cases, with the knowledge
					that the compiler will apply static binding when safe and
					desirable.</P>

					<P>Even in cases that require dynamic binding, the design of
					Eiffel, in particular the typing rules, enable compilers to
					make the penalty over the static-binding calls of traditional
					approaches very small and, most importantly,
					<SPAN CLASS="bold">constant-bounded</SPAN>: it does not grow
					with the depth or complexity of the inheritance structure.
					The discovery in 1985 of a technique for constant-time
					dynamic binding calls, even in the presence of multiple and
					repeated inheritance, was the event that gave the green light
					to the development of Eiffel.</P>

					<P>Dynamic binding is particularly interesting for
					polymorphic data structures. If you iterate over the list of
					accounts of various kinds,
					<SPAN CLASS="efeature">accounts</SPAN>:
					<SPAN CLASS="eclass">LIST</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">ACCOUNT</SPAN><SPAN CLASS="esymbol">]</SPAN>,
					illustrated in the last figure, and at each step let
					<SPAN CLASS="elocal">acc</SPAN> represent the current list
					element, you can repeatedly apply</P>

					<CODE>
						<P><SPAN CLASS="elocal">acc</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">deposit</SPAN>
						<SPAN CLASS="esymbol">(</SPAN>&#8230;<SPAN CLASS="esymbol">)</SPAN></P>
					</CODE>

					<P>to have the appropriate variant of the
					<SPAN CLASS="efeature">deposit</SPAN> operation triggered
					for each element.</P>

					<P>The benefit of such techniques appears clearly if we
					compare them with the traditional way to address such needs:
					using multi-branch discriminating instructions of the form
					<SPAN CLASS="ekeyword">if</SPAN>
					<SPAN CLASS="esymbol">&quot;</SPAN><SPAN CLASS="estring">Account is a savings account</SPAN><SPAN CLASS="esymbol">&quot;</SPAN>
					<SPAN CLASS="ekeyword">then</SPAN> &#8230;
					<SPAN CLASS="ekeyword">elseif</SPAN>
					<SPAN CLASS="esymbol">&quot;</SPAN><SPAN CLASS="estring">It is a money market account</SPAN>
					<SPAN CLASS="esymbol">&quot;</SPAN>
					<SPAN CLASS="ekeyword">then</SPAN> &#8230; and so on, or the
					corresponding <SPAN CLASS="ekeyword">case</SPAN>&#8230;
					<SPAN CLASS="ekeyword">of </SPAN>&#8230;,
					<SPAN CLASS="ekeyword">switch</SPAN> or
					<SPAN CLASS="ekeyword">inspect</SPAN> instructions.
					Apart from their heaviness and complexity, such solutions
					cause many components of a software system to rely on the
					knowledge of the exact set of variants available for a
					certain notion, such as bank account. Then any addition,
					change or removal of variants can cause a ripple of changes
					throughout the architecture. This is one of the majors
					obstacles to extendibility and reusability in traditional
					approaches. In contrast, using the combination of
					inheritance, redefinition, polymorphism and dynamic binding
					makes it possible to have a
					<SPAN CLASS="bold">point of single choice</SPAN> -- a unique
					location in the system which knows the exhaustive list of
					variants. Every client then manipulates entities of the most
					general type, <SPAN CLASS="eclass">ACCOUNT</SPAN>, through
					dynamically bound calls of the form
					<SPAN CLASS="elocal">acc</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">some_account_feature</SPAN>
					<SPAN CLASS="esymbol">(</SPAN>&#8230;<SPAN CLASS="esymbol">)</SPAN>.</P>

					<P>These observations make dynamic binding appear for what it
					is: not an implementation mechanism, but an
					<SPAN CLASS="bold">architectural technique</SPAN> that plays
					a key role (along with information hiding, which it extends,
					and Design by Contract&#153, to which it is linked through
					the assertion redefinition rules seen below) in providing the
					modular system architectures of Eiffel, the basis for the method's
					approach to reusability and extendibility. These properties apply
					as early as analysis and modeling, and continue to be useful
					throughout the subsequent steps.</P>

					<A NAME="41757"></A><H2>Deferred features and classes</H2>

					<P>The examples of dynamic binding seen so far assumed that
					all classes were fully implemented, and dynamically bound
					features had a version in every relevant class, including
					the most general ones such as
					<SPAN CLASS="eclass">ACCOUNT</SPAN>.</P>

					<P>It is also useful to define classes that leave the
					implementation of some of their features entirely to proper
					descendants. Such an abstract class is known as
					<SPAN CLASS="ekeyword">deferred</SPAN>; so are its
					unimplemented features. The reverse of deferred is
					<SPAN CLASS="ekeyword">effective</SPAN>, meaning fully
					implemented.</P>

					<P><SPAN CLASS="eclass">LIST</SPAN> is a typical example of
					deferred class. As it describes the general notion of list,
					it should not favor any particular implementation; that will
					be the task of its effective descendants, such as
					<SPAN CLASS="eclass">LINKED_LIST</SPAN> (linked
					implementation), <SPAN CLASS="eclass">TWO_WAY_LIST</SPAN>
					(linked both ways), <SPAN CLASS="eclass">ARRAYED_LIST</SPAN>
					(implementation by an array), all effective, and all indeed
					to be found in EiffelBase.</P>

					<P>At the level of the deferred class
					<SPAN CLASS="eclass">LIST</SPAN>, some features such as
					<SPAN CLASS="efeature">extend</SPAN> (add an item at the end
					of the list) will have no implementation and hence will be
					declared as deferred. Here is the corresponding form,
					illustrating the syntax for both deferred classes and their
					deferred features:</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">indexing</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eitag">description:</SPAN>
						<SPAN CLASS="estring">&quot;Sequential finite lists, without
						a commitment to a representation&quot;</SPAN></P>

						<P><SPAN CLASS="ekeyword">deferred class</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eclass">LIST</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="egeneric">G</SPAN><SPAN CLASS="esymbol">]</SPAN>
						</P>

						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="ecomment">-- Access</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">count</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Number of items in list</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						&#8230; See below; this feature can be effective &#8230;</P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="ecomment">-- Element change</SPAN></P>

						<P>&nbsp;&nbsp;<SPAN CLASS="efeature">extend</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="egeneric">G</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Add <SPAN CLASS="elocal">x</SPAN> at end of list.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">require</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">space_available</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="efeature">not</SPAN> <SPAN CLASS="efeature">full</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">deferred</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">ensure</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">one_more</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="efeature">count</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="ekeyword">old</SPAN> <SPAN CLASS="efeature">count</SPAN>
						<SPAN CLASS="esymbol">+</SPAN> <SPAN CLASS="enumber">1</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN>

						<P>&#8230; Other feature declarations and invariant &#8230;</P>

						<P><SPAN CLASS="ekeyword">end</SPAN>
						<SPAN CLASS="ecomment">-- class</SPAN>
						<SPAN CLASS="eclass">LIST</SPAN></P>
					</CODE>

					<P>A deferred feature (considered to be a routine, although
					it can yield an attribute in a proper descendant) has the
					single keyword <SPAN CLASS="ekeyword">deferred</SPAN> in
					lieu of the <SPAN CLASS="ekeyword">do</SPAN>
					<SPAN CLASS="efeature">Instructions</SPAN> clause of an
					effective routine. A deferred class -- defined as a class
					that has at least one deferred feature -- must be introduced
					by <SPAN CLASS="ekeyword">deferred class</SPAN> instead of
					just <SPAN CLASS="ekeyword">class</SPAN>.</P>

					<P>As the example of <SPAN CLASS="efeature">extend</SPAN>
					shows, a deferred feature, although it has no implementation,
					can be equipped with assertions. They will be binding on
					implementations in descendants, in a way to be explained
					below.</P>

					<P>Deferred classes do not have to be
					<SPAN CLASS="italics">fully</SPAN> deferred. They may contain
					some effective features along with their deferred ones. Here,
					for example, we may express
					<SPAN CLASS="efaeture">count</SPAN> as a function:</P>

					<CODE>
						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">count</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Number of items in list</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">from</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">start</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">until</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">after</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">loop</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">Result</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="ekeyword">Result</SPAN>
						<SPAN CLASS="efeature">+</SPAN>
						<SPAN CLASS="enumber">1</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">forth</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>


					<P>This implementation relies on the loop construct
					described below (<SPAN CLASS="ekeyword">from</SPAN>
					introduces the loop initialization) and on a set of
					deferred features of the class which allow traversal
					of a list based on moving a fictitious cursor:
					<SPAN CLASS="ekeyword">start</SPAN> to bring the
					cursor to the first element if any,
					<SPAN CLASS="ekeyword">after</SPAN> to find out
					whether all relevant elements have been seen, and
					<SPAN CLASS="ekeyword">forth</SPAN> (with precondition
					<SPAN CLASS="efeature">not</SPAN>
					<SPAN CLASS="efeature">after</SPAN>) to advance the cursor
					to the next element. Procedure
					<SPAN CLASS="efeature">forth</SPAN> itself appears as</P>

					<CODE>
						<P><P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">forth</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Advance cursor by one position</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">require</SPAN>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">not_after</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="efeature">not</SPAN> <SPAN CLASS="efeature">after</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">deferred</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">ensure</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">moved_right</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="efeature">index</SPAN> <SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="ekeyword">old</SPAN> <SPAN CLASS="efeature">index</SPAN>
						<SPAN CLASS="esymbol">+</SPAN> <SPAN CLASS="enumber">1</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>where <SPAN CLASS="feature">index</SPAN> -- another
					deferred feature -- is the integer position of the cursor.</P>

					<P>Although the above version of feature
					<SPAN CLASS="efeature">count</SPAN> is time-consuming --
					it implies a whole traversal just for the purpose of
					determining the number of elements -- it has the advantage
					of being applicable to all variants, without any commitment
					to a choice of implementation, as would follow for example
					if we decided to treat <SPAN CLASS="efeature">count</SPAN>
					as an attribute. Proper descendants can always redefine
					<SPAN CLASS="efeature">count</SPAN> for more efficiency.</P>

					<P>Function <SPAN CLASS="efeature">count</SPAN> illustrates
					one of the most important contributions of the method to
					reusability: the ability to define
					<SPAN CLASS="bold">behavior classes</SPAN> that capture
					common behaviors (such as <SPAN CLASS="efeature">count</SPAN>) while leaving the details
					of the behaviors (such as <SPAN CLASS="efeature">start</SPAN>,
					<SPAN CLASS="efeature">after</SPAN>,
					<SPAN CLASS="efeature">forth</SPAN>) open to many variants.
					As noted earlier, traditional approaches to reusability
					provide closed reusable components. A component such as
					<SPAN CLASS="eclass">LIST</SPAN>, although equipped with
					directly usable behaviors such as <SPAN CLASS="efeature">count</SPAN>, is open to many
					variations, to be provided by proper descendants.</P>

					<P CLASS=note>Some O-O languages support only the two
					extremes: fully effective classes, and fully deferred
					&quot;interfaces&quot;, but not classes with a mix of
					effective and deferred features. This is an unacceptable
					limitation, negating the object-oriented method's support
					for a seamless, continuous spectrum from the most abstract
					to the most concrete.</P>

					<P>A class <SPAN CLASS="eclass">B</SPAN> inheriting from a
					deferred class <SPAN CLASS="eclass">A</SPAN> may provide
					implementations -- effective declarations -- for the features
					inherited in deferred form. In this case there is no need for
					a <SPAN CLASS="ekeyword">redefine</SPAN> subclause; the
					effective versions simply replace the inherited versions. The
					class is said to <SPAN CLASS="ekeyword">effect</SPAN> the
					corresponding features. If after this process there remain any
					deferred features, B is still considered deferred, even if it
					introduces no deferred features of its own, and must be
					declared as <SPAN CLASS="ekeyword">deferred class</SPAN>.</P>

					<P>In the example, classes such as
					<SPAN CLASS="eclass">LINKED_LIST</SPAN> and
					<SPAN CLASS="eclass">ARRAYED_LIST</SPAN> will effect all the
					deferred features they inherit from
					<SPAN CLASS="eclass">LIST</SPAN> --
					<SPAN CLASS="efeature">extend</SPAN>,
					<SPAN CLASS="efeature">start</SPAN> etc. -- and hence will be
					effective.</P>

					<P>Except in some applications restricted to pure system
					modeling -- as discussed next -- the main benefit of
					deferred classes and features comes from polymorphism and
					dynamic binding. Because <SPAN CLASS="efeature">extend</SPAN>
					has no implementation in class
					<SPAN CLASS="eclass">LIST</SPAN>, a call of the form
					<SPAN CLASS="elocal">my_list</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">extend</SPAN>
					<SPAN CLASS="esymbol">(</SPAN>&#8230;<SPAN CLASS="esymbol">)</SPAN>
					with my_list of type
					<SPAN CLASS="eclass">LIST [T]</SPAN> for some
					<SPAN CLASS="eclass">T</SPAN> can only be executed if
					<SPAN CLASS="elocal">my_list</SPAN> is attached to a direct
					instance of an effective proper descendant of
					<SPAN CLASS="eclass">LIST</SPAN>, such as
					<SPAN CLASS="eclass">LINKED_LIST</SPAN>; then it will use the
					corresponding version of <SPAN CLASS="efeature">extend</SPAN>.
					Static binding would not even make sense here.</P>

					<P>Even an effective feature of <SPAN CLASS="eclass">LIST</SPAN>
					such as count may depend on deferred features (<SPAN CLASS="efeature">start</SPAN> and so on),
					so that a call of the form
					<SPAN CLASS="elocal">my_list</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">count</SPAN>
					can only be executed in the context of an effective descendant.</P>

					<P>All this indicates that a deferred class must have
					<SPAN CLASS="bold">no direct instance</SPAN>. (It will have
					instances, the direct instances of its effective descendants.)
					If it had any, we could call deferred features on them,
					leading to execution-time impossibility. The rule that
					achieves this goal is simple: if the base type of
					<SPAN CLASS="elocal">x</SPAN> is a deferred class, no creation
					instruction of target <SPAN CLASS="elocal">x</SPAN>, of the
					form <SPAN CLASS="ekeyword">create</SPAN>
					<SPAN CLASS="elocal">x</SPAN>&#8230;, is permitted.</P>

					<H2><A NAME="48949"></A>Applications of deferred classes</H2>

					<P>Deferred classes cover abstract notions with many possible
					variants. They are widely used in Eiffel where they cover
					various needs:</P>

					<UL>
						<LI>Capturing high-level classes, with common behaviors.</LI>
						<LI>Defining the higher levels of a general taxonomy,
						especially in the inheritance structure of a library.</LI>
						<LI>Defining the components of an architecture during
						system design, without commitment to a final implementation.</LI>
						<LI>Describing domain-specific concepts in analysis and modeling.</LI>
					</UL>

					<P>These applications make deferred classes a central tool of
					the Eiffel method's support for seamlessness and
					reversibility. The last one in particular uses deferred
					classes and features to model objects from an application
					domain, without any commitment to implementation, design, or
					even software (and computers). Deferred classes are the ideal
					tool here: they express the properties of the domain's
					abstractions, without any temptation of implementation bias,
					yet with the precision afforded by type declarations,
					inheritance structures (to record classifications of the domain
					concepts), and contracts to express the abstract properties of
					the objects being described.</P>

					<P>Rather than using a separate method and notation for
					analysis and design, this apprroach integrates seamlessly
					with the subsequent phases (assuming the decision is indeed
					taken to develop a software system): it suffices to refine
					the deferred classes progressively by introducing effective
					elements, either by modifying the classes themselves, or by
					introducing design- and implementation-oriented descendants.
					In the resulting system, the classes that played an important
					role for analysis, and are the most meaningful for customers,
					will remain important; as we have seen
					(<A HREF="tutorial-04.html#24218">&quot;Seamlessness and reversibility&quot;</A>)
					this <SPAN CLASS="italics">direct mapping</SPAN> property
					is a great help for extendibility.</P>

					<P>The following sketch (from the book
					<A HREF="http://eiffel.com/doc/oosc/">Object-Oriented Software Construction</A>)
					illustrates these ideas on the example of scheduling the
					programs of a TV station. This is pure modeling of an
					application domain; no computers or software are involved yet.
					The class describes the notion of program segment.</P>

					<P>Note the use of assertions to define semantic properties
					of the class, its instances and its features. Although often
					presented as high-level, most object-oriented analysis methods
					(with the exception of Wald&eacute;n's and Nerson's Business
					Object Notation) have no support for the expression of such
					properties, limiting themselves instead to the description of
					broad structural relationships.</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">indexing</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eitag">description:</SPAN>
						<SPAN CLASS="estring">&quot;Individual fragments of a broadcasting schedule&quot;</SPAN>
						</P>

						<P><SPAN CLASS="ekeyword">deferred class</SPAN></P>

						<P><SPAN CLASS="eclass">&nbsp;&nbsp;&nbsp;SEGMENT</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="ecomment">-- Access</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">schedule</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">SCHEDULE</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">deferred</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Schedule to which segment belongs</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">index</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">deferred</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Position of segment in its schedule</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">starting_time</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="efeature">ending_time</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">deferred</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Beginning and end of scheduled air time</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">next</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">SEGMENT</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">deferred</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Segment to be played next, if any</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">sponsor</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">COMPANY</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">deferred</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Segment's principal sponsor</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">rating</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">deferred</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Segment's rating (for children's viewing etc.)</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">Minimum_duration</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN> <SPAN CLASS="enumber">30</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Minimum length of segments, in seconds</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">Maximum_interval</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">INTEGER</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN> <SPAN CLASS="enumber">2</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Maximum time (seconds) between successive segments</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="ecomment">-- Element change</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">set_sponsor</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">s</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">SPONSOR</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">require</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">not_void</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="elocal">s</SPAN>
						<SPAN CLASS="esymbol">/=</SPAN> <SPAN CLASS="efeature">Void</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">deferred</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">ensure</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">sponsor_set</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="efeature">sponsor</SPAN> <SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="elocal">s</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ecomment">&#8230;</SPAN>
						<SPAN CLASS="efeature">change_next</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="efeature">set_rating</SPAN>
						<SPAN CLASS="ecomment">omitted</SPAN>
						<SPAN CLASS="ecomment">&#8230;</SPAN></P>

						<P><SPAN CLASS="ekeyword">invariant</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eitag">in_list</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="enumber">1</SPAN>
						<SPAN CLASS="esymbol">&lt;=</SPAN>
						<SPAN CLASS="efeature">index</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">and</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">index</SPAN>
						<SPAN CLASS="esymbol">&lt;=</SPAN>
						<SPAN CLASS="efeature">schedule</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">segments</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">count</SPAN><SPAN CLASS="esymbol">)</SPAN>
						</P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eitag">in_schedule</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="efeature">schedule</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">segments</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">item</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">index</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="esymbol">=</SPAN> <SPAN CLASS="ekeyword">Current</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eitag">next_in_list</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">next</SPAN>
						<SPAN CLASS="esymbol">/=</SPAN>
						<SPAN CLASS="efeature">Void</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">implies</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">schedule</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">segments</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">item</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">index</SPAN>
						<SPAN CLASS="esymbol">+</SPAN>
						<SPAN CLASS="enumber">1</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="efeature">next</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eitag">no_next_iff_last</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">next</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="efeature">Void</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">index</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="efeature">schedule</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">segments</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">count</SPAN><SPAN CLASS="esymbol">)</SPAN>
						</P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eitag">non_negative_rating</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="efeature">rating</SPAN> <SPAN CLASS="esymbol">&gt;=</SPAN>
						<SPAN CLASS="enumber">0</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eitag">positive times</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">starting_time</SPAN>
						<SPAN CLASS="efeature">&gt;</SPAN>
						<SPAN CLASS="enumber">0</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">and</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">ending_time</SPAN>
						<SPAN CLASS="efeature">&gt;</SPAN>
						<SPAN CLASS="enumber">0</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eitag">sufficient_duration</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="efeature">ending_time</SPAN>
						<SPAN CLASS="esymbol">-</SPAN>
						<SPAN CLASS="efeature">starting_time</SPAN>
						<SPAN CLASS="esymbol">&gt;=</SPAN>
						<SPAN CLASS="efeature">Minimum_duration</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eitag">decent_interval</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">next</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">starting_time</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="esymbol">-</SPAN>
						<SPAN CLASS="efeature">ending_time</SPAN>
						<SPAN CLASS="esymbol">&lt;=</SPAN>
						<SPAN CLASS="efeature">Maximum_interval</SPAN></P>

						<P><SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<A NAME="46202"></A><H2>Structural property classes</H2>

					<P>Some deferred classes describe a structural property,
					useful to the description of many other classes. Typical
					examples are classes of the Kernel Library in EiffelBase:</P>

					<UL>
						<LI><SPAN CLASS="eclass">NUMERIC</SPAN> describes objects
						on which arithmetic operations +, -, x, / are
						available, with the properties of a ring (associativity,
						distributivity, zero elements etc.). Kernel Library
						classes such as <SPAN CLASS="eclass">INTEGER</SPAN> and
						<SPAN CLASS="eclass">REAL</SPAN> -- but not, for example,
						<SPAN CLASS="eclass">STRING</SPAN> -- are descendants of
						<SPAN CLASS="eclass">NUMERIC</SPAN>. An application that
						defines a class <SPAN CLASS="eclass">MATRIX</SPAN> may
						also make it a descendant of
						<SPAN CLASS="eclass">NUMERIC</SPAN>.</LI>

						<LI><SPAN CLASS="eclass">COMPARABLE</SPAN> describes
						objects on which comparison operations &lt;, &lt;=,
						&gt;, &gt;= are available, with the properties of a total
						preorder (transitivity, irreflexivity). Kernel Library
						classes such as <SPAN CLASS="eclass">CHARACTER</SPAN>,
						<SPAN CLASS="eclass">STRING</SPAN> and
						<SPAN CLASS="eclass">INTEGER</SPAN> -- but not our
						<SPAN CLASS="eclass">MATRIX </SPAN> example -- are
						descendants of <SPAN CLASS="eclass">NUMERIC</SPAN>.</LI>
					</UL>

					<P>For such classes it is again essential to permit effective
					features in a deferred class, and to include assertions. For
					example class <SPAN CLASS="eclass">COMPARABLE</SPAN> declares
					<SPAN CLASS="ekeyword">infix</SPAN>
					<SPAN CLASS="esymbol">&quot;</SPAN><SPAN CLASS="efeature">&lt;</SPAN><SPAN CLASS="esymbol">&quot;</SPAN>
					as deferred, and expresses
					<SPAN CLASS="efeature">&gt;</SPAN>,
					<SPAN CLASS="efeature">&gt;=</SPAN> and
					<SPAN CLASS="efeature">&lt;=</SPAN> effectively in terms of it.</P>

					<P CLASS=note>The type <SPAN CLASS="ekeyword">like</SPAN>
					<SPAN CLASS="ekeyword">Current</SPAN> will be explained in
					<A HREF="tutorial-10.html#46019">&quot;Covariance and anchored declarations&quot;</A>;
					you may understand it, in the following class, as equivalent
					to <SPAN CLASS="eclass">COMPARABLE</SPAN>.</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">indexing</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eitag">description:</SPAN>
						<SPAN CLASS="estring">&quot;Objects that can be compared according to a total preorder relation&quot;</SPAN>
						</P>

						<P><SPAN CLASS="ekeyword">deferred class</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">COMPARABLE</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN>
						<SPAN CLASS="ecomment">-- Comparison</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">infix</SPAN>
						<SPAN CLASS="esymbol">&quot;</SPAN><SPAN CLASS="efeature">&lt;</SPAN><SPAN CLASS="esymbol">&quot;</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">other</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="ekeyword">like</SPAN>
						<SPAN CLASS="ekeyword">Current</SPAN><SPAN CLASS="esymbol">):</SPAN>
						<SPAN CLASS="eclass">BOOLEAN</SPAN> <SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Is current object less than <SPAN CLASS="elocal">other</SPAN>?</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">require</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">other_exists</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="elocal">other</SPAN>
						<SPAN CLASS="esymbol">/=</SPAN>
						<SPAN CLASS="efeature">Void</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">deferred</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">ensure</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">asymmetric</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="ekeyword">Result</SPAN>
						<SPAN CLASS="ekeyword">implies</SPAN>
						<SPAN CLASS="efeature">not</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">other</SPAN>
						<SPAN CLASS="efeature">&lt;</SPAN>
						<SPAN CLASS="ekeyword">Current</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">infix</SPAN>
						<SPAN CLASS="esymbol">&quot;</SPAN><SPAN CLASS="efeature">&lt;=</SPAN><SPAN CLASS="esymbol">&quot;</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">other</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="ekeyword">like</SPAN>
						<SPAN CLASS="ekeyword">Current</SPAN><SPAN CLASS="esymbol">):</SPAN>
						<SPAN CLASS="eclass">BOOLEAN</SPAN> <SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Is current object less than or equal to <SPAN CLASS="elocal">other</SPAN>?</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">require</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">other_exists</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="elocal">other</SPAN>
						<SPAN CLASS="esymbol">/=</SPAN>
						<SPAN CLASS="efeature">Void</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">Result</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">Current</SPAN>
						<SPAN CLASS="efeature">&lt;</SPAN>
						<SPAN CLASS="elocal">other</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">or</SPAN>
						<SPAN CLASS="efeature">is_equal</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">other</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">ensure</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">definition</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="ekeyword">Result</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">Current</SPAN>
						<SPAN CLASS="efeature">&lt;</SPAN>
						<SPAN CLASS="elocal">other</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">or</SPAN>
						<SPAN CLASS="efeature">is_equal</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">other</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&#8230;<SPAN CLASS="ecomment">Other features:</SPAN>
						<SPAN CLASS="ekeyword">infix</SPAN>
						<SPAN CLASS="esymbol">&quot;</SPAN><SPAN CLASS="efeature">&gt;</SPAN><SPAN CLASS="esymbol">&quot;</SPAN>						 <SPAN CLASS="efeature">min</SPAN><SPAN CLASS="esymbol">,</SPAN>
						 <SPAN CLASS="efeature">max</SPAN><SPAN CLASS="esymbol">,</SPAN>
						 &#8230;</P>

						<P><SPAN CLASS="ekeyword">invariant</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eitag">irreflexive</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="efeature">not</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="ekeyword">Current</SPAN>
						<SPAN CLASS="efeature">&lt;</SPAN>
						<SPAN CLASS="ekeyword">Current</SPAN><SPAN CLASS="esymbol">)</SPAN>
						</P>

						<P></A><SPAN CLASS="ekeyword">end</SPAN>
						<SPAN CLASS="ecomment"> -- class</SPAN>
						<SPAN CLASS="eclass">COMPARABLE</SPAN></P>
					</CODE>

					<H2><A NAME="pgfId-515346"></A><A NAME="21906"></A>Multiple inheritance and renaming</H2>

					<P>It is often necessary to define a new class in terms of
					several existing ones. For example:</P>

					<UL>
						<LI>The Kernel Library classes
						<SPAN CLASS="eclass">INTEGER</SPAN> and
						<SPAN CLASS="eclass">REAL</SPAN> must inherit from both
						<SPAN CLASS="eclass">NUMERIC</SPAN> and
						<SPAN CLASS="eclass">COMPARABLE</SPAN>.</LI>

						<LI>A class <SPAN CLASS="eclass">TENNIS_PLAYER</SPAN>,
						in a system for keeping track of player ranking, will
						inherit from <SPAN CLASS="eclass">COMPARABLE</SPAN>, as
						well as from other domain-specific classes.</LI>

						<LI>A class <SPAN CLASS="eclass">COMPANY_PLANE</SPAN>
						may inherit from both <SPAN CLASS="eclass">PLANE</SPAN>
						and <SPAN CLASS="eclass">ASSET</SPAN>.</LI>

						<LI>Class <SPAN CLASS="eclass">ARRAYED_LIST</SPAN>,
						describing an implementation of lists through arrays,
						may inherit from both <SPAN CLASS="eclass">LIST</SPAN>
						and <SPAN CLASS="eclass">ARRAY</SPAN>.</LI>
					</UL>

					<P>In all such cases multiple inheritance provides the
					answer.</P>

					<P>Multiple inheritance can cause
					<SPAN CLASS="bold">name clashes</SPAN>: two parents may
					include a feature with the same name. This would conflict
					with the ban on name overloading within a class -- the rule
					that no two features of a class may have the same name.
					Eiffel provides a simple way to remove the name clash at the
					point of inheritance through the
					<SPAN CLASS="ekeyword">rename</SPAN> subclause, as in</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">indexing</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eitag">description:</SPAN>
						<SPAN CLASS="estring">&quot;Sequential finite lists implemented as arrays&quot;</SPAN></P>

						<P><SPAN CLASS="ekeyword">class</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eclass">ARRAYED_LIST</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="egeneric">G</SPAN><SPAN CLASS="esymbol">]</SPAN>
						</P>

						<P><SPAN CLASS="ekeyword">inherit</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eclass">LIST</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="egeneric">G</SPAN><SPAN CLASS="esymbol">]</SPAN>
						</P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="eclass">ARRAY</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="egeneric">G</SPAN><SPAN CLASS="esymbol">]</SPAN>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">rename</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">count</SPAN>
						<SPAN CLASS="ekeyword">as</SPAN>
						<SPAN CLASS="efeature">capacity</SPAN><SPAN CLASS="esymbol">,</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">item</SPAN>
						<SPAN CLASS="ekeyword">as</SPAN>
						<SPAN CLASS="efeature">array_item</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&#8230;</P>

						<P><SPAN CLASS="ekeyword">end</SPAN>
						<SPAN CLASS="ecomment">-- clas</SPAN>
						<SPAN CLASS="eclass">ARRAYED_LIST</SPAN></P>
					</CODE>

					<P>Here both <SPAN CLASS="eclass">LIST</SPAN> and
					<SPAN CLASS="eclass">ARRAY</SPAN> have features called
					<SPAN CLASS="efeature">count</SPAN> and
					<SPAN CLASS="efeature">item</SPAN>. To make the new class
					valid, we give new names to the features inherited from
					<SPAN CLASS="eclass">ARRAY</SPAN>, which will be known
					within <SPAN CLASS="eclass">ARRAYED_LIST</SPAN> as
					<SPAN CLASS="efeature">capacity</SPAN> and
					<SPAN CLASS="efeature">array_item</SPAN>. Of course we
					could have renamed the <SPAN CLASS="eclass">LIST</SPAN>
					versions instead, or renamed along both inheritance branches.</P>

					<P>Every feature of a class has a
					<SPAN CLASS="bold">final name</SPAN>: for a feature
					introduced in the class itself (&quot;immediate&quot;
					feature) it is the name appearing in the declaration; for
					an inherited feature that is not renamed, it is the feature's
					name in the parent; for a renamed feature, it is the name
					resulting from the renaming. This definition yields a precise
					statement of the rule against in-class overloading:</P>

					<P CLASS="tip"><SPAN CLASS="bold">Final Name rule</SPAN><BR />
					Two different features of a class may not have the same final name.</P>

					<P>It is interesting to compare renaming and redefinition.
					The principal distinction is between features and feature
					names. Renaming keeps a feature, but changes its name.
					Redefinition keeps the name, but changes the feature. In
					some cases, it is of course appropriate to do both.</P>

					<P>Renaming is interesting even in the absence of name
					clashes. A class may inherit from a parent a feature which
					it finds useful for its purposes, but whose name, appropriate
					for the context of the parent, is not consistent with the
					context of the heir. This is the case with
					<SPAN CLASS="eclass">ARRAY</SPAN>'s feature
					<SPAN CLASS="feature">count</SPAN> in the last example: the
					feature that defines the number of items in an array -- the
					total number of available entries -- becomes, for an arrayed
					list, the <SPAN CLASS="italics">maximum</SPAN> number of list
					items; the truly interesting indication of the number of
					items is the count of how many items have been inserted in
					the list, as given by feature
					<SPAN CLASS="efeature">count</SPAN> from
					<SPAN CLASS="eclass">LIST</SPAN>. But even if we did not have
					a name clash because of the two inherited
					<SPAN CLASS="efeature">count</SPAN> features we should rename
					<SPAN CLASS="eclass">ARRAY</SPAN>'s
					<SPAN CLASS="efeature">count</SPAN> as
					<SPAN CLASS="efeature">capacity</SPAN> to maintain the
					consistency of the local feature terminology.</P>

					<P>The <SPAN CLASS="ekeyword">rename</SPAN> subclause appears
					before all the other feature adaptation subclauses --
					<SPAN CLASS="ekeyword">redefine</SPAN> already seen, and the
					remaining ones <SPAN CLASS="ekeyword">export</SPAN>,
					<SPAN CLASS="ekeyword">undefine</SPAN> and
					<SPAN CLASS="ekeyword">select</SPAN> -- since an inherited
					feature that has been renamed sheds its earlier identity once
					and for all: within the class, and to its own clients and
					descendants, it will be known solely through the new name.
					The original name has simply disappeared from the name space.
					This is essential to the view of classes presented earlier:
					self-contained, consistent abstractions prepared carefully
					for the greatest enjoyment of clients and descendants.</P>

					<H2><A NAME="83610"></A>Inheritance and contracts</H2>

					<P>A proper understanding of inheritance requires looking at
					the mechanism in the framework of Design by Contract&#153,
					where it will appear as a form of
					<SPAN CLASS="italics">subcontracting</SPAN>.</P>

					<P>The first rule is that invariants accumulate down an
					inheritance structure:</P>

					<P CLASS="tip"><SPAN CLASS="bold">Invariant Accumulation rule</SPAN><BR />
					The invariants of all the parents of a class apply to the
					class itself.</P>

					<P>The invariant of a class is automatically considered to
					include -- in the sense of logical &quot;and&quot; -- the
					invariants of all its parents. This is a consequence of the
					view of inheritance as an &quot;is&quot; relation: if we may
					consider every instance of <SPAN CLASS=eclass>B</SPAN> as an
					instance of <SPAN CLASS="eclass">A</SPAN>, then every
					consistency constraint on instances of
					<SPAN CLASS="eclass">A</SPAN> must also apply to instances of
					<SPAN CLASS="eclass">B</SPAN>.</P>

					<P>Next we consider routine preconditions and postconditions.
					The rule here will follow from an examination of what
					contracts mean in the presence of polymorphism and dynamic
					binding.</P>

					<P>Consider a parent <SPAN CLASS="eclass">A</SPAN> and a
					proper descendant <SPAN CLASS="eclass">B</SPAN> (a direct
					heir on the following figure), which redefines a routine
					<SPAN CLASS="efeature">r</SPAN> inherited from
					<SPAN CLASS="eclass">A</SPAN>.</P>

					<IMG SRC="tutorial-12.png">

					<P>As a result of dynamic binding, a call
					<SPAN CLASS="elocal">a1</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">r</SPAN>
					from a client <SPAN CLASS="eclass">C</SPAN> may be serviced
					not by <SPAN CLASS="eclass">A</SPAN>'s version of
					<SPAN CLASS="efeature">r</SPAN> but by
					<SPAN CLASS="eclass">B</SPAN>'s version if
					<SPAN CLASS="elocal">a1</SPAN>, although declared of type
					<SPAN CLASS="elocal">A</SPAN>, becomes at run time attached
					to an instance of <SPAN CLASS="eclass">B</SPAN>. This shows
					the combination of inheritance, redefinition, polymorphism
					and dynamic binding as providing a form of subcontracting;
					<SPAN CLASS="eclass">A</SPAN> subcontracts certain calls to
					<SPAN CLASS="eclass">B</SPAN>.</P>

					<P>The problem is to keep subcontractors honest. Assuming
					preconditions and postconditions as shown on the last figure,
					a call in <SPAN CLASS="eclass">C</SPAN> of the form</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">if</SPAN>
						<SPAN CLASS="elocal">a1</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">pre</SPAN>
						<SPAN CLASS="ekeyword">then</SPAN>
						<SPAN CLASS="elocal">a1</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">r</SPAN>
						<SPAN CLASS="ekeyword">end</SPAN>
					</CODE>

					<P>or just</P>

					<CODE>
						<P><SPAN CLASS="elocal">a1</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">q</SPAN><SPAN CLASS="esymbol">;</SPAN>
						<SPAN CLASS="elocal">a1</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">r</SPAN></P>
					</CODE>

					<P>where the postcondition of <SPAN CLASS="efeature">q</SPAN>
					implies the precondition <SPAN CLASS="efeature">pre</SPAN> of
					<SPAN CLASS="efeature">r</SPAN>, satisfies the terms of the
					contract and hence is entitled to being handled correctly --
					to terminate in a state satisfying
					<SPAN CLASS="elocal">a1</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">post</SPAN>.
					But if we let the subcontractor <SPAN CLASS="eclass">B</SPAN>
					redefine the assertions to arbitrary
					<SPAN CLASS="efeature">pre'</SPAN>
					<SPAN CLASS="ekeyword">and</SPAN>
					<SPAN CLASS="efeature">post'</SPAN>, this is not necessarily
					the case: <SPAN CLASS="efeature">pre'</SPAN> could be stronger
					than <SPAN CLASS="efeature">pre</SPAN>, enabling
					<SPAN CLASS="eclass">B</SPAN> not to process correctly certain
					calls that are correct from <SPAN CLASS="eclass">A</SPAN>'s
					perspective; and <SPAN CLASS="efeature">post'</SPAN> could be
					weaker than <SPAN CLASS="efeature">post</SPAN>, enabling
					<SPAN CLASS="eclass">B</SPAN> to do less of a job than
					advertized for <SPAN CLASS="efeature">r</SPAN> in the
					Contract Form of <SPAN CLASS="eclass">A</SPAN>, the only
					official reference for authors of client classes such as
					<SPAN CLASS="eclass">C</SPAN>. (An assertion
					<SPAN CLASS="efeature">p</SPAN> is stronger than or equal to
					an assertion <SPAN CLASS="efeature">q</SPAN> if
					<SPAN CLASS="efeature">p</SPAN> implies
					<SPAN CLASS="efeature">q</SPAN> in the sense of boolean
					implication.)</P>

					<P>The rule, then, is that for the redefinition to be correct
					the new precondition <SPAN CLASS="efeature">pre'</SPAN> must
					be weaker than or equal to the original
					<SPAN CLASS="efeature">pre</SPAN>, and the new postcondition
					<SPAN CLASS="efeature">post'</SPAN> must be stronger than or
					equal to the original <SPAN CLASS="efeature">post'</SPAN>.</P>

					<P>Because it is impossible to check simply that an assertion
					is weaker or stronger than another, the language rule relies
					on different forms of the assertion constructs,
					<SPAN CLASS="ekeyword">require else</SPAN> and
					<SPAN CLASS="ekeyword">ensure then</SPAN>, for redeclared
					routines. They rely on the mathematical property that, for
					any assertions <SPAN CLASS="efeature">p</SPAN> and
					<SPAN CLASS="efeature">q</SPAN>,
					<SPAN CLASS="efeature">p</SPAN>
					<SPAN CLASS="ekeyword">implies</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">p</SPAN>
					<SPAN CLASS="ekeyword">or</SPAN>
					<SPAN CLASS="efeature">q</SPAN><SPAN CLASS="esymbol">)</SPAN>,
					and
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">p</SPAN>
					<SPAN CLASS="ekeyword">and</SPAN>
					<SPAN CLASS="efeature">q</SPAN><SPAN CLASS="esymbol">)</SPAN>
					<SPAN CLASS="ekeyword">implies</SPAN>
					<SPAN CLASS="efeature">p</SPAN>.
					For a precondition, using
					<SPAN CLASS="ekeyword">require else</SPAN> with a new
					assertion will perform an <SPAN CLASS="ekeyword">or</SPAN>,
					which can only weaken the original; for a postcondition,
					<SPAN CLASS="ekeyword">ensure then</SPAN> will perform an
					<SPAN CLASS="ekeyword">and</SPAN>, which can only
					strengthen the original. Hence the rule:</P>

					<P CLASS="tip"><SPAN CLASS="bold">Assertion Redeclaration rule</SPAN><BR />
					In the redeclared version of a routine, it is not permitted
					to use a <SPAN CLASS="ekeyword">require</SPAN>
					or <SPAN CLASS="ekeyword">ensure</SPAN> clause. Instead you
					may:<BR />

					* Introduce a new condition with
					<SPAN CLASS="ekeyword">require else</SPAN>, for or-ing with
					the original precondition.<BR />

					* Introduce a new condition with
					<SPAN CLASS="ekeyword">ensure then</SPAN>, for and-ing with
					the original postcondition.
					</P>

					In the absence of such a clause, the original assertions
					are retained.</P>

					<P>The last case -- retaining the original -- is frequent but
					by no means universal.</P>

					<P>The Assertion Redeclaration rule applies to
					<SPAN CLASS="bold">redeclarations</SPAN>. This terms covers
					not just redefinition but also effecting (the implementation,
					by a class, of a feature that it inherits deferred). The
					rules -- not just for assertions but also, as reviewed below,
					for typing -- are indeed the same in both cases. Without the
					Assertion Redeclaration rule, assertions on deferred
					features, such as those on
					<SPAN CLASS="efeature">extend</SPAN>,
					<SPAN CLASS="efeature">count</SPAN> and
					<SPAN CLASS="efeature">forth</SPAN> in
					<A HREF="tutorial-10.html#41757">&quot;Deferred features and classes&quot;</A>,
					would be almost useless -- wishful thinking; the rule makes
					them binding on all effectings in descendants.</P>

					<P>From the Assertion Redeclaration rule follows an
					interesting technique:
					<SPAN CLASS="bold">abstract preconditions</SPAN>. What needs
					to be weakened for a precondition (or strengthened for a
					postcondition) is not the assertion's concrete semantics but
					its abstract specification as seen by the client. A
					descendant can change the
					<SPAN CLASS="italics">implementation</SPAN> of that
					specification as it pleases, even to the effect of
					strengthening the concrete precondition, as long as the
					abstract form is kept or weakened. The precondition of
					procedure <SPAN CLASS="efeature">extend</SPAN> in the
					deferred class <SPAN CLASS="eclass">LIST</SPAN> provided an
					example. We wrote the routine as</P>

					<CODE>
						<P>&nbsp;&nbsp;
						<SPAN CLASS="efeature">extend</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="egeneric">G</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Add <SPAN CLASS="elocal">x</SPAN> at end of list.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">require</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">space_available:</SPAN>
						<SPAN CLASS="efeature">not full</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">deferred</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">ensure</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">one_more:</SPAN>
						<SPAN CLASS="efeature">count</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="ekeyword">old</SPAN>
						<SPAN CLASS="efeature">count</SPAN>
						<SPAN CLASS="esymbol">+</SPAN>
						<SPAN CLASS="enumber">1</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>The precondition expresses that it is only possible to
					add an item to a list if the representation is not full. We
					may well consider -- in line with the Eiffel principle that
					whenever possible structures should be of unbounded capacity
					-- that <SPAN CLASS="eclass">LIST </SPAN> should by default
					make <SPAN CLASS="efeature">full</SPAN> always return false:</P>

					<CODE>
						<P><SPAN CLASS="efeature">full</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">BOOLEAN</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Is representation full?</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- (Default: no)</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">Result</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="efeature">False</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>Now a class <SPAN CLASS="eclass">BOUNDED_LIST</SPAN> that
					implements bounded-size lists (inheriting, like the earlier
					<SPAN CLASS="eclass">ARRAYED_LIST</SPAN>, from both
					<SPAN CLASS="eclass">LIST</SPAN> and
					<SPAN CLASS="eclass">ARRAY</SPAN>) may redefine
					<SPAN CLASS="efeature">full</SPAN>:</P>

					<CODE>
						<P><SPAN CLASS="efeature">full</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">BOOLEAN</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Is representation full?</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- (Answer: if and only if number
						of items is <SPAN CLASS="efeature">capacity</SPAN>)</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">Result</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="efeature">count</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="efeature">capacity</SPAN><SPAN CLASS="esymbol">)</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>Procedure <SPAN CLASS="efeature">extend</SPAN> remains
					applicable as before; any client that used it properly with
					<SPAN CLASS="eclass">LIST</SPAN> can rely polymorphically on
					the <SPAN CLASS="eclass">FIXED_LIST</SPAN> implementation.
					The abstract precondition of
					<SPAN CLASS="efeature">extend</SPAN> has not changed, even
					though the concrete implementation of that precondition has
					in fact been strengthened.</P>

					<P>Note that a class such as
					<SPAN CLASS="eclass">BOUNDED_LIST</SPAN>, the likes of which
					indeed appear in EiffelBase, is not a violation of the Eiffel
					advice to stay away from fixed-size structures. The
					corresponding structures are bounded, but the bounds are
					changeable. Although <SPAN CLASS="efeature">extend</SPAN>
					requires <SPAN CLASS="efeature">not</SPAN>
					<SPAN CLASS="efeature">full</SPAN>, another feature, called
					<SPAN CLASS="efeature">force</SPAN> in all applicable classes,
					will add an element at the appropriate position by resizing
					and reallocating the structure if necessary. Even arrays in
					Eiffel are not fixed-size, and have a procedure
					<SPAN CLASS="efeature">force</SPAN> with no precondition,
					accepting any index position.</P>

					<P>The Assertion Redeclaration rule, together with the
					Invariant Accumulation rule, provides the right
					methodological perspective for understanding inheritance and
					the associated mechanisms. Defining a class as inheriting
					from another is a strong commitment; it means inheriting not
					only the features but the logical constraints. Redeclaring a
					routine is bound by a similar committment: to provide a new
					implementation (or, for an effecting, a first implementation)
					of a previously defined semantics, as expressed by the
					original contract. Usually you have a wide margin for
					choosing your implementation, since the contract only defines
					a range of possible behaviors (rather than just one
					behavior), but you <SPAN CLASS="bold">must</SPAN> remain
					within that range. Otherwise you would be perverting the
					goals of redeclaration, using this mechanism as a sort of
					late-stage hacking to override bugs in ancestor classes.</P>

					<A NAME="61102"></A><H2>Join and uneffecting</H2>

					<P>It is not an error to inherit two deferred features from
					different parents under the same name, provided they have the
					same signature (number and types of arguments and result). In
					that case a process of <SPAN CLASS="bold">feature join</SPAN>
					takes place: the features are merged into just one -- with
					their preconditions and postconditions, if any, respectively
					or-ed and and-ed.</P>

					<P>More generally, it is permitted to have any number of
					deferred features and at most
					<SPAN CLASS="italics">one</SPAN> effective feature that share
					the same name: the effective version, if present will effect
					all the others.</P>

					<P>All this is not a violation of the Final Name rule, since
					the name clashes prohibited by the rule involve two
					<SPAN CLASS="italics">different</SPAN> features having the
					same final name; here the result is just
					<SPAN CLASS="italics">one</SPAN> feature, resulting from the
					join of all the inherited versions.</P>

					<P>Sometimes we may want to join
					<SPAN CLASS="italics">effective</SPAN> features inherited
					from different parents, assuming again the features have
					compatible signatures. One way is to redefine them all into a
					new version; then they again become one feature, with no name
					clash in the sense of the Final Name rule. But in other cases
					we may simply want one of the inherited implementations to
					take over the others. The solution is to revert to the
					preceding case by <SPAN CLASS="bold">uneffecting</SPAN>
					the other features; uneffecting an inherited effective
					feature makes it deferred (this is the reverse of effecting,
					which turns an inherited deferred feature into an effective
					one). The syntax uses the
					<SPAN CLASS="ekeyword">undefine</SPAN> subclause:</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">class</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">D</SPAN></P>

						<P><SPAN CLASS="ekeyword">inherit</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">A</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">rename</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">g</SPAN>
						<SPAN CLASS="ekeyword">as</SPAN>
						<SPAN CLASS="efeature">f</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- <SPAN CLASS="efeature">g</SPAN>
						was effective in <SPAN CLASS="eclass">A</SPAN>.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">undefine</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">f</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">B</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">undefine</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">f</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="EKEYWord">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- <SPAN CLASS="efeature">f</SPAN>
						was effective in <SPAN CLASS="eclass">B</SPAN>.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">C</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- <SPAN CLASS="eclass">C</SPAN>
						also has an effective feature
						<SPAN CLASS="efeature">f</SPAN>, which will serve as</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- implementation for the result
						of the join.</SPAN></P>

						<P><SPAN CLASS="ekeyword">feature</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&#8230;</P>
					</CODE>

					<P>Again what counts, to determine if there is an invalid
					name clash, is the final name of the features. In this
					example to of the joined features were originally called
					<SPAN CLASS="efeature">f</SPAN>; the one from
					<SPAN CLASS="eclass">A</SPAN> was called
					<SPAN CLASS="efeature">g</SPAN>, but in
					<SPAN CLASS="eclass">D</SPAN> it is renamed as
					<SPAN CLASS="efeature">f</SPAN>, so without the undefinition
					it would cause an invalid name clash.</P>

					<P>Feature joining is the most common application of
					uneffecting. In some non-joining cases, however, it may be
					useful to forget the original implementation of a feature and
					let it start a new life devoid of any burden from the past.</P>

					<H2>Changing the export status</H2>

					<P>Another Feature Adaptation subclause,
					<SPAN CLASS="ekeyword">export</SPAN>, makes it possible to
					change the export status of an inherited feature. By default
					-- covering the behavior desired in the vast majority of
					practical cases -- an inherited feature keeps its original
					export status (exported, secret, selectively exported). In
					some cases, however, this is not appropriate:</P>

					<UL>
						<LI>A feature may have played a purely
						implementation-oriented role in the parent, but become
						interesting to clients of the heir. Its status will
						change from secret to exported.</LI>

						<LI>In implementation inheritance (for example
						<SPAN CLASS="eclass">ARRAYED_LIST</SPAN> inheriting from
						<SPAN CLASS="eclass">ARRAY</SPAN>) an exported feature of
						the parent may not be suitable for direct use by clients
						of the heir. The change of status in this case is from
						exported to secret.</LI>
					</UL>

					<P>You can achieve either of these goals by writing</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">class</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">D</SPAN></P>

						<P><SPAN CLASS="ekeyword">inherit</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">A</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">export</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="esymbol">{</SPAN><SPAN CLASS="eclass">X</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="eclass">Y</SPAN><SPAN CLASS="esymbol">,</SPAN>
						&#8230;<SPAN CLASS="esymbol">}</SPAN>
						<SPAN CLASS="efeature">feature1</SPAN><SPAN CLASS="esymbol">,</SPAN>
						<SPAN CLASS="efeature">feature2</SPAN><SPAN CLASS="esymbol">,</SPAN>
						&#8230;</P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>This gives a new export status to the features listed
					(under their final names since, as noted,
					<SPAN CLASS="ekeyword">export</SPAN> like all other
					subclauses comes after <SPAN CLASS="ekeyword">rename</SPAN>
					if present): they become exported to the classes listed. In
					most cases this list of classes,
					<SPAN CLASS="eclass">X</SPAN>,
					<SPAN CLASS="eclass">Y</SPAN>, &#8230;, consists of just
					<SPAN CLASS="eclass">ANY</SPAN>, to re-export a previously
					secret feature, or <SPAN CLASS="eclass">NONE</SPAN>, to hide
					a previously exported feature. It is also possible, in lieu
					of the feature list, to use the keyword
					<SPAN CLASS="ekeyword">all</SPAN> to apply the new status to
					all features inherited from the listed parent. Then there can
					be more than one class-feature list, as in</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">class</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">ARRAYED_LIST</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="egeneric">G</SPAN><SPAN CLASS="esymbol">]</SPAN></P>

						<P><SPAN CLASS="ekeyword">inherit</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">ARRAY</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="egeneric">G</SPAN><SPAN CLASS="esymbol">]</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">rename</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">count</SPAN>
						<SPAN CLASS="ekeyword">as</SPAN>
						<SPAN CLASS="efeature">capacity</SPAN><SPAN CLASS="esymbol">,</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">item</SPAN>
						<SPAN CLASS="ekeyword">as</SPAN>
						<SPAN CLASS="efeature">array_item</SPAN><SPAN CLASS="esymbol">,</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">put</SPAN>
						<SPAN CLASS="ekeyword">as</SPAN>
						<SPAN CLASS="efeature">array_put</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">export</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="esymbol">{</SPAN><SPAN CLASS="eclass">NONE</SPAN><SPAN CLASS="esymbol">}</SPAN>
						<SPAN CLASS="ekeyword">all</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="esymbol">{</SPAN><SPAN CLASS="eclass">ANY</SPAN><SPAN CLASS="esymbol">}</SPAN>
						<SPAN CLASS="efeature">capacity</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&#8230;</P>
					</CODE>

					<P>where any explicit listing of a feature, such as
					<SPAN CLASS="efeature">capacity</SPAN>, takes precedence over
					the export status specified for
					<SPAN CLASS="ekeyword">all</SPAN>. Here most features of
					<SPAN CLASS="eclass">ARRAY</SPAN> are secret in
					<SPAN CLASS="eclass">ARRAYED_LIST</SPAN>, because the clients
					should not permitted to manipulate array entries directly:
					they will manipulate them indirectly through list features
					such as <SPAN CLASS="efeature">extend</SPAN> and
					<SPAN CLASS="efeature">item</SPAN>, whose implementation
					relies on <SPAN CLASS="efeature">array_item</SPAN> and
					<SPAN CLASS="efeature">array_put</SPAN>. But
					<SPAN CLASS="eclass">ARRAY</SPAN>'s feature
					<SPAN CLASS="efeature">count</SPAN> remains useful, under the
					name <SPAN CLASS="efeature">capacity</SPAN>, to the clients
					of <SPAN CLASS="eclass">ARRAYED_LIST</SPAN>.</P>

					<H2><A NAME="11134"></A>Flat and Flat-Contract Forms</H2>

					<P>Thanks to inheritance, a concise class text may achieve a
					lot, relying on all the features inherited from direct and
					indirect ancestors.</P>

					<P>This is part of the power of the object-oriented form of
					reuse, but can create a comprehension and documentation
					problem when the inheritance structures become deep: how does
					one understand such a class, either as client author or as
					maintainer? For clients, the Contract Form, entirely deduced
					from the class text, does not tell the full story about
					available features; and maintainers must look to proper
					ancestors for much of the relevant information.</P>

					<P>These observations suggest ways to produce, from a class
					text, a version that is equivalent feature-wise and
					assertion-wise, but has no inheritance dependency. This is
					called the <SPAN CLASS="bold">Flat Form</SPAN> of the class.
					It is a class text that has no inheritance clause and
					includes all the features of the class, immediate (declared
					in the class itself) as well as inherited. For the inherited
					features, the flat form must of course take account of all
					the feature adaptation mechanisms: renaming (each feature
					must appear under its final name), redefinition, effecting,
					uneffecting and export status change. For redeclared
					features, <SPAN CLASS="ekeyword">require else</SPAN> clauses
					are or-ed with the precursors' preconditions, and
					<SPAN CLASS="ekeyword">ensure then</SPAN> clauses are and-ed
					with precursors' postconditions. For invariants, all the
					ancestors' clauses are concatenated. As a result, the flat
					form yields a view of the class, its features and its
					assertions that conforms exactly to the view offered to
					clients and (except for polymorphic uses) heirs.</P>

					<P>As with the Contract Form
					(<A HREF="tutorial-09.html#pgfId-514906">&quot;The contract form of a class&quot;</A>),
					producing the Flat Form is the responsibility of tools in
					the development environment. In EiffelStudio, you will just
					click the &quot;Flat&quot; icon. In Eiffel ENViSioN!, you use
					the Documentation Project.</P>

					<P>The Contract Form of the Flat Form of a class is known as
					its <SPAN CLASS="bold">Flat-Contract Form</SPAN>. It gives
					the complete interface specification, documenting all
					exported features and assertions -- immediate or inherited --
					and hiding implementation aspects. It is the appropriate
					documentation for a class.</P>

					<H2><A NAME="pgfId-515560"></A><A NAME="69912"></A>Repeated inheritance and selection</H2>

					<P>An inheritance mechanism, following from multiple
					inheritance, remains to be seen. Through multiple
					inheritance, a class can be a proper descendant of another
					through more than one path. This is called repeated
					inheritance and can be indirect, as in the following figure,
					or even direct, when a class <SPAN CLASS="eclass">D</SPAN>
					lists a class <SPAN CLASS="eclass">A</SPAN> twice in its
					<SPAN CLASS="ekeyword">inherit</SPAN> clause.</P>

					<IMG SRC="tutorial-13.png">

					<P>The figure's particular example is in fact often used by
					introductory presentations of
					<SPAN CLASS="italics">multiple</SPAN> inheritance, which is a
					pedagogical mistake: simple multiple inheritance examples
					(such as <SPAN CLASS="eclass">INTEGER</SPAN> inheriting from
					<SPAN CLASS="eclass">NUMERIC</SPAN> and
					<SPAN CLASS="eclass">COMPARABLE</SPAN>, or
					<SPAN CLASS="eclass">COMPANY_PLANE</SPAN> from
					<SPAN CLASS="eclass">ASSET</SPAN> and
					<SPAN CLASS="eclass">PLANE</SPAN>) should involve the
					combination of
					<SPAN CLASS="bold">separate abstractions</SPAN>. Repeated
					inheritance is an advanced technique; although invaluable, it
					does not arise in elementary uses and requires a little more
					care.</P>

					<P>In fact there is only one non-trivial issue in repeated
					inheritance: what does a feature of the repeated ancestor,
					such as <SPAN CLASS="efeature">change_address</SPAN> and
					<SPAN CLASS="efeature">computer_account</SPAN>, mean for the
					repeated descendant, here
					<SPAN CLASS="eclass">TEACHING_ASSISTANT</SPAN> (The example
					features chosen involve a routine and an attribute; the basic
					rules will be the same.)</P>

					<P>There are two possibilities: sharing (the repeatedly
					inherited feature yields just one feature in the repeated
					descendant) and duplication (it yields two). Examination of
					various cases shows quickly that a fixed policy, or one that
					would apply to all the features of a class, would be
					inappropriate.</P>

					<UL>
						<LI>Feature <SPAN CLASS="efeature">change_address</SPAN>
						calls for sharing: as a teaching assistant, you may be
						both teacher and student, but you are just one person,
						with just one official domicile.</LI>

						<LI>If there are separate accounts for students' course
						work and for faculty, you may need one of each kind,
						suggesting that
						<SPAN CLASS="efeature">computer_account</SPAN> calls for
						duplication.</LI>
					</UL>

					<P>The Eiffel rule enables, once again, the software
					developer to craft the resulting class so as to tune it to
					the exact requirements. Not surprisingly, it is based on
					names, in accordance with the Final Name rule (no in-class
					overloading):</P>

					<P CLASS="tip"><SPAN CLASS="bold">Repeated Inheritance rule</SPAN><BR />
					* A feature inherited multiply under one name will be
					shared: it is considered to be just one feature in the
					repeated descendant.<BR />
					* A feature inherited multiply under different names
					will be replicated, yielding as many variants as names.
					</P>

					<P>So to tune the repeated descendant, feature by feature,
					for sharing and replication it suffices to use renaming.</P>

					<UL>
						<LI>Doing nothing will cause sharing, which is indeed the
						desired policy in most cases (especially those cases of
						<SPAN CLASS="italics">unintended</SPAN> repeated
						inheritance: making <SPAN CLASS="eclass">D</SPAN> inherit
						from <SPAN CLASS="eclass">A</SPAN> even though it also
						inherits from <SPAN CLASS="eclass">B</SPAN>, which you
						forgot is already a descendant of
						<SPAN CLASS="eclass">A</SPAN>).</LI>

						<LI>If you use renaming somewhere along the way, so that
						the final names are different, you will obtain two
						separate features. It does not matter where the renaming
						occurs; all that counts is whether in the common
						descendant, <SPAN CLASS="eclass">TEACHING_ASSISTANT</SPAN>
						in the last figure, the names are the same or different.
						So you can use renaming at that last stage to cause
						replication; but if the features have been renamed higher
						you can also use last-minute renaming to
						<SPAN CLASS="italics">avoid</SPAN> replication, by
						bringing them back to a single name.</LI>
					</UL>

					<P>The Repeated Inheritance rule gives the desired flexibility
					to disambiguate the meaning of repeatedly inherited features.
					There remains a problem in case of redeclaration and
					polymorphism. Assume that somewhere along the inheritance
					paths one or both of two replicated versions of a feature
					<SPAN CLASS="efeature">f</SPAN>, such as
					<SPAN CLASS="efeature">computer_account</SPAN> in the example,
					has been redeclared; we need to define the effect of a call
					<SPAN CLASS="elocal">a</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">f</SPAN>
					(<SPAN CLASS="elocal">a</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">computer_account</SPAN>
					in the example) if <SPAN CLASS="elocal">a</SPAN> is of the
					repeated ancestor type, here
					<SPAN CLASS="eclass">UNIVERSITY_PERSON</SPAN>, and has become
					attached as a result of polymorphism to an instance of the
					repeated descendant, here
					<SPAN CLASS="eclass">TEACHING_ASSISTANT</SPAN>. If one or
					more of the intermediate ancestors has redefined its version
					of the feature, the dynamically-bound call has two or more
					versions to choose from.</P>

					<P><SPAN CLASS="ekeyword">select</SPAN> clause will resolve
					the ambiguity, as in</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">class</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">TEACHING_ASSISTANT</SPAN></P>

						<P><SPAN CLASS="ekeyword">inherit</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">TEACHER</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">rename</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">computer_account</SPAN>
						<SPAN CLASS="ekeyword">as</SPAN>
						<SPAN CLASS="efeature">faculty_account</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">select</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">faculty_account</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">STUDENT</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">rename</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">computer_account</SPAN>
						<SPAN CLASS="ekeyword">as</SPAN>
						<SPAN CLASS="efeature">student_account</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&#8230;</P>
					</CODE>

					<P>We assume here that that no other renaming has occurred --
					<SPAN CLASS="eclass">TEACHING_ASSISTANT</SPAN> takes care of
					the renaming to ensure replication -- but that one of the two
					parents has redefined
					<SPAN CLASS="efeature">computer_account</SPAN>, for example
					<SPAN CLASS="eclass">TEACHER</SPAN> to express the special
					privileges of faculty accounts. In such a case the rule is
					that one (and exactly one) of the two parent clauses in
					<SPAN CLASS="eclass">TEACHING_ASSISTANT</SPAN>
					<SPAN CLASS="bold">must</SPAN> select the corresponding
					version. Note that no problem arises for an entity declared
					as</P>

					<CODE>
						<P><SPAN CLASS="elocal">ta</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">TEACHING_ASSISTANT</SPAN>
					</CODE>

					<P>since the valid calls are of the form
					<SPAN CLASS="elocal">ta</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">faculty_account</SPAN>
					and
					<SPAN CLASS="elocal">ta</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">student_account</SPAN>,
					neither of them ambiguous; the call
					<SPAN CLASS="elocal">ta</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">computer_account</SPAN>
					would be invalid, since after the renamings class
					<SPAN CLASS="eclass">TEACHING_ASSISTANT</SPAN> has no feature
					of that name. The <SPAN CLASS="ekeyword">select</SPAN> only
					applies to a call</P>

					<CODE>
						<P><SPAN CLASS="elocal">up</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">computer_account</SPAN>
						</P>
					</CODE>

					<P>with <SPAN CLASS="elocal">up</SPAN> of type
					<SPAN CLASS="eclass">UNIVERSITY_PERSON</SPAN>, dynamically
					attached to an instance of
					<SPAN CLASS="eclass">TEACHING_ASSISTANT</SPAN>; then the
					<SPAN CLASS="ekeyword">select</SPAN> resolves the ambiguity
					by causing the call to use the version from
					<SPAN CLASS="eclass">TEACHER</SPAN>.</P>

					<P>So if you traverse a list
					<SPAN CLASS="efeature">computer_users</SPAN>:
					<SPAN CLASS="eclass">LIST</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">UNIVERSITY_PERSON</SPAN><SPAN CLASS="esymbol">]</SPAN>
					to print some information about the computer account of each
					list element, the account used for a teaching assistant is
					the faculty account, not the student account.</P>

					<P CLASS=note>You may, if desired, redefine
					<SPAN CLASS="efeature">faculty_account</SPAN> in class
					<SPAN CLASS="eclass">TEACHING_ASSISTANT</SPAN>, using
					<SPAN CLASS="efeature">student_account</SPAN> if necessary,
					to take into consideration the existence of another account.
					But in all cases we need a precise disambiguation of what
					<SPAN CLASS="efeature">computer_account</SPAN> means for a
					<SPAN CLASS="eclass">TEACHING_ASSISTANT</SPAN> object known
					only through a <SPAN CLASS="eclass">UNIVERSITY_PERSON</SPAN>
					entity.</P>

					<P>The <SPAN CLASS="ekeyword">select</SPAN> is only needed in
					case of replication. If the Repeated Inheritance rule would
					imply sharing, as with change_address, and one or both of the
					shared versions has been redeclared, the Final Name rule
					makes the class invalid, since it now has
					<SPAN CLASS="bold">two different features</SPAN> with the same
					name. (This is only a problem if both versions are effective;
					if one or both are deferred there is no conflict but a mere
					case of feature joining as explained in
					<A HREF="tutorial-10.html#61102">&quot;Join and uneffecting&quot;</A>.)
					The two possible solutions follow from the previous
					discussions:</P>

					<UL>
						<LI>If you do want sharing, one of the two versions must
						take precedence over the other. It suffices to
						<SPAN CLASS="bold">undefine</SPAN> the other, and
						everything gets back to order. Alternatively, you can
						redefine both into a new version, which takes precedence
						over both.</LI>

						<LI>If you want to keep both versions, switch from
						sharing to replication: rename one or both of the
						features so that they will have different names; then you
						must <SPAN CLASS="ekeyword">select</SPAN> one of them.</LI>
					</UL>

					<H2>Constrained genericity</H2>

					<P>Eiffel's inheritance mechanism has an important
					application to extending the flexibility of the
					<SPAN CLASS="bold">genericity</SPAN> mechanism. In a class
					<SPAN CLASS="eclass">SOME_CONTAINER</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="egeneric">G</SPAN><SPAN CLASS="esymbol">]</SPAN>,
					as noted (section
					<A HREF="tutorial-08.html#pgfId-514722">7</A>), the only
					operations available on entities of type
					<SPAN CLASS="egeneric">G</SPAN>, the formal generic parameter,
					are those applicable to entities of all types. A generic
					class may, however, need to assume more about the generic
					parameter, as with a class
					<SPAN CLASS="eclass">SORTABLE_ARRAY</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="egeneric">G</SPAN>&#8230;
					<SPAN CLASS="esymbol">]</SPAN> which will have a procedure
					<SPAN CLASS="efeature">sort</SPAN> that needs, at some
					stage, to perform tests of the form</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">if</SPAN>
						<SPAN CLASS="efeature">item</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">i</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="efeature">&lt;</SPAN>
						<SPAN CLASS="efeature">item</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">j</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">then</SPAN>&#8230;
					</CODE>

					<P>where <SPAN CLASS="efeature">item</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">i</SPAN><SPAN CLASS="esymbol">)</SPAN>
					and <SPAN CLASS="efeature">item</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">j</SPAN><SPAN CLASS="esymbol">)</SPAN>
					are of type <SPAN CLASS="egeneric">G</SPAN>. But this requires
					the availability of a feature
					<SPAN CLASS="ekeyword">infix</SPAN>
					<SPAN CLASS="esymbol">&quot;</SPAN><SPAN CLASS="efeature">&lt;</SPAN><SPAN CLASS="esymbol">&quot;</SPAN>
					in all types that may serve as actual generic parameters
					corresponding to <SPAN CLASS="egeneric">G</SPAN>. Using the
					type <SPAN CLASS="eclass">SORTABLE_ARRAY</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">]</SPAN>
					should be permitted, because
					<SPAN CLASS="eclass">INTEGER</SPAN> has such a feature; but
					not <SPAN CLASS="eclass">SORTABLE_ARRAY</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">COMPLEX</SPAN><SPAN CLASS="esymbol">]</SPAN>
					if there is no total order relation on
					<SPAN CLASS="eclass">COMPLEX</SPAN>.</P>

					<P>To cover such cases, declare the class as</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">class</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="eclass">SORTABLE_ARRAY </SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="egeneric">G</SPAN>
						<SPAN CLASS="esymbol">-&gt;</SPAN>
						<SPAN CLASS="eclass">COMPARABLE</SPAN><SPAN CLASS="esymbol">]</SPAN>
					</CODE>

					<P>making it <SPAN CLASS="bold">constrained generic</SPAN>.
					The symbol <SPAN CLASS="esymbol">-&gt;</SPAN> recalls the
					arrow of inheritance diagrams; what follows it is a type,
					known as the generic constraint. Such a declaration means
					that:</P>

					<UL>
						<LI>Within the class, you may apply the features of the
						generic constraint -- here the features of
						<SPAN CLASS="eclass">COMPARABLE</SPAN>:
						<SPAN CLASS="ekeyword">infix</SPAN>
						<SPAN CLASS="esymbol">&quot;</SPAN><SPAN CLASS="efeature">&lt;</SPAN><SPAN CLASS="esymbol">&quot;</SPAN>,
						<SPAN CLASS="ekeyword">infix</SPAN>
						<SPAN CLASS="esymbol">&quot;</SPAN><SPAN CLASS="efeature">&lt;=</SPAN><SPAN CLASS="esymbol">&quot;</SPAN>
						etc. -- to expressions of type
						<SPAN CLASS="egeneric">G</SPAN>.</LI>

						<LI>A generic derivation is only valid if the chosen
						actual generic parameter conforms to the constraint.
						Here you can use
						<SPAN CLASS="eclass">SORTABLE_ARRAY</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">INTEGER</SPAN><SPAN CLASS="esymbol">]</SPAN>
						since <SPAN CLASS="eclass">INTEGER</SPAN>
						inherits from
						<SPAN CLASS="eclass">COMPARABLE</SPAN>, but not
						<SPAN CLASS="eclass">SORTABLE_ARRAY</SPAN>
						<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">COMPLEX</SPAN><SPAN CLASS="esymbol">]</SPAN>
						if <SPAN CLASS="eclass">COMPLEX</SPAN> is not a
						descendant of <SPAN CLASS="eclass">COMPARABLE</SPAN>.</LI>
					</UL>

					<P>A class can have a mix of constrained and unconstrained
					generic parameters, as in the EiffelBase class
					<SPAN CLASS="eclass">HASH_TABLE</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="egeneric">G</SPAN><SPAN CLASS="esymbol">,</SPAN>
					<SPAN CLASS="egeneric">H</SPAN>
					<SPAN CLASS="esymbol">-&gt;</SPAN>
					<SPAN CLASS="eclass">HASHABLE</SPAN><SPAN CLASS="esymbol">]</SPAN>
					whose first parameter represents the types of objects stored
					in a hash table, the second representing the types of the
					keys used to store them, which must be
					<SPAN CLASS="eclass">HASHABLE</SPAN>. As these examples
					suggest, structural property classes such as
					<SPAN CLASS="eclass">COMPARABLE</SPAN>,
					<SPAN CLASS="eclass">NUMERIC</SPAN> and
					<SPAN CLASS="eclass">HASHABLE</SPAN> are the most common
					choice for generic constraints.</P>

					<P>Unconstrained genericity, as in
					<SPAN CLASS="eclass">C</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="egeneric">G</SPAN><SPAN CLASS="esymbol">]</SPAN>,
					is defined as equivalent to
					<SPAN CLASS="eclass">C</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="egeneric">G</SPAN>
					<SPAN CLASS="esymbol">-&gt;</SPAN>
					<SPAN CLASS="eclass">ANY</SPAN><SPAN CLASS="esymbol">]</SPAN>.

					<H2>Assignment attempt</H2>

					<P>The Type Conformance rule
					(<A HREF="tutorial-10.html#65123">&quot;Polymorphism&quot;</A>)
					ensures type safety by requiring all assignments to be from a
					more specific source to a more general target.</P>

					<P>Sometimes you can't be sure of the source object's type.
					This happens for example when the object comes from the
					outside -- a file, a database, a network. The persistence
					storage mechanism
					(<A HREF="tutorial-07.html#35815">&quot;Deep operations and persistence&quot;</A>)
					includes, along with the procedure
					<SPAN CLASS="efeature">store</SPAN> seen there, the reverse
					operation, a function <SPAN CLASS="efeature">retrieved</SPAN>
					which yields an object structure retrieved from a file or
					network, to which it was sent using
					<SPAN CLASS="efeature">store</SPAN>. But
					<SPAN CLASS="efeature">retrieved</SPAN> as declared in the
					corresponding class <SPAN CLASS="eclass">STORABLE</SPAN> of
					EiffelBase can only return the most general type,
					<SPAN CLASS="eclass">ANY</SPAN>; it is not possible to know
					its exact type until execution time, since the corresponding
					objects are not under the control of the retrieving system,
					and might even have been corrupted by some external agent.</P>

					<P>In such cases you cannot trust the declared type but must
					check it against the type of an actual run-time object.
					Eiffel introduces for this purpose the
					<SPAN CLASS="bold">assignment attempt</SPAN> operation,
					written</P>

					<CODE>
						<P><SPAN CLASS="elocal">x</SPAN>
						<SPAN CLASS="esymbol">?=</SPAN>
						<SPAN CLASS="elocal">y</SPAN></P>
					</CODE>

					<P>with the following effect (only applicable if
					<SPAN CLASS="elocal">x</SPAN> is a writable entity of
					reference type):</P>

					<UL>
						<LI>If <SPAN CLASS="elocal">y</SPAN> is attached, at the
						time of the instruction's execution to an object whose
						type conforms to the type of
						<SPAN CLASS="elocal">x</SPAN>, perform a normal
						reference assignment.</LI>

						<LI>Otherwise (if <SPAN CLASS="elocal">y</SPAN> is void,
						or attached to a non-conforming object), make
						<SPAN CLASS="elocal">x</SPAN> void.</LI>
					</UL>

					<P>Using this mechanism, a typical object structure retrieval
					will be of the form</P>

					<CODE>
						<P><SPAN CLASS="elocal">x</SPAN>
						<SPAN CLASS="esymbol">?=</SPAN>
						<SPAN CLASS="efeature">retrieved</SPAN></P>

						<P><SPAN CLASS="ekeyword">if</SPAN>
						<SPAN CLASS="elocal">x</SPAN>
						<SPAN CLASS="esymbol">=</SPAN>
						<SPAN CLASS="efeature">Void</SPAN>
						<SPAN CLASS="ekeyword">then</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="ecomment">&quot;We did not get what we expected&quot;</SPAN></P>

						<P><SPAN CLASS="ekeyword">else</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="ecomment">&quot;Proceed with normal computation,
						which will typically involve</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="ecomment">calls of the form
						<SPAN CLASS="elocal">x</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">some_feature</SPAN>&quot;</SPAN></P>

						<P><SPAN CLASS="ekeyword">end</SPAN>
					</CODE>

					<P>As another application, assume we have a
					<SPAN CLASS="eclass">LIST</SPAN>
					<SPAN CLASS="esymbol">[</SPAN><SPAN CLASS="eclass">ACCOUNT</SPAN><SPAN CLASS="esymbol">]</SPAN>
					and class <SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN>, a
					descendant of <SPAN CLASS="eclass">ACCOUNT</SPAN>, has a
					feature <SPAN CLASS="efeature">interest_rate</SPAN> which was
					not in <SPAN CLASS="eclass">ACCOUNT</SPAN>. We want to find
					the maximum interest rate for savings accounts in the list.
					Assignment attempt easily solves the problem:</P>

					<CODE>
						<P><SPAN CLASS="ekeyword">local</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="elocal">s</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN></P>

						<P><SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">from</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">account_list</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">start</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">until</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">account_list</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">after</SPAN>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">loop</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="elocal">s</SPAN>
						<SPAN CLASS="esymbol">?=</SPAN>
						<SPAN CLASS="efeature">acc_list</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">item</SPAN>
						</P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- <SPAN CLASS="efeature">item</SPAN>
						from <SPAN CLASS="eclass">LIST</SPAN> yields the element at cursor position</SPAN>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">if</SPAN>
						<SPAN CLASS="elocal">s</SPAN>
						<SPAN CLASS="esymbol">/=</SPAN>
						<SPAN CLASS="efeature">Void</SPAN>
						<SPAN CLASS="ekeyword">and</SPAN>
						<SPAN CLASS="ekeyword">then</SPAN>
						<SPAN CLASS="elocal">s</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">interest_rate</SPAN>
						<SPAN CLASS="esymbol">&gt;</SPAN>
						<SPAN CLASS="ekeyword">Result</SPAN>
						<SPAN CLASS="ekeyword">then</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Using <SPAN CLASS="ekeyword">and</SPAN>
						<SPAN CLASS="ekeyword">then</SPAN> (rather than
						<SPAN CLASS="ekeyword">and</SPAN>) guarantees that</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- <SPAN CLASS="elocal">s</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="feature">interest_rate</SPAN>
						is not evaluated</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- if <SPAN CLASS="elocal">s</SPAN>
						= <SPAN CLASS="efeature">Void</SPAN> is true.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">Result</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="elocal">s</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">interest_rate</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">account_list</SPAN><SPAN CLASS="edot">.</SPAN><SPAN CLASS="efeature">forth</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>

						<P><SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>Note that if there is no savings account at all in the
					list the assignment attempt will always yield void, so
					that the result of the function will be 0, the default
					initialization.</P>

					<P>Assignment attempt is useful in the cases cited --
					access to external objects beyond the software's own
					control, and access to specific properties in a polymorphic
					data structure. The form of the instruction precisely serves
					these purposes; not being a general type comparison, but only
					a verification of a specific expected type, it does not carry
					the risk of encouraging developers to revert to multi-branch
					instruction structures, for which Eiffel provides the far
					preferable alternative of polymorphic, dynamically-bound
					feature calls.</P>

					<H2><A NAME="46019"></A>Covariance and anchored declarations</H2>

					<P>The final property of Eiffel inheritance involves the rules
					for adapting not only the implementation of inherited features
					(through redeclaration of either kind, redeclaration and
					redefinition, as seen so far) and their contracts (through
					the Assertion Redeclaration rule), but also their types. More
					general than type is the notion of a feature's
					<SPAN CLASS="bold">signature</SPAN>, defined by the number of
					its arguments, their types, the indication of whether it has a
					result (that is to say, is a function or attribute rather
					than a procedure) and, if so, the type of the result.</P>

					<P>In many cases the signature of a redeclared feature
					remains the same as the original's. But in some cases you may
					want to adapt it to the new class. Assume for example that
					class <SPAN CLASS="eclass">ACCOUNT</SPAN> has features</P>

					<CODE>
						<P><SPAN CLASS="efeature">owner</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">HOLDER</SPAN>

						<P><SPAN CLASS="efeature">set_owner</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">h</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">HOLDER</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Make <SPAN CLASS="elocal">h</SPAN>
						the account owner.</SPAN>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">require</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">not_void:</SPAN>
						<SPAN CLASS="elocal">h</SPAN>
						<SPAN CLASS="esymbol">/=</SPAN>
						<SPAN CLASS="efeature">Void</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">owner</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="elocal">h</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>We introduce an heir
					<SPAN CLASS="eclass">BUSINESS_ACCOUNT</SPAN> of
					<SPAN CLASS="eclass">ACCOUNT</SPAN> to represent special
					business accounts, corresponding to class
					<SPAN CLASS="eclass">BUSINESS</SPAN> inheriting from
					<SPAN CLASS="eclass">HOLDER</SPAN>:</P>

					<IMG SRC="tutorial-14.png">

					<P>Clearly, we must redefine
					<SPAN CLASS="efeature">owner</SPAN> in class
					<SPAN CLASS="eclass">BUSINESS_ACCOUNT</SPAN> to yield a
					result of type <SPAN CLASS="eclass">BUSINESS</SPAN>; the same
					signature redefinition must be applied to the argument of
					<SPAN CLASS="eclass">set_owner</SPAN>. This case is typical
					of the general scheme of signature redefinition: in a
					descendant, you may need to redefine both results and
					arguments to types conforming to the originals. This is
					reflected by a language rule:</P>

					<P CLASS="tip"><SPAN CLASS="bold">Covariance rule</SPAN><BR />
					In a feature redeclaration, both the result type if the
					feature is a query (attribute or function) and the type of
					any argument if it is a routine (procedure or function) must
					conform to the original type as declared in the precursor
					version.</P>

					<P>The term &quot;covariance&quot; reflects the property that
					all types -- those of arguments and those of results -- vary
					together in the same direction as the inheritance structure.</P>

					<P>If a feature such as <SPAN CLASS="efeature">set_owner </SPAN>
					has to be redefined for more than its signature -- to update
					its implementation or assertions -- the signature
					redefinition will be explicit. For example
					<SPAN CLASS="efeature">set_owner</SPAN> could do more for
					business owners than it does for ordinary owners. Then the
					redefinition will be of the form</P>

					<CODE>
						<P><SPAN CLASS="efeature">set_owner</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">b</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="eclass">BUSINESS</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Make <SPAN CLASS="elocal">b</SPAN>
						the account owner.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&#8230; New routine body &#8230;</P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>In other cases, however, the body will be exactly the same
					as in the precursor. Then explicit redefinition would be
					tedious, implying much text duplication. The mechanism of
					<SPAN CLASS="bold">anchored redeclaration</SPAN> solves this
					problem. The original declaration of
					<SPAN CLASS="efeature">set_owner</SPAN> in
					<SPAN CLASS="eclass">ACCOUNT</SPAN> should be of the form</P>

					<CODE>
						<P><SPAN CLASS="efeature">set_owner</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">h</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="ekeyword">like Current</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- Make <SPAN CLASS="elocal">h</SPAN>
						the account owner.</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="ecomment">-- The rest as before:</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="ekeyword">require</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="eitag">not_void:</SPAN>
						<SPAN CLASS="elocal">h</SPAN>
						<SPAN CLASS="esyMbol">/=</SPAN>
						<SPAN CLASS="efeature">Void</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">do</SPAN></P>

						<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
						<SPAN CLASS="efeature">owner</SPAN>
						<SPAN CLASS="esymbol">:=</SPAN>
						<SPAN CLASS="elocal">h</SPAN></P>

						<P>&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">end</SPAN></P>
					</CODE>

					<P>A <SPAN CLASS="ekeyword">like</SPAN>
					<SPAN CLASS="efeature">anchor</SPAN> type, known as an anchored
					type, may appear in any context in which
					<SPAN CLASS="efeature">anchor</SPAN> has a well-defined type;
					<SPAN CLASS="efeature">anchor </SPAN> can be an attribute or
					function of the enclosing class, or an argument of the
					enclosing routine. Then, assuming
					<SPAN CLASS="eclass">T</SPAN> is the type of
					<SPAN CLASS="efeature">anchor</SPAN>, the type
					<SPAN CLASS="ekeyword">like</SPAN>
					<SPAN CLASS="efeature">anchor</SPAN> means the following:</P>

					<UL>
						<LI>In the class in which it appears,
						<SPAN CLASS="ekeyword">like</SPAN>
						<SPAN CLASS="efeature">anchor</SPAN> means the same as
						<SPAN CLASS="eclass">T</SPAN>. For example, in
						<SPAN CLASS="efeature">set_owner</SPAN> above, the
						declaration of <SPAN CLASS="elocal">h</SPAN> has the same
						effect as if <SPAN CLASS="elocal">h</SPAN> had been
						declared of type <SPAN CLASS="eclass">HOLDER</SPAN>, the
						type of the anchor <SPAN CLASS="efeature">owner</SPAN> in
						class <SPAN CLASS="eclass">ACCOUNT</SPAN>.</LI>

						<LI>The difference comes in proper descendants: if a type
						redefinition changes the type of
						<SPAN CLASS="efeature">anchor</SPAN>, any entity declared
						<SPAN CLASS="ekeyword">like</SPAN>
						<SPAN CLASS="efeature">anchor</SPAN> will be considered
						to have been redefined too.</LI>
					</UL>

					<P>This means that anchored declaration are a form of of
					implicit covariant redeclaration.</P>

					<P>In the example, class
					<SPAN CLASS="eclass">BUSINESS_ACCOUNT</SPAN> only needs to
					redefine the type of <SPAN CLASS="efeature">owner</SPAN>
					(to <SPAN CLASS="eclass">BUSINESS</SPAN>). It doesn't have to
					redefine <SPAN CLASS="efeature">set_owner</SPAN> except if it
					needs to change its implementation or assertions.</P>

					<P>It is possible to use <SPAN CLASS="ekeyword">Current</SPAN>
					as anchor; the declaration <SPAN CLASS="ekeyword">like</SPAN>
					<SPAN CLASS="ekeyword">Current</SPAN> denotes a type based on
					the current class (with the same generic parameters if any).
					This is in fact a common case; we saw in
					<A HREF="tutorial-10.html#46202">&quot;Structural property classes&quot;</A>,
					that it applies in class
					<SPAN CLASS="eclass">COMPARABLE</SPAN> to features such as</P>

					<CODE>
						<P>&nbsp;&nbsp;
						<SPAN CLASS="ekeyword">infix</SPAN>
						<SPAN CLASS="esymbol">&quot;</SPAN><SPAN CLASS="efeature">&lt;</SPAN><SPAN CLASS="esymbol">&quot;</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">other</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="ekeyword">like</SPAN>
						<SPAN CLASS="ekeyword">Current</SPAN><SPAN CLASS="esymbol">):</SPAN>
						<SPAN CLASS="eclass">BOOLEAN</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN> &#8230;
					</CODE>

					<P>since we only want to compare two comparable elements of
					compatible types -- but not, for example, integer and
					strings, even if both types conform to
					<SPAN CLASS="eclass">COMPARABLE</SPAN>. (A
					&quot;balancing rule&quot; makes it possible, however, to mix
					the various arithmetic types, consistently with mathematical
					traditions, in arithmetic expressions such as
					<SPAN CLASS="enumber">3</SPAN> <SPAN CLASS="esymbol">+</SPAN>
					<SPAN CLASS="enumber">45.82</SPAN> or boolean expressions
					such as <SPAN CLASS="enumber">3</SPAN>
					<SPAN CLASS="efeature">&lt;</SPAN>
					<SPAN CLASS="enumber">45.82</SPAN>.)</P>

					<P>Similarly, class <SPAN CLASS="eclass">ANY</SPAN> declares
					procedure <SPAN CLASS="efeature">copy</SPAN> as</P>

					<CODE>
						<P>&nbsp;&nbsp;&nbsp;<SPAN CLASS="efeature">copy</SPAN>
						<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">other</SPAN><SPAN CLASS="esymbol">:</SPAN>
						<SPAN CLASS="ekeyword">like</SPAN>
						<SPAN CLASS="ekeyword">Current</SPAN><SPAN CLASS="esymbol">)</SPAN>
						<SPAN CLASS="ekeyword">is</SPAN></P> &#8230;</P>
					</CODE>

					<P>with the argument anchored to the current object. Function
					<SPAN CLASS="efeature">clone</SPAN>, for its part, has
					signature <SPAN CLASS="efeature">clone</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">other</SPAN><SPAN CLASS="esymbol">:</SPAN>
					<SPAN CLASS="eclass">ANY</SPAN><SPAN CLASS="esymbol">):</SPAN>
					<SPAN CLASS="ekeyword">like</SPAN>
					<SPAN CLASS="elocal">other</SPAN>, with both argument and
					result anchored to the argument, so that for any
					<SPAN CLASS="elocal">x</SPAN> the type of
					<SPAN CLASS="efeature">clone</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">x</SPAN><SPAN CLASS="esymbol">)</SPAN>
					is the same as the type of <SPAN CLASS="elocal">x</SPAN>.</P>

					<P>A final, more application-oriented example of anchoring to
					<SPAN CLASS="ekeyword">Current</SPAN> is the feature
					<SPAN CLASS="efeature">merge</SPAN> posited in an earlier
					<A HREF="tutorial-07.html#ROUTINE_MERGE">example</A>
					with the signature <SPAN CLASS="efeature">merge </SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">other</SPAN><SPAN CLASS="esymbol">:</SPAN>
					<SPAN CLASS="eclass">ACCOUNT</SPAN>). By using instead
					<SPAN CLASS="efeature">merge</SPAN>
					<SPAN CLASS="esymbol">(</SPAN><SPAN CLASS="elocal">other</SPAN><SPAN CLASS="esymbol">:</SPAN>
					<SPAN CLASS="ekeyword">like</SPAN>
					<SPAN CLASS="ekeyword">Current</SPAN>) we can ensure that in
					any descendant class --
					<SPAN CLASS="eclass">BUSINESS_ACCOUNT</SPAN>,
					<SPAN CLASS="eclass">SAVINGS_ACCOUNT</SPAN>,
					<SPAN CLASS="eclass">MINOR_ACCOUNT</SPAN>&#8230; -- an
					account will only be mergeable with another of a compatible
					type.</P>

					<P>Covariance makes static type checking more delicate;
					mechanisms of &quot;system validity&quot; and
					&quot;catcalls&quot; address the problem, discussed in detail
					in the book
					<A HREF="http://eiffel.com/doc/oosc/">Object-Oriented
					Software Construction</A></P>

					<P CLASS="seealso"><B>See also</B><BR />
						<A HREF="tutorial-11.html">Other Mechanisms</A>
					</P>
				</TD>
			</TR>
		</TABLE>
		<TABLE CLASS="FOOTER">
			<TR>
				<TD> 2003-2004 Eiffel Software. All rights reserved.</TD>
			</TR>
		</TABLE>
	</BODY>
</HTML>