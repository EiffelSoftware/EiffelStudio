<html>

<head>
<title>Multithreaded GC</title>
<link rel="stylesheet" type="text/css" href="../default.css">
</head>

<body>

<h1>Multithreaded GC</h1>

<h2>Stop the world solution</h2>

<p>How to implement a portable stop the world solution?</p>
<p>In the Eiffel code, each Eiffel C generated routine is equipped with the 
following code:</p>
<pre>if (gc_collecting) {
	current_thread.status = suspended
	gc_mutex.lock
	gc_condition_variable.wait (gc_mutex)
	gc_mutex.unlock
	current_thread.status = normal
}</pre>
<p>For all routines from the thread library that might 
block we have:</p>
<pre>current_thread.status = `blocked;
CALL TO BLOCKING STUFF
if (gc_collecting) {
	current_thread.status = suspended
	gc_mutex.lock
	gc_condition_variable.wait (gc_mutex)
	gc_mutex.unlock
}
current_thread.status = normal</pre>
<p>In the code which performs the GC we have the following:</p>
<pre>current_thread.status = starting_gc

gc_collecting_mutex.lock
gc_collecting = true

Loop until all threads but current one are marked `suspended' or `starting_gc' or `blocked'.

Perform GC operation

gc_collecting = false

	// Signal all other threads so that they resume their execution
gc_condition_variable.broadcast

Loop until all threads but current one are marked `normal' or `starting_gc' or `blocked'
and for each suspended thread do `gc_condition_variable.signal'.

gc_collecting_mutex.unlock

current_thread.status = normal</pre>
<p>Of course the members are:</p>
<p>volatile EIF_BOOLEAN gc_collecting;</p>
</body>
</html>