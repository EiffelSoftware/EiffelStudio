<document title="Reusing a COM Component" output="studio">
	<meta_data/>
	<paragraph>
		<paragraph>
			The wizard generates the necessary code to access the existing component. The plumbing is already done so that 
			instantiating an Eiffel class corresponding to one of the component's coclasses automatically calls the right 
			COM initialization APIs.
		</paragraph>
		<heading>
			<size>2</size> Using the Generated Code
		</heading>
		<paragraph>
			Calling a feature on an Eiffel class corresponding to one of the component's coclasses forwards the call to the 
			member on the corresponding interface. The data types of the function arguments are either Eiffel types defined 
			in Eiffel data structure libraries, standard data types defined in the EiffelCOM library, or custom data types 
			declared in the COM definition file. For example, from the following IDL line:
		</paragraph>
		<code_block>
<class_name>HRESULT</class_name> <feature_name>Function</feature_name> (<comment>[in]</comment> <class_name>int</class_name> <local_variable>a</local_variable>, <comment>[out, retval]</comment> <class_name>MyStruct</class_name> <symbol>*</symbol> <local_variable>b</local_variable>)</code_block>
		<paragraph>
			The wizard generates the following feature:
		</paragraph>
		<code_block>
<feature_name>function</feature_name> <symbol>(</symbol><feature_name>a</feature_name><symbol>:</symbol> <class_name>INTEGER</class_name><symbol>)</symbol><symbol>:</symbol> <class_name>MY_STRUCT_RECORD</class_name></code_block>
		<paragraph>
			where <class_name>MY_STRUCT_RECORD</class_name> is a generated Eiffel wrapper around the 
			IDL defined structure <class_name>MyStruct</class_name>. Structures represent one case of custom data types, 
			interfaces represent another so for the following IDL:
		</paragraph>
		<code_block>
<class_name>HRESULT</class_name> <feature_name>Function</feature_name> (<comment>[in]</comment> <class_name>ISomething</class_name> <symbol>*</symbol> <local_variable>pInterface</local_variable>)</code_block>
		<paragraph>
			The wizard generates the following Eiffel feature:
		</paragraph>
		<code_block>
<feature_name>function</feature_name> <symbol>(</symbol><local_variable>p_interface</local_variable><symbol>:</symbol> <class_name>ISOMETHING_INTERFACE</class_name><symbol>)</symbol></code_block>
		<paragraph>
			where <class_name>ISOMETHING_INTERFACE</class_name> is a generated deferred class corresponding to the 
			<class_name>ISomething</class_name> interface. Calling <feature_name>function</feature_name> requires passing an 
			instance of a type that implements <class_name>ISOMETHING_INTERFACE</class_name>. The <bold>stubs</bold> implementing such interfaces  
			can be found in <bold>Server\Interfaces_stub</bold>. In our example the Eiffel class would be named 
			<class_name>ISOMETHING_INTERFACE_IMPL_STUB</class_name>. The default implementation of the stub is empty and should 
			be completed to implement the wanted behavior. This is how callbacks can be implemented using EiffelCOM.
		</paragraph>
		<heading>
			<size>2</size> Contracts
		</heading>
		<paragraph>
			All the Eiffel classes corresponding to the component's interfaces are generated in <bold>Common\Interfaces</bold>. 
			These deferred classes include one deferred feature per function defined on the interface. They are equipped with 
			automatically generated assertions. However, the wizard cannot generate fully specified contracts since it has no domain specific knowledge. 
			It can only generate contracts that are domain independent. Such contracts, although useful, are not 
			enough to describe entirely the behavior of the component. Generated contracts include checking for 
			<feature_name>Void</feature_name> Eiffel objects as well as <keyword>null</keyword> C pointers for wrappers. There might 
			be a need for additional assertions. Invariants and postconditions can be added in an heir of the 
			generated Eiffel coclass proxy. Preconditions, however, cannot be strengthened. A workaround provided by the 
			wizard consists of generating a precondition function for each feature in the interface. The default 
			implementation of these functions always returns <feature_name>True</feature_name>. They can be 
			redefined to implement the correct behavior:
		</paragraph>
		<code_block>
<feature_name>function</feature_name> <symbol>(</symbol><local_variable>a</local_variable><symbol>:</symbol> <class_name>INTEGER</class_name><symbol>)</symbol><symbol>:</symbol> <class_name>MY_STRUCT</class_name> <keyword>is</keyword>
		<comment>-- Example of a generated Eiffel coclass feature</comment>
	<keyword>require</keyword>
		function_user_precondition: <feature_name>function_user_precondition</feature_name>
	<keyword>do</keyword>
		...
	<keyword>ensure</keyword>
		non_void_my_struct: <keyword>Result</keyword> <keyword>/=</keyword> <feature_name>Void</feature_name>
	<keyword>end</keyword></code_block>
		<paragraph>
			So the complete class hierarchy for an Eiffel client coclass is the following:
		</paragraph>
		<image>
			<url>../images/client_inheritance.png</url>
		</image>
		<heading>
			<size>2</size>  Exceptions
		</heading>
		<paragraph>
			The COM standard requires that any interface function returns a status value (known as a 
			<class_name>HRESULT</class_name>). This means that any function which adheres to the COM 
			standard actually corresponds to a side effect feature which the Eiffel methodology tries 
			to avoid according to the <italic>Command Query Separation Principle</italic>. The 
			workaround used in EiffelCOM systems consists in mapping these return values to Eiffel 
			exceptions. So if the component returns an <class_name>HRESULT</class_name> corresponding 
			to an error code, the EiffelCOM runtime raises an Eiffel exception that needs to be caught 
			by the client.
		</paragraph>
		<image>
			<url>../images/exception_raising.png</url>
		</image>
		<paragraph>
			As a result, any feature in the client making calls to the Eiffel classes corresponding to 
			the component's coclasses should include a <keyword>rescue</keyword> clause. The processing 
			done in this clause might depend on the nature of the exception. All the standard COM 
			exceptions can be found in the library class <class_name>ECOM_EXCEPTION_CODES</class_name>, 
			which is inherited from by <class_name>ECOM_EXCEPTION</class_name>. The later also inherits 
			from the kernel class <class_name>EXCEPTIONS</class_name> and can consequently be used by 
			the coclass client to catch the exceptions.
		</paragraph>
		<paragraph>
			The following code snippet illustrates how a client can process exceptions raised by a call to 
			an Eiffel class representing a component's coclass:
		</paragraph>
		<code_block>
<keyword>indexing</keyword>
	description<keyword>:</keyword> <string>"Eiffel coclass client example"</string>

<keyword>class</keyword>
	<class_name>COCLASS_CLIENT</class_name>

<keyword>inherit</keyword>
	<class_name>ECOM_EXCEPTION</class_name>
		<keyword>export</keyword>
			<symbol>{</symbol><class_name>NONE</class_name><symbol>}</symbol> <keyword>all</keyword>
		<keyword>end</keyword>

<keyword>feature</keyword> <comment>-- Basic Operations</comment>

	<feature_name>coclass_feature_client</feature_name> <keyword>is</keyword>
			<comment>-- Example of a coclass feature caller</comment>
		<keyword>local</keyword>
			<local_variable>retried</local_variable><symbol>:</symbol> <class_name>BOOLEAN</class_name>
			<local_variable>coclass</local_variable><symbol>:</symbol> <class_name>EIFFEL_COCLASS_PROXY</class_name>
		<keyword>do</keyword>
			<keyword>if</keyword> <keyword>not</keyword> <local_variable>retried</local_variable> <keyword>then</keyword>
				<keyword>create</keyword> <local_variable>coclass</local_variable><symbol>.</symbol><feature_name>make</feature_name>
				<local_variable>coclass</local_variable><symbol>.</symbol><feature_name>coclass_feature</feature_name> <comment>-- Actual call</comment>
			<keyword>end</keyword>
		<keyword>rescue</keyword>
			<keyword>if</keyword> <feature_name>hresult</feature_name> <symbol>=</symbol> <feature_name>E_notimpl</feature_name> <keyword>then</keyword>
					<comment>-- Process non implemented function error.</comment>
				<local_variable>retried</local_variable> <symbol>:=</symbol> <keyword>True</keyword>
				<keyword>retry</keyword>
			<keyword>elseif</keyword> <feature_name>hresult</feature_name> <symbol>=</symbol> <feature_name>E_invalidarg</feature_name> <keyword>then</keyword>
					<comment>-- Process invalid argument error.</comment>
				<local_variable>retried</local_variable> <symbol>:=</symbol> <keyword>True</keyword>
				<keyword>retry</keyword>
			<keyword>else</keyword>
				<comment>-- Forward exception to caller.</comment>
			<keyword>end</keyword>
		<keyword>end</keyword>

<keyword>end</keyword> <comment>-- class COCLASS_CLIENT</comment></code_block>
		<seealso>
			<bold>See Also</bold>: <link><url>10_how_wizard_works.xml</url><label>How the EiffelCOM Wizard Works</label></link>, 
			<link><url>20_generated_files.xml</url><label>Generated Files</label></link>, 
			<link><url>30_class_hierarchy.xml</url><label>Class Hierarchy</label></link>, 
			<link><url>40_eiffel_project.xml</url><label>Adding a COM Interface to an Eiffel Project</label></link>, 
			<link><url>60_building.xml</url><label>Reusing a COM Component</label></link>, 
			<link><url>70_options.xml</url><label>Command Line Options</label></link>
		</seealso>
	</paragraph>
</document>
