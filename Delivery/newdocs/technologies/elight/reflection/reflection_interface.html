<html>
	<head>
		<TITLE>ISE.ReflectionInterface.dll</TITLE>
		<LINK REL="StyleSheet" HREF="/default.css">
		<META NAME ="MS-HKWD" CONTENT = "ISE.Reflection.ReflectionInterface.dll">
		<META NAME ="MS-HKWD" CONTENT = "Reflection interface">
		<META NAME ="MS-HKWD" CONTENT = "Database, storage, retrieval, removal">
	</head>

	<body>

		<br><br>
		<h2>3. ISE.Reflection.ReflectionInterface.dll</h2>

				<p>
						The ISE reflection interface is aimed at connecting .NET names with corresponding Eiffel names by using XML files. It is a kind of database where you put XML files describing .NET types and you retrieve a more user-friendly type description. <br>
						Only shared assemblies can be stored in this database.
				</p>
				<br>

				<a name = storage></a>
				<h3>3.1 How can I put a type in the database?</h3>
				<br>

						<a name = start_storage></a>
						<h4>3.1.1 Start assembly storage...</h4>

								<p>
										First, you have to notify the database you want to start storage by calling one of the two following features: <SPAN CLASS = "efeature">start_assembly_storage_from_type</SPAN> or <SPAN CLASS = "efeature">start_assembly_storage_from_info</SPAN>. <br>
										In fact, the interface assumes you will store an entire assembly, meaning all the types in the assembly. So you have to specify the assembly before adding any type.<br>
										Depending on the context you are using ISE reflection interface, you may prefer to call <SPAN CLASS = "efeature">start_assembly_storage_from_type</SPAN> or <SPAN CLASS = "efeature">start_assembly_storage_from_info</SPAN>. These two features do exactly the same thing, namely notify the database that storage begins. So the choice is really up to you, it is just a matter of convenience.<br><br>

										Short forms of these features can be found in the delivery. At this point, feature signatures will be enough for explanations:
										<P CLASS= "code">
												<SPAN CLASS = "efeature">start_assembly_storage_from_type</SPAN> <SPAN CLASS = "esymbol">(</SPAN><SPAN CLASS = "elocal">a_type</SPAN><SPAN CLASS = "esymbol">:</SPAN> <SPAN CLASS = "eclass">SYSTEM_TYPE</SPAN><SPAN CLASS = "esymbol">)</SPAN><br>
												<SPAN CLASS = "efeature">start_assembly_storage_from_info</SPAN> <SPAN CLASS = "esymbol">(</SPAN><SPAN CLASS = "elocal">a_version</SPAN><SPAN CLASS = "esymbol">,</SPAN> <SPAN CLASS = "elocal">a_culture</SPAN><SPAN CLASS = "esymbol">,</SPAN> <SPAN CLASS = "elocal">a_public_
												key</SPAN><SPAN CLASS = "esymbol">:</SPAN> <SPAN CLASS = "eclass">STRING</SPAN><SPAN CLASS = "esymbol">)</SPAN><br>
										</P>

										As mentioned earlier, the point is to specify the assembly you will work on. So you can either give an instance of <SPAN CLASS = "eclass">SYSTEM_TYPE</SPAN> (<SPAN CLASS = "eclass">System.Type</SPAN>) or the assembly version, culture and public key, knowing that only this information will be internally used by the database.
										<br><br>

										Several processes may use this database at the same time. Therefore it provides a synchronization mechanism between concurrent processes. Actually, each time a user asks for storage, a write lock file is generated, and each time a user asks for retrieval, a read lock file is created. When you call one the two previous features to start assembly storage, you cannot be aware other users are currently reading or writing. The reflection interface will check whether storage is possible and make result available in <SPAN CLASS = "efeature">last_write_successful</SPAN>. <br>
										Thus, you have to check <SPAN CLASS = "efeature">last_write_successful</SPAN> is True before adding any type.
								</p>
						<br>

						<a name = add_type></a>
						<h4>3.1.2 Add a type to the database...</h4>

								<p>
										Once you have notified the database that you start storage and checked start was successful, you can add a new type by calling feature:
								</p>
								<P CLASS = "code">
										<SPAN CLASS = "efeature">add_type</SPAN> <SPAN CLASS = "esymbol">(</SPAN><SPAN CLASS = "elocal">xml_filename</SPAN><SPAN CLASS = "esymbol">:</SPAN> <SPAN CLASS = "eclass">STRING</SPAN><SPAN CLASS = "esymbol">)</SPAN>
								</P>
								<p>
										The argument <SPAN CLASS = "elocal">xml_filename</SPAN> is the path to type description XML file.<br>
								</p>
								<p>
										As highlighted before, the ISE reflection interface is designed in a way you can add as many types as you want to the database by calling <SPAN CLASS = "efeature">add_type</SPAN>, with no need to call `start_assembly_storage_from...' on the condition all types belong to the same assembly.
								</p>
								<p>
										In fact, if you use assembly `ISE.Reflection.CodeGenerator.dll' to generate your Xml files (usually by calling the emitter), you don't have to call <SPAN CLASS = "efeature">add_type</SPAN>, since generators from `ISE.Reflection.CodeGenerator.dll' automatically put generated files in the database. This feature is only provided in case you want to generate XML files on your own.
								</p>
						<br>

						<a name = end_storage></a>
						<h4>3.1.3 End assembly storage...</h4>

								<p>
										In the same way you have notified the database you want to store data, you have to notify you have finished to store types, at least in this assembly, by calling <SPAN CLASS = "efeature">end_assembly_storage</SPAN>.<br>
										This feature takes no argument. It only has a function of notification. When <SPAN CLASS = "efeature">end_assembly_storage</SPAN> is called, the database will remove write lock on the assembly.
								</p>
				<br>

			<a name = retrieval></a>
			<h3>3.2 How can I retrieve information from the database?</h3>
			<br>

					<a name = assembly_retrieval></a>
					<h4>3.2.1 Retrieve an assembly...</h4>

							<p>
									The first kind of information you may want to retrieve is an assembly. In the same way you had two features to start assembly storage, ISE reflection interface provides two queries to get information about an assembly:
							</P>
										<P CLASS= "code">
												<SPAN CLASS = "efeature">assembly_from_type</SPAN> <SPAN CLASS = "esymbol">(</SPAN><SPAN CLASS = "elocal">a_type</SPAN><SPAN CLASS = "esymbol">:</SPAN> <SPAN CLASS = "eclass">SYSTEM_TYPE</SPAN><SPAN CLASS = "esymbol">)</SPAN><SPAN CLASS = "esymbol">:</SPAN> <SPAN CLASS = "eclass">EIFFEL_ASSEMBLY</SPAN><br>
												<SPAN CLASS = "efeature">assembly_from_info</SPAN> <SPAN CLASS = "esymbol">(</SPAN><SPAN CLASS = "elocal">a_version</SPAN><SPAN CLASS = "esymbol">,</SPAN> <SPAN CLASS = "elocal">a_culture</SPAN><SPAN CLASS = "esymbol">,</SPAN> <SPAN CLASS = "elocal">a_public_
												key</SPAN><SPAN CLASS = "esymbol">:</SPAN> <SPAN CLASS = "eclass">STRING</SPAN><SPAN CLASS = "esymbol">)</SPAN><SPAN CLASS = "esymbol">:</SPAN> <SPAN CLASS = "eclass">EIFFEL_ASSEMBLY</SPAN><br>
										</P>
							<P>
									The first feature may be more convenient sometimes, but the only information used by the database to retrieve assembly description file is version, culture and key.<br>
									Then it will use the XML file to generate an instance of <SPAN CLASS = "eclass">EIFFEL_ASSEMBLY</SPAN> (cf. <a href = "./Eiffel_components.html">2. ISE.Reflection.EiffelComponents.dll</a>), which may be easier to use.
							</p>
					<br>

					<a name = type_retrieval></a>
					<h4>3.2.2 Retrieve a type...</h4>

							<p>
									ISE reflection interface also provides a query (<SPAN CLASS = "efeature">type</SPAN>) to get information about a .NET type. Its signature is:
							</P>
							<P CLASS = "code">
									<SPAN CLASS = "efeature">type</SPAN> <SPAN CLASS = "esymbol">(</SPAN><SPAN CLASS = "elocal">a_type</SPAN><SPAN CLASS = "esymbol">:</SPAN> <SPAN CLASS = "eclass">SYSTEM_TYPE</SPAN><SPAN CLASS = "esymbol">)</SPAN><SPAN CLASS = "esymbol">:</SPAN> <SPAN CLASS = "eclass">EIFFEL_CLASS</SPAN>
							</P>
							<P>
									First, the database looks for the assembly defining this type by using type assembly qualified name. Then, it uses type full name to find location of type description XML file. At last, it uses XML file to generate a more user-friendly representation that is an instance of <SPAN CLASS = "eclass">EIFFEL_CLASS</SPAN> (<SPAN CLASS = "eclass">EiffelClass</SPAN>).<br>
									This class provides useful information to match .NET names and Eiffel names (cf. <a href = "./Eiffel_components.html">2. ISE.Reflection.EiffelComponents.dll</a>).
							</p>
					<br>

					<a name = assemblies_retrieval></a>
					<h4>3.2.3 Retrieve all the assemblies...</h4>

							<p>
									ISE reflection interface also provides a query called <SPAN CLASS = "efeature">assemblies</SPAN>, which enables you to get all the assemblies stored in the database. The result is an instance of <SPAN CLASS = "eclass">SYSTEM_COLLECTIONS_ARRAYLIST</SPAN> (<SPAN CLASS = "eclass">System.Collections.ArrayList</SPAN>), which is in fact a list of <SPAN CLASS = "eclass">EIFFEL_ASSEMBLY</SPAN> (cf. <a href = "./Eiffel_components.html">2. ISE.Reflection.EiffelComponents.dll</a>).<br>
									A point that has not been mentioned yet is that database keeps a kind of index in XML format with paths to assembly description XML files, that is used to build this list of <SPAN CLASS = "eclass">EIFFEL_ASSEMBLY</SPAN> (<SPAN CLASS = "eclass">EiffelAssembly</SPAN>). This index is updated each time feature <SPAN CLASS = "efeature">end_assembly_storage</SPAN> is called (not earlier to be sure that no error has occurred during storage).
							</p>
					<br>

					<a name = concurrence_issue></a>
					<h4>3.2.4 Concurrence issue</h4>

							<p>
									In the same way storage may be impossible because of concurrent processes, data retrieval may also fail. Therefore, ISE reflection interface updates a boolean called <SPAN CLASS = "efeature">last_read_successful</SPAN> to let you about this.<br>
									In both cases, you can have some more information about the storage/retrieval error by calling <SPAN CLASS = "efeature">last_error</SPAN>. This query return an instance of <SPAN CLASS = "eclass">REFLECTION_ERROR_INFO</SPAN>, which has three attributes: <SPAN CLASS = "efeature">code</SPAN><SPAN CLASS = "esymbol">:</SPAN> <SPAN CLASS = "eclass">INTEGER</SPAN>, <SPAN CLASS = "feature">name</SPAN><SPAN CLASS = "esymbol">:</SPAN> <SPAN CLASS = "eclass">STRING</SPAN> and <SPAN CLASS = "efeature">description</SPAN><SPAN CLASS = "esymbol">:</SPAN> <SPAN CLASS = "eclass">STRING</SPAN>.
							</p>

			<br>

			<a name = removal></a>
			<h3>3.3 How can I remove an assembly from the database?</h3>

					<p>
							In the same way you had two features to start assembly storage or retrieve an assembly from the database, ISE reflection interface provides two procedures to remove an assembly from the database:
					</p>
					<P CLASS= "code">
							<SPAN CLASS = "efeature">remove_assembly_from_type</SPAN> <SPAN CLASS = "esymbol">(</SPAN><SPAN CLASS = "elocal">a_type</SPAN><SPAN CLASS = "esymbol">:</SPAN> <SPAN CLASS = "eclass">SYSTEM_TYPE</SPAN><SPAN CLASS = "esymbol">)</SPAN><br>
							<SPAN CLASS = "efeature">remove_assembly_from_info</SPAN> <SPAN CLASS = "esymbol">(</SPAN><SPAN CLASS = "elocal">a_version</SPAN><SPAN CLASS = "esymbol">,</SPAN> <SPAN CLASS = "elocal">a_culture</SPAN><SPAN CLASS = "esymbol">,</SPAN> <SPAN CLASS = "elocal">a_public_
							key</SPAN><SPAN CLASS = "esymbol">:</SPAN> <SPAN CLASS = "eclass">STRING</SPAN><SPAN CLASS = "esymbol">)</SPAN><br>
					</P>
					<p>
							These two features perform the same task. Thus choosing one rather than the other is totally up to you. It is just a matter of convenience.<br>
							When you remove an assembly from the database, it will not only remove the folder containing all XML files but it will also update the `index.xml' with all assemblies folder names in the database. If there is no assembly left in the database, `index.xml' will be destroyed.
					</p>
					<p>
							Before removing an assembly, the ISE reflection interface checks there are no access violation problem. It will make result available in <SPAN CLASS = "efeature">last_removal_successful</SPAN>.
					</p>

			<br>

			<a name = hash_value></a>
			<h3>3.4 MD5 Hash algorithm (`ISE.Reflection.Support')</h3>

					<p>
							ISE reflection interface uses MD5 hash algorithm to generate unique names for assembly folders. Therefore you will find a feature called <SPAN CLASS = "efeature">hash_value</SPAN> <SPAN CLASS = "esymbol">(</SPAN><SPAN CLASS = "elocal">a_string</SPAN><SPAN CLASS = "esymbol">:</SPAN> <SPAN CLASS = "eclass">STRING</SPAN><SPAN CLASS = "esymbol">)</SPAN><SPAN CLASS = "esymbol">:</SPAN> <SPAN CLASS = "eclass">STRING</SPAN> in dynamic library `ISE.Reflection.Support', which gives the hash value of <SPAN CLASS = "elocal">a_string</SPAN> by using MD5 algorithm provided by the SDK framework.<br>
							This feature is used internally by `start_assembly_storage...' to create the folder where Xml files will be stored. <br>
							It is also used by the generators of `ISE.Reflection.CodeGenerator.dll' to generate xml files in the right folder.
					</p>
		<br><br>
	</body>
</html>