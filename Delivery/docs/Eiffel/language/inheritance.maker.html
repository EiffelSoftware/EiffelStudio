<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<TITLE>Inheritance</TITLE>
<link rev="made" href="mailto:webmaster@eiffel.com">
<link rel="stylesheet" href="../../styles/tech.css" type="text/css">

<meta name="Microsoft Border" content="t, default">
</head>

<body><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><table border="0" cellspacing="0" cellpadding="0" width="100%">
  <tr>
    <td valign="top" bgcolor="#000063" width="291"><b><font face="Arial" size="4" color="#FFFFFF">Interactive<br>
      Software Engineering</font></b></td>
    <td valign="top" bgcolor="#000063" width="720"><b><font face="Arial" size="6" color="#FFFFCC">Inheritance</font></b></td>
  </tr>
  <tr>
    <td colspan="2" valign="top" width="100%">
<p align="center"><nobr>[&nbsp;<a href="../../index.html">Home</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../../release_notes.html">Release&nbsp;Notes</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../../papers/index.html">Technology&nbsp;Papers</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../../install.html">Installation&nbsp;Notes</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../index.html">About&nbsp;Eiffel</a>&nbsp;]</nobr>
<hr>

    </td>
  </tr>
</table></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><!--msnavigation--><td valign="top"><table cols="1" cellpadding="5" cellspacing="0" border="0">
<tr><td>

<H2><A NAME="HDR0"></A>8 INHERITANCE</H2>

<P>Inheritance, the other fundamental generalization mechanism, makes it
possible to define a new class by combination and specialization of existing
classes rather than from scratch. </P>

<P>The following simple example, from the Data Structure Library in EiffelBase,
is typical. <I>LIST</I>, as indicated, describes lists in any meaningful
representation. One such representation if the lists have a fixed number
of elements uses an array. We may define the corresponding class by combination
of <I>LIST</I> and <I>ARRAY</I>, as follows: </P>

    <ul>
<DL>
<DT><B><FONT COLOR="#0000FF">class </FONT></B><I>ARRAYED_LIST [G] </I><B><FONT COLOR="#0000FF">inherit
</FONT></B><BR>
<BR>
</DT>

<DD><I>LIST [G]; </I><BR>
<BR>
</DD>

<DD><I>ARRAY [G] </I></DD>

<DD><B><FONT COLOR="#FFFFFF">export </FONT></B>... See below ...<BR>
<BR>
</DD>

<DT><B><FONT COLOR="#0000FF">feature </FONT></B><BR>
<BR>
</DT>

<DD><I>... </I>Specific features of fixed-size lists ... <BR>
<BR>
</DD>

<DT><B><FONT COLOR="#0000FF">end </FONT></B><I>-- </I>class<I> ARRAYED_LIST
</I></DT>
</DL>
    </ul>

<P>The <B><I>inherit</I></B>... clause lists all the &quot;parents&quot;
of the new class, which is said to be their &quot;heir&quot;. (The &quot;ancestors&quot;
of a class include the class itself, its parents, grandparents etc.; the
reverse term is &quot;descendant&quot;.) Declaring <I>ARRAYED_LIST</I>
as shown ensures that all the features and properties of lists and arrays
are applicable to fixed lists as well. Since the class has more than one
parent, this is a case of <I>multiple</I> inheritance. </P>

<P>Standard graphical conventions serve to illustrate such inheritance
structures: </P>

<CENTER><P><IMG SRC="inheritance.maker.fig_1.gif" HEIGHT=140 WIDTH=318>
</P></CENTER>

<H3 ALIGN=CENTER><B><I>An inheritance structure</I></B></H3>

<P>An heir class such as <I>ARRAYED_LIST</I> needs the ability to define
its own export policy. By default, inherited features keep their export
status (publicly available, secret, available to selected classes only);
but this may be changed in the heir. Here, for example, <I>ARRAYED_LIST</I>
will export only the exported features of <I>LIST</I>, making those of
<I>ARRAY</I> unavailable directly to <I>ARRAYED_LIST</I>'s clients. The
syntax to achieve this is straightforward: </P>

    <ul>
<DL>
<DT><B><FONT COLOR="#0000FF">clas<I>s</I></FONT></B><I><FONT COLOR="#0000FF">
</FONT>ARRAYED_LIST [G] </I><B><FONT COLOR="#0000FF">inherit </FONT></B><BR>
<BR>
</DT>

<DD><I>LIST [G]; </I><BR>
<BR>
</DD>

<DD><I>ARRAY [G] </I></DD>

<DL>
<DD><B><FONT COLOR="#0000FF">export </FONT></B><I>{NONE}<B> </B></I><B><FONT COLOR="#0000FF">all
end </FONT></B></DD>
</DL>

<P><BR>
<BR>
</P>

<DT><I>... </I>The rest as above ... </DT>
</DL>
    </ul>

<P>Another example of multiple inheritance comes from a windowing system
based on a class <I>WINDOW</I>, close to actual classes in EiffelVision.
Windows have <B>graphical</B> features: a height, a width, a position,
routines to scale windows, move them, and other graphical operations. The
system permits windows to be nested, so that a window also has <B>hierarchical</B>
features: access to subwindows and the parent window, adding a subwindow,
deleting a subwindow, attaching to another parent and so on. Rather than
writing a complex class that would contain specific implementations for
all of these features, it is preferable to inherit all hierarchical features
from <I>TREE</I> (a class in EiffelBase describing trees), and all graphical
features from a class <I>RECTANGLE</I>. </P>

<P>Inheritance yields remarkable economies of effort -- whether for analysis,
design, implementation or evolution -- and has a profound effect on the
entire software development process. </P>

<P>The very power of inheritance demands adequate means to keep it under
control. Multiple inheritance, in particular, raises the question of name
conflicts between features inherited from different parents; this case
will inevitably arise in practice, especially for classes contributed by
independent developers. Such a name conflict may be removed through <B>renaming</B>,
as in </P>

    <ul>
<DL>
<DT><B><FONT COLOR="#0000FF">class </FONT></B><I>C </I><B><FONT COLOR="#0000FF">inherit
</FONT></B><BR>
<BR>
</DT>

<DD><I>A </I><B><FONT COLOR="#0000FF">rename </FONT></B><I>x </I><B><FONT COLOR="#0000FF">a<I>s</I></FONT></B><I><FONT COLOR="#0000FF">
</FONT>x1, y </I><B><FONT COLOR="#0000FF">as</FONT></B> <I>y1 </I><FONT COLOR="#0000FF"><B>end</B><I>
</I></FONT><BR>
<BR>
</DD>

<DD><I>B </I><B><FONT COLOR="#0000FF">rename </FONT></B><I>x </I><B>as
</B><I>x2, y </I><B><FONT COLOR="#0000FF">as </FONT></B><I>y2 </I><B><FONT COLOR="#0000FF">end
</FONT></B><BR>
<BR>
</DD>

<DT><B><FONT COLOR="#0000FF">feature</FONT></B><I>... </I></DT>
</DL>
    </ul>

<P>Here, if both <I>A </I>and <I>B</I> have features named <I>x</I> and<I>
y</I>, class <I>C</I> would be invalid without the renaming. </P>

<P>Renaming also serves to provide more appropriate feature names in descendants.
For example, class <I>WINDOW</I> may inherit a routine <I>insert_subtree</I>
from <I>TREE</I>. For clients of <I>WINDOW</I>, however, such a routine
name is no longer appropriate. An application using this class for window
manipulation needs coherent window terminology, and should not be concerned
with the inheritance structure that led to the implementation of the class.
So you may wish to rename <I>insert_subtree</I> as <I>add_subwindow</I>
in the inheritance clause of <I>WINDOW</I>. </P>

<P>As a further facility to protect against misusing the multiple inheritance
mechanism, the invariants of all parent classes automatically apply to
a newly defined class. So classes may not be combined if their invariants
are incompatible. </P>

<center>
<P><A HREF="genericity.maker.html"><IMG SRC="fm2html-previous.gif" HEIGHT=16 WIDTH=16></A> <A HREF="BOOK.maker.html"><IMG SRC="fm2html-toc.gif" HEIGHT=16 WIDTH=16></A> <A HREF="polymorphism.maker.html"><IMG SRC="fm2html-next.gif" HEIGHT=16 WIDTH=16></A>
</center>

  </td></tr></table>&nbsp;<!--msnavigation--></td></tr><!--msnavigation--></table></BODY>
</HTML>
