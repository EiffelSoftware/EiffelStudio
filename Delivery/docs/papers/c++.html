

<HTML>
<head>
<TITLE>Eiffel-C++ interface and Legacy++</TITLE>

<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Legacy++ and the C++ interface</title>
<link rev="made" href="mailto:webmaster@eiffel.com">
<link rel="stylesheet" href="../styles/tech.css" type="text/css">
<meta name="Microsoft Border" content="t, default">
</head>

<BODY><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td><table border="0" cellspacing="0" cellpadding="0" width="100%">
  <tr>
    <td valign="top" bgcolor="#000063" width="291"><b><font face="Arial" size="4" color="#FFFFFF">Interactive<br>
      Software Engineering</font></b></td>
    <td valign="top" bgcolor="#000063" width="720"><b><font face="Arial" size="6" color="#FFFFCC">Legacy++ and the C++ interface</font></b></td>
  </tr>
  <tr>
    <td colspan="2" valign="top" width="100%">
<p align="right"><nobr>[&nbsp;<a href="../index.html">Home</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../release_notes.html">Release&nbsp;Notes</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="index.html">Technology&nbsp;Papers</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../install.html">Installation&nbsp;Notes</a>&nbsp;]</nobr> <nobr>[&nbsp;<a href="../Eiffel/index.html">About&nbsp;Eiffel</a>&nbsp;]</nobr>
    </td>
  </tr>
</table></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><!--msnavigation--><td valign="top"><table cols="1" cellpadding="5" cellspacing="0" border="0">
<tr><td>

<IMG SRC="../images/power.gif" ALT="Eiffel Power (TM) from ISE" VSPACE="2"
ALIGN=RIGHT width="109" height="226">
This document is appendix F to the manual
<I>Eiffel: The Environment</I>.
References to "the previous appendix" denote appendix E of
the manual, which describes the C interface.
<P>
The C++ interface and Legacy++ are part of all versions of ISE Eiffel
starting with version 4.1.
<H2>1 OVERVIEW</H2>
<P>
Eiffel software must interact with software written in other languages. The previous appendix
described how to access C software from Eiffel; in the present one you will learn about how
to incorporate C++ classes in your Eiffel software.
<P>
The C++ interface offers the following mechanisms:
    <ul>
<p>&nbsp;
      <li> You can create instances of C++ classes from Eiffel, using the C++ "constructor" of
your choice.</li>

<p>&nbsp;
      <li> You can apply to these objects all the corresponding operations from the C++ class:
executing functions ("methods"), accessing data members, executing destructors.</li>

<p>&nbsp;
      <li>You can use the Legacy++ tool to produce an Eiffel "wrapper class" encapsulating all
the features of a C++ class, so that the result will look to the rest of the Eiffel software
as if it had been written in Eiffel.</li>
    </ul>
<P>

To profit best from this appendix, it will be useful to be familiar with the essentials of
the C interface as described in the preceding appendix in
<I>Eiffel: The Environment</I>.
<P>
The discussion concentrates on using C++ software from Eiffel. In the other direction,
as noted in the preceding appendix, you can use the Cecil library (C-Eiffel Call-In Library)
described in chapter 24 of
<A HREF="/G:/Delivery/docs/Eiffel/books.html#etl"><I>Eiffel: The Language</I></A>
with important complements in the
<A HREF="/doc/manuals/technology/library/cecil/page.html">on-line Cecil manual</A>
and at ftp://ftp.eiffel.com.
<P>
&nbsp;
<H2>2 THE SYNTAX SPECIFICATION</H2>
<P>
In the following specification,
the syntax for <FONT COLOR="#AA00FF">External</FONT> and <FONT COLOR="#AA00FF">External_name</FONT> is
retained unchanged from <I>Eiffel: The Language</I>, where
<FONT COLOR="#AA00FF">Language_name</FONT> is defined simply as
<FONT COLOR="#AA00FF">Manifest_string</FONT>;
the rest covers the additional facilities.
<FONT COLOR="#AA00FF">
<PRE>
    External == external Language_name [External_name]

    Language_name ==
            '&quot;'
            Basic_language_name
            [Special_external_declaration]
            [Signature]
            [Include_files]
                    '&quot;'

    Basic_language_name == &quot;C&quot; | &quot;C++&quot;

    Special_external_declaration == &quot;[&quot; Special_feature &quot;]&quot;

    Special_feature == Special_C_feature | Special_C++_feature

    Special_C_feature == <FONT COLOR="#FF0000">... See appendix E...</FONT>

    Special_C++_feature ==
            Member_function_call|
            Static_function_call |
            Object_creation |
            Object_deletion |
            Data_member_access |

    Member_function_call == C++_Class

    C++_Class == Class_name File_name

    Class_name == Identifier

    Static_function_call == <B><FONT COLOR="#000080">static</FONT></B> C++_Class

    Object_creation == <B><FONT COLOR="#000080">new</FONT></B> C++_Class

    Object_deletion == <B><FONT COLOR="#000080">delete</FONT></B> C++_Class

    Data_member_access == <B><FONT COLOR="#000080">data_member</FONT></B> C++_Class

                <FONT COLOR="#FF0000">-- The remaining elements are repeated</FONT>
                <FONT COLOR="#FF0000">-- from the C interface specification (page 291 in <I>Eiffel: The Environment</I>).</FONT> 

    File_name ==  User_file_name | System_file_name

    User_file_name == '%&quot;' Manifest string '%&quot;'

    System_file_name == &quot;&lt;&quot; Manifest_string &quot;&gt;&quot;

    Signature ==  &quot;(&quot; Type_list &quot;)&quot; [Result_type]

    Type_list ==  {Type &quot;,&quot; ...}

    Result_type ==  &quot;:&quot; Type

    Include_files ==  &quot;|&quot; File_list

    File_list ==  {File_name &quot;,&quot; ...}

    External_name ==  <B><FONT COLOR="#000080">alias</FONT></B> Manifest_string
</PRE>
</FONT>
<P>
As with the C extensions of the previous appendix, the syntax description conventions are those of
<I>Eiffel: The Language</I>.  means "is defined as". The vertical bar <FONT COLOR="#AA00FF">|</FONT> separates alternative choices, such as the three
possibilities for Special_feature. The brackets <FONT COLOR="#AA00FF">[...]</FONT> enclose optional components; for example a
<FONT COLOR="#AA00FF">Language_name</FONT> is made of required quotes, a required Basic_language_name and three further
components, any or all of which may be absent. The notation <FONT COLOR="#AA00FF">{Element Separator ...}</FONT> means: 0
or more occurrences ("specimens") of <FONT COLOR="#AA00FF">Element</FONT> separated, if more than one, by <FONT COLOR="#AA00FF">Separator</FONT>.
<P>
Several of the symbols of the syntax notation, such as the brackets or the vertical bar, also appear in
the language; to avoid any confusion they are given in double quotes. For example the specification
for <FONT COLOR="#AA00FF">Include_files</FONT> begins with <FONT COLOR="#AA00FF">"|"</FONT> to indicate that an <FONT COLOR="#AA00FF">Include_files</FONT> part starts with a vertical bar. Single
quotes may be used instead of double quotes when one of the quoted characters is itself a double
quote; for example <FONT COLOR="#AA00FF">'%"'</FONT> appearing in the production for <FONT COLOR="#AA00FF">User_file_name</FONT> denotes the percent character
followed by the double quote character. Special words such as <B><FONT COLOR="#AA00FF">static</FONT></B> in bold italics stand for
themselves, unquoted.
<P>
&nbsp;
<H2>3 AVAILABLE POSSIBILITIES</H2>
<P>
&nbsp;
<H3><I>3.1 Processing C++ features</I></H3>
<P>
A <FONT COLOR="#AA00FF">Special_C++_feature</FONT>, if present, indicates one of the following, all illustrated by examples in
the next sections:
    <ul>
      <li>
If the special feature's declaration simply starts with a C++ class name, followed by the
associated file name, it indicates that the Eiffel feature will call a C++ member function
(also known as a "method") from that class. The name of the member function is by
default the same as the name of the Eiffel feature; as usual, you can specify a different
name through the alias clause of the external declaration.</li>
      <BR><BR>
      <li>
If the declaration starts with <B><FONT COLOR="#000080">static</FONT></B>, it indicates a call to a C++ static function.</li>
      <BR><BR>
      <li>
If the declaration starts with <B><FONT COLOR="#000080">new</FONT></B>, it indicates a call to one of the constructors in the C++
class, which will create a new instance of that class and apply to it the corresponding
constructor function.</li>
      <BR><BR>
      <li>
If the declaration starts with <B><FONT COLOR="#000080">delete</FONT></B>, it indicates a call to a destructor from the C++ class.
In this case the Eiffel class will inherit from <I>MEMORY</I> and redefine the dispose procedure
to execute the destructor operations whenever the Eiffel objects are garbage-collected.</li>
      <BR><BR>
      <li>
If the declaration starts with <B><FONT COLOR="#000080">data_member</FONT></B>,
it indicates access to a data member (attribute
in Eiffel terminology) from the C++ class.</li>
    </ul>
<P>
The rest of the possible components are the same as in the C interface:
<FONT COLOR="#AA00FF">Signature</FONT> to specify
types for arguments and results; possible <FONT COLOR="#AA00FF">Include</FONT> file.
<P>
&nbsp;
<H3><I>3.2 Extra argument</I></H3>
<P>
For a non-static C++ member function or destructor, the corresponding Eiffel feature should
include an extra argument of type POINTER, at the first position. This argument represents the
C++ object to which the function will be applied.
<P>
For example, a C++ function<PRE>
    void add (int new_int);
</PRE>
<P>
should have the Eiffel counterpart
<P>
&nbsp;
    <ul>
<I>cpp_add</I> (<I>obj: POINTER; new_int: INTEGER</I>) <B><FONT COLOR="#000080">is</FONT></B>
      <ul>
        <ul>
<FONT COLOR="#FF0000">-- Encapsulation of member function </FONT><I>add</I>.
        </ul>
<B><FONT COLOR="#000080">external</FONT></B>
        <ul>
"<I>C++</I> [<I>IntArray %</I>"<I>intarray.h%</I>"] (<I>IntArray *, int</I>)"
        </ul>
<B><FONT COLOR="#000080">end</FONT></B>
      </ul>
    </ul>
This scheme, however, is often inconvenient because it forces the Eiffel side to work on
objects in a non-object-oriented way. (The object-oriented way treats the current object, within
a class, as implicit.) A better approach, used by Legacy++, is to make a feature such as cpp_add
secret, and to export a feature whose signature corresponds to that of the original C++ function,
with no extra object argument; that feature will use a secret attribute object_ptr to access the
object. In the example this will give the feature
<P>
&nbsp;
    <ul>
<I>add</I> (<I>new_int</I>:<I> INTEGER</I>) <B><FONT COLOR="#000080">is</FONT></B>
      <ul>
        <ul>
<FONT COLOR="#FF0000">-- Encapsulation of member function </FONT><I>add</I>.
        </ul>
<B><FONT COLOR="#000080">do</FONT></B>
        <ul>
<I>cpp_add</I> (<I>object_ptr, new_int</I>)
        </ul>
<B><FONT COLOR="#000080">end</FONT></B>
      </ul>
    </ul>
<P>
where <I>object_ptr</I> is a secret attribute of type <I>POINTER</I>, initialized by the creation procedures
of the class. To the Eiffel developer, add looks like a normal object-oriented feature, which
takes only the expected argument. Further examples appear below.
<P>
There is no need for an extra argument in the case of static member functions, constructors
and data members.
<P>
&nbsp;
<H2>4 WRAPPING C++ CLASSES: LEGACY++</H2>
<P>
Before taking a look at examples of the various facilities mentioned, it is useful to consider the
tool that will help you, in many cases, avoid worrying about their details.
<P>
&nbsp;
<H3><I>4.1 The role of Legacy++</I></H3>
<P>
Often you will want to provide an Eiffel encapsulation of all the facilities -- member functions,
static functions, constructors, destructors, data members -- of a C++ class. This means
producing an Eiffel class that will provide an Eiffel feature for each one of these C++ facilities,
using external declarations based on the mechanisms listed in the preceding section.
<P>
Rather than writing these external declarations and the class structure manually, you can
use the Legacy++ tool to produce the Eiffel class automatically from the C++ class.
<P>
&nbsp;
<H3><I>4.2 Calling Legacy++</I></H3>
<P>
Legacy++ is called with an argument denoting a <I>.h</I> file that must contain C++ code: one or more
classes and structure declarations. It will translate these declarations into Eiffel wrapper
classes.
<P>
The following options are available:
    <ul>
      <li>
<B>-E</B>: apply the C preprocessor to the file, so that it will process #include, #define, #ifdef
and other preprocessor directives. This is in fact the default, so that you do not need to
specify -E explicitly (see next option).</li>
      <BR><BR>
      <li>
<B>-NE</B>: do not apply the C preprocessor to the file.</li>
      <BR><BR>
      <li>
<B>-p </B><I>directories</I>: use <I>directories</I> as include path.</li>
      <BR><BR>
      <li>
<B>-c</B><I>compiler</I>: use <I>compiler</I> as the C++ compiler.</li>
      <BR><BR>
      <li>
<B>-g</B>: treat the C++ code as being intended for the GNU C++ compiler.</li>
    </ul>
<P>
&nbsp;
<H3><I>4.3 Result of applying Legacy++</I></H3>
<P>
Running Legacy++ on a C++ file will produce the corresponding Eiffel classes. Legacy++
processes not only C++ classes but also C++ "structs"; in both cases it will generate an Eiffel
class.
<P>
Legacy++ knows about default specifiers: public for classes, private for structs.
<P>
Legacy++ will generate Eiffel features for member functions (static or not).
<P>
It will also handle any constructors and destructors given in the C++ code, yielding the
corresponding Eiffel creation procedures. If there is no constructor, it will produce a creation
procedure with no arguments and an empty body.
<P>
For any non-static member function or destructor, Legacy++ will generate a secret feature
with an extra argument representing the object, as explained in the preceding earlier in this
appendix. It will also produce a public feature with the same number of arguments as the C++
function, relying on a call to the secret feature, as illustrated for add and cpp_add above.
<P>
The * char type is translated into <I>STRING</I>. Pointer types, as well as reference types
corresponding to classes and types that Legacy++ has processed, will be translated into
<I>POINTER</I>. Other types will yield the type <I>UNRESOLVED_TYPE</I>.
<P>
&nbsp;
<H3><I>4.4 Legacy++ limitations</I></H3>
<P>
It is up to you to supply Eiffel equivalents of all the needed types. If Legacy++ encounters the
name of a C++ class or type that is does not know -- i.e. it is neither a predefined type nor a
previously translated class -- it will use the Eiffel type name <I>UNRESOLVED_TYPE</I>. If you do
not change that type in the generated class, the Eiffel compiler will produce an error (unknown
class) at degree 5.
<P>
Legacy++ does not handle inline function declarations.
<P>
Legacy++ makes no effort to understand the C++ inheritance structure.
<P>
More generally, given the differences in the semantic models of C++ and Eiffel, Legacy++
can only perform the basic Eiffel wrapping of a C++ class, rather than a full translation. You
should always inspect the result and be prepared to adapt it manually.
<P>
Legacy++'s contribution is to take care of the bulk of the work, in particular the tedious
and repetitive parts. The final details are left to the Eiffel software developer.
<P>
&nbsp;
<H2>5 AN EXAMPLE</H2>
<P>
Consider the following C++ class, which has an example of every kind of facility that one may
wish to access from the Eiffel side:<PRE>
    class IntArray

            {

            public:

                IntArray (int size);

                ~IntArray ();

                void output ();

                void add (int new_int);

                static char * type ();

            protected:

                int *_integers;

            };
</PRE>
<P>
Here is the result of applying Legacy++ to that class, which will serve as an illustration of
both the C++ interface mechanisms and Legacy++:<PRE>
    <B><FONT COLOR="#000080">indexing</FONT></B><I>
        description</I>:<I>
            &quot;Eiffel encapsulation of C++ class IntArray&quot;;

        date: &quot;$Date$&quot;;
        revision: &quot;$Revision$&quot;

    </I><B><FONT COLOR="#000080">class</FONT></B><I>
        INTARRAY

    </I><B><FONT COLOR="#000080">inherit</FONT></B><I>
        MEMORY
            </I><B><FONT COLOR="#000080">redefine</FONT></B><I>
                dispose
            </I><B><FONT COLOR="#000080">end</FONT></B><I>

    </I><B><FONT COLOR="#000080">creation</FONT></B><I>
        make

    </I><B><FONT COLOR="#000080">feature</FONT></B> <FONT COLOR="#FF0000">-- Initialization</FONT><I>

        make (size: INTEGER) </I><B><FONT COLOR="#000080">is</FONT></B><I>
                </I><FONT COLOR="#FF0000">-- Create Eiffel and C++ objects.</FONT><I>
            </I><B><FONT COLOR="#000080">do</FONT></B><I>
                object_ptr := cpp_new (size)
            </I><B><FONT COLOR="#000080">end</FONT></B><I>

    </I><B><FONT COLOR="#000080">feature</FONT></B> <FONT COLOR="#FF0000">-- Removal</FONT><I>

        dispose </I><B><FONT COLOR="#000080">is</FONT></B><I>
                </I><FONT COLOR="#FF0000">-- Delete C++ object.</FONT><I>
            </I><B><FONT COLOR="#000080">do</FONT></B><I>
                cpp_delete (object_ptr)
            </I><B><FONT COLOR="#000080">end</FONT></B><I>

    </I><B><FONT COLOR="#000080">feature</FONT></B><I>

        output </I><B><FONT COLOR="#000080">is</FONT></B><I>
                </I><FONT COLOR="#FF0000">-- Call C++ counterpart.</FONT><I>
            </I><B><FONT COLOR="#000080">do</FONT></B><I>
                cpp_output (object_ptr)
            </I><B><FONT COLOR="#000080">end</FONT></B><I>

        add (new_int: INTEGER) </I><B><FONT COLOR="#000080">is</FONT></B><I>
                    </I><FONT COLOR="#FF0000">-- Call C++ counterpart.</FONT><I>
            </I><B><FONT COLOR="#000080">do</FONT></B><I>
                cpp_add (object_ptr, new_int)
            </I><B><FONT COLOR="#000080">end</FONT></B><I>

    </I><B><FONT COLOR="#000080">feature</FONT></B> {<I>INTARRAY</I>}<I>

        underscore_integers: POINTER </I><B><FONT COLOR="#000080">is</FONT></B><I>
                    </I><FONT COLOR="#FF0000">-- Value of corresponding C++ data member.</FONT><I>
            </I><B><FONT COLOR="#000080">do</FONT></B><I>
                Result := underscore_integers (object_ptr)
            </I><B><FONT COLOR="#000080">end</FONT></B><I>

    </I><B><FONT COLOR="#000080">feature</FONT></B> {<I>NONE</I>} <FONT COLOR="#FF0000">-- Externals</FONT><I>

        cpp_new (size: INTEGER): POINTER </I><B><FONT COLOR="#000080">is</FONT></B><I>
                    </I><FONT COLOR="#FF0000">-- Call single constructor of C++ class.</FONT><I>
            </I><B><FONT COLOR="#000080">external</FONT></B><I>
                &quot;C++ [new IntArray %&quot;INTARRAY.H%&quot;] (EIF_INTEGER)&quot;
            </I><B><FONT COLOR="#000080">end</FONT></B><I>

        cpp_delete (cpp_obj: POINTER) </I><B><FONT COLOR="#000080">is</FONT></B><I>
                    </I><FONT COLOR="#FF0000">-- Call C++ destructor on C++ object.</FONT><I>
            </I><B><FONT COLOR="#000080">external</FONT></B><I>
                    &quot;C++ [delete IntArray %&quot;INTARRAY.H%&quot;] ()&quot;
            </I><B><FONT COLOR="#000080">end</FONT></B><I>

        cpp_output (cpp_obj: POINTER) </I><B><FONT COLOR="#000080">is</FONT></B><I>
                    </I><FONT COLOR="#FF0000">-- Call C++ member function.</FONT><I>
            </I><B><FONT COLOR="#000080">external</FONT></B><I>
                    &quot;C++ [IntArray %&quot;INTARRAY.H%&quot;] ()&quot;
            </I><B><FONT COLOR="#000080">alias</FONT></B><I>
                    &quot;output&quot;
            </I><B><FONT COLOR="#000080">end</FONT></B><I>

        cpp_add (cpp_obj: POINTER; new_int: INTEGER) </I><B><FONT COLOR="#000080">is</FONT></B><I>
                    </I><FONT COLOR="#FF0000">-- Call C++ member function.</FONT><I>
            </I><B><FONT COLOR="#000080">external</FONT></B><I>
                    &quot;C++ [IntArray %&quot;INTARRAY.H%&quot;] (EIF_INTEGER)&quot;
            </I><B><FONT COLOR="#000080">alias</FONT></B><I>
                    &quot;add&quot;
            </I><B><FONT COLOR="#000080">end</FONT></B><I>

        cpp_underscore_integers (cpp_obj: POINTER): POINTER </I><B><FONT COLOR="#000080">is</FONT></B><I>
                    </I><FONT COLOR="#FF0000">-- Value of C++ data member</FONT><I>
            </I><B><FONT COLOR="#000080">external</FONT></B><I>
                    &quot;C++ [data_member IntArray %&quot;INTARRAY.H%&quot;]: EIF_POINTER&quot;
            </I><B><FONT COLOR="#000080">alias</FONT></B><I>
                    &quot;_integers&quot;
            </I><B><FONT COLOR="#000080">end</FONT></B><I>

    </I><B><FONT COLOR="#000080">feature</FONT></B> {<I>NONE</I>} <FONT COLOR="#FF0000">-- Implementation</FONT><I>

            object_ptr: POINTER

    </I><B><FONT COLOR="#000080">end</FONT></B> <FONT COLOR="#FF0000">--</FONT> <B><FONT COLOR="#000080">class</FONT></B><I> INTARRAY</I>
</PRE>

  </td></tr></table>&nbsp;<!--msnavigation--></td></tr><!--msnavigation--></table></BODY>
</HTML>
