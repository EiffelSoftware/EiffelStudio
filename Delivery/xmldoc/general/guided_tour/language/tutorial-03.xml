<document title="2 General Properties">
	<meta_data>
		<help>
			<toc>
				<envision_location>Eiffel, The Language\Tutorials\An Eiffel Tutorial</envision_location>
				<envision_pseudo_name>20</envision_pseudo_name>
				<envision_title>General Properties</envision_title>
				<studio_location></studio_location>
				<studio_title></studio_title>
			</toc>
		</help>
	</meta_data>
	<paragraph>
		<heading>
			<size>1</size>
			<content>2 GENERAL PROPERTIES</content>
		</heading>
		<paragraph>Here is an overview of the facilities supported by Eiffel:</paragraph>
		<list ordered="false">
			<item> Completely 
				<italic>object-oriented</italic> approach.  Eiffel is a full-fledged application of object technology, not a "hybrid" of O-O and traditional concepts.  
			</item>
			<item> 
				<italic>External interfaces</italic> .  Eiffel is a software composition tool and is easily interfaced with software written in such languages as C, C++, Java and C#.  
			</item>
			<item> 
				<italic>Full lifecycle support</italic> .  Eiffel is applicable throughout the development process, including analysis, design, implementation and maintenance.  
			</item>
			<item> 
				<italic>Classes</italic> as the basic structuring tool.  A class is the description of a set of run-time objects, specified through the applicable operations and abstract properties.  An Eiffel system is made entirely of classes, serving as the only module mechanism.  
			</item>
			<item> 
				<italic>Consistent type system</italic> .  Every type is based on a class, including basic types such as integer, boolean, real, character, string, array.  
			</item>
			<item> 
				<italic>Design by Contract.  </italic> Every system component can be accompanied by a precise specification of its abstract properties, governing its internal operation and its interaction with other components.  
			</item>
			<item> 
				<italic>Assertions</italic> .  The method and notation support writing the logical properties of object states, to express the terms of the contracts.  These properties, known as assertions, can be monitored at run-time for testing and quality assurance.  They also serve as documentation mechanism.  Assertions include preconditions, postconditions, class invariants, loop invariants, and also appear in "check" instructions.  
			</item>
			<item> 
				<italic>Exception handling</italic> .  You can set up your software to detect abnormal conditions, such as unexpected operating system signals and contract violations, correct them, and recover
			</item>
			<item> 
				<italic>Information hiding</italic> .  Each class author decides, for each feature, whether it is available to all client classes, to specific clients only, or just for internal purposes.  
			</item>
			<item> 
				<italic>Self-documentation</italic> .  The notation is designed to enable environment tools to produce abstract views of classes and systems, textual or graphical, and suitable for reusers, maintainers and client authors.  
			</item>
			<item> 
				<italic>Inheritance</italic> .  You can define a class as extension or specialization of others.  
			</item>
			<item> 
				<italic>Redefinition</italic> .  An inherited feature (operation) can be given a different implementation or signature.  
			</item>
			<item> 
				<italic>Explicit redefinition</italic> .  Any feature redefinition must be explicitly stated.  
			</item>
			<item> 
				<italic>Subcontracting</italic> .  Redefinition rules require new assertions to be compatible with inherited ones.  
			</item>
			<item> 
				<italic>Deferred features and classes</italic> .  It is possible for a feature, and the enclosing class, to be specified -- including with assertions -- but not implemented.  Deferred classes are also known as abstract classes.  
			</item>
			<item> 
				<italic>Polymorphism</italic> .  An entity (variable, argument etc.  ) can become attached to objects of many different types.  
			</item>
			<item> 
				<italic>Dynamic binding</italic> .  Calling a feature on an object always triggers the version of the feature specifically adapted to that object, even in the presence of polymorphism and redefinition.  
			</item>
			<item> 
				<italic>Static typing</italic> .  A compiler can check statically that all type combinations will be valid, so that no run-time situation will occur in which an attempt will be made to apply an inexistent feature to an object.  
			</item>
			<item> 
				<italic>Assignment attempt</italic> ("type narrowing").  It is possible to check at run time whether the type of an object conforms to a certain expectation, for example if the object comes from a database or a network.  
			</item>
			<item> 
				<italic>Multiple inheritance</italic> .  A class can inherit from any number of others.  
			</item>
			<item> 
				<italic>Feature renaming</italic> .  To remove name clashes under multiple inheritance, or to give locally better names, a class can give a new name to an inherited feature.  
			</item>
			<item> 
				<italic>Repeated inheritance</italic> : 
				<italic>sharing and replication</italic> .  If, as a result of multiple inheritance, a class inherits from another through two or more paths, the class author can specify, for each repeatedly inherited feature, that it yields either one feature (sharing) or two (replication).  
			</item>
			<item> 
				<italic>No ambiguity under repeated inheritance</italic>.  Conflicting redefinitions under repeated inheritance are resolved through a "selection" mechanism.  
			</item>
			<item> 
				<italic>Unconstrained genericity</italic> .  A class can be parameterized, or "generic", to describe containers of objects of an arbitrary type.  
			</item>
			<item> 
				<italic>Constrained genericity</italic> .  A generic class can be declared with a generic constraint, to indicate that the corresponding types must satisfy some properties, such as the presence of a particular operation.  
			</item>
			<item> 
				<italic>Garbage collection</italic> .  The dynamic model is designed so that memory reclamation, in a supporting environment, can be automatic rather than programmer-controlled.  
			</item>
			<item> 
				<italic>No-leak modular structure</italic> .  All software is built out of classes, with only two inter-class relations, client and inheritance.  
			</item>
			<item> 
				<italic>Once routines</italic> .  A feature can be declared s "once", so that it is executed only for its first call, subsequently returning always the same result (if required).  This serves as a convenient initialization mechanism, and for shared objects.  
			</item>
			<item> 
				<italic>Standardized library</italic> .  The Kernel Library, providing essential abstractions, is standardized across implementations.  
			</item>
			<item> 
				<italic>Other libraries</italic> .  Eiffel development is largely based on high-quality libraries covering many common needs of software development, from general algorithms and data structures to networking and databases.  
			</item>
		</list>
		<paragraph>It is also useful, as in any design, to list some of what is 
			<bold>not</bold> present in Eiffel.  The approach is indeed based on a small number of coherent concepts so as to remain easy to master.  Eiffel typically takes a few hours to a few days to learn, and users seldom need to return to the reference manual once they have understood the basic concepts.  Part of this simplicity results from the explicit decision to exclude a number of possible facilities:
		</paragraph>
		<list ordered="false">
			<item> 
				<italic>No global variables</italic>, which would break the modularity of systems and hamper extendibility, reusability and reliability.  
			</item>
			<item> 
				<italic>No union types</italic> (or record type with variants), which force the explicit enumeration of all variants; in contrast, inheritance is an open mechanism which permits the addition of variants at any time without changing existing code.  
			</item> 
			<item> 
				<italic>No in-class overloading</italic> which, by assigning the same name to different features within a single context, causes confusions, errors, and conflicts with object-oriented mechanisms such as dynamic binding.  (Dynamic binding itself is a powerful form of inter-class overloading, without any of these dangers.  )
			</item>
			<item> 
				<italic>No goto instructions</italic> or similar control structures (break, exit, multiple-exit loops) which break the simplicity of the control flow and make it harder or impossible to reason about the software (in particular through loop invariants and variants).  
			</item>
			<item> 
				<italic>No exceptions to the type rules</italic> .  To be credible, a type system must not allow unchecked "casts" converting from a type to another.  (Safe cast-like operations are available through assignment attempt.  )
			</item>
			<item> 
				<italic>No side-effect expression operators</italic> confusing computation and modification.  
			</item>
			<item> 
				<italic>No low-level pointers, no pointer arithmetic</italic>, a well-known source of bugs.  (There is however a type 
				<italic>POINTER</italic>, used for interfacing Eiffel with C and other languages.  )
			</item>
		</list>
	</paragraph>
</document>