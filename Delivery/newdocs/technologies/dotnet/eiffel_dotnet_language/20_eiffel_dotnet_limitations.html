<HTML>
	<HEAD>
		<TITLE>Eiffel.NET Limitations</TITLE>
		<LINK REL=StyleSheet HREF="../../../default.css">
	</HEAD>

<body>

<h1>Differences between Eiffel and Eiffel.NET and .NET</h1>

<h2>Differences between Eiffel and Eiffel.NET</h2>

<h3>Missing from Eiffel.NET</h3>

<p>Eiffel.NET does not support the new Eiffel constructs that were added after
the publication of the current edition of <i>Eiffel: The Language</i>. These
constructs include agents and related classes (<SPAN CLASS="eclass">TUPLE</SPAN>,
<SPAN CLASS="eclass">ROUTINE</SPAN>, <SPAN CLASS="eclass">PROCEDURE</SPAN> and
<SPAN CLASS="eclass">FUNCTION</SPAN>), generic conformance, and generic
argument creation.</p>

<p>Eiffel.NET does not support full Eiffel multiple inheritance mechanism. Instead, 
it supports multiple inheritance of completely deferred classes (i.e. classes
that either directly inherits from <SPAN CLASS="eclass">ANY</SPAN> or from another completely deferred class
and whose features are all deferred) and only support single inheritance of class.</p>

<p>Eiffel.NET expanded classes are frozen, i.e. they cannot be inherited.</p>

<p>There are no other differences between Eiffel and Eiffel.NET; in fact, Eiffel.NET
supports contracts, exception handling, and genericity, some of the hallmarks of
Eiffel programming.</p>

<h3>Added to Eiffel and Eiffel.NET</h3>

<p>To improve the expressiveness of Eiffel.NET for .NET we added a flexible
language change that enables the author of Eiffel.NET libraries to define names
with a specific case. Not having this functionality will close a few doors to
Eiffel.NET assemblies. Indeed sometime, you will need to implement a feature
with a certain name. The chosen solution is the addition to Eiffel of an
indexing clause per feature. So far the indexing clause was used on per class
basis.<br>
</p>

<p>We have  added to Eiffel.NET the ability to
generate .NET custom attributes using the following indexing syntax:</p>

<pre><span class=efeature>empty</span>: <span class=eclass>BOOLEAN</span> is
	<span class=ekeyword>indexing</span>
		<span class="etag">description:</span> &quot;Is Current empty?&quot;
		<span class="etag"><span style="background-position: 0 0">attribute</span>:</span> <span class=ekeyword>create </span>{<span class=eclass>SYSTEM_OBSOLETEATTRIBUTE</span><span class="esymbol">}.</span><span class="efeature">make_obsoleteattribute_1</span> <span class="esymbol">(</span><span class="estring">&quot;Use `is_empty' instead&quot;</span><span class="esymbol">)</span> <span class=ekeyword>end</span>
	<span class=ekeyword>obsolete</span>
		<span class="ecomment">&quot;Use <span class=efeature>is_empty</span> instead&quot;</span>
	<span class=ekeyword>do</span>
		<span class=ekeyword>Result </span>:= <span class=efeature>is_empty</span>
	<span class=ekeyword>end</span>
</pre>

<p>&nbsp;In the previous example, we are declaring obsolete the routine <span class=efeature>empty
</span>and although we added the Eiffel obsolete clause, we add a .NET custom
attribute of type <span class=eclass>SYSTEM_OBSOLETEATTRIBUTE.</span></p>

<h2>Differences between Eiffel.NET and .NET</h2>

<h3>Covariance</h3>
<p>The CLR (Common Language Runtime) does not support covariance due to the type safety issue that 
full covariance implies (known as polymorphic CATCALLS
in Eiffel). Although very rare,&nbsp; CATCALLS are not suitable to .NET where safety is
one of the primary goals.</p>
<p>Eiffel.NET implements a safe variant of covariance that will always perform a
check on the types to avoid a CATCALL. So when a CATCALL is going to be
performed a `Invalid Cast&nbsp; Exception' will be raised by the CLR instead of an
unexpected behavior as it is currently done in Eiffel.</p>
<p>Another advantage of Eiffel.NET's implementation of covariance is that it can be
easily understood by CLS compliant consumer tools. These tools will actually benefit from the Eiffel.NET covariance.</p>

<h3>Genericity</h3>

<p>The CLR does not support generics at all, so that the following Eiffel.NET 
classes:</p>
<ul>
  <li>
    <span class="eclass">LIST [ANY]</span></li>
  <li><span class="eclass">LIST [INTEGER]</span></li>
</ul>

<p>will actually be generated as:</p>
<ul>
  <li><span class="eclass">LIST_ANY</span></li>
  <li><span class="eclass">LIST_Int32</span></li>
</ul>
<p>Meaning that if one wants to reuse an Eiffel generic class from another 
language than Eiffel.NET, one has to use either <span class="eclass">LIST_ANY </span>or <span class="eclass">
LIST_Int32</span>.</p>

<h3>Attributes</h3>
<p>Eiffel.NET attributes are generated as .NET properties. This enables the
Eiffel.NET compiler to do covariant redefinitions of attributes and have this
functionality exported to other .NET languages. The backing field of the
property is a private field of the  Eiffel.NET class which is only accessible
from the assembly. The Eiffel.NET assembly is using this private field to access
the attribute since it knows how they are used, but this is not the case for
other .NET languages, thus the need to generate the corresponding .NET property.</p>
<h3>Enum types</h3>
<p>Eiffel.NET supports in a hidden way .NET enum types. From the point of view 
of Eiffel, they are just considered as expanded classes. The only difference is 
in the code generation. Eiffel.NET cannot declare new enum types yet.</p>

<h3>ByRef</h3>
<p>Eiffel does not have the notion of `byref' argument passing. At the moment,
Eiffel.NET cannot call nor can it redefine a feature that has a byref argument.</p>

</body>

</html>