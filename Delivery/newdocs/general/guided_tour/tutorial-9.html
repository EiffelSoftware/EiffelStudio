<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="tutorial.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE> 8  DESIGN BY CONTRACTTM, ASSERTIONS, EXCEPTIONS</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<p class="top" align="center"><a href="http://www.eiffel.com">Eiffel Home Page (Web)</a> -- <a href="index.html">Getting started with Eiffel (local)</a>

<img src="power.gif" ALT="Eiffel Home Page" align="right" border="0"  usemap="#eiffel"><map name="eiffel"><area shape="RECT" alt="Eiffel Home Page" coords="0,0,109,226" HREF="http://www.eiffel.com"><area shape="default" nohref></map>

<p class="top" ALIGN="left"><IMG SRC="normaldoc.gif" ALT="Previous, Up, Next" BORDER="0" WIDTH="300" HEIGHT="40" USEMAP="#navigation"><map name="navigation"><AREA SHAPE="RECT" alt="Previous section" COORDS="0,0,95,40" HREF="tutorial-8.html"><AREA SHAPE="RECT" alt="Up" COORDS="96,0,199,40" HREF="tutorial.html"><AREA SHAPE="RECT" alt="Next section" COORDS="200,0,300,40" HREF="tutorial-10.html"><area shape="default" nohref></MAP>
</DIV>
<H1 CLASS="aa-sec2">
<A NAME="pgfId-514761"></A>8  <A NAME="30455"></A>DESIGN BY CONTRACT<SPAN CLASS="superscript">
TM</SPAN>
, ASSERTIONS, EXCEPTIONS</H1>
<P CLASS="nn-first">
<A NAME="pgfId-514762"></A>Eiffel directly implements the ideas of Design by Contract<SPAN CLASS="superscript">
TM</SPAN>
, which enhance software reliability and provide a sound basis for software specification, documentation and testing, as well as exception handling and the proper use of inheritance.</P>
<DIV>
<H2 CLASS="aa-sec3">
<A NAME="pgfId-514763"></A>Design by Contract basics</H2>
<P CLASS="nn-first">
<A NAME="pgfId-514764"></A>A system -- a software system in particular, but the ideas are more general -- is made of a number of cooperating components. Design by Contract states that their cooperation should be based on precise specifications -- <SPAN CLASS="ff-italics">
contracts</SPAN>
 -- describing each party's expectations and guarantees.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514765"></A>An Eiffel contract is similar to a real-life contract between two people or two companies, which it is convenient to express in the form of tables listing the expectations and guarantees. Here for example is how we could sketch the contract between a homeowner and the telephone company:</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltext">
<A NAME="pgfId-514768"></A><SPAN CLASS="ee-text">
provide_service</SPAN>
</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltitle">
<A NAME="pgfId-514770"></A>OBLIGATIONS</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltitle">
<A NAME="pgfId-514772"></A>BENEFITS</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltitle">
<A NAME="pgfId-514774"></A>Client</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltext">
<A NAME="pgfId-514776"></A>(Satisfy precondition:)</P>
<P CLASS="mm-celltext">
<A NAME="pgfId-514777"></A>Pay bill</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltext">
<A NAME="pgfId-514779"></A>(From postcondition:)</P>
<P CLASS="mm-celltext">
<A NAME="pgfId-514780"></A>Get telephone service</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltitle">
<A NAME="pgfId-514782"></A>Supplier</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltext">
<A NAME="pgfId-514784"></A>(Satisfy postcondition:)</P>
<P CLASS="mm-celltext">
<A NAME="pgfId-514785"></A>Provide telephone service</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltext">
<A NAME="pgfId-514787"></A>(From precondition:)</P>
<P CLASS="mm-celltext">
<A NAME="pgfId-514788"></A>No need to provide anything if bill not paid</P>
</TD>
</TR>
</TABLE>
<P CLASS="nn-first">
<A NAME="pgfId-514789"></A>Note how the obligation for each of the parties maps onto a benefit for the other. This will be a general pattern.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514790"></A>The client's obligation, which protects the supplier, is called a <SPAN CLASS="ff-bold">
precondition</SPAN>
. It states what the client must satisfy before requesting a certain service. The client's benefit, which describes what the supplier must do (assuming the precondition was satisfied), is called a <SPAN CLASS="ff-bold">
postcondition</SPAN>
.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514791"></A>In addition to preconditions and postconditions, contract clauses include <SPAN CLASS="ff-bold">
class invariants</SPAN>
, which apply to a class as a whole. More precisely a class invariant must be ensured by every creation procedure (or by the default initialization if there is no creation procedure), and maintained by every exported routine of the class.</P>
</DIV>
<DIV>
<H2 CLASS="aa-sec3">
<A NAME="pgfId-514792"></A>Expressing assertions</H2>
<P CLASS="nn-first">
<A NAME="pgfId-514793"></A>Eiffel provides syntax for expressing preconditions (<SPAN CLASS="ee-keyword">
require</SPAN>
), postconditions (<SPAN CLASS="ee-keyword">
ensure</SPAN>
) and class invariants (<SPAN CLASS="ee-keyword">
invariant</SPAN>
), as well as other assertion constructs studied later (see <A HREF="tutorial-11.html#38021" CLASS="XRef"><SPAN CLASS="ww-crossref">
&quot;Instructions&quot;,  page 85</SPAN>
</A>): loop invariants and variants, check instructions.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514832"></A>Here is a partial update of class <SPAN CLASS="ee-text">
ACCOUNT</SPAN>
 with more assertions:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-begin">
<A NAME="pgfId-514799"></A><SPAN CLASS="ee-keyword">
indexing</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514800"></A>	description: &quot;Simple bank accounts&quot;</P>
<P CLASS="ee-text">
<A NAME="pgfId-514801"></A><SPAN CLASS="ee-keyword">
class</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514802"></A>	ACCOUNT</P>
<P CLASS="ee-text">
<A NAME="pgfId-514803"></A><SPAN CLASS="ee-keyword">
feature</SPAN>
<SPAN CLASS="ee-comment">
 -- Access</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514804"></A>	balance: INTEGER</P>
<P CLASS="ee-comment">
<A NAME="pgfId-514805"></A>			-- Current balance</P>
<P CLASS="ee-text">
<A NAME="pgfId-514806"></A>	deposit_count: INTEGER <SPAN CLASS="ee-keyword">
is</SPAN>
</P>
<P CLASS="ee-comment">
<A NAME="pgfId-514807"></A>			-- Number of deposits made since opening</P>
<P CLASS="ee-text">
<A NAME="pgfId-514808"></A>		<SPAN CLASS="ee-keyword">
do</SPAN>
</P>
<P CLASS="ee-comment">
<A NAME="pgfId-514809"></A>			&#8230; As before &#8230; </P>
<P CLASS="ee-text">
<A NAME="pgfId-514810"></A>		<SPAN CLASS="ee-keyword">
end</SPAN>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-514812"></A><SPAN CLASS="ee-keyword">
feature</SPAN>
 <SPAN CLASS="ee-comment">
-- Element change</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514813"></A>	deposit (sum: INTEGER) <SPAN CLASS="ee-keyword">
is</SPAN>
</P>
<P CLASS="ee-comment">
<A NAME="pgfId-514814"></A>			-- Add <SPAN CLASS="ee-text">
sum</SPAN>
 to account.</P>
<P CLASS="ee-text">
<A NAME="pgfId-514815"></A>		<SPAN CLASS="ee-keyword">
require</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514816"></A>			non_negative: sum &gt;= 0</P>
<P CLASS="ee-text">
<A NAME="pgfId-514817"></A>		<SPAN CLASS="ee-keyword">
do</SPAN>
</P>
<P CLASS="ee-comment">
<A NAME="pgfId-514818"></A>			&#8230; As before &#8230; </P>
<P CLASS="ee-text">
<A NAME="pgfId-514819"></A>		<SPAN CLASS="ee-keyword">
ensure</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514820"></A>			one_more_deposit:<BR>
				deposit_count = <SPAN CLASS="ee-keyword">
old</SPAN>
 deposit_count + 1</P>
<P CLASS="ee-text">
<A NAME="pgfId-514821"></A>			updated: balance = <SPAN CLASS="ee-keyword">
old</SPAN>
 balance + sum</P>
<P CLASS="ee-text">
<A NAME="pgfId-514822"></A>		<SPAN CLASS="ee-keyword">
end</SPAN>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-514824"></A><SPAN CLASS="ee-keyword">
feature </SPAN>
<SPAN CLASS="ee-comment">
{</SPAN>
NONE<SPAN CLASS="ee-comment">
} -- Implementation</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514825"></A>	all_deposits: DEPOSIT_LIST</P>
<P CLASS="ee-comment">
<A NAME="pgfId-514826"></A>			-- List of deposits since account's opening.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-514828"></A><SPAN CLASS="ee-keyword">
invariant</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514829"></A>	consistent_balance: (all_deposits /= Void) <SPAN CLASS="ee-keyword">
implies<BR>
</SPAN>
							(balance = all_deposits<SPAN CLASS="ee-dot">
.</SPAN>
total)</P>
<P CLASS="ee-text">
<A NAME="pgfId-514830"></A>	zero_if_no_deposits: (all_deposits = Void) <SPAN CLASS="ee-keyword">
implies<BR>
</SPAN>
							(balance = 0)</P>
<P CLASS="ee-text">
<A NAME="pgfId-514831"></A><SPAN CLASS="ee-keyword">
end</SPAN>
 <SPAN CLASS="ee-comment">
-- class</SPAN>
 ACCOUNT</P>
</TD>
</TR>
</TABLE>
<P CLASS="nn-first">
<A NAME="pgfId-514833"></A>Each assertion is made of one or more subclauses, each of them a boolean expression (with the additional possibility of the <SPAN CLASS="ee-keyword">
old</SPAN>
 construct). The effect of including more than one subclause, as in the postcondition of <SPAN CLASS="ee-text">
deposit </SPAN>
and in the invariant, is the same as connecting them through an <SPAN CLASS="ee-keyword">
and</SPAN>
. Each clause may be preceded by a label, such as <SPAN CLASS="ee-text">
consistent_balance</SPAN>
 in the invariant, and a colon; the label is optional and does not affect the assertion's semantics, except for error reporting as explained in the next section, but including it systematically is part of the recommended style. The value of the boolean expression <SPAN CLASS="ee-text">
a</SPAN>
 <SPAN CLASS="ee-keyword">
implies</SPAN>
 <SPAN CLASS="ee-text">
b</SPAN>
 is true except if <SPAN CLASS="ee-text">
a</SPAN>
 is true and <SPAN CLASS="ee-text">
b</SPAN>
 false.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514834"></A>Because assertions benefit from the full power of boolean expressions, they may include function calls. This makes it possible to express sophisticated consistency conditions, such as &quot;<SPAN CLASS="ff-italics">
the graph contains no cycle</SPAN>
&quot;, which would not be otherwise expressible through simple expressions, or even through first-order predicate calculus, but which are easy to implement as Eiffel functions returning boolean results.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514835"></A>The precondition of a routine expresses conditions that the routine is imposing on its clients. Here a call to <SPAN CLASS="ee-text">
deposit</SPAN>
 is correct if and only if the value of the argument is non-negative. The routine does not guarantee anything for a call that does not satisfy the precondition. It is in fact part of the Eiffel method that a routine body should <SPAN CLASS="ff-bold">
never</SPAN>
 test for the precondition, since it is the client's responsibility to ensure it. (An apparent paradox of Design by Contract, which is reflected in the bottom-right entries of the preceding and follwing contract tables, and should not be a paradox any more at the end of this discussion, is that one can get <SPAN CLASS="ff-italics">
more</SPAN>
 reliable software by having <SPAN CLASS="ff-italics">
fewer</SPAN>
 explicit checks in the software text.)</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514836"></A>The postcondition of a routine expresses what the routine guaranteed to its clients for calls satisfying the precondition. The notation <SPAN CLASS="ee-keyword">
old</SPAN>
<SPAN CLASS="ee-text">
 expression</SPAN>
, valid in postconditions (<SPAN CLASS="ee-keyword">
ensure </SPAN>
clauses) only, denotes the value that <SPAN CLASS="ee-text">
expression</SPAN>
 had on entry to the routine.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514837"></A>The precondition and postcondition state the terms of the contract between the routine and its clients, similar to the earlier example of a human contract:</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltext">
<A NAME="pgfId-514840"></A><SPAN CLASS="ee-text">
deposit</SPAN>
</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltitle">
<A NAME="pgfId-514842"></A>OBLIGATIONS</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltitle">
<A NAME="pgfId-514844"></A>BENEFITS</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltitle">
<A NAME="pgfId-514846"></A>Client</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltext">
<A NAME="pgfId-514848"></A>(Satisfy precondition:)</P>
<P CLASS="mm-celltext">
<A NAME="pgfId-514849"></A>Use a non-negative argument.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltext">
<A NAME="pgfId-514851"></A>(From postcondition:)</P>
<P CLASS="mm-celltext">
<A NAME="pgfId-514852"></A>Get deposits list and balance updated.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltitle">
<A NAME="pgfId-514854"></A>Supplier</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltext">
<A NAME="pgfId-514856"></A>(Satisfy postcondition:)</P>
<P CLASS="mm-celltext">
<A NAME="pgfId-514857"></A>Update deposits list and balance.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltext">
<A NAME="pgfId-514859"></A>(From precondition:)</P>
<P CLASS="mm-celltext">
<A NAME="pgfId-514860"></A>No need to handle negative arguments.</P>
</TD>
</TR>
</TABLE>
<P CLASS="nn-first">
<A NAME="pgfId-514861"></A>The class invariant, as noted, applies to all features. It must be satisfied on exit by any creation procedure, and is implicitly added to both the precondition and postcondition of every exported routine. In this respect it is both good news and bad news for the routine implementer: good news because it guarantees that the object will initially be in a stable state, averting the need in the example to check that the total of <SPAN CLASS="ee-text">
all_deposits</SPAN>
 is compatible with the <SPAN CLASS="ee-text">
balance</SPAN>
; bad news because, in addition to its official contract as expressed by its specific postcondition, every routine must take care of restoring the invariant on exit.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514862"></A>A requirement on meaningful contracts is that they should be in good faith: satisfiable by an honest partner. This implies a consistency rule: if a routine is exported to a client (either generally or selectively), any feature appearing in its precondition must also be available to that client. Otherwise -- for example if the precondition included <SPAN CLASS="ee-keyword">
require </SPAN>
<SPAN CLASS="ee-text">
n </SPAN>
&gt; <SPAN CLASS="ee-text">
0</SPAN>
, where <SPAN CLASS="ee-text">
n</SPAN>
 is a secret attribute -- the supplier would be making demands that a good-faith client cannot possibly check for.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514863"></A>Note in this respect that <SPAN CLASS="ff-italics">
guaranteeing </SPAN>
a precondition does not necessarily mean, for the client, <SPAN CLASS="ff-italics">
testing</SPAN>
 for it. Assuming <SPAN CLASS="ee-text">
n</SPAN>
 is exported, a call may test for the precondition</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-514866"></A><SPAN CLASS="ee-keyword">
if </SPAN>
<SPAN CLASS="ee-text">
x</SPAN>
<SPAN CLASS="ee-dot">
.</SPAN>
<SPAN CLASS="ee-text">
n </SPAN>
&gt; <SPAN CLASS="ee-text">
0 </SPAN>
<SPAN CLASS="ee-keyword">
then </SPAN>
<SPAN CLASS="ee-text">
x</SPAN>
<SPAN CLASS="ee-dot">
.</SPAN>
 <SPAN CLASS="ee-text">
r </SPAN>
<SPAN CLASS="ee-keyword">
end</SPAN>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="nn-first">
<A NAME="pgfId-527989"></A>possibly with an <SPAN CLASS="ee-keyword">
else</SPAN>
 part. But if the context of the call, in the client's code, implies that <SPAN CLASS="ee-text">
n</SPAN>
 is positive -- perhaps because some preceding call set it to the sum of two squares -- then there is no need for an <SPAN CLASS="ee-keyword">
if</SPAN>
 or similar construct.</P>
<P CLASS="jj-small">
<A NAME="pgfId-527999"></A>In such a case, a <SPAN CLASS="ee-keyword">
check </SPAN>
instruction as introduced later (<A HREF="tutorial-11.html#38021" CLASS="XRef"><SPAN CLASS="ww-crossref">
&quot;Instructions&quot;,  page 85</SPAN>
</A>) is recommended if the reason for omitting the test is non-trivial.</P>
</DIV>
<DIV>
<H2 CLASS="aa-sec3">
<A NAME="pgfId-514871"></A>Using contracts for built-in reliability</H2>
<P CLASS="nn-first">
<A NAME="pgfId-514872"></A>What are contracts good for? Their first use is purely methodological. By applying a discipline of expressing, as precisely as possible, the logical assumptions behind software elements, you can write software whose reliability is built-in: software that is developed hand-in-hand with the rationale for its correctness.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514873"></A>This simple observation -- usually not clear to people until they have practiced Design by Contract thoroughly on a large-scale project -- brings as much change to software practices and quality as the rest of object technology.</P>
</DIV>
<DIV>
<H2 CLASS="aa-sec3">
<A NAME="pgfId-514874"></A>Run-time assertion monitoring</H2>
<P CLASS="nn-first">
<A NAME="pgfId-514875"></A>Contracts in Eiffel are not just wishful thinking. They can be monitored at run time under the control of compilation options.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514876"></A>It should be clear from the preceding discussion that contracts are not a mechanism to test for special conditions, for example erroneous user input. For that purpose, the usual control structures (<SPAN CLASS="ee-keyword">
if</SPAN>
 <SPAN CLASS="ee-text">
deposit_sum</SPAN>
 <SPAN CLASS="ee-comment">
&gt;=</SPAN>
 <SPAN CLASS="ee-text">
0 </SPAN>
<SPAN CLASS="ee-keyword">
then </SPAN>
&#8230;) are available, complemented in applicable cases by the exception handling mechanism reviewed next. An assertion is instead a <SPAN CLASS="ff-bold">
correctness condition</SPAN>
 governing the relationship between two software modules (not a software module and a human, or a software module and an external device). If <SPAN CLASS="ee-text">
sum</SPAN>
 is negative on entry to <SPAN CLASS="ee-text">
deposit</SPAN>
, violating the precondition, the culprit is some other software element, whose author was not careful enough to observe the terms of the deal. Bluntly:</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="mm-celltitle">
<A NAME="pgfId-514879"></A>Assertion Violation rule</P>
<P CLASS="mm-celltext">
<A NAME="pgfId-514880"></A>A run-time assertion violation is the manifestation of a bug.</P>
</TD>
</TR>
</TABLE>
<P CLASS="nn-first">
<A NAME="pgfId-514881"></A>To be more precise:</P>
<UL>
<LI CLASS="ll-bull">
<A NAME="pgfId-514882"></A>A precondition violation signals a bug in the client, which did not observe its part of the deal.</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-514883"></A>A postcondition (or invariant) violation signals a bug in the supplier -- the routine -- which did not do its job.</LI>
</UL>
<P CLASS="nn-normal">
<A NAME="pgfId-514884"></A>That violations indicate bugs explains why it is legitimate to enable or disable assertion monitoring through mere compilation options: for a correct system -- one without bugs -- assertions will always hold, so the compilation option makes no difference to the semantics of the system. </P>
<P CLASS="nn-normal">
<A NAME="pgfId-514885"></A>But of course for an incorrect system the best way to find out where the bug is -- or just that there is a bug -- is often to monitor the assertions during development and testing. Hence the presence of the compilation options, which ISE's EiffelStudio lets you set separately for each class, with defaults at the system and cluster levels:</P>
<UL>
<LI CLASS="ll-bull">
<A NAME="pgfId-514886"></A><SPAN CLASS="ee-keyword">
no</SPAN>
: assertions have no run-time effect.</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-514887"></A><SPAN CLASS="ee-keyword">
require</SPAN>
: monitor preconditions only, on routine entry.</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-514888"></A><SPAN CLASS="ee-keyword">
ensure</SPAN>
: preconditions on entry, postconditions on exit.</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-514889"></A><SPAN CLASS="ee-keyword">
invariant</SPAN>
: like <SPAN CLASS="ee-keyword">
ensure</SPAN>
, plus class invariant on both entry and exit for qualified calls.</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-514892"></A><SPAN CLASS="ee-keyword">
all</SPAN>
: like <SPAN CLASS="ee-keyword">
invariant</SPAN>
, plus <SPAN CLASS="ee-keyword">
check</SPAN>
 instructions, loop invariants and loop variants (<A HREF="tutorial-11.html#38021" CLASS="XRef"><SPAN CLASS="ww-crossref">
&quot;Instructions&quot;,  page 85</SPAN>
</A>).</LI>
</UL>
<P CLASS="nn-first">
<A NAME="pgfId-514894"></A>An assertion violation, if detected at run time under one of these options other than the first, will cause an exception (<A HREF="tutorial-9.html#10722" CLASS="XRef"><SPAN CLASS="ww-crossref">
&quot;Exception handling&quot;,  page 46</SPAN>
</A>). Unless the software has an explicit &quot;retry&quot; plan as explained in the discussion of exceptions, the violation will cause produce an exception trace and cause termination (or, in EiffelStudio, a return to the environment's browsing and debugging facilities at the point of failure). If present, the label of the violated subclause will be displayed, to help identify the problem.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-528059"></A>The default is <SPAN CLASS="ee-keyword">
require</SPAN>
. This is particularly interesting in connection with the Eiffel method's insistence on reuse: with libraries such as EiffelBase, richly equipped with preconditions expressing terms of use, an error in the<SPAN CLASS="ff-bold">
 client software</SPAN>
 will often lead, for example through an incorrect argument, to violating one of these preconditions. A somewhat paradoxical consequence is that even an application developer who does not apply the method too well (out of carelessness, haste, indifference or ignorance) will still benefit from the presence of contracts in <SPAN CLASS="ff-italics">
someone else</SPAN>
's library code.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-528060"></A>During development and testing, assertion monitoring should be turned on at the highest possible level. Combined with static typing and the immediate feedback of compilation techniques such as the Melting Ice Technology, this permits the development process mentioned in the section <A HREF="tutorial-4.html#94733" CLASS="XRef"><SPAN CLASS="ww-crossref">
&quot;Quality and functionality&quot;,  page 10</SPAN>
</A>, where errors are exterminated at birth. No one who has not practiced the method in a real project can imagine how many mistakes are found in this way; surprisingly often, a violation will turn out to affect an assertion that was just included for goodness' sake, the developer being convinced that it could never &quot;possibly&quot; fail to be satisfied.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514903"></A>By providing a precise reference (the description of what the software is supposed to do) against which to assess the reality (what the software actually does), Design by Contract profoundly transforms the activities of debugging, testing and quality assurance.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514904"></A>When releasing the final version of a system, it is usually appropriate to turn off assertion monitoring, or bring it down to the <SPAN CLASS="ee-keyword">
require</SPAN>
 level. The exact policy depends on the circumstances; it is a tradeoff between efficiency considerations, the potential cost of mistakes, and how much the developers and quality assurance team trust the product. When developing the software, however, you should always assume -- to avoid loosening your guard -- that in the end monitoring will be turned off.</P>
</DIV>
<DIV>
<H2 CLASS="aa-sec3">
<A NAME="pgfId-514906"></A><A NAME="78482"></A>The contract form of a class</H2>
<P CLASS="nn-first">
<A NAME="pgfId-514907"></A>Another application of assertions governs documentation. Environment mechanisms, such as clicking the <SPAN CLASS="ee-keyword">
Contract Form </SPAN>
icon in EifffelStudio, will produce, from a class text, an abstracted version which only includes the information relevant for client authors. Here is the contract form of class <SPAN CLASS="ee-text">
ACCOUNT</SPAN>
 in the latest version given:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-514910"></A><SPAN CLASS="ee-keyword">
indexing</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514911"></A>	description: &quot;Simple bank accounts&quot;</P>
<P CLASS="ee-text">
<A NAME="pgfId-514912"></A><SPAN CLASS="ee-keyword">
class</SPAN>
 <SPAN CLASS="ee-keyword">
interface</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514913"></A>	ACCOUNT</P>
<P CLASS="ee-text">
<A NAME="pgfId-514914"></A><SPAN CLASS="ee-keyword">
feature</SPAN>
<SPAN CLASS="ee-comment">
 -- Access</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514915"></A>	balance: INTEGER</P>
<P CLASS="ee-comment">
<A NAME="pgfId-514916"></A>			-- Current balance</P>
<P CLASS="ee-text">
<A NAME="pgfId-514917"></A>	deposit_count: INTEGER</P>
<P CLASS="ee-comment">
<A NAME="pgfId-514918"></A>			-- Number of deposits made since opening</P>
<P CLASS="ee-text">
<A NAME="pgfId-514919"></A><SPAN CLASS="ee-keyword">
feature</SPAN>
 -- Element change</P>
<P CLASS="ee-text">
<A NAME="pgfId-514920"></A>	deposit (sum: INTEGER)</P>
<P CLASS="ee-comment">
<A NAME="pgfId-514921"></A>			-- Add <SPAN CLASS="ee-text">
sum</SPAN>
 to account.</P>
<P CLASS="ee-text">
<A NAME="pgfId-514922"></A>		<SPAN CLASS="ee-keyword">
require</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514923"></A>			non_negative: sum &gt;= 0</P>
<P CLASS="ee-text">
<A NAME="pgfId-514924"></A>		<SPAN CLASS="ee-keyword">
ensure</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514925"></A>			one_more_deposit: deposit_count = <SPAN CLASS="ee-keyword">
old</SPAN>
 deposit_count + 1</P>
<P CLASS="ee-text">
<A NAME="pgfId-514926"></A>			updated: balance = <SPAN CLASS="ee-keyword">
old</SPAN>
 balance + sum</P>
<P CLASS="ee-text">
<A NAME="pgfId-514927"></A><SPAN CLASS="ee-keyword">
invariant</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514928"></A>	consistent_balance: balance = all_deposits<SPAN CLASS="ee-dot">
.</SPAN>
total</P>
<P CLASS="ee-text">
<A NAME="pgfId-514929"></A><SPAN CLASS="ee-keyword">
end</SPAN>
 --<SPAN CLASS="ee-comment">
 class interface</SPAN>
 ACCOUNT</P>
</TD>
</TR>
</TABLE>
<P CLASS="nn-first">
<A NAME="pgfId-514930"></A>The words<SPAN CLASS="ee-keyword">
 class interface </SPAN>
are used instead of just <SPAN CLASS="ee-keyword">
class</SPAN>
 to avoid any confusion with actual Eiffel text, since this is documentation, not executable software. (It is in fact possible to generate a compilable variant of the Contract Form in the form of a deferred class, a notion defined later.)</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514931"></A>Compared to the full text, the Contract Form of a class (also called its &quot;<SPAN CLASS="ff-italics">
short form</SPAN>
&quot;) retains all its interface properties, relevant to client authors:</P>
<UL>
<LI CLASS="ll-bull">
<A NAME="pgfId-514932"></A>Names and signatures (argument and result type information) for exported features.</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-514933"></A>Header comments of these features, which carry informal descriptions of their purpose. (Hence the importance, mentioned in section <A HREF="tutorial-5.html#35212" CLASS="XRef"><SPAN CLASS="ww-crossref">
4</SPAN>
</A>, of always including such comments and writing them carefully.)</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-514937"></A>Preconditions and postconditions of these features (at least the subclauses involving only exported features).</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-514938"></A>Class invariant (same observation).</LI>
</UL>
<P CLASS="nn-first">
<A NAME="pgfId-514939"></A>The following elements, however, are not in the Contract Form: any information about non-exported features; all the routine bodies (<SPAN CLASS="ee-keyword">
do</SPAN>
 clauses, or the <SPAN CLASS="ee-keyword">
external</SPAN>
 and <SPAN CLASS="ee-keyword">
once</SPAN>
 variants seen in <A HREF="tutorial-6.html#91180" CLASS="XRef"><SPAN CLASS="ww-crossref">
&quot;External software&quot;,  page 16</SPAN>
</A> above and <A HREF="tutorial-11.html#71816" CLASS="XRef"><SPAN CLASS="ww-crossref">
&quot;Once routines and shared objects&quot;,  page 82</SPAN>
</A> below); assertion subclauses involving non-exported features; and some keywords not useful in the documentation, such as <SPAN CLASS="ee-keyword">
is</SPAN>
 for a routine.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514949"></A>In accordance with the Uniform Access principle (page <A HREF="tutorial-7.html#UNIFORM ACCESS" CLASS="XRef"><SPAN CLASS="ww-crossref">
19</SPAN>
</A>), the Contract Form does not distinguish between attributes and argument-less queries. In the above example, <SPAN CLASS="ee-text">
balance</SPAN>
 could be one or the other, as it makes no difference to clients, except possibly for performance.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514950"></A>The Contract Form is the fundamental tool for using supplier classes in the Eiffel method. It enables client authors to reuse software elements without having to read their source code. This is a crucial requirement in large-scale industrial developments.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514951"></A>The Contract Form satisfies two key requirements of good software documentation:</P>
<UL>
<LI CLASS="ll-bull">
<A NAME="pgfId-514952"></A>It is truly abstract, free from the implementation details of what it describes and concentrating instead on its functionality.</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-514953"></A>Rather than being developed separately -- an unrealistic requirement, hard to impose on developers initially and becoming impossible in practice if we expect the documentation to remain up to date as the software evolves -- the documentation is extracted from the software itself. It is not a separate product but a different view of the same product. This prolongs the<SPAN CLASS="ff-bold">
 Single Product</SPAN>
 principle that lies at the basis of Eiffel's seamless development model (section <A HREF="tutorial-4.html#41726" CLASS="XRef"><SPAN CLASS="ww-crossref">
3</SPAN>
</A>).</LI>
</UL>
<P CLASS="nn-normal">
<A NAME="pgfId-514957"></A>The Contract Form is only one of the relevant views. EiffelStudio, for example, generates graphical representations of system structures, to show classes and their relations -- client, inheritance -- according to the conventions of BON (the Business Object Notation). In accordance with the principles of seamlessness and reversibility, EiffelStudio lets you both work on the text, producing the graphics on the fly, or work on the graphics, updating the text on the fly; you can alternate as you wish between these two modes. The resulting process is quite different from more traditional approaches based on separate tools: an analysis and CASE workbench, often based on UML, to deal with an initial &quot;bubble-and-arrow&quot; description; and a separate programming environment, to deal with implementation aspects only. In Eiffel the environment provides consistent, seamless support from beginning to end.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-528221"></A>The Contract Form -- or its variant the Flat-Contract Form, which takes account of inheritance (<A HREF="tutorial-10.html#11134" CLASS="XRef"><SPAN CLASS="ww-crossref">
&quot;Flat and Flat-Contract Forms&quot;,  page 72</SPAN>
</A>) are the standard form of library documentation, used extensively, for example, in the book <SPAN CLASS="ww-crossref">
<A HREF="http://www.eiffel.com/doc/page.html#rs" CLASS="URL">Reusable Software</A></SPAN>
 (see bibliography). Assertions play a central role in such documentation by expressing the terms of the contract. As demonstrated <SPAN CLASS="ff-italics">
a contrario</SPAN>
 by the widely publicized $500-million crash of the Ariane-5 rocket launcher in June of 1996, due to the incorrect reuse of a software module from the Ariane-4 project, <SPAN CLASS="ff-bold">
reuse without a contract documentation</SPAN>
 is the path to disaster. Non-reuse would, in fact, be preferable.</P>
</DIV>
<DIV>
<H2 CLASS="aa-sec3">
<A NAME="pgfId-514963"></A><A NAME="10722"></A>Exception handling</H2>
<P CLASS="nn-first">
<A NAME="pgfId-514964"></A>Another application of Design by Contract governs the handling of unexpected cases. The vagueness of many discussions of this topic follows from the lack of a precise definition of terms such as &quot;exception&quot;. With Design by Contract we are in a position to be specific:</P>
<UL>
<LI CLASS="ll-bull">
<A NAME="pgfId-514965"></A>Any routine has a contract to achieve.</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-514966"></A>Its body defines a strategy to achieve it -- a sequence of operations, or some other control structure involving operations. Some of these operations are calls to routines, with their own contracts; but even an atomic operation, such as the computation of an arithmetic operation, has an implicit contract, stating that the result will be representable.</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-514967"></A>Any one of these operations may <SPAN CLASS="ee-keyword">
fail</SPAN>
, that is to say be unable to meet its contract; for example an arithmetic operation may produce an overflow (a non-representable result).</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-514968"></A>The failure of an operation is an <SPAN CLASS="ff-bold">
exception</SPAN>
 for the routine that needed the operation.</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-514969"></A>As a result the routine may fail too -- causing an exception in its own caller.</LI>
</UL>
<P CLASS="nn-first">
<A NAME="pgfId-514970"></A>Note the precise definitions of the two key concepts, failure and exception. Although failure is the more basic one -- since it is defined for atomic, non-routine operations -- the definitions are mutually recursive, since an exception may cause a failure of the recipient routine, and a routine's failure causes an exception in its own caller.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514971"></A>Why state that an exception &quot;may&quot; cause a failure? It is indeed possible to &quot;rescue&quot; a routine from failure in the case of an exception, by equipping it with a clause labeled <SPAN CLASS="ee-keyword">
rescue</SPAN>
, as in:</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-514974"></A>read_next_character (f: FILE) <SPAN CLASS="ee-keyword">
is</SPAN>
</P>
<P CLASS="ee-comment">
<A NAME="pgfId-514975"></A>		-- Make next character available in <SPAN CLASS="ee-text">
last_character</SPAN>
;</P>
<P CLASS="ee-comment">
<A NAME="pgfId-514976"></A>		-- if impossible, set <SPAN CLASS="ee-text">
failed</SPAN>
 to True.</P>
<P CLASS="ee-text">
<A NAME="pgfId-514977"></A>	<SPAN CLASS="ee-keyword">
require</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514978"></A>		readable: file<SPAN CLASS="ee-dot">
.</SPAN>
readable</P>
<P CLASS="ee-text">
<A NAME="pgfId-514979"></A>	<SPAN CLASS="ee-keyword">
local</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514980"></A>		impossible: BOOLEAN</P>
<P CLASS="ee-text">
<A NAME="pgfId-514981"></A>	<SPAN CLASS="ee-keyword">
do</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514982"></A>		<SPAN CLASS="ee-keyword">
if</SPAN>
 impossible <SPAN CLASS="ee-keyword">
then</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514983"></A>			failed  := True</P>
<P CLASS="ee-text">
<A NAME="pgfId-514984"></A>		<SPAN CLASS="ee-keyword">
else</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514985"></A>			last_character := low_level_read_function <SPAN CLASS="ee-comment">
(</SPAN>
f<SPAN CLASS="ee-comment">
)</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514986"></A>		<SPAN CLASS="ee-keyword">
end</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514987"></A>	<SPAN CLASS="ee-keyword">
rescue</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514988"></A>		impossible := True</P>
<P CLASS="ee-text">
<A NAME="pgfId-514989"></A>		<SPAN CLASS="ee-keyword">
retry</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514990"></A>	<SPAN CLASS="ee-keyword">
end</SPAN>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="nn-first">
<A NAME="pgfId-514991"></A>This example includes the only two constructs needed for exception handling: <SPAN CLASS="ee-keyword">
rescue</SPAN>
 and <SPAN CLASS="ee-keyword">
retry</SPAN>
. A <SPAN CLASS="ee-keyword">
retry</SPAN>
 instruction is only permitted in a rescue clause; its effect is to start again the execution of the routine, without repeating the initialization of local entities (such as <SPAN CLASS="ee-text">
impossible</SPAN>
 in the example, which was initialized to <SPAN CLASS="ee-text">
False</SPAN>
 on first entry). Features <SPAN CLASS="ee-text">
failed</SPAN>
 and <SPAN CLASS="ee-text">
last_character</SPAN>
 are assumed to be attributes of the enclosing class.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-514992"></A>This example is typical of the use of exceptions: as a last resort, for situations that should not occur. The routine has a precondition, <SPAN CLASS="ee-text">
file</SPAN>
<SPAN CLASS="ee-dot">
.</SPAN>
<SPAN CLASS="ee-text">
readable</SPAN>
, which ascertains that the file exists and is accessible for reading characters. So clients should check that everything is fine before calling the routine. Although this check is almost always a guarantee of success, a rare combination of circumstances could cause a change of file status (because a user or some other system is manipulating the file) between the check for <SPAN CLASS="ee-text">
readable</SPAN>
 and the call to <SPAN CLASS="ee-text">
low_level_read_function</SPAN>
. If we assume this latter function will fail if the file is not readable, we must catch the exception.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-515007"></A>A variant would be</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-514995"></A>	<SPAN CLASS="ee-keyword">
local</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514996"></A>		attempts: INTEGER</P>
<P CLASS="ee-text">
<A NAME="pgfId-514997"></A>	<SPAN CLASS="ee-keyword">
do</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514998"></A>		<SPAN CLASS="ee-keyword">
if</SPAN>
 attempts &lt; Max_attempts <SPAN CLASS="ee-keyword">
then</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-514999"></A>			last_character := low_level_read_function (f)</P>
<P CLASS="ee-text">
<A NAME="pgfId-515000"></A>		<SPAN CLASS="ee-keyword">
else</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-515001"></A>			failed := True</P>
<P CLASS="ee-text">
<A NAME="pgfId-515002"></A>		<SPAN CLASS="ee-keyword">
end</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-515003"></A>	<SPAN CLASS="ee-keyword">
rescue</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-515004"></A>		attempts := attempts + 1</P>
<P CLASS="ee-text">
<A NAME="pgfId-515005"></A>		<SPAN CLASS="ee-keyword">
retry</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-515006"></A>	<SPAN CLASS="ee-keyword">
end</SPAN>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="nn-first">
<A NAME="pgfId-515008"></A>which would try again up to <SPAN CLASS="ee-text">
Max_attempts</SPAN>
 times before giving up.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-515009"></A>The above routine, in either variant, never fails: it always fulfills its contract, which states that it should either read a character or set <SPAN CLASS="ee-text">
failed</SPAN>
 to record its inability to do so. In contrast, consider the new variant</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-515012"></A>	<SPAN CLASS="ee-keyword">
local</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-515013"></A>		attempts: INTEGER</P>
<P CLASS="ee-text">
<A NAME="pgfId-515014"></A>	<SPAN CLASS="ee-keyword">
do</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-515015"></A>		last_character := low_level_read_function (f)</P>
<P CLASS="ee-text">
<A NAME="pgfId-515016"></A>	<SPAN CLASS="ee-keyword">
rescue</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-515017"></A>		attempts := attempts + 1</P>
<P CLASS="ee-text">
<A NAME="pgfId-515018"></A>		<SPAN CLASS="ee-keyword">
if</SPAN>
 attempts &lt; Max_attempts <SPAN CLASS="ee-keyword">
then</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-515019"></A>			<SPAN CLASS="ee-keyword">
retry</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-515020"></A>		<SPAN CLASS="ee-keyword">
end</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-515021"></A>	<SPAN CLASS="ee-keyword">
end</SPAN>
</P>
</TD>
</TR>
</TABLE>
<P CLASS="nn-first">
<A NAME="pgfId-515022"></A>with no more role for <SPAN CLASS="ee-text">
failed</SPAN>
. In this case, after <SPAN CLASS="ee-text">
Max_attempts</SPAN>
 unsuccessful attempts, the routine will execute its <SPAN CLASS="ee-keyword">
rescue</SPAN>
 clause to the end, with no <SPAN CLASS="ee-keyword">
retry</SPAN>
 (the <SPAN CLASS="ee-keyword">
if</SPAN>
 having no <SPAN CLASS="ee-keyword">
else</SPAN>
 clause). This is how a routine <SPAN CLASS="ff-bold">
fails</SPAN>
. It will, as noted, pass on the exception to its caller.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-515023"></A>Such a rescue clause should, before terminating, restore the invariant of the class so that the caller and possible subsequent <SPAN CLASS="ee-keyword">
retry </SPAN>
attempts from higher up find the objects in a consistent state. As a result, the rule for an absent <SPAN CLASS="ee-keyword">
rescue</SPAN>
 clause -- the case for the vast majority of routines in most systems -- is that it is equivalent to</P>
<TABLE>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="ee-text">
<A NAME="pgfId-515026"></A><SPAN CLASS="ee-keyword">
rescue</SPAN>
</P>
<P CLASS="ee-text">
<A NAME="pgfId-515027"></A>	default_rescue</P>
</TD>
</TR>
</TABLE>
<P CLASS="nn-first">
<A NAME="pgfId-515028"></A>where procedure <SPAN CLASS="ee-text">
default_rescue</SPAN>
 comes from <SPAN CLASS="ee-text">
ANY</SPAN>
, where it is defined to do nothing; in a system built for robustness, classes subject to non-explicitly-<SPAN CLASS="ee-keyword">
rescue</SPAN>
d exceptions should redefine <SPAN CLASS="ee-text">
default_rescue</SPAN>
 (perhaps using a creation procedure, which is bound by the same formal requirement) so that it will always restore the invariant.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-515029"></A>Behind Eiffel's exception handling scheme lies the principle -- at first an apparent platitude, but violated by many existing mechanisms -- that a routine should <SPAN CLASS="ff-bold">
either succeed or fail</SPAN>
. This is in turn a consequence of Design by Contract principles: succeeding means being able to fulfill the contract, possibly after one or more <SPAN CLASS="ee-keyword">
retry</SPAN>
; failure is the other case, which must always trigger an exception in the caller. Otherwise it would be possible for a routine to miss its contract and yet return to its caller in a seemingly normal state. That is the worst possible way to handle an exception.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-515030"></A>Concretely, exceptions may result from the following events:</P>
<UL>
<LI CLASS="ll-bull">
<A NAME="pgfId-515031"></A>A routine failure (<SPAN CLASS="ee-keyword">
rescue</SPAN>
 clause executed to the end with no <SPAN CLASS="ee-keyword">
retry</SPAN>
), as just seen.</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-515032"></A>Assertion violation, if for a system that runs with assertion monitoring on.</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-515033"></A>Attempt to call a feature on a void reference: <SPAN CLASS="ee-text">
x</SPAN>
<SPAN CLASS="ee-dot">
.</SPAN>
<SPAN CLASS="ee-text">
f</SPAN>
 <SPAN CLASS="ee-comment">
(</SPAN>
&#8230;<SPAN CLASS="ee-comment">
)</SPAN>
, the fundamental computational mechanism, can only work if <SPAN CLASS="ee-text">
x</SPAN>
 is attached to an object, and will cause an exception otherwise.</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-515034"></A>Developer exception, as seen next.</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-515035"></A>Operating system signal:arithmetic overfolow; no memory available for a requested creation or clone -- even after garbage collection has rummaged everything to find some space. (But no C/C++-like &quot;wrong pointer address&quot;, which cannot occur thanks to the statically typed nature of Eiffel.)</LI>
</UL>
<P CLASS="nn-first">
<A NAME="pgfId-515036"></A>It is sometimes useful, when handling exceptions in <SPAN CLASS="ee-keyword">
rescue</SPAN>
 clauses, to ascertain the exact nature of the exception that got the execution there. For this it is suffices to inherit from the Kernel Library class <SPAN CLASS="ee-text">
EXCEPTIONS</SPAN>
, which provides queries such as <SPAN CLASS="ee-text">
exception</SPAN>
, giving the code for the last exception, and symbolic names (<A HREF="tutorial-11.html#94304" CLASS="XRef"><SPAN CLASS="ww-crossref">
&quot;Constant and unique attributes&quot;,  page 83</SPAN>
</A>) for all such codes, such as <SPAN CLASS="ee-text">
No_more_memory</SPAN>
. You can then process different exceptions differently by testing <SPAN CLASS="ee-text">
exception</SPAN>
 against various possibilities. The method strongly suggests, however, that exception handling code should remain simple; a complicated algorithm in a <SPAN CLASS="ee-keyword">
rescue</SPAN>
 clause is usually a sign that the mechanism is being misused.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-515040"></A>Class <SPAN CLASS="ee-text">
EXCEPTIONS</SPAN>
 also provides various facilities for fine-tuning the exception facilities, such as a procedure <SPAN CLASS="ee-text">
raise</SPAN>
 that will explicitly trigger a &quot;developer exception&quot; with a code than can then be detected and processed.</P>
<P CLASS="nn-normal">
<A NAME="pgfId-515041"></A>Exception handling helps produce Eiffel software that is not just correct but robust, by planning for cases that should <SPAN CLASS="ff-italics">
not</SPAN>
 normally arise, but might out of Murphy's law, and ensuring they do not affect the software's basic safety and simplicity.</P>
</DIV>
<DIV>
<H2 CLASS="aa-sec3">
<A NAME="pgfId-515042"></A>Other applications of Design by Contract</H2>
<P CLASS="nn-first">
<A NAME="pgfId-515043"></A>The Design by Contract ideas pervade the Eiffel method. In addition to the applications just mentioned, they have two particularly important consequences:</P>
<UL>
<LI CLASS="ll-bull">
<A NAME="pgfId-515044"></A>They make it possible to use Eiffel for analysis and design. At a high level of abstraction, it is necessary to be precise too. With the exception of BON, object-oriented analysis and design methods tend to favor abstraction over precision. Thanks to assertions, it is possible to express precise properties of a system (&quot;<SPAN CLASS="ff-italics">
At what speed should the alarm start sounding?</SPAN>
&quot;) without making any commitment to implementation. The discussion of deferred classes (<A HREF="tutorial-10.html#48949" CLASS="XRef"><SPAN CLASS="ww-crossref">
&quot;Applications of deferred classes&quot;,  page 60</SPAN>
</A>) will show how to write a purely descriptive, non-software model in Eiffel, using contracts to describe the essential properties of a system without any computer or software aspect.</LI>
<LI CLASS="ll-bull">
<A NAME="pgfId-515048"></A>Assertions also serve to control the power of inheritance-related mechanisms -- redeclaration, polymorphism, dynamic binding -- and channel them to correct uses by assigning the proper semantic limits. See <A HREF="tutorial-10.html#83610" CLASS="XRef"><SPAN CLASS="ww-crossref">
&quot;Inheritance and contracts&quot;,  page 66</SPAN>
</A>.</LI>
</UL>
</DIV>
<p class="bottom" ALIGN="left"><IMG SRC="normaldoc.gif" ALT="Previous, Up, Next" BORDER="0" WIDTH="300" HEIGHT="40" USEMAP="#navigation"><map name="navigation"><AREA SHAPE="RECT" alt="Previous section" COORDS="0,0,95,40" HREF="tutorial-8.html"><AREA SHAPE="RECT" alt="Up" COORDS="96,0,199,40" HREF="tutorial.html"><AREA SHAPE="RECT" alt="Next section" COORDS="200,0,300,40" HREF="tutorial-10.html"><area shape="default" nohref></MAP>

<p class="bottom" align="center"><a href="http://www.eiffel.com">Eiffel Home Page (Web)</a> -- <a href="index.html">Getting started with Eiffel (local)</a>

<p class="copyright" align="center">Copyright Interactive Software Engineering, 2001
</BODY>
</HTML>
