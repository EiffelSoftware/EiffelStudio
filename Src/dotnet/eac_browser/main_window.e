indexing
	description: "Objects that represent an EV_TITLED_WINDOW generated by Build."
	author: ""
	date: "$Date$"
	revision: "$Revision$"

class
	MAIN_WINDOW

inherit
	MAIN_WINDOW_IMP

feature {NONE} -- Implementation

	user_initialization is
			-- Called by `select_actions' of `execute'.
		do
			set_width (800)
			set_height (600)
			widget_tree.set_minimum_width (180)
			initialize_tree_view ()
		end
		
	initialize_tree_view is
			-- Add widgets to `widget_tree'.
		local
			tree_item, tree_item1: EV_TREE_ITEM
			eac: EAC_BROWSER
			ci: CACHE_INFO
			counter: INTEGER
			path: CACHE_PATH
			info_file_name: STRING
		do
			create tree_item.make_with_text ("Eiffel Assembly Cache")
			widget_tree.extend (tree_item)
			
			create eac
			create path
			ci := eac.info (path.absolute_info_assemblies_path)
			from 
				counter := 1
			until
				counter > ci.assemblies.count
			loop
				create tree_item1.make_with_text (ci.assemblies.item (counter).name)
				tree_item.extend (tree_item1)
				
					-- Add a ficitve element for a cross to appear
				tree_item1.extend (create {EV_TREE_ITEM})
				tree_item1.expand_actions.extend (agent initialize_assembly (ci.assemblies.item (counter), tree_item1))

				counter := counter + 1
			end
		end

	initialize_assembly (an_assembly: CONSUMED_ASSEMBLY; tree_item_parent: EV_TREE_ITEM) is
			-- initialize widget_tree if not allready done.
			-- Add classes in cache.
		require
			non_void_assembly: an_assembly /= Void
			non_void_tree_item_parent: tree_item_parent /= Void
		local
			tree_buffer: SORTABLE_ARRAY [STRING]
			tree_item: EV_TREE_ITEM
			eac: EAC_BROWSER
			cat: CONSUMED_ASSEMBLY_TYPES
			l_dotnet_type_name: STRING
			counter: INTEGER
			path: CACHE_PATH
			a_file_name: STRING
			cache: CACHE
		do
				-- Is it allready initilized?
			if tree_item_parent.is_empty or tree_item_parent.count = 1 then
				if tree_item_parent.count = 1 then
						-- remove element that served to show the cross to expand tree.
					tree_item_parent.first.destroy
				end
				
				create eac
				create path
				a_file_name := path.absolute_info_assembly_path (an_assembly)
				cat := eac.consumed_assembly (a_file_name)
				from
					counter := 1
					create cache
					create tree_buffer.make (1, cat.dotnet_names.count)
				until
					counter > cat.dotnet_names.count
				loop
					l_dotnet_type_name := cat.dotnet_names.item (counter)
					if l_dotnet_type_name /= Void then
						tree_buffer.put (l_dotnet_type_name, counter)
							-- add type in cache
						if not cache.Types.has (l_dotnet_type_name) then
							cache.Types.extend (cat.eiffel_names.item (counter), l_dotnet_type_name)
						end
					end
					counter := counter + 1
				end
				
				from
					counter := 1
					tree_buffer.sort
				until
					counter > tree_buffer.count
				loop
					l_dotnet_type_name := tree_buffer.item (counter)
					create tree_item.make_with_text (l_dotnet_type_name)
					tree_item.select_actions.extend (agent print_type (an_assembly, l_dotnet_type_name))
					tree_item_parent.extend (tree_item)

					counter := counter + 1
				end
			end
		end		

	print_type (an_assembly: CONSUMED_ASSEMBLY; a_dotnet_type_name: STRING) is
			-- Print in `l_text_1' the features corresponding to `a_dotnet_type_name'.
		require
			non_void_a_type_name: a_dotnet_type_name /= Void
		local
			output: TYPE_PRINTER
		do
			create output.make (l_text_1)
			output.print_type (an_assembly, a_dotnet_type_name)
		end
			
end -- class MAIN_WINDOW

